/*
===========================================================================
Copyright (C) 2000 - 2013, Raven Software, Inc.
Copyright (C) 2001 - 2013, Activision, Inc.
Copyright (C) 2013 - 2015, OpenJK contributors

This file is part of the OpenJK source code.

OpenJK is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License version 2 as
published by the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, see <http://www.gnu.org/licenses/>.
===========================================================================
*/

/// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ///
///																																///
///																																///
///													SERENITY JEDI ENGINE														///
///										          LIGHTSABER COMBAT SYSTEM													    ///
///																																///
///						      System designed by Serenity and modded by JaceSolaris. (c) 2019 SJE   		                    ///
///								    https://www.moddb.com/mods/serenityjediengine-20											///
///																																///
/// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ///

#include "g_local.h"
#include "anims.h"
#include "b_local.h"
#include "g_functions.h"
#include "wp_saber.h"
#include "g_vehicles.h"
#include "../qcommon/tri_coll_test.h"
#include "../cgame/cg_local.h"
#include "g_public.h"

#define JK2_RAGDOLL_GRIPNOHEALTH

constexpr auto MAX_SABER_VICTIMS = 8192;
static int victimEntityNum[MAX_SABER_VICTIMS];
static float totalDmg[MAX_SABER_VICTIMS];
static vec3_t dmgDir[MAX_SABER_VICTIMS];
static vec3_t dmgNormal[MAX_SABER_VICTIMS];
static vec3_t dmgBladeVec[MAX_SABER_VICTIMS];
static vec3_t dmgSpot[MAX_SABER_VICTIMS];
static float dmgFraction[MAX_SABER_VICTIMS];
static int hit_loc[MAX_SABER_VICTIMS];
static qboolean hitDismember[MAX_SABER_VICTIMS];
static int hitDismemberLoc[MAX_SABER_VICTIMS];
static vec3_t saberHitLocation, saberHitNormal = { 0, 0, 1.0 };
static float saberHitFraction;
static float sabersCrossed;
static int saberHitEntity;
static int numVictims = 0;
extern cvar_t* g_debugFatigueBars;
extern cvar_t* g_RealisticBlockingMode;
extern cvar_t* g_sex;
extern cvar_t* g_timescale;
extern cvar_t* g_dismemberment;
extern cvar_t* g_debugSaberLock;
extern cvar_t* g_saberLockRandomNess;
extern cvar_t* d_slowmodeath;
extern cvar_t* com_rend2;
extern cvar_t* g_cheats;
extern cvar_t* g_saberRestrictForce;
extern cvar_t* g_saberPickuppableDroppedSabers;
extern cvar_t* debug_subdivision;
extern cvar_t* d_slowmoaction;
extern cvar_t* g_SaberAttackSpeedMD;
extern cvar_t* g_overpoweredsaberthrow;
void wp_block_points_regenerate_over_ride(const gentity_t* self, int override_amt);
extern qboolean NPC_IsOversized(const gentity_t* self);
extern void npc_check_speak(gentity_t* speaker_npc);
extern qboolean WP_SaberBladeUseSecondBladeStyle(const saberInfo_t* saber, int blade_num);
extern qboolean WP_SaberBladeDoTransitionDamage(const saberInfo_t* saber, int blade_num);
extern qboolean Q3_TaskIDPending(const gentity_t* ent, taskID_t taskType);
extern qboolean G_ClearViewEntity(gentity_t* ent);
extern void G_SetViewEntity(gentity_t* self, gentity_t* view_entity);
extern qboolean G_ControlledByPlayer(const gentity_t* self);
extern void G_AddVoiceEvent(const gentity_t* self, int event, int speak_debounce_time);
extern void CG_ChangeWeapon(int num);
extern void CG_SaberDoWeaponHitMarks(const gclient_t* client, const gentity_t* saber_ent,
	gentity_t* hit_ent, int saber_num, int blade_num, vec3_t hit_pos, vec3_t hit_dir,
	vec3_t uaxis, float size_time_scale);
extern void G_AngerAlert(const gentity_t* self);
extern qboolean PM_WalkingOrRunningAnim(int anim);
extern void G_StasisMissile(gentity_t* ent, gentity_t* missile);
extern void G_ReflectMissile_JKA(gentity_t* ent, gentity_t* missile, vec3_t forward);
extern void G_ReflectMissileNPC(gentity_t* ent, gentity_t* missile, vec3_t forward);
extern void G_ReflectMissileAuto(gentity_t* ent, gentity_t* missile, vec3_t forward);
extern void G_MissileBouncedoffSaber(gentity_t* ent, gentity_t* missile, vec3_t forward);
extern qboolean BG_IsAlreadyinTauntAnim(int anim);
extern int G_CheckLedgeDive(gentity_t* self, float check_dist, const vec3_t check_vel, qboolean try_opposite,
	qboolean try_perp);
extern void G_BounceMissile(gentity_t* ent, trace_t* trace);
extern qboolean G_PointInBounds(const vec3_t point, const vec3_t mins, const vec3_t maxs);
extern void NPC_UseResponse(gentity_t* self, const gentity_t* user, qboolean useWhenDone);
extern void G_MissileImpacted(gentity_t* ent, gentity_t* other, vec3_t impact_pos, vec3_t normal, int hit_loc = HL_NONE);
extern evasionType_t jedi_saber_block_go(gentity_t* self, usercmd_t* cmd, vec3_t p_hitloc, vec3_t phit_dir,
	const gentity_t* incoming, float dist = 0.0f);
extern void jedi_rage_stop(const gentity_t* self);
extern int PM_PickAnim(const gentity_t* self, int min_anim, int max_anim);
extern void NPC_SetPainEvent(gentity_t* self);
extern qboolean PM_SwimmingAnim(int anim);
extern qboolean PM_InAnimForSaberMove(int anim, int saber_move);
extern qboolean PM_SpinningSaberAnim(int anim);
extern qboolean pm_saber_in_special_attack(int anim);
extern qboolean PM_SaberInInstankillKillAttack(int anim);
extern qboolean PM_SaberInKillAttack(int anim);
extern qboolean PM_SaberInLockWin(int anim);
extern qboolean PM_SaberInAttack(int move);
extern qboolean PM_SaberInAttackPure(int move);
extern qboolean PM_SaberInTransition(int move);
extern qboolean PM_SaberInStart(int move);
extern qboolean PM_SaberInTransitionAny(int move);
extern qboolean PM_SaberInReturn(int move);
extern qboolean PM_SaberInBounce(int move);
extern qboolean PM_SaberInParry(int move);
extern qboolean PM_SaberInKnockaway(int move);
extern qboolean PM_SaberInBrokenParry(int move);
extern qboolean PM_SpinningSaberAnim(int anim);
extern saber_moveName_t PM_SaberBounceForAttack(int move);
extern saber_moveName_t PM_BrokenParryForAttack(int move);
extern saber_moveName_t PM_KnockawayForParry(int move);
extern qboolean PM_FlippingAnim(int anim);
extern qboolean PM_RollingAnim(int anim);
extern qboolean PM_CrouchAnim(int anim);
extern qboolean PM_SaberInIdle(int move);
extern qboolean PM_SaberInReflect(int move);
extern qboolean PM_InSpecialJump(int anim);
extern qboolean PM_InKnockDown(const playerState_t* ps);
extern qboolean BG_InKnockDown(int anim);
extern qboolean PM_ForceUsingSaberAnim(int anim);
extern qboolean PM_SuperBreakLoseAnim(int anim);
extern qboolean PM_SuperBreakWinAnim(int anim);
extern qboolean PM_SaberLockBreakAnim(int anim);
extern qboolean PM_InOnGroundAnim(playerState_t* ps);
extern qboolean PM_KnockDownAnim(int anim);
extern qboolean PM_SaberInKata(saber_moveName_t saber_move);
extern qboolean PM_SaberInBackAttack(saber_moveName_t saber_move);
extern qboolean PM_SaberInOverHeadSlash(saber_moveName_t saber_move);
extern qboolean PM_SaberInRollStab(saber_moveName_t saber_move);
extern qboolean PM_SaberInLungeStab(saber_moveName_t saber_move);
extern qboolean PM_StabDownAnim(int anim);
extern int PM_PowerLevelForSaberAnim(const playerState_t* ps, int saber_num = 0);
extern void PM_VelocityForSaberMove(const playerState_t* ps, vec3_t throw_dir);
extern qboolean PM_VelocityForBlockedMove(const playerState_t* ps, vec3_t throw_dir);
extern qboolean PM_SaberCanInterruptMove(int move, int anim);
extern int jedi_re_calc_parry_time(const gentity_t* self, evasionType_t evasion_type);
extern qboolean jedi_dodge_evasion(gentity_t* self, gentity_t* shooter, trace_t* tr, int hit_loc);
extern void jedi_play_deflect_sound(const gentity_t* self);
extern void jedi_play_blocked_push_sound(const gentity_t* self);
extern qboolean jedi_waiting_ambush(const gentity_t* self);
extern void jedi_ambush(gentity_t* self);
extern qboolean jedi_saber_busy(const gentity_t* self);
extern qboolean jedi_cultist_destroyer(const gentity_t* self);
extern qboolean Boba_Flying(const gentity_t* self);
extern void JET_FlyStart(gentity_t* self);
extern void Mando_DoFlameThrower(gentity_t* self);
extern void Boba_StopFlameThrower(const gentity_t* self);
extern qboolean SaberAttacking(const gentity_t* self);
void G_SaberBounce(const gentity_t* self, gentity_t* other);
extern qboolean PM_InGetUp(const playerState_t* ps);
extern qboolean PM_InForceGetUp(const playerState_t* ps);
extern Vehicle_t* G_IsRidingVehicle(const gentity_t* pEnt);
extern int SaberDroid_PowerLevelForSaberAnim(const gentity_t* self);
extern qboolean G_ValidEnemy(const gentity_t* self, const gentity_t* enemy);
extern void G_StartMatrixEffect(const gentity_t* ent, int me_flags = 0, int length = 1000, float time_scale = 0.0f,
	int spin_time = 0);
extern int PM_AnimLength(const int index, const animNumber_t anim);
extern void G_Knockdown(gentity_t* self, gentity_t* attacker, const vec3_t push_dir, float strength, const qboolean breakSaberLock);
extern void G_KnockOffVehicle(gentity_t* pRider, const gentity_t* self, qboolean bPull);
extern qboolean PM_LockedAnim(int anim);
extern qboolean rosh_being_healed(const gentity_t* self);
extern qboolean G_OkayToLean(const playerState_t* ps, const usercmd_t* cmd, qboolean interrupt_okay);
int WP_AbsorbConversion(const gentity_t* attacked, int atd_abs_level, int at_power, int at_power_level,
	int at_force_spent);
void WP_ForcePowerStart(gentity_t* self, forcePowers_t force_power, int override_amt);
void WP_ForcePowerStop(gentity_t* self, forcePowers_t force_power);
qboolean WP_ForcePowerUsable(const gentity_t* self, forcePowers_t force_power, int override_amt);
void WP_SaberInFlightReflectCheck(gentity_t* self);
void WP_SaberDrop(const gentity_t* self, gentity_t* saber);
qboolean WP_SaberLose(gentity_t* self, vec3_t throw_dir);
void WP_SaberReturn(const gentity_t* self, gentity_t* saber);
qboolean WP_SaberBlockNonRandom(gentity_t* self, vec3_t hitloc, qboolean missileBlock);
qboolean WP_SaberBlockNonRandom_MD(gentity_t* self, vec3_t hitloc, qboolean missileBlock);
qboolean WP_ForcePowerAvailable(const gentity_t* self, forcePowers_t force_power, int override_amt);
void WP_ForcePowerDrain(const gentity_t* self, forcePowers_t force_power, int override_amt);
void WP_DeactivateSaber(const gentity_t* self, qboolean clear_length = qfalse);
qboolean FP_ForceDrainGrippableEnt(const gentity_t* victim);
extern qboolean PM_RunningAnim(int anim);
extern qboolean PM_WalkingAnim(int anim);
extern saber_moveName_t PM_BrokenParryForParry(int move);
extern qboolean BG_SaberInNonIdleDamageMove(const playerState_t* ps);
qboolean BG_SaberInPartialDamageMove(gentity_t* self);
extern qboolean PM_KickingAnim(int anim);
extern qboolean BG_InSlowBounce(const playerState_t* ps);
extern qboolean PM_InSlowBounce(const playerState_t* ps);
qboolean g_accurate_blocking(const gentity_t* blocker, const gentity_t* attacker, vec3_t hit_loc);
extern qboolean WalkCheck(const gentity_t* self);
extern qboolean pm_saber_innonblockable_attack(int anim);
extern int BG_InGrappleMove(int anim);
extern qboolean PM_KickMove(int move);
extern qboolean PM_SaberInDamageMove(int move);
extern qboolean PM_SaberDoDamageAnim(int anim);
extern qboolean PM_RestAnim(int anim);
extern qboolean PM_StabAnim(int anim);
extern void PM_AddFatigue(playerState_t* ps, int fatigue);
void BG_ReduceSaberMishapLevel(playerState_t* ps);
extern qboolean PM_SaberInSpecial(int move);
extern void jedi_decloak(gentity_t* self);
extern qboolean PM_SaberInMassiveBounce(int move);
extern qboolean PM_SaberInBashedAnim(int anim);
void player_Freeze(gentity_t* self);
void Player_CheckFreeze(gentity_t* self);
extern void G_StartStasisEffect_FORCE_LEVEL_2(const gentity_t* ent, int me_flags = 0, int length = 1000,
	float time_scale = 0.0f, int spin_time = 0);
extern void G_StartStasisEffect_FORCE_LEVEL_1(const gentity_t* ent, int me_flags = 0, int length = 1000,
	float time_scale = 0.0f, int spin_time = 0);
void WP_BlockPointsRegenerate(const gentity_t* self, int override_amt);
void WP_ForcePowerRegenerate(const gentity_t* self, int override_amt);
extern void PM_AddBoltBlockFatigue(playerState_t* ps, int fatigue);
extern qboolean PM_Saberinstab(int move);
extern void PM_AddBlockFatigue(playerState_t* ps, int fatigue);
extern cvar_t* g_SaberPerfectBlockingTimerEasy;
extern cvar_t* g_SaberPerfectBlockingTimerNormal;
extern cvar_t* g_SaberPerfectBlockingTimerHard;
extern cvar_t* g_SaberPerfectBlockingTimerMissile;
qboolean WP_SaberMBlockDirection(gentity_t* self, vec3_t hitloc, qboolean missileBlock);
qboolean WP_SaberMBlockDirectionNPC(gentity_t* self, vec3_t hitloc, qboolean missileBlock);
extern qboolean PM_InRoll(const playerState_t* ps);
qboolean WP_SaberFatigueDirection(gentity_t* self, vec3_t hitloc, qboolean missileBlock);
qboolean WP_SaberBounceDirection(gentity_t* self, vec3_t hitloc, qboolean missileBlock);
extern qboolean PM_InKataAnim(int anim);
extern qboolean PM_StaggerAnim(int anim);
qboolean WP_SaberBlockBolt_MD(gentity_t* self, vec3_t hitloc, qboolean missileBlock);
extern void player_decloak(gentity_t* self);
extern qboolean PM_DeathCinAnim(int anim);
extern qboolean PM_InWallHoldMove(int anim);
extern qboolean PM_HasAnimation(const gentity_t* ent, int animation);
extern qboolean jedi_is_kick_resistant(gentity_t* self);
extern qboolean jedi_jedi_master_low(const gentity_t* self);
extern qboolean jedi_jedi_master_high(const gentity_t* self);
extern qboolean char_is_force_user_attacker(const gentity_t* self);
extern void Boba_FlyStop(gentity_t* self);
extern void Jetpack_Off(const gentity_t* ent);
qboolean WP_SaberFatiguedParryDirection(gentity_t* self, vec3_t hitloc, qboolean missileBlock);
extern saber_moveName_t PM_SaberAttackStagger(int move);
void G_StaggerAttacker(gentity_t* atk);
extern qboolean PM_LungRollAnim(int anim);
extern qboolean jedi_win_po(const gentity_t* self);
void WP_BlockPointsDrain(const gentity_t* self, int fatigue);
extern qboolean sab_beh_attack_vs_block(gentity_t* attacker, gentity_t* blocker, int saber_num, int blade_num, vec3_t hit_loc);
extern qboolean sab_beh_block_vs_attack(gentity_t* blocker, gentity_t* attacker, int saber_num, int blade_num, vec3_t hit_loc);
extern void g_fatigue_bp_knockaway(gentity_t* blocker);
void G_Beskar_Attack_Bounce(const gentity_t* self, gentity_t* other);
extern qboolean Mandalorian_Character(const gentity_t* self);
extern void jet_fly_stop(gentity_t* self);
extern qboolean g_standard_humanoid(gentity_t* self);

extern cvar_t* g_saberAutoBlocking;
extern cvar_t* g_saberRealisticCombat;
extern cvar_t* g_saberDamageCapping;
extern cvar_t* g_saberNewControlScheme;

extern cvar_t* g_InvertedHolsteredSabers;
extern cvar_t* g_CannonHolsteredSabers;

extern cvar_t* g_SerenityJediEngineMode;
extern cvar_t* g_IsSaberDoingAttackDamage;
extern cvar_t* g_DebugSaberCombat;
extern cvar_t* g_lightningdamage;
extern cvar_t* com_outcast;

extern cvar_t* g_SaberBounceOnWalls;
extern cvar_t* g_SaberMustReturn;

extern int g_crosshairEntNum;

qboolean g_saberNoEffects = qfalse;
qboolean g_noClashFlare = qfalse;
int g_saberFlashTime = 0;
vec3_t g_saberFlashPos = { 0, 0, 0 };

int forcePowerDarkLight[NUM_FORCE_POWERS] = //0 == neutral
{
	//nothing should be usable at rank 0..
	FORCE_LIGHTSIDE, //FP_HEAL,//instant
	0, //FP_LEVITATION,//hold/duration
	0, //FP_SPEED,//duration
	0, //FP_PUSH,//hold/duration
	0, //FP_PULL,//hold/duration
	FORCE_LIGHTSIDE, //FP_TELEPATHY,//instant
	FORCE_DARKSIDE, //FP_GRIP,//hold/duration
	FORCE_DARKSIDE, //FP_LIGHTNING,//hold/duration
	0, //FP_SABERATTACK,
	0, //FP_SABERDEFEND,
	0, //FP_SABERTHROW,
	//new Jedi Academy powers
	FORCE_DARKSIDE, //FP_RAGE,//duration
	FORCE_LIGHTSIDE, //FP_PROTECT,//duration
	FORCE_LIGHTSIDE, //FP_ABSORB,//duration
	FORCE_DARKSIDE, //FP_DRAIN,//hold/duration
	0, //FP_SEE,//duration
	FORCE_DARKSIDE, //FP_DESTRUCTION
	FORCE_LIGHTSIDE, //FP_STASIS

	FORCE_LIGHTSIDE, //FP_GRASP,//hold/duration
	FORCE_LIGHTSIDE, //FP_REPULSE
	FORCE_DARKSIDE, //FP_LIGHTNING_STRIKE,
	FORCE_DARKSIDE, //FP_FEAR,
	FORCE_DARKSIDE, //FP_DEADLYSIGHT
	FORCE_LIGHTSIDE, //FP_PROJECTION,//duration
	FORCE_LIGHTSIDE, //FP_BLAST,//Instant
	//NUM_FORCE_POWERS
};

int forcePowerNeeded[NUM_FORCE_POWERS] =
{
	0, //FP_HEAL,//instant
	10, //FP_LEVITATION,//hold/duration
	50, //FP_SPEED,//duration
	15, //FP_PUSH,//hold/duration
	15, //FP_PULL,//hold/duration
	20, //FP_TELEPATHY,//instant
	1, //FP_GRIP,//hold/duration - FIXME: 30?
	1, //FP_LIGHTNING,//hold/duration
	20, //FP_SABERTHROW,
	1, //FP_SABER_DEFENSE,
	0, //FP_SABER_OFFENSE,
	//new Jedi Academy powers
	50,
	//FP_RAGE,//duration - speed, invincibility and extra damage for short period, drains your health and leaves you weak and slow afterwards.
	30,
	//FP_PROTECT,//duration - protect against physical/energy (level 1 stops blaster/energy bolts, level 2 stops projectiles, level 3 protects against explosions)
	30, //FP_ABSORB,//duration - protect against dark force powers (grip, lightning, drain)
	1, //FP_DRAIN,//hold/duration - drain force power for health
	20, //FP_SEE,//duration - detect/see hidden enemies
	60, //FP_DESTRUCTION
	35, //FP_STASIS

	1, //FP_GRASP,//hold/duration
	30, //FP_REPULSE
	30, //FP_LIGHTNING_STRIKE,
	20, //FP_FEAR,
	90, //FP_DEADLYSIGHT
	20, //FP_PROJECTION,
	30 //FP_BLAST,//Instant
	//NUM_FORCE_POWERS
};

float forceJumpStrength[NUM_FORCE_POWER_LEVELS] =
{
	JUMP_VELOCITY, //normal jump
	420,
	590,
	840
};

float forceJumpHeight[NUM_FORCE_POWER_LEVELS] =
{
	32, //normal jump (+stepheight+crouchdiff = 66)
	96, //(+stepheight+crouchdiff = 130)
	192, //(+stepheight+crouchdiff = 226)
	384 //(+stepheight+crouchdiff = 418)
};

float forceJumpHeightMax[NUM_FORCE_POWER_LEVELS] =
{
	66, //normal jump (32+stepheight(18)+crouchdiff(24) = 74)
	130, //(96+stepheight(18)+crouchdiff(24) = 138)
	226, //(192+stepheight(18)+crouchdiff(24) = 234)
	418 //(384+stepheight(18)+crouchdiff(24) = 426)
};

float forcePushPullRadius[NUM_FORCE_POWER_LEVELS] =
{
	0, //none
	384, //256,
	448, //384,
	512
};

float forcePushPullRadiusMD[NUM_FORCE_POWER_LEVELS] =
{
	0, //none
	448, //256,
	512, //384,
	576
};

float forcePushCone[NUM_FORCE_POWER_LEVELS] =
{
	1.0f, //none
	1.0f,
	0.8f,
	0.6f
};

float forcePullCone[NUM_FORCE_POWER_LEVELS] =
{
	1.0f, //none
	1.0f,
	1.0f,
	0.8f
};

float forceDashValue[NUM_FORCE_POWER_LEVELS] =
{
	1.0f, //none
	1.0f,
	1.0f,
	1.0f
};

float forceSpeedValue[NUM_FORCE_POWER_LEVELS] =
{
	1.0f, //none
	0.75f,
	0.5f,
	0.25f
};

float forceSpeedRangeMod[NUM_FORCE_POWER_LEVELS] =
{
	0.0f, //none
	30.0f,
	45.0f,
	60.0f
};

float forceDashRangeMod[NUM_FORCE_POWER_LEVELS] =
{
	0.0f, //none
	0.0f,
	0.0f,
	0.0f
};

float forceSpeedFOVMod[NUM_FORCE_POWER_LEVELS] =
{
	0.0f, //none
	20.0f,
	30.0f,
	40.0f
};

int forceGripDamage[NUM_FORCE_POWER_LEVELS] =
{
	0, //none
	3,
	6,
	9
};

int forceGraspDamage[NUM_FORCE_POWER_LEVELS] =
{
	0, //none
	0,
	0,
	0
};

float forceDashFOVMod[NUM_FORCE_POWER_LEVELS] =
{
	0.0f, //none
	0.0f,
	0.0f,
	0.0f
};

int mindTrickTime[NUM_FORCE_POWER_LEVELS] =
{
	0, //none
	10000, //5000,
	15000, //10000,
	30000 //15000
};

int stasisTime[NUM_FORCE_POWER_LEVELS] =
{
	0, //none
	3000, //5000,
	6000, //10000,
	9000 //15000
};

int stasisJediTime[NUM_FORCE_POWER_LEVELS] =
{
	0, //none
	2000, //5000,
	4000, //10000,
	6000 //15000
};

float forceStasisRadius[NUM_FORCE_POWER_LEVELS] =
{
	0, //none
	512, //256,
	1024, //384,
	2048
};

float forceStasisCone[NUM_FORCE_POWER_LEVELS] =
{
	1.0f, //none
	1.0f,
	0.8f,
	0.6f
};

//NOTE: keep in synch with table below!!!
int saberThrowDist[NUM_FORCE_POWER_LEVELS] =
{
	0, //none
	256,
	400,
	400
};

//NOTE: keep in synch with table above!!!
int saberThrowDistSquared[NUM_FORCE_POWER_LEVELS] =
{
	0, //none
	65536,
	160000,
	160000
};

int parryDebounce[NUM_FORCE_POWER_LEVELS] =
{
	500, //if don't even have defense, can't use defense!
	300,
	150,
	50
};

float saberAnimSpeedMod[NUM_FORCE_POWER_LEVELS] =
{
	0.0f, //if don't even have offense, can't use offense!
	0.75f,
	1.0f,
	2.0f
};

stringID_table_t SaberStyleTable[] =
{
	{"NULL", SS_NONE},
	ENUM2STRING(SS_FAST),
	{"fast", SS_FAST},
	ENUM2STRING(SS_MEDIUM),
	{"medium", SS_MEDIUM},
	ENUM2STRING(SS_STRONG),
	{"strong", SS_STRONG},
	ENUM2STRING(SS_DESANN),
	{"desann", SS_DESANN},
	ENUM2STRING(SS_TAVION),
	{"tavion", SS_TAVION},
	ENUM2STRING(SS_DUAL),
	{"dual", SS_DUAL},
	ENUM2STRING(SS_STAFF),
	{"staff", SS_STAFF},
	{"", 0},
};

//SABER INITIALIZATION======================================================================

void G_CreateG2HolsteredWeaponModel(gentity_t* ent, const char* ps_weapon_model, const int bolt_num,
	const int weapon_num, vec3_t angles, vec3_t offset)
{
	if (!ps_weapon_model)
	{
		assert(ps_weapon_model);
		return;
	}
	if (ent->playerModel == -1)
	{
		return;
	}
	if (bolt_num == -1)
	{
		return;
	}

	if (weapon_num < 0 || weapon_num >= MAX_INHAND_WEAPONS)
	{
		return;
	}
	char weapon_model[64];

	strcpy(weapon_model, ps_weapon_model);
	if (char* spot = strstr(weapon_model, ".md3"))
	{
		*spot = 0;
		spot = strstr(weapon_model, "_w");
		//i'm using the in view weapon array instead of scanning the item list, so put the _w back on
		if (!spot && !strstr(weapon_model, "noweap"))
		{
			strcat(weapon_model, "_w");
		}
		strcat(weapon_model, ".glm"); //and change to ghoul2
	}

	// give us a saber model
	const int w_model_index = G_ModelIndex(weapon_model);
	if (w_model_index)
	{
		ent->holsterModel[weapon_num] = gi.G2API_InitGhoul2Model(ent->ghoul2, weapon_model, w_model_index, NULL_HANDLE,
			NULL_HANDLE, 0, 0);
		if (ent->holsterModel[weapon_num] != -1)
		{
			// attach it to the hip. need some correction of rotation first though!
			const int holsterorigin = gi.G2API_AddBolt(&ent->ghoul2[ent->holsterModel[weapon_num]], "*holsterorigin");
			mdxaBone_t bolt_matrix2;
			if (holsterorigin != -1)
			{
				constexpr vec3_t origin = { 0, 0, 0 };
				gi.G2API_GetBoltMatrix(ent->ghoul2, ent->holsterModel[weapon_num], holsterorigin, &bolt_matrix2, origin,
					origin, 0, nullptr, ent->s.modelScale);
			}
			gi.G2API_AttachG2Model(&ent->ghoul2[ent->holsterModel[weapon_num]], &ent->ghoul2[ent->playerModel],
				bolt_num,
				ent->playerModel);

			if (holsterorigin == -1)
			{
				if (ent->client->ps.saber[0].type == SABER_DAGGER)
				{
					//COUNT ME OUT ON THIS ONE
				}
				else
				{
					if (com_rend2->integer == 0) //rend2 is off
					{
						gi.G2API_SetBoneAnglesOffset(&ent->ghoul2[ent->holsterModel[weapon_num]],
							"ModView internal default",
							angles, BONE_ANGLES_PREMULT, POSITIVE_X, NEGATIVE_Y, NEGATIVE_Z,
							nullptr, 0, 0, offset);
					}
				}
			}
			else
			{
				bolt_matrix2.matrix[1][3] -= 1.0f;
				gi.G2API_SetBoneAnglesMatrix(&ent->ghoul2[ent->holsterModel[weapon_num]], "ModView internal default",
					bolt_matrix2, BONE_ANGLES_PREMULT, nullptr, 0, 0);
			}
			// set up a bolt on the end so we can get where the sabre muzzle is - we can assume this is always bolt 0
			gi.G2API_AddBolt(&ent->ghoul2[ent->holsterModel[weapon_num]], "*flash");
		}
	}
}

void G_CreateG2AttachedWeaponModel(gentity_t* ent, const char* ps_weapon_model, const int bolt_num,
	const int weapon_num)
{
	if (!ps_weapon_model)
	{
		assert(ps_weapon_model);
		return;
	}
	if (ent->playerModel == -1)
	{
		return;
	}
	if (bolt_num == -1)
	{
		return;
	}

	if (ent && ent->client && ent->client->NPC_class == CLASS_GALAKMECH)
	{
		//hack for galakmech, no weaponmodel
		ent->weaponModel[0] = ent->weaponModel[1] = -1;
		return;
	}

	//if (ent && ent->client && ent->client->NPC_class == CLASS_SBD)
	//{
	//	//hack for sbd, no weaponmodel
	//	ent->weaponModel[0] = ent->weaponModel[1] = -1;
	//	return;
	//}

	//if (ent && ent->client && ent->client->NPC_class == CLASS_DROIDEKA)
	//{
	//	//hack for galakmech, no weaponmodel
	//	ent->weaponModel[0] = ent->weaponModel[1] = -1;
	//	return;
	//}

	if (weapon_num < 0 || weapon_num >= MAX_INHAND_WEAPONS)
	{
		return;
	}
	char weapon_model[64];

	strcpy(weapon_model, ps_weapon_model);
	if (char* spot = strstr(weapon_model, ".md3"))
	{
		*spot = 0;
		spot = strstr(weapon_model, "_w");
		//i'm using the in view weapon array instead of scanning the item list, so put the _w back on
		if (!spot && !strstr(weapon_model, "noweap"))
		{
			strcat(weapon_model, "_w");
		}
		strcat(weapon_model, ".glm"); //and change to ghoul2
	}

	// give us a saber model
	const int w_model_index = G_ModelIndex(weapon_model);

	if (w_model_index)
	{
		ent->weaponModel[weapon_num] = gi.G2API_InitGhoul2Model(ent->ghoul2, weapon_model, w_model_index, NULL_HANDLE,
			NULL_HANDLE, 0, 0);
		if (ent->weaponModel[weapon_num] != -1)
		{
			// attach it to the hand
			gi.G2API_AttachG2Model(&ent->ghoul2[ent->weaponModel[weapon_num]], &ent->ghoul2[ent->playerModel], bolt_num,
				ent->playerModel);
			// set up a bolt on the end so we can get where the sabre muzzle is - we can assume this is always bolt 0
			if (gi.G2API_AddBolt(&ent->ghoul2[ent->weaponModel[weapon_num]], "*cannonflash") != -1)
			{
				constexpr vec3_t gun_angles = { 0.0f, 0.0f, 0.0f };
				constexpr vec3_t offset = { 0.0f, 0.0f, -10.0f };

				if (com_rend2->integer == 0) //rend2 is off
				{
					gi.G2API_SetSurfaceOnOff(&ent->ghoul2[ent->weaponModel[weapon_num]], "eweb_cannon", 0x00000002);
					gi.G2API_SetBoneAnglesOffset(&ent->ghoul2[ent->weaponModel[weapon_num]], "base", gun_angles,
						BONE_ANGLES_PREMULT, POSITIVE_X, NEGATIVE_Y, NEGATIVE_Z, nullptr, 0, 0,
						offset);
				}
			}
			else
			{
				gi.G2API_AddBolt(&ent->ghoul2[ent->weaponModel[weapon_num]], "*flash");
			}
		}
	}
}

void WP_SaberAddG2SaberModels(gentity_t* ent, const int specific_saber_num)
{
	int saber_num = 0, max_saber = 1;
	if (specific_saber_num != -1 && specific_saber_num <= max_saber)
	{
		saber_num = max_saber = specific_saber_num;
	}
	for (; saber_num <= max_saber; saber_num++)
	{
		if (ent->weaponModel[saber_num] > 0)
		{
			//we already have a weapon model in this slot
			//remove it
			gi.G2API_SetSkin(&ent->ghoul2[ent->weaponModel[saber_num]], -1, 0);
			gi.G2API_RemoveGhoul2Model(ent->ghoul2, ent->weaponModel[saber_num]);
			ent->weaponModel[saber_num] = -1;
		}
		if (saber_num > 0)
		{
			//second saber
			if (!ent->client->ps.dualSabers
				|| G_IsRidingVehicle(ent))
			{
				//only have one saber or riding a vehicle and can only use one saber
				return;
			}
		}
		else if (saber_num == 0)
		{
			//first saber
			if (ent->client->ps.saberInFlight)
			{
				//it's still out there somewhere, don't add it
				//FIXME: call it back?
				continue;
			}
		}
		int hand_bolt = saber_num == 0 ? ent->handRBolt : ent->handLBolt;

		if (ent->client && ent->client->ps.saber[saber_num].saberFlags & SFL_BOLT_TO_WRIST)
		{
			//special case, bolt to forearm
			if (saber_num == 0)
			{
				hand_bolt = gi.G2API_AddBolt(&ent->ghoul2[ent->playerModel], "*r_hand_cap_r_arm");
			}
			else
			{
				hand_bolt = gi.G2API_AddBolt(&ent->ghoul2[ent->playerModel], "*l_hand_cap_l_arm");
			}
		}
		G_CreateG2AttachedWeaponModel(ent, ent->client->ps.saber[saber_num].model, hand_bolt, saber_num);

		if (ent->client->ps.saber[saber_num].skin != nullptr)
		{
			//if this saber has a customSkin, use it
			// lets see if it's out there
			const int saber_skin = gi.RE_RegisterSkin(ent->client->ps.saber[saber_num].skin);
			if (saber_skin)
			{
				// put it in the config strings
				// and set the ghoul2 model to use it
				gi.G2API_SetSkin(&ent->ghoul2[ent->weaponModel[saber_num]],
					G_SkinIndex(ent->client->ps.saber[saber_num].skin), saber_skin);
			}
		}
	}
}

static qboolean GalenHolster(const gentity_t* ent)
{
	if (ent->client->ps.saber[0].type == SABER_STAFF
		&& (!Q_stricmp("md_galen", ent->NPC_type) ||
			!Q_stricmp("md_galen_jt", ent->NPC_type) ||
			!Q_stricmp("md_galencjr", ent->NPC_type) ||
			!Q_stricmp("md_starkiller", ent->NPC_type) ||
			!Q_stricmp("md_sithstalker", ent->NPC_type) ||
			!Q_stricmp("md_stk_lord", ent->NPC_type) ||
			!Q_stricmp("md_stk_tat", ent->NPC_type)))
	{
		return qtrue;
	}
	return qfalse;
}

qboolean SaberStaffWeapon(const gentity_t* ent)
{
	if (!GalenHolster(ent) &&
		(ent->client->ps.saber[0].type == SABER_STAFF ||
			ent->client->ps.saber[0].type == SABER_STAFF_SFX ||
			ent->client->ps.saber[0].type == SABER_STAFF_UNSTABLE ||
			ent->client->ps.saber[0].type == SABER_STAFF_THIN))
	{
		return qtrue;
	}
	return qfalse;
}

static qboolean SaberCanNotHolster(const gentity_t* ent)
{
	if (ent->client->ps.saber[0].type == SABER_DAGGER ||
		ent->client->ps.saber[0].type == SABER_STAFF_SFX ||
		ent->client->ps.saber[0].type == SABER_GRIE ||
		ent->client->NPC_class == CLASS_JANGO ||
		ent->client->NPC_class == CLASS_JANGODUAL ||
		!Q_stricmp("md_grievous4", ent->NPC_type) ||
		!Q_stricmp("md_gungan_warrior", ent->NPC_type))
	{
		return qtrue; // no holster model for these
	}
	return qfalse;
}

qboolean DarthMaulHolster(const gentity_t* ent)
{
	if (!Q_stricmp("md_maul", ent->NPC_type) ||
		!Q_stricmp("md_maul_robed", ent->NPC_type) ||
		!Q_stricmp("md_maul_hooded", ent->NPC_type) ||
		!Q_stricmp("md_maul_rebels", ent->NPC_type) ||
		!Q_stricmp("md_maul_rebels2", ent->NPC_type) ||
		!Q_stricmp("md_maul_rebels3", ent->NPC_type) ||
		!Q_stricmp("md_maul_rebels4", ent->NPC_type) ||
		!Q_stricmp("md_maul_rebels5", ent->NPC_type) ||
		!Q_stricmp("md_maul_rebels6", ent->NPC_type) ||
		!Q_stricmp("md_maul_wots", ent->NPC_type))
	{
		return qtrue;
	}
	return qfalse;
}

static qboolean SecondSisterHolster(const gentity_t* ent)
{
	if (!Q_stricmp("md_2ndsister", ent->NPC_type))
	{
		return qtrue;
	}
	return qfalse;
}

static qboolean NinthSisterHolster(const gentity_t* ent)
{
	if (!Q_stricmp("md_9thsister", ent->NPC_type))
	{
		return qtrue;
	}
	return qfalse;
}

static qboolean FifthBrotherHolster(const gentity_t* ent)
{
	if (!Q_stricmp("md_5thbrother", ent->NPC_type))
	{
		return qtrue;
	}
	return qfalse;
}

static qboolean GamorreanHolster(const gentity_t* ent)
{
	if (!Q_stricmp("gamorrean", ent->NPC_type))
	{
		return qtrue;
	}
	return qfalse;
}

static qboolean RoyalguardHolster(const gentity_t* ent)
{
	if (!Q_stricmp("md_royalguard", ent->NPC_type))
	{
		return qtrue;
	}
	return qfalse;
}

static qboolean SeventhSisterHolster(const gentity_t* ent)
{
	if (!Q_stricmp("md_7thsister", ent->NPC_type))
	{
		return qtrue;
	}
	return qfalse;
}

static qboolean EighthBrotherHolster(const gentity_t* ent)
{
	if (!Q_stricmp("md_8thbrother", ent->NPC_type))
	{
		return qtrue;
	}
	return qfalse;
}

static qboolean InquisitorHolster(const gentity_t* ent)
{
	if (!Q_stricmp("md_inquisitor", ent->NPC_type))
	{
		return qtrue;
	}
	return qfalse;
}

static qboolean CalKestisHolster(const gentity_t* ent)
{
	if (!Q_stricmp("cal_kestis", ent->NPC_type) ||
		!Q_stricmp("cal_kestis_cape", ent->NPC_type) ||
		!Q_stricmp("cal_inquisitor", ent->NPC_type) ||
		!Q_stricmp("cal_kestis_staff", ent->NPC_type))
	{
		return qtrue;
	}
	return qfalse;
}

void WP_SaberAddHolsteredG2SaberModels(gentity_t* ent, const int specific_saber_num)
{
	int saber_num = 0, max_saber = 1;

	if (!(ent && ent->client && ent->client->ps.weapons[WP_SABER]))
	{
		return;
	}

	if (SaberCanNotHolster(ent))
	{
		return;
	}

	if (ent->client->ps.saber[saber_num].holsterPlace == HOLSTER_NONE)
	{
		return;
	}

	if (specific_saber_num != -1 && specific_saber_num <= max_saber)
	{
		saber_num = max_saber = specific_saber_num;
	}

	for (; saber_num <= max_saber; saber_num++)
	{
		if (ent->holsterModel[saber_num] > 0)
		{
			//we already have a weapon model in this slot
			//remove it
			gi.G2API_SetSkin(&ent->ghoul2[ent->holsterModel[saber_num]], -1, 0);
			gi.G2API_RemoveGhoul2Model(ent->ghoul2, ent->holsterModel[saber_num]);
			ent->holsterModel[saber_num] = -1;
		}
		if (saber_num > 0)
		{
			//second saber
			if (!ent->client->ps.dualSabers)
			{
				//only have one saber or riding a vehicle and can only use one saber
				return;
			}
		}
		else if (saber_num == 0)
		{
			//first saber
			if (ent->client->ps.saberInFlight)
			{
				//it's still out there somewhere, don't add it
				//FIXME: call it back?
				continue;
			}
		}
		else if (ent->client->ps.saber[saber_num].holsterPlace == HOLSTER_NONE)
		{
			continue;
		}

		int hand_bolt = -1;
		const holster_locations_t holsterPlace = ent->client->ps.saber[saber_num].holsterPlace;
		vec3_t offset = { 0.0f, 0.0f, 0.0f };
		vec3_t angles = { 0.0f, 0.0f, 0.0f };

		if (holsterPlace == HOLSTER_RHIP || holsterPlace == HOLSTER_RHIPF || holsterPlace == HOLSTER_RHIPB)
		{
			angles[PITCH] = 180.0f;
			angles[ROLL] = 180.0f;

			if (g_InvertedHolsteredSabers && g_InvertedHolsteredSabers->integer > 0)
			{
				//facing up
				angles[YAW] = 180.0f;

				if (SaberStaffWeapon(ent))
				{
					VectorSet(offset, 0.0f, -1.0f, 10.0f);
				}
				else
				{
					VectorSet(offset, 0.0f, -1.0f, -5.0f);
				}
			}
			else
			{
				//facing down
				angles[YAW] = 0.0f;

				if (SaberStaffWeapon(ent))
				{
					if (DarthMaulHolster(ent) && holsterPlace == HOLSTER_RHIPB)
					{
						VectorSet(offset, 0.0f, -1.0f, -10.0f);
					}
					else if (CalKestisHolster(ent))
					{
						VectorSet(offset, 0.0f, -1.0f, -10.0f);
					}
					else
					{
						VectorSet(offset, 0.0f, -1.0f, 10.0f);
					}
				}
				else
				{
					VectorSet(offset, 0.0f, -1.0f, -10.0f);
				}
			}
		}
		else if (holsterPlace == HOLSTER_LHIP || holsterPlace == HOLSTER_LHIPF || holsterPlace == HOLSTER_LHIPB)
		{
			angles[PITCH] = 180.0f;
			angles[ROLL] = 180.0f;

			if (g_InvertedHolsteredSabers && g_InvertedHolsteredSabers->integer > 0)
			{
				//facing up
				angles[YAW] = 180.0f;

				if (SaberStaffWeapon(ent))
				{
					VectorSet(offset, 0.0f, -1.0f, 10.0f);
				}
				else
				{
					VectorSet(offset, 0.0f, -1.0f, -5.0f);
				}
			}
			else
			{
				//facing down
				angles[YAW] = 0.0f;

				if (SaberStaffWeapon(ent))
				{
					VectorSet(offset, 0.0f, -1.0f, 10.0f);
				}
				else
				{
					VectorSet(offset, 0.0f, -1.0f, -10.0f);
				}
			}
		}
		else if (holsterPlace == HOLSTER_BACKU)
		{
			if (g_InvertedHolsteredSabers && g_InvertedHolsteredSabers->integer > 0)
			{
				angles[ROLL] = 90.0f;
				angles[YAW] = 270.0f;
				VectorSet(offset, 0.0f, -2.0f, 4.0f);
			}
			else
			{
				angles[ROLL] = 90.0f;
				angles[YAW] = 90.0f;
				VectorSet(offset, 0.0f, -2.0f, 4.0f);
			}
		}
		else if (holsterPlace == HOLSTER_BACKL)
		{
			if (g_InvertedHolsteredSabers && g_InvertedHolsteredSabers->integer > 0)
			{
				angles[ROLL] = 90.0f;
				angles[YAW] = 270.0f;
				VectorSet(offset, 0.0f, -2.0f, -10.0f);
			}
			else
			{
				angles[ROLL] = 90.0f;
				angles[YAW] = 90.0f;
				VectorSet(offset, 0.0f, -2.0f, -10.0f);
			}
		}
		else if (holsterPlace == HOLSTER_LCHESTL)
		{
			angles[PITCH] = 180.0f;
			angles[ROLL] = 180.0f;

			if (g_InvertedHolsteredSabers && g_InvertedHolsteredSabers->integer > 0)
			{
				angles[YAW] = 180.0f;
				VectorSet(offset, 0.0f, -2.0f, 0.0f);
			}
			else
			{
				angles[YAW] = 0.0f;
				VectorSet(offset, 0.0f, -2.0f, -5.0f);
			}
		}
		else if (holsterPlace == HOLSTER_RCHESTL)
		{
			angles[PITCH] = 180.0f;
			angles[ROLL] = 180.0f;

			if (g_InvertedHolsteredSabers && g_InvertedHolsteredSabers->integer > 0)
			{
				angles[YAW] = 180.0f;
				VectorSet(offset, 0.0f, -2.0f, 0.0f);
			}
			else
			{
				angles[YAW] = 0.0f;
				VectorSet(offset, 0.0f, -2.0f, -5.0f);
			}
		}
		else if (holsterPlace == HOLSTER_LCHESTU)
		{
			angles[PITCH] = 180.0f;
			angles[ROLL] = 180.0f;

			if (g_InvertedHolsteredSabers && g_InvertedHolsteredSabers->integer > 0)
			{
				angles[YAW] = 180.0f;
				VectorSet(offset, 0.0f, -2.0f, 0.0f);
			}
			else
			{
				angles[YAW] = 0.0f;
				VectorSet(offset, 0.0f, -2.0f, -5.0f);
			}
		}
		else if (holsterPlace == HOLSTER_RCHESTU)
		{
			angles[PITCH] = 180.0f;
			angles[ROLL] = 180.0f;

			if (g_InvertedHolsteredSabers && g_InvertedHolsteredSabers->integer > 0)
			{
				angles[YAW] = 180.0f;
				VectorSet(offset, 0.0f, -2.0f, 0.0f);
			}
			else
			{
				angles[YAW] = 0.0f;
				VectorSet(offset, 0.0f, -2.0f, -5.0f);
			}
		}
		else if (holsterPlace == HOLSTER_BACK)
		{
			if (g_InvertedHolsteredSabers && g_InvertedHolsteredSabers->integer > 0)
			{
				angles[YAW] = 180.0f;
				VectorSet(offset, 0.0f, -2.0f, 4.0f);
			}
			else
			{
				if (SecondSisterHolster(ent))
				{
					angles[ROLL] = 90.0f;
					angles[YAW] = 0.0f;
					VectorSet(offset, 0.0f, -2.0f, -4.0f);
				}
				else if (FifthBrotherHolster(ent) || EighthBrotherHolster(ent) || SeventhSisterHolster(ent) ||
					InquisitorHolster(ent))
				{
					angles[ROLL] = 90.0f;
					angles[YAW] = 90.0f;

					if (InquisitorHolster(ent))
					{
						VectorSet(offset, 0.0f, -2.0f, 4.0f);
					}
					else if (FifthBrotherHolster(ent))
					{
						VectorSet(offset, 0.0f, -2.0f, 0.0f);
					}
					else
					{
						VectorSet(offset, 0.0f, -2.0f, -4.0f);
					}
				}
				else if (GamorreanHolster(ent))
				{
					angles[ROLL] = 90.0f;
					angles[YAW] = 20.0f;
					VectorSet(offset, 0.0f, -8.0f, -12.0f);
				}
				else if (RoyalguardHolster(ent))
				{
					angles[YAW] = 0.0f;
					VectorSet(offset, 0.0f, -2.0f, -12.0f);
				}
				else
				{
					angles[YAW] = 0.0f;
					VectorSet(offset, 0.0f, -2.0f, -4.0f);
				}
			}
			angles[PITCH] = 22.5f;
		}

		if (saber_num == 0)
		{
			if (holsterPlace == HOLSTER_LHIP)
			{
				hand_bolt = gi.G2API_AddBolt(&ent->ghoul2[ent->playerModel], "*hip_l");
			}
			else if (holsterPlace == HOLSTER_LHIPF)
			{
				if (g_CannonHolsteredSabers && g_CannonHolsteredSabers->integer > 0)
				{
					if (CalKestisHolster(ent))
					{
						hand_bolt = gi.G2API_AddBolt(&ent->ghoul2[ent->playerModel], "*hip_r");
					}
					else
					{
						hand_bolt = gi.G2API_AddBolt(&ent->ghoul2[ent->playerModel], "*hip_fl");
					}
				}
				else
				{
					hand_bolt = gi.G2API_AddBolt(&ent->ghoul2[ent->playerModel], "*hip_r");
				}
			}
			else if (holsterPlace == HOLSTER_LHIPB)
			{
				hand_bolt = gi.G2API_AddBolt(&ent->ghoul2[ent->playerModel], "*hip_bl");
			}
			else if (holsterPlace == HOLSTER_RHIP)
			{
				hand_bolt = gi.G2API_AddBolt(&ent->ghoul2[ent->playerModel], "*hip_r");
			}
			else if (holsterPlace == HOLSTER_RHIPF)
			{
				hand_bolt = gi.G2API_AddBolt(&ent->ghoul2[ent->playerModel], "*hip_fr");
			}
			else if (holsterPlace == HOLSTER_RHIPB)
			{
				if (DarthMaulHolster(ent))
				{
					hand_bolt = gi.G2API_AddBolt(&ent->ghoul2[ent->playerModel], "*hip_r");
				}
				else if (CalKestisHolster(ent))
				{
					hand_bolt = gi.G2API_AddBolt(&ent->ghoul2[ent->playerModel], "*hip_r");
				}
				else
				{
					hand_bolt = gi.G2API_AddBolt(&ent->ghoul2[ent->playerModel], "*hip_br");
				}
			}
			else if (holsterPlace == HOLSTER_LCHESTL)
			{
				hand_bolt = gi.G2API_AddBolt(&ent->ghoul2[ent->playerModel], "*lchest_l");
			}
			else if (holsterPlace == HOLSTER_RCHESTL)
			{
				hand_bolt = gi.G2API_AddBolt(&ent->ghoul2[ent->playerModel], "*lchest_r");
			}
			else if (holsterPlace == HOLSTER_LCHESTU)
			{
				hand_bolt = gi.G2API_AddBolt(&ent->ghoul2[ent->playerModel], "*uchest_l");
			}
			else if (holsterPlace == HOLSTER_RCHESTU)
			{
				hand_bolt = gi.G2API_AddBolt(&ent->ghoul2[ent->playerModel], "*uchest_r");
			}
			else if (holsterPlace == HOLSTER_BACKU || holsterPlace == HOLSTER_BACKL || holsterPlace == HOLSTER_BACK)
			{
				if (SecondSisterHolster(ent))
				{
					hand_bolt = gi.G2API_AddBolt(&ent->ghoul2[ent->playerModel], "*hip_l");
				}
				else
				{
					hand_bolt = gi.G2API_AddBolt(&ent->ghoul2[ent->playerModel], "*back");
				}
			}
		}
		else
		{
			if (holsterPlace == HOLSTER_RHIP || holsterPlace == HOLSTER_LHIP)
			{
				if (ent->client->ps.saber[0].holsterPlace == HOLSTER_LHIP)
				{
					hand_bolt = gi.G2API_AddBolt(&ent->ghoul2[ent->playerModel], "*hip_r");
				}
				else
				{
					hand_bolt = gi.G2API_AddBolt(&ent->ghoul2[ent->playerModel], "*hip_l");
				}
			}
			else if (holsterPlace == HOLSTER_RHIPF || holsterPlace == HOLSTER_LHIPF)
			{
				if (ent->client->ps.saber[0].holsterPlace == HOLSTER_LHIPF)
				{
					if (g_CannonHolsteredSabers && g_CannonHolsteredSabers->integer > 0)
					{
						hand_bolt = gi.G2API_AddBolt(&ent->ghoul2[ent->playerModel], "*hip_l");
					}
					else
					{
						if (CalKestisHolster(ent))
						{
							hand_bolt = gi.G2API_AddBolt(&ent->ghoul2[ent->playerModel], "*hip_r");
						}
						else
						{
							hand_bolt = gi.G2API_AddBolt(&ent->ghoul2[ent->playerModel], "*hip_fr");
						}
					}
				}
				else
				{
					hand_bolt = gi.G2API_AddBolt(&ent->ghoul2[ent->playerModel], "*hip_fl");
				}
			}

			else if (holsterPlace == HOLSTER_RHIPB || holsterPlace == HOLSTER_LHIPB)
			{
				if (ent->client->ps.saber[0].holsterPlace == HOLSTER_LHIPB)
				{
					if (DarthMaulHolster(ent))
					{
						hand_bolt = gi.G2API_AddBolt(&ent->ghoul2[ent->playerModel], "*hip_r");
					}
					else
					{
						hand_bolt = gi.G2API_AddBolt(&ent->ghoul2[ent->playerModel], "*hip_br");
					}
				}
				else
				{
					if (CalKestisHolster(ent))
					{
						hand_bolt = gi.G2API_AddBolt(&ent->ghoul2[ent->playerModel], "*hip_r");
					}
					else
					{
						hand_bolt = gi.G2API_AddBolt(&ent->ghoul2[ent->playerModel], "*hip_bl");
					}
				}
			}
			else if (holsterPlace == HOLSTER_LCHESTL)
			{
				hand_bolt = gi.G2API_AddBolt(&ent->ghoul2[ent->playerModel], "*lchest_l");
			}
			else if (holsterPlace == HOLSTER_RCHESTL)
			{
				hand_bolt = gi.G2API_AddBolt(&ent->ghoul2[ent->playerModel], "*lchest_r");
			}
			else if (holsterPlace == HOLSTER_LCHESTU)
			{
				hand_bolt = gi.G2API_AddBolt(&ent->ghoul2[ent->playerModel], "*uchest_l");
			}
			else if (holsterPlace == HOLSTER_RCHESTU)
			{
				hand_bolt = gi.G2API_AddBolt(&ent->ghoul2[ent->playerModel], "*uchest_r");
			}
			else if (holsterPlace == HOLSTER_BACKU || holsterPlace == HOLSTER_BACKL || holsterPlace == HOLSTER_BACK)
			{
				if (ent->client->ps.saber[0].holsterPlace == HOLSTER_BACKU || ent->client->ps.saber[0].holsterPlace ==
					HOLSTER_BACKL || ent->client->ps.saber[0].holsterPlace == HOLSTER_BACK)
				{
					continue;
				}
				if (SecondSisterHolster(ent))
				{
					hand_bolt = gi.G2API_AddBolt(&ent->ghoul2[ent->playerModel], "*hip_l");
				}
				else
				{
					hand_bolt = gi.G2API_AddBolt(&ent->ghoul2[ent->playerModel], "*back");
				}
			}
		}

		G_CreateG2HolsteredWeaponModel(ent, ent->client->ps.saber[saber_num].model, hand_bolt, saber_num, angles,
			offset);

		if (ent->client->ps.saber[saber_num].skin != nullptr)
		{
			//if this saber has a customSkin, use it
			// lets see if it's out there
			const int saber_skin = gi.RE_RegisterSkin(ent->client->ps.saber[saber_num].skin);
			if (saber_skin)
			{
				// put it in the config strings
				// and set the ghoul2 model to use it
				gi.G2API_SetSkin(&ent->ghoul2[ent->holsterModel[saber_num]],
					G_SkinIndex(ent->client->ps.saber[saber_num].skin), saber_skin);
			}
		}
	}
}

//----------------------------------------------------------
void G_Throw(gentity_t* targ, const vec3_t new_dir, const float push)
//----------------------------------------------------------
{
	vec3_t kvel;
	float mass;

	if (targ
		&& targ->client
		&& (targ->client->NPC_class == CLASS_ATST
			|| targ->client->NPC_class == CLASS_RANCOR
			|| targ->client->NPC_class == CLASS_SAND_CREATURE))
	{
		//much to large to *ever* throw
		return;
	}

	if (targ && targ->physicsBounce > 0) //override the mass
	{
		mass = targ->physicsBounce;
	}
	else
	{
		mass = 200;
	}

	if (g_gravity->value > 0)
	{
		if (jedi_is_kick_resistant(targ))
		{
			VectorScale(new_dir, g_knockback->value * 5 / mass, kvel);
		}
		else
		{
			VectorScale(new_dir, g_knockback->value * push / mass * 0.8, kvel);
		}
		if (!targ->client || targ->client->ps.groundEntityNum != ENTITYNUM_NONE)
		{
			//give them some z lift to get them off the ground
			kvel[2] = new_dir[2] * g_knockback->value * push / mass * 1.5;
		}
	}
	else
	{
		if (jedi_is_kick_resistant(targ))
		{
			VectorScale(new_dir, g_knockback->value * 5 / mass, kvel);
		}
		else
		{
			VectorScale(new_dir, g_knockback->value * push / mass, kvel);
		}
	}

	if (targ && targ->client)
	{
		VectorAdd(targ->client->ps.velocity, kvel, targ->client->ps.velocity);
	}
	else if (targ->s.pos.trType != TR_STATIONARY && targ->s.pos.trType != TR_NONLINEAR_STOP && targ->s.pos.trType != TR_LINEAR_STOP)
	{
		VectorAdd(targ->s.pos.trDelta, kvel, targ->s.pos.trDelta);
		VectorCopy(targ->currentOrigin, targ->s.pos.trBase);
		targ->s.pos.trTime = level.time;
	}

	// set the timer so that the other client can't cancel
	// out the movement immediately
	if (targ->client && !targ->client->ps.pm_time)
	{
		int t = push * 2;

		if (t < 50)
		{
			t = 50;
		}
		if (t > 200)
		{
			t = 200;
		}
		targ->client->ps.pm_time = t;
		targ->client->ps.pm_flags |= PMF_TIME_KNOCKBACK;
	}
}

//----------------------------------------------------------
void G_Kick_Throw(gentity_t* targ, const vec3_t new_dir, const float push)
//----------------------------------------------------------
{
	vec3_t kvel;
	float mass;

	if (targ
		&& targ->client
		&& (targ->client->NPC_class == CLASS_ATST
			|| targ->client->NPC_class == CLASS_RANCOR
			|| targ->client->NPC_class == CLASS_SAND_CREATURE))
	{
		//much to large to *ever* throw
		return;
	}

	if (targ && targ->physicsBounce > 0) //override the mass
	{
		mass = targ->physicsBounce;
	}
	else
	{
		mass = 200;
	}

	if (g_gravity->value > 0)
	{
		if (jedi_is_kick_resistant(targ))
		{
			VectorScale(new_dir, g_knockback->value * 5 / mass, kvel);
		}
		else
		{
			VectorScale(new_dir, g_knockback->value * push / mass * 0.8, kvel);
		}
		if (!targ->client || targ->client->ps.groundEntityNum != ENTITYNUM_NONE)
		{
			//give them some z lift to get them off the ground
			kvel[2] = new_dir[2] * g_knockback->value * push / mass * 1.5;
		}
	}
	else
	{
		if (jedi_is_kick_resistant(targ))
		{
			VectorScale(new_dir, g_knockback->value * 5 / mass, kvel);
		}
		else
		{
			VectorScale(new_dir, g_knockback->value * push / mass, kvel);
		}
	}

	if (targ && targ->client)
	{
		VectorAdd(targ->client->ps.velocity, kvel, targ->client->ps.velocity);
	}
	else if (targ->s.pos.trType != TR_STATIONARY && targ->s.pos.trType != TR_NONLINEAR_STOP && targ->s.pos.trType != TR_LINEAR_STOP)
	{
		VectorAdd(targ->s.pos.trDelta, kvel, targ->s.pos.trDelta);
		VectorCopy(targ->currentOrigin, targ->s.pos.trBase);
		targ->s.pos.trTime = level.time;
	}

	// set the timer so that the other client can't cancel
	// out the movement immediately
	if (targ->client && !targ->client->ps.pm_time)
	{
		int t = push * 2;

		if (t < 10)
		{
			t = 10;
		}
		if (t > 150)
		{
			t = 150;
		}
		targ->client->ps.pm_time = t;
		targ->client->ps.pm_flags |= PMF_TIME_KNOCKBACK;
	}
}

static int WP_SetSaberModel(gclient_t* client, const class_t npc_class)
{
	//FIXME: read from NPCs.cfg
	if (client)
	{
		switch (npc_class)
		{
		case CLASS_DESANN: //Desann
			client->ps.saber[0].model = "models/weapons2/saber_desann/saber_w.glm";
			break;
		case CLASS_VADER: //Desann
			client->ps.saber[0].model = "models/weapons2/saber_VaderEp5/saber_w.glm";
			break;
		case CLASS_LUKE: //Luke
			client->ps.saber[0].model = "models/weapons2/saber_luke/saber_w.glm";
			break;
		case CLASS_YODA: //YODA
			client->ps.saber[0].model = "models/weapons2/saber_plasma/saber_yoda.glm";
			break;
		case CLASS_PLAYER: //Kyle NPC and player
		case CLASS_PROJECTION:
		case CLASS_KYLE: //Kyle NPC and player
			client->ps.saber[0].model = "models/weapons2/saber/saber_w.glm";
			break;
		default: //reborn and tavion and everyone
			client->ps.saber[0].model = DEFAULT_SABER_MODEL;
			break;
		}
		return G_ModelIndex(client->ps.saber[0].model);
	}
	switch (npc_class)
	{
	case CLASS_DESANN: //Desann
		return G_ModelIndex("models/weapons2/saber_desann/saber_w.glm");
	case CLASS_VADER: //Desann
		return G_ModelIndex("models/weapons2/saber_VaderEp5/saber_w.glm");
	case CLASS_LUKE: //Luke
		return G_ModelIndex("models/weapons2/saber_luke/saber_w.glm");
	case CLASS_YODA: //Luke
		return G_ModelIndex("models/weapons2/saber_plasma/saber_yoda.glm");
	case CLASS_PLAYER: //Kyle NPC and player
	case CLASS_PROJECTION:
	case CLASS_KYLE: //Kyle NPC and player
		return G_ModelIndex("models/weapons2/saber/saber_w.glm");
	default: //reborn and tavion and everyone else
		return G_ModelIndex(DEFAULT_SABER_MODEL);
	}
}

void WP_SetSaberEntModelSkin(const gentity_t* ent, gentity_t* saberent)
{
	int saber_model;
	qboolean new_model = qfalse;

	if (!ent->client->ps.saber[0].model)
	{
		saber_model = WP_SetSaberModel(ent->client, ent->client->NPC_class);
	}
	else
	{
		//got saberModel from NPCs.cfg
		saber_model = G_ModelIndex(ent->client->ps.saber[0].model);
	}
	if (saber_model && saberent->s.modelindex != saber_model)
	{
		if (saberent->playerModel >= 0)
		{
			//remove the old one, if there is one
			gi.G2API_RemoveGhoul2Model(saberent->ghoul2, saberent->playerModel);
		}
		//add the new one
		saberent->playerModel = gi.G2API_InitGhoul2Model(saberent->ghoul2, ent->client->ps.saber[0].model, saber_model,
			NULL_HANDLE, NULL_HANDLE, 0, 0);
		saberent->s.modelindex = saber_model;
		new_model = qtrue;
	}
	//set skin, too
	if (ent->client->ps.saber[0].skin == nullptr)
	{
		gi.G2API_SetSkin(&saberent->ghoul2[0], -1, 0);
	}
	else
	{
		//if this saber has a customSkin, use it
		// lets see if it's out there
		const int saber_skin = gi.RE_RegisterSkin(ent->client->ps.saber[0].skin);
		if (saber_skin && (new_model || saberent->s.modelindex2 != saber_skin))
		{
			// put it in the config strings
			// and set the ghoul2 model to use it
			gi.G2API_SetSkin(&saberent->ghoul2[0], G_SkinIndex(ent->client->ps.saber[0].skin), saber_skin);
			saberent->s.modelindex2 = saber_skin;
		}
	}
}

void WP_SaberFallSound(const gentity_t* owner, const gentity_t* saber)
{
	if (!saber)
	{
		return;
	}
	if (owner && owner->client)
	{
		//have an owner, use their data (assume saber_num is 0 because only the 0 saber can be thrown)
		if (owner->client->ps.saber[0].fallSound[0])
		{
			//have an override
			G_Sound(saber, owner->client->ps.saber[0].fallSound[Q_irand(0, 2)]);
		}
		else if (owner->client->ps.saber[0].type == SABER_SITH_SWORD)
		{
			//is a sith sword
			G_Sound(saber, G_SoundIndex(va("sound/weapons/sword/fall%d.wav", Q_irand(1, 7))));
		}
		else
		{
			//normal saber
			G_Sound(saber, G_SoundIndex(va("sound/weapons/saber/bounce%d.wav", Q_irand(1, 3))));
		}
	}
	else if (saber->NPC_type && saber->NPC_type[0])
	{
		//have a saber name to look up
		saberInfo_t saber_info;
		if (WP_SaberParseParms(saber->NPC_type, &saber_info))
		{
			//found it
			if (saber_info.fallSound[0])
			{
				//have an override sound
				G_Sound(saber, saber_info.fallSound[Q_irand(0, 2)]);
			}
			else if (saber_info.type == SABER_SITH_SWORD)
			{
				//is a sith sword
				G_Sound(saber, G_SoundIndex(va("sound/weapons/sword/fall%d.wav", Q_irand(1, 7))));
			}
			else
			{
				//normal saber
				G_Sound(saber, G_SoundIndex(va("sound/weapons/saber/bounce%d.wav", Q_irand(1, 3))));
			}
		}
		else
		{
			//can't find it
			G_Sound(saber, G_SoundIndex(va("sound/weapons/saber/bounce%d.wav", Q_irand(1, 3))));
		}
	}
	else
	{
		//no saber name specified
		G_Sound(saber, G_SoundIndex(va("sound/weapons/saber/bounce%d.wav", Q_irand(1, 3))));
	}
}

void WP_SaberSwingSound(const gentity_t* ent, const int saber_num, const swingType_t swing_type)
{
	int index = 1;
	if (!ent || !ent->client)
	{
		return;
	}
	if (swing_type == SWING_FAST)
	{
		index = Q_irand(1, 3);
	}
	else if (swing_type == SWING_MEDIUM)
	{
		index = Q_irand(4, 6);
	}
	else if (swing_type == SWING_STRONG)
	{
		index = Q_irand(7, 9);
	}

	if (ent->client->ps.saber[saber_num].swingSound[0])
	{
		G_SoundIndexOnEnt(ent, CHAN_WEAPON, ent->client->ps.saber[saber_num].swingSound[Q_irand(0, 2)]);
	}
	else if (ent->client->ps.saber[saber_num].type == SABER_SITH_SWORD)
	{
		G_SoundOnEnt(ent, CHAN_WEAPON, va("sound/weapons/sword/swing%d.wav", Q_irand(1, 4)));
	}
	else
	{
		G_SoundOnEnt(ent, CHAN_WEAPON, va("sound/weapons/saber/saberhup%d.wav", index));
	}
}

static void WP_SaberHitSound(const gentity_t* ent, const int saber_num, const int blade_num)
{
	const qboolean saber_in_stab_down = PM_StabDownAnim(ent->client->ps.torsoAnim);
	const qboolean saber_in_special = PM_SaberInKillAttack(ent->client->ps.torsoAnim);
	const qboolean saber_in_over_head_attack = PM_SaberInOverHeadSlash(
		static_cast<saber_moveName_t>(ent->client->ps.saber_move));
	const qboolean saber_in_kata = PM_SaberInKata(static_cast<saber_moveName_t>(ent->client->ps.saber_move));
	const qboolean saber_in_lock_win = PM_SaberInLockWin(ent->client->ps.torsoAnim);
	const qboolean saber_in_back_attack = PM_SaberInBackAttack(static_cast<saber_moveName_t>(ent->client->ps.saber_move));
	const qboolean saber_in_lunge_attack = PM_LungRollAnim(ent->client->ps.torsoAnim);
	const qboolean saber_in_roll_stab = PM_SaberInRollStab(static_cast<saber_moveName_t>(ent->client->ps.saber_move));

	if (!ent || !ent->client)
	{
		return;
	}

	const int index = Q_irand(1, 3);
	const int index_stab = Q_irand(1, 11);
	const int index_kill = Q_irand(1, 17);
	const int indexspecial = Q_irand(1, 21);
	const int indexdroidkill = Q_irand(1, 5);

	if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
		&& ent->client->ps.saber[saber_num].hitSound[0])
	{
		G_Sound(ent, ent->client->ps.saber[saber_num].hitSound[Q_irand(0, 2)]);
	}
	else if (WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
		&& ent->client->ps.saber[saber_num].hit2Sound[0])
	{
		G_Sound(ent, ent->client->ps.saber[saber_num].hit2Sound[Q_irand(0, 2)]);
	}
	else if (ent->client->ps.saber[saber_num].type == SABER_SITH_SWORD)
	{
		G_Sound(ent, G_SoundIndex(va("sound/weapons/sword/stab%d.wav", Q_irand(1, 4))));
	}
	else
	{
		if (saber_in_stab_down)
		{
			G_Sound(ent, G_SoundIndex(va("sound/weapons/saber/saberstabdown%d.mp3", index_stab)));
			if (g_SerenityJediEngineMode->integer == 2 && (d_SaberactionInfo->integer || g_DebugSaberCombat->integer))
			{
				gi.Printf(S_COLOR_RED"AMD Mode saberstabdownsound\n");
			}
		}
		else if (saber_in_special && !saber_in_roll_stab || (saber_in_over_head_attack || saber_in_kata)
			&& (ent->enemy && ent->enemy->health >= 15))
		{
			G_Sound(ent, G_SoundIndex(va("sound/weapons/saber/saberhit_md%d.mp3", indexspecial)));
			if (g_SerenityJediEngineMode->integer == 2 && (d_SaberactionInfo->integer || g_DebugSaberCombat->integer))
			{
				gi.Printf(S_COLOR_RED"AMD Mode saberspecialhitsound\n");
			}
		}
		else if (ent->enemy && ent->enemy->health <= 5
			|| saber_in_back_attack
			|| saber_in_lunge_attack
			|| saber_in_roll_stab
			|| saber_in_lock_win
			|| (saber_in_over_head_attack || saber_in_kata) && (ent->enemy && ent->enemy->health <= 15))
		{
			if (ent->client->NPC_class == CLASS_ATST
				|| ent->client->NPC_class == CLASS_GONK
				|| ent->client->NPC_class == CLASS_INTERROGATOR
				|| ent->client->NPC_class == CLASS_MARK1
				|| ent->client->NPC_class == CLASS_MARK2
				|| ent->client->NPC_class == CLASS_MOUSE
				|| ent->client->NPC_class == CLASS_PROBE
				|| ent->client->NPC_class == CLASS_PROTOCOL
				|| ent->client->NPC_class == CLASS_R2D2
				|| ent->client->NPC_class == CLASS_R5D2
				|| ent->client->NPC_class == CLASS_SEEKER
				|| ent->client->NPC_class == CLASS_SENTRY
				|| ent->client->NPC_class == CLASS_SBD
				|| ent->client->NPC_class == CLASS_BATTLEDROID
				|| ent->client->NPC_class == CLASS_DROIDEKA
				|| ent->client->NPC_class == CLASS_OBJECT
				|| ent->client->NPC_class == CLASS_ASSASSIN_DROID
				|| ent->client->NPC_class == CLASS_SABER_DROID)
			{
				G_Sound(ent, G_SoundIndex(va("sound/weapons/saber/saberhit_droid_md%d.mp3", indexdroidkill)));

				if (g_SerenityJediEngineMode->integer == 2 && (d_SaberactionInfo->integer || g_DebugSaberCombat->integer))
				{
					gi.Printf(S_COLOR_RED"AMD Mode saberDroidkillsound\n");
				}
			}
			else
			{
				G_Sound(ent, G_SoundIndex(va("sound/weapons/saber/saberkill%d.mp3", index_kill)));

				if (g_SerenityJediEngineMode->integer == 2 && (d_SaberactionInfo->integer || g_DebugSaberCombat->integer))
				{
					gi.Printf(S_COLOR_RED"AMD Mode saberkillsound\n");
				}
			}
		}
		else if (ent->enemy && ent->enemy->health <= 5 && saber_in_lunge_attack)
		{
			if (ent->client->NPC_class == CLASS_ATST
				|| ent->client->NPC_class == CLASS_GONK
				|| ent->client->NPC_class == CLASS_INTERROGATOR
				|| ent->client->NPC_class == CLASS_MARK1
				|| ent->client->NPC_class == CLASS_MARK2
				|| ent->client->NPC_class == CLASS_MOUSE
				|| ent->client->NPC_class == CLASS_PROBE
				|| ent->client->NPC_class == CLASS_PROTOCOL
				|| ent->client->NPC_class == CLASS_R2D2
				|| ent->client->NPC_class == CLASS_R5D2
				|| ent->client->NPC_class == CLASS_SEEKER
				|| ent->client->NPC_class == CLASS_SENTRY
				|| ent->client->NPC_class == CLASS_SBD
				|| ent->client->NPC_class == CLASS_BATTLEDROID
				|| ent->client->NPC_class == CLASS_DROIDEKA
				|| ent->client->NPC_class == CLASS_OBJECT
				|| ent->client->NPC_class == CLASS_ASSASSIN_DROID
				|| ent->client->NPC_class == CLASS_SABER_DROID)
			{
				G_Sound(ent, G_SoundIndex(va("sound/weapons/saber/saberhit_droid_md%d.mp3", indexdroidkill)));

				if (g_SerenityJediEngineMode->integer == 2 && (d_SaberactionInfo->integer || g_DebugSaberCombat->integer))
				{
					gi.Printf(S_COLOR_RED"AMD Mode saberDroidkillsound\n");
				}
			}
			else
			{
				G_Sound(ent, G_SoundIndex(va("sound/weapons/saber/saberkill%d.mp3", index_kill)));

				if (g_SerenityJediEngineMode->integer == 2 && (d_SaberactionInfo->integer || g_DebugSaberCombat->integer))
				{
					gi.Printf(S_COLOR_RED"AMD Mode saberkillsound\n");
				}
			}
		}
		else
		{
			G_Sound(ent, G_SoundIndex(va("sound/weapons/saber/saberhit_md%d.mp3", indexspecial)));
			if (g_SerenityJediEngineMode->integer == 2 && (d_SaberactionInfo->integer || g_DebugSaberCombat->integer))
			{
				gi.Printf(S_COLOR_RED"AMD Mode saberhitsound\n");
			}
		}
	}
}

static void WP_SaberBlockSound(const gentity_t* ent, const int saber_num, const int blade_num)
{
	if (!ent || !ent->client)
	{
		return;
	}
	const int index = Q_irand(1, 90);
	const int classicindex = Q_irand(1, 30);

	if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
		&& ent->client->ps.saber[saber_num].blockSound[0])
	{
		G_Sound(ent, ent->client->ps.saber[saber_num].blockSound[Q_irand(0, 2)]);
	}
	else if (WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
		&& ent->client->ps.saber[saber_num].block2Sound[0])
	{
		G_Sound(ent, ent->client->ps.saber[saber_num].block2Sound[Q_irand(0, 2)]);
	}
	else
	{
		if (ent->client->ps.saber[saber_num].type == SABER_SINGLE_CLASSIC)
		{
			G_Sound(ent, G_SoundIndex(va("sound/weapons/saber/classicblock%d.mp3", classicindex)));
		}
		else
		{
			G_Sound(ent, G_SoundIndex(va("sound/weapons/saber/saberblock%d.mp3", index)));
		}
	}
}

static void WP_SaberBounceOnWallSound(const gentity_t* ent, const int saber_num, const int blade_num)
{
	if (!ent || !ent->client)
	{
		return;
	}
	const int index = Q_irand(1, 90);
	const int classicindex = Q_irand(1, 30);

	if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
		&& ent->client->ps.saber[saber_num].bounceSound[0])
	{
		G_Sound(ent, ent->client->ps.saber[saber_num].bounceSound[Q_irand(0, 2)]);
	}
	else if (WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
		&& ent->client->ps.saber[saber_num].bounce2Sound[0])
	{
		G_Sound(ent, ent->client->ps.saber[saber_num].bounce2Sound[Q_irand(0, 2)]);
	}
	else if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
		&& ent->client->ps.saber[saber_num].blockSound[0])
	{
		G_Sound(ent, ent->client->ps.saber[saber_num].blockSound[Q_irand(0, 2)]);
	}
	else if (WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
		&& ent->client->ps.saber[saber_num].block2Sound[0])
	{
		G_Sound(ent, ent->client->ps.saber[saber_num].block2Sound[Q_irand(0, 2)]);
	}
	else
	{
		if (ent->client->ps.saber[saber_num].type == SABER_SINGLE_CLASSIC)
		{
			G_Sound(ent, G_SoundIndex(va("sound/weapons/saber/classicblock%d.mp3", classicindex)));
		}
		else
		{
			G_Sound(ent, G_SoundIndex(va("sound/weapons/saber/saberblock%d.mp3", index)));
		}
	}
}

static void WP_SaberBounceSound(const gentity_t* ent, const gentity_t* play_on_ent, const int saber_num, const int blade_num)
{
	if (!ent || !ent->client)
	{
		return;
	}
	const int index = Q_irand(1, 3);
	const int classicindex = Q_irand(1, 30);

	if (!play_on_ent)
	{
		play_on_ent = ent;
	}
	if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
		&& ent->client->ps.saber[saber_num].blockSound[0])
	{
		G_Sound(play_on_ent, ent->client->ps.saber[saber_num].blockSound[Q_irand(0, 2)]);
	}
	else if (WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
		&& ent->client->ps.saber[saber_num].block2Sound[0])
	{
		G_Sound(play_on_ent, ent->client->ps.saber[saber_num].block2Sound[Q_irand(0, 2)]);
	}
	else
	{
		if (ent->client->ps.saber[saber_num].type == SABER_SINGLE_CLASSIC)
		{
			G_Sound(ent, G_SoundIndex(va("sound/weapons/saber/classicblock%d.mp3", classicindex)));
		}
		else
		{
			G_Sound(play_on_ent, G_SoundIndex(va("sound/weapons/saber/saberbounce%d.wav", index)));
		}
	}
}

int WP_SaberInitBladeData(gentity_t* ent)
{
	if (!ent->client)
	{
		return 0;
	}
	if (true)
	{
		VectorClear(ent->client->renderInfo.muzzlePoint);
		VectorClear(ent->client->renderInfo.muzzlePointOld);
		VectorClear(ent->client->renderInfo.muzzleDir);
		VectorClear(ent->client->renderInfo.muzzleDirOld);

		for (auto& saber_num : ent->client->ps.saber)
		{
			for (auto& blade_num : saber_num.blade)
			{
				VectorClear(blade_num.muzzlePoint);
				VectorClear(blade_num.muzzlePointOld);
				VectorClear(blade_num.muzzleDir);
				VectorClear(blade_num.muzzleDirOld);
				blade_num.lengthOld = blade_num.length = 0;
				if (!blade_num.lengthMax)
				{
					if (ent->client->NPC_class == CLASS_DESANN || ent->client->NPC_class == CLASS_VADER)
					{
						//longer saber
						blade_num.lengthMax = 48;
					}
					else if (ent->client->NPC_class == CLASS_REBORN)
					{
						//shorter saber
						blade_num.lengthMax = 32;
					}
					else
					{
						//standard saber length
						blade_num.lengthMax = 40;
					}
				}
			}
		}
		ent->client->ps.saberLockEnemy = ENTITYNUM_NONE;
		ent->client->ps.saberLockTime = 0;
		if (ent->s.number)
		{
			if (!ent->client->ps.saber_anim_level)
			{
				if (ent->client->NPC_class == CLASS_DESANN || ent->client->NPC_class == CLASS_VADER)
				{
					ent->client->ps.saber_anim_level = SS_DESANN;
				}
				else if (ent->client->NPC_class == CLASS_TAVION)
				{
					ent->client->ps.saber_anim_level = SS_TAVION;
				}
				else if (ent->client->NPC_class == CLASS_YODA)
				{
					ent->client->ps.saber_anim_level = SS_TAVION;
				}
				else if (ent->client->NPC_class == CLASS_ALORA)
				{
					ent->client->ps.saber_anim_level = SS_DUAL;
				}
				else if (ent->client->NPC_class == CLASS_GALEN)
				{
					ent->client->ps.saber_anim_level = SS_STAFF;
				}
				else if (!Q_stricmpn("cultist", ent->NPC_type, 7))
				{
					//should already be set in the .npc file
					ent->client->ps.saber_anim_level = Q_irand(SS_FAST, SS_STRONG);
				}
				else if (ent->NPC && ent->client->playerTeam == TEAM_ENEMY && (ent->NPC->rank == RANK_CIVILIAN || ent->
					NPC->rank == RANK_LT_JG))
				{
					//grunt and fencer always uses quick attacks
					ent->client->ps.saber_anim_level = SS_FAST;
				}
				else if (ent->NPC && ent->client->playerTeam == TEAM_ENEMY && (ent->NPC->rank == RANK_CREWMAN || ent->
					NPC->rank == RANK_ENSIGN))
				{
					//acrobat & force-users always use medium attacks
					ent->client->ps.saber_anim_level = SS_MEDIUM;
				}
				else if (ent->client->playerTeam == TEAM_ENEMY && ent->client->NPC_class == CLASS_SHADOWTROOPER)
				{
					//shadowtroopers
					ent->client->ps.saber_anim_level = Q_irand(SS_FAST, SS_STRONG);
				}
				else if (ent->NPC && ent->client->playerTeam == TEAM_ENEMY && ent->NPC->rank == RANK_LT)
				{
					//boss always starts with strong attacks
					ent->client->ps.saber_anim_level = SS_STRONG;
				}
				else if (ent->client->NPC_class == CLASS_PLAYER || ent->client->NPC_class == CLASS_PROJECTION)
				{
					ent->client->ps.saber_anim_level = g_entities[0].client->ps.saber_anim_level;
				}
				else
				{
					//?
					ent->client->ps.saber_anim_level = Q_irand(SS_FAST, SS_STRONG);
				}
			}
		}
		else
		{
			if (!ent->client->ps.saber_anim_level)
			{
				//initialize, but don't reset
				if (ent->s.number < MAX_CLIENTS)
				{
					if (!ent->client->ps.saberStylesKnown)
					{
						ent->client->ps.saberStylesKnown = 1 << SS_MEDIUM;
					}

					if (ent->client->ps.saberStylesKnown & 1 << SS_FAST)
					{
						ent->client->ps.saber_anim_level = SS_FAST;
					}
					else if (ent->client->ps.saberStylesKnown & 1 << SS_STRONG)
					{
						ent->client->ps.saber_anim_level = SS_STRONG;
					}
					else if (ent->client->ps.saberStylesKnown & 1 << SS_DESANN)
					{
						ent->client->ps.saber_anim_level = SS_DESANN;
					}
					else if (ent->client->ps.saberStylesKnown & 1 << SS_TAVION)
					{
						ent->client->ps.saber_anim_level = SS_TAVION;
					}
					else
					{
						ent->client->ps.saber_anim_level = SS_MEDIUM;
					}
				}
				else
				{
					ent->client->ps.saber_anim_level = SS_MEDIUM;
				}
			}

			cg.saberAnimLevelPending = ent->client->ps.saber_anim_level;
			if (ent->client->sess.missionStats.weaponUsed[WP_SABER] <= 0)
			{
				//let missionStats know that we actually do have the saber, even if we never use it
				ent->client->sess.missionStats.weaponUsed[WP_SABER] = 1;
			}
		}
		ent->client->ps.saberAttackChainCount = MISHAPLEVEL_NONE;

		if (ent->client->ps.saberEntityNum <= 0 || ent->client->ps.saberEntityNum >= ENTITYNUM_WORLD)
		{
			gentity_t* saberent = G_Spawn();
			ent->client->ps.saberEntityNum = saberent->s.number;
			saberent->classname = "lightsaber";

			saberent->s.eType = ET_GENERAL;
			saberent->svFlags = SVF_USE_CURRENT_ORIGIN;
			saberent->s.weapon = WP_SABER;
			saberent->owner = ent;
			saberent->s.otherentity_num = ent->s.number;
			//clear the enemy
			saberent->enemy = nullptr;

			saberent->clipmask = MASK_SOLID | CONTENTS_LIGHTSABER;
			saberent->contents = CONTENTS_LIGHTSABER; //|CONTENTS_SHOTCLIP;

			VectorSet(saberent->mins, -3.0f, -3.0f, -3.0f);
			VectorSet(saberent->maxs, 3.0f, 3.0f, 3.0f);
			saberent->mass = 10; //necc?

			saberent->s.eFlags |= EF_NODRAW;
			saberent->svFlags |= SVF_NOCLIENT;
			/*
			Ghoul2 Insert Start
			*/
			saberent->playerModel = -1;
			WP_SetSaberEntModelSkin(ent, saberent);

			// set up a bolt on the end so we can get where the sabre muzzle is - we can assume this is always bolt 0
			gi.G2API_AddBolt(&saberent->ghoul2[0], "*flash");
			if (ent->client->ps.dualSabers)
			{
				G_ModelIndex(ent->client->ps.saber[1].model);
			}

			/*
			Ghoul2 Insert End
			*/

			ent->client->ps.saberInFlight = qfalse;
			ent->client->ps.saberEntityDist = 0;
			ent->client->ps.saberEntityState = SES_LEAVING;

			ent->client->ps.saber_move = ent->client->ps.saberMoveNext = LS_NONE;

			//FIXME: need a think function to create alerts when turned on or is on, etc.
		}
		else
		{
			//already have one, might just be changing sabers, register the model and skin and use them if different from what we're using now.
			WP_SetSaberEntModelSkin(ent, &g_entities[ent->client->ps.saberEntityNum]);
		}
	}

	if (ent->client->ps.dualSabers)
	{
		return 2;
	}

	return 1;
}

void WP_SaberUpdateOldBladeData(gentity_t* ent)
{
	if (ent->client)
	{
		qboolean did_event = qfalse;
		for (auto& saber_num : ent->client->ps.saber)
		{
			for (int blade_num = 0; blade_num < saber_num.numBlades; blade_num++)
			{
				VectorCopy(saber_num.blade[blade_num].muzzlePoint, saber_num.blade[blade_num].muzzlePointOld);
				VectorCopy(saber_num.blade[blade_num].muzzleDir, saber_num.blade[blade_num].muzzleDirOld);
				if (!did_event)
				{
					if (saber_num.blade[blade_num].lengthOld <= 0 && saber_num.blade[blade_num].length > 0)
					{
						//just turned on
						//do sound event
						vec3_t saber_org;
						VectorCopy(g_entities[ent->client->ps.saberEntityNum].currentOrigin, saber_org);
						if (!ent->client->ps.saberInFlight && ent->client->ps.groundEntityNum == ENTITYNUM_WORLD
							//holding saber and on ground
							|| g_entities[ent->client->ps.saberEntityNum].s.pos.trType == TR_STATIONARY)
							//saber out there somewhere and on ground
						{
							//a ground alert
							AddSoundEvent(ent, saber_org, 256, AEL_SUSPICIOUS, qfalse, qtrue);
						}
						else
						{
							//an in-air alert
							AddSoundEvent(ent, saber_org, 256, AEL_SUSPICIOUS);
						}
						did_event = qtrue;
					}
				}
				saber_num.blade[blade_num].lengthOld = saber_num.blade[blade_num].length;
			}
		}
		VectorCopy(ent->client->renderInfo.muzzlePoint, ent->client->renderInfo.muzzlePointOld);
		VectorCopy(ent->client->renderInfo.muzzleDir, ent->client->renderInfo.muzzleDirOld);
	}
}

//SABER DAMAGE==============================================================================
//SABER DAMAGE==============================================================================
//SABER DAMAGE==============================================================================
//SABER DAMAGE==============================================================================
//SABER DAMAGE==============================================================================
//SABER DAMAGE==============================================================================
int WPDEBUG_SaberColor(const saber_colors_t saber_color)
{
	switch (static_cast<int>(saber_color))
	{
	case SABER_RED:
		return 0x000000ff;
	case SABER_ORANGE:
		return 0x000088ff;
	case SABER_YELLOW:
		return 0x0000ffff;
	case SABER_GREEN:
		return 0x0000ff00;
	case SABER_BLUE:
		return 0x00ff0000;
	case SABER_PURPLE:
		return 0x00ff00ff;
	case SABER_UNSTABLE_RED:
		return 0x000000ff;
	default:
		return 0x00ffffff; //white
	}
}

extern int PM_SaberDeflectionForQuad(int quad);

static qboolean WP_GetSaberDeflectionAngle(const gentity_t* attacker, const gentity_t* defender)
{
	vec3_t temp, att_saber_base, att_start_pos, saber_mid_next, att_hit_dir, att_hit_pos, def_blade_dir;

	if (!attacker || !attacker->client || attacker->client->ps.saberInFlight || attacker->client->ps.SaberLength() <= 0)
	{
		return qfalse;
	}
	if (!defender || !defender->client || defender->client->ps.saberInFlight || defender->client->ps.SaberLength() <= 0)
	{
		return qfalse;
	}
	if (PM_SuperBreakLoseAnim(attacker->client->ps.torsoAnim)
		|| PM_SuperBreakWinAnim(attacker->client->ps.torsoAnim))
	{
		return qfalse;
	}
	attacker->client->ps.saberBounceMove = LS_NONE;

	//get the attacker's saber base pos at time of impact
	VectorSubtract(attacker->client->renderInfo.muzzlePoint, attacker->client->renderInfo.muzzlePointOld, temp);
	VectorMA(attacker->client->renderInfo.muzzlePointOld, saberHitFraction, temp, att_saber_base);

	//get the position along the length of the blade where the hit occurred
	const float att_saber_hit_length = Distance(saberHitLocation, att_saber_base) / attacker->client->ps.SaberLength();

	//now get the start of that midpoint in the swing and the actual impact point in the swing (shouldn't the latter just be saberHitLocation?)
	VectorMA(attacker->client->renderInfo.muzzlePointOld, att_saber_hit_length,
		attacker->client->renderInfo.muzzleDirOld,
		att_start_pos);
	VectorMA(attacker->client->renderInfo.muzzlePoint, att_saber_hit_length, attacker->client->renderInfo.muzzleDir,
		saber_mid_next);
	VectorSubtract(saber_mid_next, att_start_pos, att_hit_dir);
	VectorMA(att_start_pos, saberHitFraction, att_hit_dir, att_hit_pos);
	VectorNormalize(att_hit_dir);

	//get the defender's saber dir at time of impact
	VectorSubtract(defender->client->renderInfo.muzzleDirOld, defender->client->renderInfo.muzzleDir, temp);
	VectorMA(defender->client->renderInfo.muzzleDirOld, saberHitFraction, temp, def_blade_dir);

	//now compare
	const float hit_dot = DotProduct(att_hit_dir, def_blade_dir);
	if (hit_dot < 0.25f && hit_dot > -0.25f)
	{
		//hit pretty much perpendicular, pop straight back
		attacker->client->ps.saberBounceMove = PM_SaberBounceForAttack(attacker->client->ps.saber_move);
		return qfalse;
	}
	//a deflection
	vec3_t att_right, att_up, att_deflection_dir;

	//get the direction of the deflection
	VectorScale(def_blade_dir, hit_dot, att_deflection_dir);
	//get our bounce straight back direction
	VectorScale(att_hit_dir, -1.0f, temp);
	//add the bounce back and deflection
	VectorAdd(att_deflection_dir, temp, att_deflection_dir);
	//normalize the result to determine what direction our saber should bounce back toward
	VectorNormalize(att_deflection_dir);

	//need to know the direction of the deflection relative to the attacker's facing
	VectorSet(temp, 0, attacker->client->ps.viewangles[YAW], 0); //presumes no pitch!
	AngleVectors(temp, nullptr, att_right, att_up);
	const float swing_r_dot = DotProduct(att_right, att_deflection_dir);
	const float swing_u_dot = DotProduct(att_up, att_deflection_dir);

	if (swing_r_dot > 0.25f)
	{
		//deflect to right
		if (swing_u_dot > 0.25f)
		{
			//deflect to top
			attacker->client->ps.saberBounceMove = LS_D1_TR;
		}
		else if (swing_u_dot < -0.25f)
		{
			//deflect to bottom
			attacker->client->ps.saberBounceMove = LS_D1_BR;
		}
		else
		{
			//deflect horizontally
			attacker->client->ps.saberBounceMove = LS_D1__R;
		}
	}
	else if (swing_r_dot < -0.25f)
	{
		//deflect to left
		if (swing_u_dot > 0.25f)
		{
			//deflect to top
			attacker->client->ps.saberBounceMove = LS_D1_TL;
		}
		else if (swing_u_dot < -0.25f)
		{
			//deflect to bottom
			attacker->client->ps.saberBounceMove = LS_D1_BL;
		}
		else
		{
			//deflect horizontally
			attacker->client->ps.saberBounceMove = LS_D1__L;
		}
	}
	else
	{
		//deflect in middle
		if (swing_u_dot > 0.25f)
		{
			//deflect to top
			attacker->client->ps.saberBounceMove = LS_D1_T_;
		}
		else if (swing_u_dot < -0.25f)
		{
			//deflect to bottom
			attacker->client->ps.saberBounceMove = LS_D1_B_;
		}
		else
		{
			//deflect horizontally?  Well, no such thing as straight back in my face, so use top
			if (swing_r_dot > 0)
			{
				attacker->client->ps.saberBounceMove = LS_D1_TR;
			}
			else if (swing_r_dot < 0)
			{
				attacker->client->ps.saberBounceMove = LS_D1_TL;
			}
			else
			{
				attacker->client->ps.saberBounceMove = LS_D1_T_;
			}
		}
	}
#ifndef FINAL_BUILD
	if (d_saberCombat->integer)
	{
		gi.Printf(S_COLOR_BLUE"%s deflected from %s to %s\n", attacker->targetname, saber_moveData[attacker->client->ps.saber_move].name, saber_moveData[attacker->client->ps.saberBounceMove].name);
	}
#endif
	return qtrue;
}

void wp_saber_clear_damage_for_ent_num(gentity_t* attacker, const int entityNum, const int saber_num, const int blade_num)
{
#ifndef FINAL_BUILD
	if (d_saberCombat->integer)
	{
		if (entityNum)
		{
			Com_Printf("clearing damage for entnum %d\n", entityNum);
		}
	}
#endif// FINAL_BUILD
	if (g_saberRealisticCombat->integer > 1)
	{
		return;
	}

	float knock_back_scale = 0.0f;
	if (attacker && attacker->client)
	{
		if (!WP_SaberBladeUseSecondBladeStyle(&attacker->client->ps.saber[saber_num], blade_num)
			&& attacker->client->ps.saber[saber_num].knockbackScale > 0.0f)
		{
			knock_back_scale = attacker->client->ps.saber[saber_num].knockbackScale;
		}
		else if (WP_SaberBladeUseSecondBladeStyle(&attacker->client->ps.saber[saber_num], blade_num)
			&& attacker->client->ps.saber[saber_num].knockbackScale2 > 0.0f)
		{
			knock_back_scale = attacker->client->ps.saber[saber_num].knockbackScale2;
		}
	}

	for (int i = 0; i < numVictims; i++)
	{
		if (victimEntityNum[i] == entityNum)
		{
			//hold on a sec, let's still do any accumulated knockback
			if (knock_back_scale)
			{
				gentity_t* victim = &g_entities[victimEntityNum[i]];
				if (victim && victim->client)
				{
					vec3_t center, dir_to_center;
					float knock_down_thresh_hold;
					const float knockback = knock_back_scale * totalDmg[i] * 0.5f;

					VectorAdd(victim->absmin, victim->absmax, center);
					VectorScale(center, 0.5, center);
					VectorSubtract(victim->currentOrigin, saberHitLocation, dir_to_center);
					VectorNormalize(dir_to_center);
					G_Throw(victim, dir_to_center, knockback);
					if (victim->client->ps.groundEntityNum != ENTITYNUM_NONE
						&& dir_to_center[2] <= 0)
					{
						//hit downward on someone who is standing on firm ground, so more likely to knock them down
						knock_down_thresh_hold = Q_irand(25, 50);
					}
					else
					{
						knock_down_thresh_hold = Q_irand(75, 125);
					}

					if (knockback > knock_down_thresh_hold)
					{
						G_Knockdown(victim, attacker, dir_to_center, 350, qtrue);
					}
				}
			}
			//now clear everything
			totalDmg[i] = 0; //no damage
			hit_loc[i] = HL_NONE;
			hitDismemberLoc[i] = HL_NONE;
			hitDismember[i] = qfalse;
			victimEntityNum[i] = ENTITYNUM_NONE; //like we never hit him
		}
	}
}

extern void PM_SaberStartTransAnim(int saber_anim_level, int anim, float* animSpeed, const gentity_t* gent,
	int fatigued);
extern float pm_get_time_scale_mod(const gentity_t* gent);

static int G_GetAttackDamageMD(const gentity_t* self, const int min_dmg, const int max_dmg, const float mult_point)
{
	int total_damage = max_dmg;
	float attack_anim_length = PM_AnimLength(self->client->clientInfo.animFileIndex,
		static_cast<animNumber_t>(self->client->ps.torsoAnim));
	float anim_speed_factor = pm_get_time_scale_mod(self); //1.0f;

	//Be sure to scale by the proper anim speed just as if we were going to play the animation

	PM_SaberStartTransAnim(self->client->ps.saber_anim_level, self->client->ps.torsoAnim, &anim_speed_factor, self,
		self->userInt3);

	const int speed_dif = attack_anim_length - attack_anim_length * anim_speed_factor;
	attack_anim_length += speed_dif;
	float peak_point = attack_anim_length;
	peak_point -= attack_anim_length * mult_point;

	//we treat torsoTimer as the point in the animation (closer it is to attackAnimLength, closer it is to beginning)
	const float current_point = self->client->ps.torsoAnimTimer;

	float damage_factor = current_point / peak_point;
	if (damage_factor > 1)
	{
		damage_factor = 2.0f - damage_factor;
		if (d_combatinfo->integer || g_DebugSaberCombat->integer)
		{
			gi.Printf(S_COLOR_RED"new damage system calculating extra damage %4.2f\n", damage_factor);
		}
	}

	total_damage *= damage_factor;

	if (total_damage < min_dmg)
	{
		total_damage = min_dmg;
	}
	if (total_damage > max_dmg)
	{
		total_damage = max_dmg;
	}

	return total_damage;
}

extern float damageModifier[];
extern float hitLocHealthPercentage[];
extern qboolean BG_SaberInTransitionDamageMove(const playerState_t* ps);
extern cvar_t* g_dismemberProbabilities;

static qboolean WP_SaberApplyDamageJKA(gentity_t* ent, const float base_damage, const int base_d_flags,
	const qboolean broken_parry, const int saber_num, const int blade_num,
	const qboolean thrown_saber)
{
	qboolean did_damage = qfalse;
	float max_dmg;
	const saberType_t saber_type = ent->client->ps.saber[saber_num].type;
	const int index = Q_irand(1, 3);

	if (!numVictims)
	{
		return qfalse;
	}

	for (int i = 0; i < numVictims; i++)
	{
		int d_flags = base_d_flags | DAMAGE_DEATH_KNOCKBACK | DAMAGE_NO_HIT_LOC;
		gentity_t* victim = &g_entities[victimEntityNum[i]];

		if (victimEntityNum[i] != ENTITYNUM_NONE && &g_entities[victimEntityNum[i]] != nullptr)
		{
			// Don't bother with this damage if the fraction is higher than the saber's fraction
			if (dmgFraction[i] < saberHitFraction || broken_parry)
			{
				if (!victim)
				{
					continue;
				}

				if (victim->e_DieFunc == dieF_maglock_die)
				{
					//*sigh*, special check for maglocks
					vec3_t test_from;
					if (ent->client->ps.saberInFlight)
					{
						VectorCopy(g_entities[ent->client->ps.saberEntityNum].currentOrigin, test_from);
					}
					else
					{
						VectorCopy(ent->currentOrigin, test_from);
					}
					test_from[2] = victim->currentOrigin[2];
					trace_t test_trace;
					gi.trace(&test_trace, test_from, vec3_origin, vec3_origin, victim->currentOrigin, ent->s.number,
						MASK_SHOT, static_cast<EG2_Collision>(0), 0);
					if (test_trace.entityNum != victim->s.number)
					{
						//can only damage maglocks if have a clear trace to the thing's origin
						continue;
					}
				}
				if (totalDmg[i] > 0)
				{
					//actually want to do *some* damage here
					if (victim->client
						&& victim->client->NPC_class == CLASS_WAMPA
						&& victim->activator == ent)
					{
					}
					else if (PM_SuperBreakWinAnim(ent->client->ps.torsoAnim)
						|| PM_StabDownAnim(ent->client->ps.torsoAnim))
					{
						//never cap the superbreak wins
					}
					else
					{
						if (victim->client
							&& (victim->s.weapon == WP_SABER || victim->client->NPC_class == CLASS_REBORN || victim->client->NPC_class == CLASS_WAMPA)
							&& !g_saberRealisticCombat->integer)
						{
							//dmg vs other saber fighters is modded by hitloc and capped
							totalDmg[i] *= damageModifier[hit_loc[i]];
							if (hit_loc[i] == HL_NONE)
							{
								max_dmg = 33 * base_damage;
							}
							else
							{
								max_dmg = 50 * hitLocHealthPercentage[hit_loc[i]] * base_damage;
								//*victim->client->ps.stats[STAT_MAX_HEALTH]*2.0f;
							}
							if (max_dmg < totalDmg[i])
							{
								totalDmg[i] = max_dmg;
							}
							//d_flags |= DAMAGE_NO_HIT_LOC;
						}

						if (victim->flags & FL_SABERDAMAGE_RESIST && (!Q_irand(0, 3)))
						{
							d_flags |= DAMAGE_NO_DAMAGE;
							G_Beskar_Attack_Bounce(ent, victim);
							G_Sound(victim, G_SoundIndex(va("sound/weapons/impacts/beskar_impact%d.mp3", index)));
						}
						//clamp the dmg
						if (victim->s.weapon != WP_SABER)
						{
							//clamp the dmg between 25 and maxhealth
							if (totalDmg[i] < 25)
							{
								totalDmg[i] = 25;
							}
							if (totalDmg[i] > 100) //+(50*g_spskill->integer) )
							{
								//clamp using same adjustment as in NPC_Begin
								totalDmg[i] = 100; //+(50*g_spskill->integer);
							}
						}
						else
						{
							//clamp the dmg between 5 and 100
							if (!victim->s.number && totalDmg[i] > 50)
							{
								//never do more than half full health damage to player
								//prevents one-hit kills
								totalDmg[i] = 50;
							}
							else if (totalDmg[i] > 100)
							{
								totalDmg[i] = 100;
							}
							else
							{
								if (totalDmg[i] < 5)
								{
									totalDmg[i] = 5;
								}
							}
						}
					}

					if (totalDmg[i] > 0)
					{
						gentity_t* inflictor = ent;
						did_damage = qtrue;
						qboolean vic_was_dismembered = qtrue;
						const auto vic_was_alive = static_cast<qboolean>(victim->health > 0);

						if (base_damage <= 0.1f)
						{
							//just get their attention?
							d_flags |= DAMAGE_NO_DAMAGE;
						}

						if (victim->client)
						{
							if (victim->client->ps.pm_time > 0 && victim->client->ps.pm_flags & PMF_TIME_KNOCKBACK &&
								victim->client->ps.velocity[2] > 0)
							{
								//already being knocked around
								d_flags |= DAMAGE_NO_KNOCKBACK;
							}
							if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
								&& ent->client->ps.saber[saber_num].saberFlags2 & SFL2_NO_DISMEMBERMENT)
							{
								//no dismemberment! (blunt/stabbing weapon?)
							}
							else if (WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
								&& ent->client->ps.saber[saber_num].saberFlags2 & SFL2_NO_DISMEMBERMENT2)
							{
								//no dismemberment! (blunt/stabbing weapon?)
							}
							else
							{
								if (debug_subdivision->integer || g_saberRealisticCombat->integer)
								{
									d_flags |= DAMAGE_DISMEMBER;
									if (hitDismember[i])
									{
										victim->client->dismembered = false;
									}
								}
								else if (hitDismember[i])
								{
									d_flags |= DAMAGE_DISMEMBER;
								}
								if (!victim->client->dismembered)
								{
									vic_was_dismembered = qfalse;
								}
							}
							if (base_damage <= 1.0f)
							{
								//very mild damage
								if (victim->s.number == 0 || victim->client->ps.weapon == WP_SABER || victim->client->
									NPC_class == CLASS_GALAKMECH)
								{
									//if it's the player or a saber-user, don't kill them with this blow
									d_flags |= DAMAGE_NO_KILL;
								}
							}
						}
						else
						{
							if (victim->takedamage)
							{
								//some other breakable thing
								//create a flash here
								if (!g_noClashFlare)
								{
									g_saberFlashTime = level.time - 50;
									VectorCopy(dmgSpot[i], g_saberFlashPos);
								}
							}
						}
						if (!PM_SuperBreakWinAnim(ent->client->ps.torsoAnim)
							&& !PM_StabDownAnim(ent->client->ps.torsoAnim)
							&& !g_saberRealisticCombat->integer
							&& g_saberDamageCapping->integer)
						{
							//never cap the superbreak wins
							if (victim->client
								&& victim->s.number >= MAX_CLIENTS)
							{
								if (victim->client->NPC_class == CLASS_SHADOWTROOPER
									|| victim->NPC && victim->NPC->aiFlags & NPCAI_BOSS_CHARACTER)
								{
									//hit a boss character
									const int dmg = (3 - g_spskill->integer) * 5 + 10;
									if (totalDmg[i] > dmg)
									{
										totalDmg[i] = dmg;
									}
								}
								else if (victim->client->ps.weapon == WP_SABER
									|| victim->client->NPC_class == CLASS_REBORN
									|| victim->client->NPC_class == CLASS_JEDI)
								{
									//hit a non-boss saber-user
									const int dmg = (3 - g_spskill->integer) * 15 + 30;
									if (totalDmg[i] > dmg)
									{
										totalDmg[i] = dmg;
									}
								}
							}
							if (victim->s.number < MAX_CLIENTS
								&& ent->NPC)
							{
								if (ent->NPC->aiFlags & NPCAI_BOSS_CHARACTER
									|| ent->NPC->aiFlags & NPCAI_SUBBOSS_CHARACTER
									|| ent->client->NPC_class == CLASS_SHADOWTROOPER)
								{
									//player hit by a boss character
									const int dmg = (g_spskill->integer + 1) * 4 + 3;
									if (totalDmg[i] > dmg)
									{
										totalDmg[i] = dmg;
									}
								}
								else if (g_spskill->integer < 3) //was < 2
								{
									//player hit by any enemy //on easy or medium?
									const int dmg = (g_spskill->integer + 1) * 10 + 20;
									if (totalDmg[i] > dmg)
									{
										totalDmg[i] = dmg;
									}
								}
							}
						}
						//victim->hit_loc = hit_loc[i];

						d_flags |= DAMAGE_NO_KNOCKBACK; //okay, let's try no knockback whatsoever...
						d_flags &= ~DAMAGE_DEATH_KNOCKBACK;
						if (g_saberRealisticCombat->integer)
						{
							d_flags |= DAMAGE_NO_KNOCKBACK;
							d_flags &= ~DAMAGE_DEATH_KNOCKBACK;
							d_flags &= ~DAMAGE_NO_KILL;
						}
						if (ent->client && !ent->s.number)
						{
							switch (hit_loc[i])
							{
							case HL_FOOT_RT:
							case HL_FOOT_LT:
							case HL_LEG_RT:
							case HL_LEG_LT:
								ent->client->sess.missionStats.legAttacksCnt++;
								break;
							case HL_WAIST:
							case HL_BACK_RT:
							case HL_BACK_LT:
							case HL_BACK:
							case HL_CHEST_RT:
							case HL_CHEST_LT:
							case HL_CHEST:
								ent->client->sess.missionStats.torsoAttacksCnt++;
								break;
							case HL_ARM_RT:
							case HL_ARM_LT:
							case HL_HAND_RT:
							case HL_HAND_LT:
								ent->client->sess.missionStats.armAttacksCnt++;
								break;
							default:
								ent->client->sess.missionStats.otherAttacksCnt++;
								break;
							}
						}

						if (saber_type == SABER_SITH_SWORD)
						{
							//do knockback
							d_flags &= ~(DAMAGE_NO_KNOCKBACK | DAMAGE_DEATH_KNOCKBACK);
						}
						if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
							&& ent->client->ps.saber[saber_num].knockbackScale > 0.0f)
						{
							d_flags &= ~(DAMAGE_NO_KNOCKBACK | DAMAGE_DEATH_KNOCKBACK);
							if (saber_num < 1)
							{
								d_flags |= DAMAGE_SABER_KNOCKBACK1;
							}
							else
							{
								d_flags |= DAMAGE_SABER_KNOCKBACK2;
							}
						}
						else if (WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
							&& ent->client->ps.saber[saber_num].knockbackScale2 > 0.0f)
						{
							d_flags &= ~(DAMAGE_NO_KNOCKBACK | DAMAGE_DEATH_KNOCKBACK);
							if (saber_num < 1)
							{
								d_flags |= DAMAGE_SABER_KNOCKBACK1_B2;
							}
							else
							{
								d_flags |= DAMAGE_SABER_KNOCKBACK2_B2;
							}
						}
						if (thrown_saber)
						{
							inflictor = &g_entities[ent->client->ps.saberEntityNum];
						}
						int damage;
						if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
							&& ent->client->ps.saber[saber_num].damageScale != 1.0f)
						{
							damage = ceil(totalDmg[i] * ent->client->ps.saber[saber_num].damageScale);
						}
						else if (WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
							&& ent->client->ps.saber[saber_num].damageScale2 != 1.0f)
						{
							damage = ceil(totalDmg[i] * ent->client->ps.saber[saber_num].damageScale2);
						}
						else
						{
							damage = ceil(totalDmg[i]);
						}
						G_Damage(victim, inflictor, ent, dmgDir[i], dmgSpot[i], damage, d_flags, MOD_SABER,
							hitDismemberLoc[i]);
						if (damage > 0 && cg.time)
						{
							float size_time_scale = 1.0f;
							if (vic_was_alive
								&& victim->health <= 0
								|| !vic_was_dismembered
								&& victim->client->dismembered
								&& hitDismemberLoc[i] != HL_NONE
								&& hitDismember[i])
							{
								size_time_scale = 3.0f;
							}
							//FIXME: if not hitting the first model on the enemy, don't do this!
							CG_SaberDoWeaponHitMarks(ent->client,
								ent->client->ps.saberInFlight
								? &g_entities[ent->client->ps.saberEntityNum]
								: nullptr,
								victim,
								saber_num,
								blade_num,
								dmgSpot[i],
								dmgDir[i],
								dmgBladeVec[i],
								size_time_scale);
						}
#ifndef FINAL_BUILD
						if (d_saberCombat->integer)
						{
							if ((d_flags & DAMAGE_NO_DAMAGE))
							{
								gi.Printf(S_COLOR_RED"damage: fake, hit_loc %d\n", hit_loc[i]);
							}
							else
							{
								gi.Printf(S_COLOR_RED"damage: %4.2f, hit_loc %d\n", totalDmg[i], hit_loc[i]);
							}
						}
#endif
						//do the effect
						if (ent->s.number == 0)
						{
							AddSoundEvent(victim->owner, dmgSpot[i], 256, AEL_DISCOVERED);
							AddSightEvent(victim->owner, dmgSpot[i], 512, AEL_DISCOVERED, 50);
						}
						if (ent->client)
						{
							if (ent->enemy && ent->enemy == victim)
							{
								//just so Jedi knows that he hit his enemy
								ent->client->ps.saberEventFlags |= SEF_HITENEMY;
							}
							else
							{
								ent->client->ps.saberEventFlags |= SEF_HITOBJECT;
							}
						}
					}
				}
			}
		}
	}
	return did_damage;
}

static qboolean WP_SaberApplyDamageMD(gentity_t* ent, const float base_damage, const int base_d_flags,
	const qboolean broken_parry, const int saber_num, const int blade_num,
	const qboolean thrown_saber)
{
	qboolean did_damage = qfalse;
	float max_dmg;
	const saberType_t saber_type = ent->client->ps.saber[saber_num].type;

	const qboolean active_blocking = ent->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCKANDATTACK ? qtrue : qfalse;
	const qboolean is_holding_block_button = ent->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCK ? qtrue : qfalse;
	//Normal Blocking
	const qboolean m_blocking = ent->client->ps.ManualBlockingFlags & 1 << PERFECTBLOCKING ? qtrue : qfalse;
	//Perfect Blocking

	if (!numVictims)
	{
		return qfalse;
	}

	if ((is_holding_block_button || active_blocking || m_blocking) && (ent->s.number < MAX_CLIENTS || G_ControlledByPlayer(ent)))
		//jacesolaris 2019 test for idlekill
	{
		return qfalse;
	}

	if (!(BG_SaberInNonIdleDamageMove(&ent->client->ps) || ent->client->ps.saberInFlight))
		//if not in a damage move like this dont do damage
	{
		return qfalse;
	}

	if (BG_SaberInTransitionDamageMove(&ent->client->ps)) //if in a transition dont do damage
	{
		return qfalse;
	}

	if (in_camera && !PM_SaberInAttack(ent->client->ps.saber_move) && g_saberRealisticCombat->integer > 1 && (ent->s.
		number >= MAX_CLIENTS && !G_ControlledByPlayer(ent)))
	{
		return qfalse;
	}

	if (!(ent->client->ps.forcePowersActive & 1 << FP_SPEED))
	{
		if (BG_SaberInPartialDamageMove(ent)) //if this is true dont do damage
		{
			return qfalse;
		}
	}

	if (PM_KickMove(ent->client->ps.saber_move))
	{
		return qfalse;
	}

	for (int i = 0; i < numVictims; i++)
	{
		int d_flags = base_d_flags | DAMAGE_DEATH_KNOCKBACK | DAMAGE_NO_HIT_LOC;
		gentity_t* victim = &g_entities[victimEntityNum[i]];

		if (victimEntityNum[i] != ENTITYNUM_NONE && &g_entities[victimEntityNum[i]] != nullptr)
		{
			// Don't bother with this damage if the fraction is higher than the saber's fraction
			if (dmgFraction[i] < saberHitFraction || broken_parry)
			{
				if (!victim)
				{
					continue;
				}

				if (victim->e_DieFunc == dieF_maglock_die)
				{
					//*sigh*, special check for maglocks
					vec3_t test_from;
					if (ent->client->ps.saberInFlight)
					{
						VectorCopy(g_entities[ent->client->ps.saberEntityNum].currentOrigin, test_from);
					}
					else
					{
						VectorCopy(ent->currentOrigin, test_from);
					}
					test_from[2] = victim->currentOrigin[2];
					trace_t test_trace;
					gi.trace(&test_trace, test_from, vec3_origin, vec3_origin, victim->currentOrigin, ent->s.number,
						MASK_SHOT, static_cast<EG2_Collision>(0), 0);
					if (test_trace.entityNum != victim->s.number)
					{
						//can only damage maglocks if have a clear trace to the thing's origin
						continue;
					}
				}
				if (totalDmg[i] > 0)
				{
					if (g_SaberAttackSpeedMD->integer && g_RealisticBlockingMode->integer && g_SerenityJediEngineMode->integer == 2 && victim->health >= 1)
					{
						if (ent->s.number < MAX_CLIENTS || G_ControlledByPlayer(ent))
						{
							CGCam_BlockShakeSP(0.25f, 100);
						}
					}
					//actually want to do *some* damage here
					if (victim->client
						&& victim->client->NPC_class == CLASS_WAMPA
						&& victim->activator == ent)
					{
						//
					}
					else if (PM_SuperBreakWinAnim(ent->client->ps.torsoAnim))
					{
						//never cap the superbreak wins
					}
					else
					{
						const qboolean saber_in_special = pm_saber_in_special_attack(ent->client->ps.torsoAnim);
						const qboolean saber_in_LeapAttack = PM_SaberInInstankillKillAttack(ent->client->ps.torsoAnim);
						const qboolean saber_in_stab_down = PM_StabDownAnim(ent->client->ps.torsoAnim);
						const qboolean saber_in_kata = PM_SaberInKata(static_cast<saber_moveName_t>(ent->client->ps.saber_move));
						const qboolean saber_in_back_attack = PM_SaberInBackAttack(static_cast<saber_moveName_t>(ent->client->ps.saber_move));
						const qboolean saber_in_over_head_attack = PM_SaberInOverHeadSlash(static_cast<saber_moveName_t>(ent->client->ps.saber_move));
						const qboolean saber_in_roll_stab = PM_SaberInRollStab(static_cast<saber_moveName_t>(ent->client->ps.saber_move));
						const qboolean saber_in_lunge_stab = PM_SaberInLungeStab(static_cast<saber_moveName_t>(ent->client->ps.saber_move));
						const int index = Q_irand(1, 3);

						if (victim->client
							&& (victim->s.weapon == WP_SABER
								|| victim->client->NPC_class == CLASS_REBORN
								|| victim->client->NPC_class == CLASS_WAMPA)
							&& !g_saberRealisticCombat->integer)
						{
							//dmg vs other saber fighters is modded by hitloc and capped
							totalDmg[i] *= damageModifier[hit_loc[i]];
							if (hit_loc[i] == HL_NONE)
							{
								max_dmg = 33 * base_damage;
							}
							else
							{
								max_dmg = 50 * hitLocHealthPercentage[hit_loc[i]] * base_damage;
							}
							if (max_dmg < totalDmg[i])
							{
								totalDmg[i] = max_dmg;
							}
						}

						if (victim->flags & FL_SABERDAMAGE_RESIST && (!Q_irand(0, 3)))
						{
							d_flags |= DAMAGE_NO_DAMAGE;
							G_Beskar_Attack_Bounce(ent, victim);
							G_Sound(victim, G_SoundIndex(va("sound/weapons/impacts/beskar_impact%d.mp3", index)));
						}

						if (!saber_in_special) // not doing a special move
						{
							if (victim->s.weapon != WP_SABER || !Q_stricmp("func_breakable", victim->classname))
							{
								// my enemy has a gun
								if (g_saberRealisticCombat->integer < 3)
								{
									// enemy has more than 30hp
									if (g_saberRealisticCombat->integer == 2 && victim->NPC && victim->health >= 30)
									{
										d_flags |= DAMAGE_NO_KILL;
										totalDmg[i] = 30;
									}
									else if (g_saberRealisticCombat->integer == 1 && victim->NPC && victim->health >=
										30)
									{
										d_flags |= DAMAGE_NO_KILL;
										totalDmg[i] = 25;
									}
									else if (g_saberRealisticCombat->integer == 0 && victim->NPC && victim->health >=
										30)
									{
										d_flags |= DAMAGE_NO_KILL;
										totalDmg[i] = 10;
									}
									else
									{
										// enemy has less than 30 hp
										if (g_saberRealisticCombat->integer == 2)
										{
											if (totalDmg[i] < 35)
											{
												totalDmg[i] = 35;
											}
											if (totalDmg[i] > 35)
											{
												//clamp using same adjustment as in NPC_Begin
												totalDmg[i] = 35;
											}
										}
										else if (g_saberRealisticCombat->integer == 1)
										{
											if (totalDmg[i] < 15)
											{
												totalDmg[i] = 15;
											}
											if (totalDmg[i] > 15)
											{
												//clamp using same adjustment as in NPC_Begin
												totalDmg[i] = 15;
											}
										}
										else if (g_saberRealisticCombat->integer == 0)
										{
											if (totalDmg[i] < 5)
											{
												totalDmg[i] = 5;
											}
											if (totalDmg[i] > 5)
											{
												//clamp using same adjustment as in NPC_Begin
												totalDmg[i] = 5;
											}
										}
									}
								}
								else
								{
									// need to add better damage control here for saber v gunner at high damage
									if (totalDmg[i] < 50)
									{
										totalDmg[i] = 50;
									}
									if (totalDmg[i] > 100)
									{
										//clamp using same adjustment as in NPC_Begin
										totalDmg[i] = 100;
									}
								}
							}
							else
							{
								// my enemy has a saber
								if (g_saberRealisticCombat->integer < 3)
								{
									// enemy has more than 30hp
									if (g_saberRealisticCombat->integer == 2 && victim->NPC && victim->health >= 30)
									{
										d_flags |= DAMAGE_NO_KILL;
										totalDmg[i] = 30;
									}
									else if (g_saberRealisticCombat->integer == 1 && victim->NPC && victim->health >=
										30)
									{
										d_flags |= DAMAGE_NO_KILL;
										totalDmg[i] = 25;
									}
									else if (g_saberRealisticCombat->integer == 0 && victim->NPC && victim->health >=
										30)
									{
										d_flags |= DAMAGE_NO_KILL;
										totalDmg[i] = 10;
									}
									else
									{
										// enemy has less than 30 hp
										if (g_saberRealisticCombat->integer == 2)
										{
											if (totalDmg[i] < 35)
											{
												totalDmg[i] = 35;
											}
											if (totalDmg[i] > 35)
											{
												//clamp using same adjustment as in NPC_Begin
												totalDmg[i] = 35;
											}
										}
										else if (g_saberRealisticCombat->integer == 1)
										{
											if (totalDmg[i] < 15)
											{
												totalDmg[i] = 15;
											}
											if (totalDmg[i] > 15)
											{
												//clamp using same adjustment as in NPC_Begin
												totalDmg[i] = 15;
											}
										}
										else if (g_saberRealisticCombat->integer == 0)
										{
											if (totalDmg[i] < 5)
											{
												totalDmg[i] = 5;
											}
											if (totalDmg[i] > 5)
											{
												//clamp using same adjustment as in NPC_Begin
												totalDmg[i] = 5;
											}
										}
									}
								}
								else
								{
									// need to add better damage control here for saber v gunner at high damage
									if (totalDmg[i] < 50)
									{
										totalDmg[i] = 50;
									}
									if (totalDmg[i] > 100)
									{
										//clamp using same adjustment as in NPC_Begin
										totalDmg[i] = 100;
									}
								}
							}
						}
						else
						{
							// doing a special move
							if (victim->s.weapon != WP_SABER || !Q_stricmp("func_breakable", victim->classname))
							{
								//clamp the dmg between 25 and maxhealth
								if (totalDmg[i] < 25)
								{
									totalDmg[i] = 25;
								}
								if (totalDmg[i] > 75 && g_saberRealisticCombat->integer == 0)
								{
									//clamp using same adjustment as in NPC_Begin
									totalDmg[i] = 75;
								}
								else if (totalDmg[i] > 100)
								{
									//clamp using same adjustment as in NPC_Begin
									totalDmg[i] = 100;
								}
							}
							else
							{
								if (saber_in_stab_down)
								{
									if (d_combatinfo->integer || g_DebugSaberCombat->integer)
									{
										gi.Printf(S_COLOR_YELLOW"saberInStabDown\n");
									}
									if (totalDmg[i] > 20 && g_saberRealisticCombat->integer == 0)
									{
										totalDmg[i] = 20;
									}
									else if (totalDmg[i] > 40 && g_saberRealisticCombat->integer == 1)
									{
										totalDmg[i] = 40;
									}
									else {
										totalDmg[i] = 80;
									}
								}
								else if (saber_in_LeapAttack)
								{
									if (d_combatinfo->integer || g_DebugSaberCombat->integer)
									{
										gi.Printf(S_COLOR_YELLOW"saber_in_LeapAttack\n");
									}
									if (g_saberRealisticCombat->integer == 0)
									{
										totalDmg[i] = G_GetAttackDamageMD(ent, 15, 30, 0.5f);
									}
									if (g_saberRealisticCombat->integer == 1)
									{
										totalDmg[i] = G_GetAttackDamageMD(ent, 30, 60, 0.5f);
									}
									else {
										totalDmg[i] = G_GetAttackDamageMD(ent, 60, 100, 0.5f);
									}
								}
								else if (saber_in_kata)
								{
									if (d_combatinfo->integer || g_DebugSaberCombat->integer)
									{
										gi.Printf(S_COLOR_YELLOW"saberInKata\n");
									}
									if (ent->client->ps.saber_anim_level == SS_DESANN || ent->client->ps.saber_anim_level ==
										SS_STRONG)
									{
										if (g_saberRealisticCombat->integer == 0)
										{
											totalDmg[i] = G_GetAttackDamageMD(ent, 30, 60, 0.5f);
										}
										if (g_saberRealisticCombat->integer == 1)
										{
											totalDmg[i] = G_GetAttackDamageMD(ent, 40, 80, 0.5f);
										}
										else {
											totalDmg[i] = G_GetAttackDamageMD(ent, 50, 100, 0.5f);
										}
									}
									else if (ent->client->ps.saber_anim_level == SS_MEDIUM)
									{
										if (g_saberRealisticCombat->integer == 0)
										{
											totalDmg[i] = G_GetAttackDamageMD(ent, 20, 40, 0.5f);
										}
										if (g_saberRealisticCombat->integer == 1)
										{
											totalDmg[i] = G_GetAttackDamageMD(ent, 25, 50, 0.5f);
										}
										else {
											totalDmg[i] = G_GetAttackDamageMD(ent, 30, 60, 0.5f);
										}
									}
									else if (ent->client->ps.saber_anim_level == SS_FAST || ent->client->ps.saber_anim_level
										== SS_TAVION)
									{
										if (g_saberRealisticCombat->integer == 0)
										{
											totalDmg[i] = G_GetAttackDamageMD(ent, 10, 30, 0.5f);
										}
										if (g_saberRealisticCombat->integer == 1)
										{
											totalDmg[i] = G_GetAttackDamageMD(ent, 15, 35, 0.5f);
										}
										else {
											totalDmg[i] = G_GetAttackDamageMD(ent, 20, 40, 0.5f);
										}
									}
									else // SS_STAFF // SS_DUAL
									{
										if (g_saberRealisticCombat->integer == 0)
										{
											totalDmg[i] = G_GetAttackDamageMD(ent, 20, 40, 0.5f);
										}
										if (g_saberRealisticCombat->integer == 1)
										{
											totalDmg[i] = G_GetAttackDamageMD(ent, 35, 60, 0.5f);
										}
										else {
											totalDmg[i] = G_GetAttackDamageMD(ent, 50, 70, 0.5f);
										}
									}
								}
								else if (saber_in_back_attack)
								{
									if (d_combatinfo->integer || g_DebugSaberCombat->integer)
									{
										gi.Printf(S_COLOR_YELLOW"saberInBackAttack\n");
									}
									if (ent->client->ps.saber_anim_level == SS_DESANN || ent->client->ps.saber_anim_level ==
										SS_STRONG)
									{
										if (g_saberRealisticCombat->integer == 0)
										{
											totalDmg[i] = G_GetAttackDamageMD(ent, 30, 50, 0.5f);
										}
										if (g_saberRealisticCombat->integer == 1)
										{
											totalDmg[i] = G_GetAttackDamageMD(ent, 40, 75, 0.5f);
										}
										else {
											totalDmg[i] = G_GetAttackDamageMD(ent, 50, 100, 0.5f);
										}
									}
									else if (ent->client->ps.saber_anim_level == SS_MEDIUM)
									{
										if (g_saberRealisticCombat->integer == 0)
										{
											totalDmg[i] = G_GetAttackDamageMD(ent, 20, 40, 0.5f);
										}
										if (g_saberRealisticCombat->integer == 1)
										{
											totalDmg[i] = G_GetAttackDamageMD(ent, 25, 50, 0.5f);
										}
										else {
											totalDmg[i] = G_GetAttackDamageMD(ent, 30, 60, 0.5f);
										}
									}
									else if (ent->client->ps.saber_anim_level == SS_FAST || ent->client->ps.saber_anim_level
										== SS_TAVION)
									{
										if (g_saberRealisticCombat->integer == 0)
										{
											totalDmg[i] = G_GetAttackDamageMD(ent, 10, 30, 0.5f);
										}
										if (g_saberRealisticCombat->integer == 1)
										{
											totalDmg[i] = G_GetAttackDamageMD(ent, 15, 35, 0.5f);
										}
										else {
											totalDmg[i] = G_GetAttackDamageMD(ent, 20, 40, 0.5f);
										}
									}
									else // SS_STAFF // SS_DUAL
									{
										if (g_saberRealisticCombat->integer == 0)
										{
											totalDmg[i] = G_GetAttackDamageMD(ent, 20, 40, 0.5f);
										}
										if (g_saberRealisticCombat->integer == 1)
										{
											totalDmg[i] = G_GetAttackDamageMD(ent, 35, 50, 0.5f);
										}
										else {
											totalDmg[i] = G_GetAttackDamageMD(ent, 50, 70, 0.5f);
										}
									}
								}
								else if (saber_in_over_head_attack)
								{
									if (d_combatinfo->integer || g_DebugSaberCombat->integer)
									{
										gi.Printf(S_COLOR_YELLOW"saberInOverHeadAttack\n");
									}
									if (ent->client->ps.saber_anim_level == SS_DESANN || ent->client->ps.saber_anim_level ==
										SS_STRONG)
									{
										if (g_saberRealisticCombat->integer == 0)
										{
											totalDmg[i] = G_GetAttackDamageMD(ent, 30, 50, 0.5f);
										}
										if (g_saberRealisticCombat->integer == 1)
										{
											totalDmg[i] = G_GetAttackDamageMD(ent, 40, 75, 0.5f);
										}
										else {
											totalDmg[i] = G_GetAttackDamageMD(ent, 50, 100, 0.5f);
										}
									}
									else if (ent->client->ps.saber_anim_level == SS_MEDIUM)
									{
										if (g_saberRealisticCombat->integer == 0)
										{
											totalDmg[i] = G_GetAttackDamageMD(ent, 20, 60, 0.5f);
										}
										if (g_saberRealisticCombat->integer == 1)
										{
											totalDmg[i] = G_GetAttackDamageMD(ent, 20, 70, 0.5f);
										}
										else {
											totalDmg[i] = G_GetAttackDamageMD(ent, 20, 80, 0.5f);
										}
									}
									else if (ent->client->ps.saber_anim_level == SS_FAST || ent->client->ps.saber_anim_level
										== SS_TAVION)
									{
										totalDmg[i] = G_GetAttackDamageMD(ent, 10, 50, 0.5f);
										/*
										if (g_saberRealisticCombat->integer == 0)
										{
											totalDmg[i] = G_GetAttackDamageMD(ent, 30, 50, 0.5f);
										}
										if (g_saberRealisticCombat->integer == 1)
										{
											totalDmg[i] = G_GetAttackDamageMD(ent, 20, 50, 0.5f);
										}
										else {
											totalDmg[i] = G_GetAttackDamageMD(ent, 10, 50, 0.5f);
										}*/
									}
									else // SS_STAFF // SS_DUAL
									{
										if (g_saberRealisticCombat->integer == 0)
										{
											totalDmg[i] = G_GetAttackDamageMD(ent, 30, 50, 0.5f);
										}
										if (g_saberRealisticCombat->integer == 1)
										{
											totalDmg[i] = G_GetAttackDamageMD(ent, 35, 60, 0.5f);
										}
										else {
											totalDmg[i] = G_GetAttackDamageMD(ent, 40, 70, 0.5f);
										}
									}
								}
								else if (saber_in_roll_stab)
								{
									if (d_combatinfo->integer || g_DebugSaberCombat->integer)
									{
										gi.Printf(S_COLOR_YELLOW"SaberInRollStab\n");
									}
									if (g_saberRealisticCombat->integer == 0)
									{
										totalDmg[i] = G_GetAttackDamageMD(ent, 10, 30, 0.5f);
									}
									if (g_saberRealisticCombat->integer == 1)
									{
										totalDmg[i] = G_GetAttackDamageMD(ent, 30, 60, 0.5f);
									}
									else {
										totalDmg[i] = G_GetAttackDamageMD(ent, 50, 80, 0.5f);
									}
								}
								else if (saber_in_lunge_stab)
								{
									if (d_combatinfo->integer || g_DebugSaberCombat->integer)
									{
										gi.Printf(S_COLOR_YELLOW"SaberInLungeStab\n");
									}
									if (g_saberRealisticCombat->integer == 0)
									{
										totalDmg[i] = G_GetAttackDamageMD(ent, 10, 30, 0.5f);
									}
									if (g_saberRealisticCombat->integer == 1)
									{
										totalDmg[i] = G_GetAttackDamageMD(ent, 30, 60, 0.5f);
									}
									else {
										totalDmg[i] = G_GetAttackDamageMD(ent, 40, 80, 0.5f);
									}
								}
								else
								{
									if (d_combatinfo->integer || g_DebugSaberCombat->integer)
									{
										gi.Printf(S_COLOR_YELLOW"saberInSpecial\n");
									}
									if (g_saberRealisticCombat->integer == 0)
									{
										totalDmg[i] = G_GetAttackDamageMD(ent, 20, 40, 0.65f);
									}
									if (g_saberRealisticCombat->integer == 1)
									{
										totalDmg[i] = G_GetAttackDamageMD(ent, 50, 120, 0.65f);
									}
									else {
										totalDmg[i] = G_GetAttackDamageMD(ent, 75, 180, 0.65f);
									}
								}
							}
						}
					}

					if (totalDmg[i] > 0)
					{
						gentity_t* inflictor = ent;
						did_damage = qtrue;
						qboolean vic_was_dismembered = qtrue;
						const auto vic_was_alive = static_cast<qboolean>(victim->health > 0);

						if (base_damage <= 0.1f)
						{
							//just get their attention?
							d_flags |= DAMAGE_NO_DAMAGE;
							G_SaberBounce(ent, victim);
						}

						if (victim->client)
						{
							if (victim->client->ps.pm_time > 0 && victim->client->ps.pm_flags & PMF_TIME_KNOCKBACK &&
								victim->client->ps.velocity[2] > 0)
							{
								//already being knocked around
								d_flags |= DAMAGE_NO_KNOCKBACK;
								G_SaberBounce(ent, victim);
							}
							if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
								&& ent->client->ps.saber[saber_num].saberFlags2 & SFL2_NO_DISMEMBERMENT)
							{
								//no dismemberment! (blunt/stabbing weapon?)
								G_SaberBounce(ent, victim);
							}
							else if (WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
								&& ent->client->ps.saber[saber_num].saberFlags2 & SFL2_NO_DISMEMBERMENT2)
							{
								//no dismemberment! (blunt/stabbing weapon?)
								G_SaberBounce(ent, victim);
							}
							else
							{
								if (debug_subdivision->integer || g_saberRealisticCombat->integer)
								{
									d_flags |= DAMAGE_DISMEMBER;
									if (hitDismember[i])
									{
										victim->client->dismembered = false;
										G_SaberBounce(ent, victim);
									}
								}
								else if (hitDismember[i])
								{
									d_flags |= DAMAGE_DISMEMBER;
								}
								if (!victim->client->dismembered)
								{
									vic_was_dismembered = qfalse;
									G_SaberBounce(ent, victim);
								}
							}
							if (base_damage <= 1.0f)
							{
								//very mild damage
								if (victim->s.number == 0 || victim->client->ps.weapon == WP_SABER || victim->client->
									NPC_class == CLASS_GALAKMECH)
								{
									//if it's the player or a saber-user, don't kill them with this blow
									G_SaberBounce(ent, victim);

									if (victim->health > 20)
									{
										d_flags |= DAMAGE_NO_KILL;
									}
								}
							}
						}
						else
						{
							if (victim->takedamage)
							{
								//some other breakable thing
								//create a flash here
								if (!g_noClashFlare)
								{
									g_saberFlashTime = level.time - 50;
									VectorCopy(dmgSpot[i], g_saberFlashPos);
									G_SaberBounce(ent, victim);
								}
							}
						}
						if (!PM_SuperBreakWinAnim(ent->client->ps.torsoAnim)
							&& !PM_StabDownAnim(ent->client->ps.torsoAnim)
							&& !g_saberRealisticCombat->integer
							&& g_saberDamageCapping->integer)
						{
							//never cap the superbreak wins
							if (victim->client
								&& victim->s.number >= MAX_CLIENTS)
							{
								if (victim->client->NPC_class == CLASS_SHADOWTROOPER
									|| victim->NPC && victim->NPC->aiFlags & NPCAI_BOSS_CHARACTER)
								{
									//hit a boss character
									const int dmg = (3 - g_spskill->integer) * 5 + 10;
									if (totalDmg[i] > dmg)
									{
										totalDmg[i] = dmg;
									}
								}
								else if (victim->client->ps.weapon == WP_SABER
									|| victim->client->NPC_class == CLASS_REBORN
									|| victim->client->NPC_class == CLASS_PROJECTION
									|| victim->client->NPC_class == CLASS_JEDI)
								{
									//hit a non-boss saber-user
									const int dmg = (3 - g_spskill->integer) * 15 + 30;
									if (totalDmg[i] > dmg)
									{
										totalDmg[i] = dmg;
									}
								}
							}
							if (victim->s.number < MAX_CLIENTS
								&& ent->NPC)
							{
								if (ent->NPC->aiFlags & NPCAI_BOSS_CHARACTER
									|| ent->NPC->aiFlags & NPCAI_SUBBOSS_CHARACTER
									|| ent->client->NPC_class == CLASS_SHADOWTROOPER)
								{
									//player hit by a boss character
									const int dmg = (g_spskill->integer + 1) * 4 + 3;
									if (totalDmg[i] > dmg)
									{
										totalDmg[i] = dmg;
									}
								}
								else if (g_spskill->integer < 3) //was < 2
								{
									//player hit by any enemy //on easy or medium?
									const int dmg = (g_spskill->integer + 1) * 10 + 20;
									if (totalDmg[i] > dmg)
									{
										totalDmg[i] = dmg;
									}
								}
							}
						}

						d_flags |= DAMAGE_NO_KNOCKBACK; //okay, let's try no knockback whatsoever...
						d_flags &= ~DAMAGE_DEATH_KNOCKBACK;
						if (g_saberRealisticCombat->integer)
						{
							d_flags |= DAMAGE_NO_KNOCKBACK;
							d_flags &= ~DAMAGE_DEATH_KNOCKBACK;
							d_flags &= ~DAMAGE_NO_KILL;
						}
						if (ent->client && !ent->s.number)
						{
							switch (hit_loc[i])
							{
							case HL_FOOT_RT:
							case HL_FOOT_LT:
							case HL_LEG_RT:
							case HL_LEG_LT:
								ent->client->sess.missionStats.legAttacksCnt++;
								break;
							case HL_WAIST:
							case HL_BACK_RT:
							case HL_BACK_LT:
							case HL_BACK:
							case HL_CHEST_RT:
							case HL_CHEST_LT:
							case HL_CHEST:
								ent->client->sess.missionStats.torsoAttacksCnt++;
								break;
							case HL_ARM_RT:
							case HL_ARM_LT:
							case HL_HAND_RT:
							case HL_HAND_LT:
								ent->client->sess.missionStats.armAttacksCnt++;
								break;
							default:
								ent->client->sess.missionStats.otherAttacksCnt++;
								break;
							}
						}

						if (saber_type == SABER_SITH_SWORD)
						{
							//do knockback
							d_flags &= ~(DAMAGE_NO_KNOCKBACK | DAMAGE_DEATH_KNOCKBACK);
							G_SaberBounce(ent, victim);
						}
						if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
							&& ent->client->ps.saber[saber_num].knockbackScale > 0.0f)
						{
							d_flags &= ~(DAMAGE_NO_KNOCKBACK | DAMAGE_DEATH_KNOCKBACK);
							if (saber_num < 1)
							{
								d_flags |= DAMAGE_SABER_KNOCKBACK1;
							}
							else
							{
								d_flags |= DAMAGE_SABER_KNOCKBACK2;
							}
						}
						else if (WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
							&& ent->client->ps.saber[saber_num].knockbackScale2 > 0.0f)
						{
							d_flags &= ~(DAMAGE_NO_KNOCKBACK | DAMAGE_DEATH_KNOCKBACK);
							if (saber_num < 1)
							{
								d_flags |= DAMAGE_SABER_KNOCKBACK1_B2;
							}
							else
							{
								d_flags |= DAMAGE_SABER_KNOCKBACK2_B2;
							}
						}
						if (thrown_saber)
						{
							inflictor = &g_entities[ent->client->ps.saberEntityNum];
						}
						int damage;
						if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
							&& ent->client->ps.saber[saber_num].damageScale != 1.0f)
						{
							damage = ceil(totalDmg[i] * ent->client->ps.saber[saber_num].damageScale);
						}
						else if (WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
							&& ent->client->ps.saber[saber_num].damageScale2 != 1.0f)
						{
							damage = ceil(totalDmg[i] * ent->client->ps.saber[saber_num].damageScale2);
						}
						else
						{
							damage = ceil(totalDmg[i]);
						}
						G_Damage(victim, inflictor, ent, dmgDir[i], dmgSpot[i], damage, d_flags, MOD_SABER,
							hitDismemberLoc[i]);
						if (damage > 0 && cg.time)
						{
							float size_time_scale = 1.0f;
							if (vic_was_alive
								&& victim->health <= 0
								|| !vic_was_dismembered
								&& victim->client->dismembered
								&& hitDismemberLoc[i] != HL_NONE
								&& hitDismember[i])
							{
								size_time_scale = 3.0f;
							}
							//FIXME: if not hitting the first model on the enemy, don't do this!
							CG_SaberDoWeaponHitMarks(ent->client,
								ent->client->ps.saberInFlight
								? &g_entities[ent->client->ps.saberEntityNum]
								: nullptr,
								victim,
								saber_num,
								blade_num,
								dmgSpot[i],
								dmgDir[i],
								dmgBladeVec[i],
								size_time_scale);
						}
#ifndef FINAL_BUILD
						if (d_saberCombat->integer)
						{
							if ((d_flags & DAMAGE_NO_DAMAGE))
							{
								gi.Printf(S_COLOR_RED"damage: fake, hit_loc %d\n", hit_loc[i]);
							}
							else
							{
								gi.Printf(S_COLOR_RED"damage: %4.2f, hit_loc %d\n", totalDmg[i], hit_loc[i]);
							}
						}
#endif
						if (ent->s.number == 0)
						{
							AddSoundEvent(victim->owner, dmgSpot[i], 256, AEL_DISCOVERED);
							AddSightEvent(victim->owner, dmgSpot[i], 512, AEL_DISCOVERED, 50);
						}
						if (ent->client)
						{
							if (ent->enemy && ent->enemy == victim)
							{
								//just so Jedi knows that he hit his enemy
								ent->client->ps.saberEventFlags |= SEF_HITENEMY;
							}
							else
							{
								ent->client->ps.saberEventFlags |= SEF_HITOBJECT;
							}
						}
					}
				}
			}
		}
	}
	return did_damage;
}

static void WP_SaberDamageAdd(const float tr_dmg, const int tr_victim_entity_num, vec3_t tr_dmg_dir, vec3_t tr_dmg_blade_vec,
	vec3_t tr_dmg_normal,
	vec3_t tr_dmg_spot, const float dmg, const float fraction, const int tr_hit_loc,
	const qboolean tr_dismember,
	const int tr_dismember_loc)
{
	if (tr_victim_entity_num < 0 || tr_victim_entity_num >= ENTITYNUM_WORLD)
	{
		return;
	}

	if (tr_dmg)
	{
		int i;
		int cur_victim = 0;
		//did some damage to something
		for (i = 0; i < numVictims; i++)
		{
			if (victimEntityNum[i] == tr_victim_entity_num)
			{
				//already hit this guy before
				cur_victim = i;
				break;
			}
		}
		if (i == numVictims)
		{
			//haven't hit his guy before
			if (numVictims + 1 >= MAX_SABER_VICTIMS)
			{
				//can't add another victim at this time
				return;
			}
			//add a new victim to the list
			cur_victim = numVictims;
			victimEntityNum[numVictims++] = tr_victim_entity_num;
		}

		const float add_dmg = tr_dmg * dmg;
		if (tr_hit_loc != HL_NONE && (hit_loc[cur_victim] == HL_NONE || hitLocHealthPercentage[tr_hit_loc] >
			hitLocHealthPercentage[hit_loc[cur_victim]]))
		{
			//this hit_loc is more critical than the previous one this frame
			hit_loc[cur_victim] = tr_hit_loc;
		}

		totalDmg[cur_victim] += add_dmg;
		if (!VectorLengthSquared(dmgDir[cur_victim]))
		{
			VectorCopy(tr_dmg_dir, dmgDir[cur_victim]);
		}
		if (!VectorLengthSquared(dmgBladeVec[cur_victim]))
		{
			VectorCopy(tr_dmg_blade_vec, dmgBladeVec[cur_victim]);
		}
		if (!VectorLengthSquared(dmgNormal[cur_victim]))
		{
			VectorCopy(tr_dmg_normal, dmgNormal[cur_victim]);
		}
		if (!VectorLengthSquared(dmgSpot[cur_victim]))
		{
			VectorCopy(tr_dmg_spot, dmgSpot[cur_victim]);
		}

		// Make sure we keep track of the fraction.  Why?
		// Well, if the saber hits something that stops it, the damage isn't done past that point.
		dmgFraction[cur_victim] = fraction;
		if (tr_dismember_loc != HL_NONE && hitDismemberLoc[cur_victim] == HL_NONE
			|| !hitDismember[cur_victim] && tr_dismember)
		{
			//either this is the first dismember loc we got or we got a loc before, but it wasn't a dismember loc, so take the new one
			hitDismemberLoc[cur_victim] = tr_dismember_loc;
		}
		if (tr_dismember)
		{
			//we scored a dismemberment hit...
			hitDismember[cur_victim] = tr_dismember;
		}
	}
}

/*
WP_SabersIntersect

Breaks the two saber paths into 2 tris each and tests each tri for the first saber path against each of the other saber path's tris

FIXME: subdivide the arc into a consistent increment
FIXME: test the intersection to see if the sabers really did intersect (weren't going in the same direction and/or passed through same point at different times)?
*/
extern qboolean tri_tri_intersect(vec3_t V0, vec3_t V1, vec3_t V2, vec3_t U0, vec3_t U1, vec3_t U2);

static qboolean WP_SabersIntersect(const gentity_t* ent1, const int ent1_saber_num, const int ent1_blade_num,
	const gentity_t* ent2, const qboolean check_dir)
{
	if (!ent1 || !ent2)
	{
		return qfalse;
	}
	if (!ent1->client || !ent2->client)
	{
		return qfalse;
	}
	if (ent1->client->ps.SaberLength() <= 0 || ent2->client->ps.SaberLength() <= 0)
	{
		return qfalse;
	}

	for (const auto& ent2_saber_num : ent2->client->ps.saber)
	{
		for (int ent2_blade_num = 0; ent2_blade_num < ent2_saber_num.numBlades; ent2_blade_num++)
		{
			if (ent2_saber_num.type != SABER_NONE
				&& ent2_saber_num.blade[ent2_blade_num].length > 0)
			{
				vec3_t dir;
				vec3_t saber_tip_next2;
				vec3_t saber_base_next2;
				vec3_t saber_tip2;
				vec3_t saber_base2;
				vec3_t saber_tip_next1;
				vec3_t saber_base_next1;
				vec3_t saber_tip1;
				vec3_t saber_base1;

				VectorCopy(ent1->client->ps.saber[ent1_saber_num].blade[ent1_blade_num].muzzlePointOld,
					saber_base1);
				VectorCopy(ent1->client->ps.saber[ent1_saber_num].blade[ent1_blade_num].muzzlePoint,
					saber_base_next1);

				VectorSubtract(ent1->client->ps.saber[ent1_saber_num].blade[ent1_blade_num].muzzlePoint,
					ent1->client->ps.saber[ent1_saber_num].blade[ent1_blade_num].muzzlePointOld, dir);
				VectorNormalize(dir);
				VectorMA(saber_base_next1, SABER_EXTRAPOLATE_DIST, dir, saber_base_next1);

				VectorMA(saber_base1, ent1->client->ps.saber[ent1_saber_num].blade[ent1_blade_num].length,
					ent1->client->ps.saber[ent1_saber_num].blade[ent1_blade_num].muzzleDirOld, saber_tip1);
				VectorMA(saber_base_next1, ent1->client->ps.saber[ent1_saber_num].blade[ent1_blade_num].length,
					ent1->client->ps.saber[ent1_saber_num].blade[ent1_blade_num].muzzleDir, saber_tip_next1);

				VectorSubtract(saber_tip_next1, saber_tip1, dir);
				VectorNormalize(dir);
				VectorMA(saber_tip_next1, SABER_EXTRAPOLATE_DIST, dir, saber_tip_next1);

				VectorCopy(ent2_saber_num.blade[ent2_blade_num].muzzlePointOld, saber_base2);
				VectorCopy(ent2_saber_num.blade[ent2_blade_num].muzzlePoint, saber_base_next2);

				VectorSubtract(ent2_saber_num.blade[ent2_blade_num].muzzlePoint,
					ent2_saber_num.blade[ent2_blade_num].muzzlePointOld, dir);
				VectorNormalize(dir);
				VectorMA(saber_base_next2, SABER_EXTRAPOLATE_DIST, dir, saber_base_next2);

				VectorMA(saber_base2, ent2_saber_num.blade[ent2_blade_num].length,
					ent2_saber_num.blade[ent2_blade_num].muzzleDirOld, saber_tip2);
				VectorMA(saber_base_next2, ent2_saber_num.blade[ent2_blade_num].length,
					ent2_saber_num.blade[ent2_blade_num].muzzleDir, saber_tip_next2);

				VectorSubtract(saber_tip_next2, saber_tip2, dir);
				VectorNormalize(dir);
				VectorMA(saber_tip_next2, SABER_EXTRAPOLATE_DIST, dir, saber_tip_next2);

				if (check_dir)
				{
					//check the direction of the two swings to make sure the sabers are swinging towards each other
					vec3_t saber_dir1, saber_dir2;

					VectorSubtract(saber_tip_next1, saber_tip1, saber_dir1);
					VectorSubtract(saber_tip_next2, saber_tip2, saber_dir2);
					VectorNormalize(saber_dir1);
					VectorNormalize(saber_dir2);
					if (DotProduct(saber_dir1, saber_dir2) > 0.6f)
					{
						//sabers moving in same dir, probably didn't actually hit
						continue;
					}
					//now check orientation of sabers, make sure they're not parallel or close to it
					const float dot = DotProduct(ent1->client->ps.saber[ent1_saber_num].blade[ent1_blade_num].muzzleDir,
						ent2_saber_num.blade[ent2_blade_num].muzzleDir);
					if (dot > 0.9f || dot < -0.9f)
					{
						//too parallel to really block effectively?
						continue;
					}
				}

				if (tri_tri_intersect(saber_base1, saber_tip1, saber_base_next1, saber_base2, saber_tip2,
					saber_base_next2))
				{
					return qtrue;
				}
				if (tri_tri_intersect(saber_base1, saber_tip1, saber_base_next1, saber_base2, saber_tip2,
					saber_tip_next2))
				{
					return qtrue;
				}
				if (tri_tri_intersect(saber_base1, saber_tip1, saber_tip_next1, saber_base2, saber_tip2,
					saber_base_next2))
				{
					return qtrue;
				}
				if (tri_tri_intersect(saber_base1, saber_tip1, saber_tip_next1, saber_base2, saber_tip2,
					saber_tip_next2))
				{
					return qtrue;
				}
			}
		}
	}
	return qfalse;
}

static float WP_SabersDistance(const gentity_t* ent1, const gentity_t* ent2)
{
	vec3_t saber_base_next1, saber_tip_next1, saber_point1;
	vec3_t saber_base_next2, saber_tip_next2, saber_point2;

	if (!ent1 || !ent2)
	{
		return qfalse;
	}
	if (!ent1->client || !ent2->client)
	{
		return qfalse;
	}
	if (ent1->client->ps.SaberLength() <= 0 || ent2->client->ps.SaberLength() <= 0)
	{
		return qfalse;
	}

	{
		VectorCopy(ent1->client->ps.saber[0].blade[0].muzzlePoint, saber_base_next1);
		VectorMA(saber_base_next1, ent1->client->ps.saber[0].blade[0].length,
			ent1->client->ps.saber[0].blade[0].muzzleDir, saber_tip_next1);
	}

	{
		VectorCopy(ent2->client->ps.saber[0].blade[0].muzzlePoint, saber_base_next2);
		VectorMA(saber_base_next2, ent2->client->ps.saber[0].blade[0].length,
			ent2->client->ps.saber[0].blade[0].muzzleDir, saber_tip_next2);
	}

	const float sabers_dist = ShortestLineSegBewteen2LineSegs(saber_base_next1, saber_tip_next1, saber_base_next2,
		saber_tip_next2, saber_point1, saber_point2);

#ifndef FINAL_BUILD
	if (d_saberCombat->integer > 2)
	{
		G_DebugLine(saberPoint1, saberPoint2, FRAMETIME, 0x00ffffff, qtrue);
	}
#endif
	return sabers_dist;
}

static qboolean wp_sabers_intersection(const gentity_t* ent1, const gentity_t* ent2, vec3_t intersect)
{
	float best_line_seg_length = Q3_INFINITE;

	if (!ent1 || !ent2)
	{
		return qfalse;
	}
	if (!ent1->client || !ent2->client)
	{
		return qfalse;
	}
	if (ent1->client->ps.SaberLength() <= 0 || ent2->client->ps.SaberLength() <= 0)
	{
		return qfalse;
	}

	//UGH, had to make this work for multiply-bladed sabers
	for (const auto& saber_num1 : ent1->client->ps.saber)
	{
		for (int blade_num1 = 0; blade_num1 < saber_num1.numBlades; blade_num1++)
		{
			if (saber_num1.type != SABER_NONE
				&& saber_num1.blade[blade_num1].length > 0)
			{
				//valid saber and this blade is on
				for (const auto& saber_num2 : ent2->client->ps.saber)
				{
					for (int blade_num2 = 0; blade_num2 < saber_num2.numBlades; blade_num2++)
					{
						if (saber_num2.type != SABER_NONE
							&& saber_num2.blade[blade_num2].length > 0)
						{
							vec3_t saber_point2;
							vec3_t saber_tip_next2;
							vec3_t saber_base_next2;
							vec3_t saber_point1;
							vec3_t saber_tip_next1;
							vec3_t saber_base_next1;
							//valid saber and this blade is on
							VectorCopy(saber_num1.blade[blade_num1].muzzlePoint, saber_base_next1);
							VectorMA(saber_base_next1, saber_num1.blade[blade_num1].length,
								saber_num1.blade[blade_num1].muzzleDir, saber_tip_next1);

							VectorCopy(saber_num2.blade[blade_num2].muzzlePoint, saber_base_next2);
							VectorMA(saber_base_next2, saber_num2.blade[blade_num2].length,
								saber_num2.blade[blade_num2].muzzleDir, saber_tip_next2);

							const float line_seg_length = ShortestLineSegBewteen2LineSegs(
								saber_base_next1, saber_tip_next1, saber_base_next2, saber_tip_next2,
								saber_point1, saber_point2);
							if (line_seg_length < best_line_seg_length)
							{
								best_line_seg_length = line_seg_length;
								VectorAdd(saber_point1, saber_point2, intersect);
								VectorScale(intersect, 0.5, intersect);
							}
						}
					}
				}
			}
		}
	}
	return qtrue;
}

const char* hit_blood_sparks = "sparks/blood_sparks";
const char* hit_blood_sparks_MD = "sparks/blood_sparks_MD";
const char* hit_blood_sparks_AMD = "sparks/blood_sparks_AMD";

const char* hit_saber_cut = "saber/saber_cut";
const char* hit_saber_cut_MD = "saber/saber_cut_MD";
const char* hit_saber_cut_AMD = "saber/saber_cut_AMD";
const char* hit_saber_cut_droid = "saber/saber_cut_droid";
const char* hit_saber_touch_droid = "saber/saber_touch_droid";

static qboolean WP_SaberDamageEffects(trace_t* tr, const float length, const float dmg, vec3_t dmg_dir, vec3_t blade_vec,
	const int enemy_team, const saberType_t saber_type, const saberInfo_t* saber,
	const int blade_num)
{
	int hit_ent_num[MAX_G2_COLLISIONS]{};
	for (int& hen : hit_ent_num)
	{
		hen = ENTITYNUM_NONE;
	}
	//NOTE: = {0} does NOT work on anything but bytes?
	float hit_ent_dmg_add[MAX_G2_COLLISIONS] = { 0 };
	float hit_ent_dmg_sub[MAX_G2_COLLISIONS] = { 0 };
	vec3_t hit_ent_point[MAX_G2_COLLISIONS]{};
	vec3_t hit_ent_normal[MAX_G2_COLLISIONS]{};
	vec3_t blade_dir;
	float hit_ent_start_frac[MAX_G2_COLLISIONS] = { 0 };
	int tr_hit_loc[MAX_G2_COLLISIONS] = { HL_NONE }; //same as 0
	int tr_dismember_loc[MAX_G2_COLLISIONS] = { HL_NONE }; //same as 0
	qboolean tr_dismember[MAX_G2_COLLISIONS] = { qfalse }; //same as 0
	int i;
	int num_hit_ents = 0;
	int hit_effect;
	gentity_t* hit_ent;

	VectorNormalize2(blade_vec, blade_dir);

	for (auto& z : tr->G2CollisionMap)
	{
		if (z.mEntityNum == -1)
		{
			//actually, completely break out of this for loop since nothing after this in the aray should ever be valid either
			continue; //break;//
		}

		CCollisionRecord& coll = z;
		const float dist_from_start = coll.mDistance;

		for (i = 0; i < num_hit_ents; i++)
		{
			if (hit_ent_num[i] == coll.mEntityNum)
			{
				//we hit this ent before
				//we'll want to add this dist
				hit_ent_dmg_add[i] = dist_from_start;
				break;
			}
		}
		if (i == num_hit_ents)
		{
			//first time we hit this ent
			if (num_hit_ents == MAX_G2_COLLISIONS)
			{
				//hit too many damn ents!
				continue;
			}
			hit_ent_num[num_hit_ents] = coll.mEntityNum;
			if (!coll.mFlags)
			{
				//hmm, we came out first, so we must have started inside
				//we'll want to subtract this dist
				hit_ent_dmg_add[num_hit_ents] = dist_from_start;
			}
			else
			{
				//we're entering the model
				//we'll want to subtract this dist
				hit_ent_dmg_sub[num_hit_ents] = dist_from_start;
			}
			//keep track of how far in the damage was done
			hit_ent_start_frac[num_hit_ents] = hit_ent_dmg_sub[num_hit_ents] / length;
			//remember the entrance point
			VectorCopy(coll.mCollisionPosition, hit_ent_point[num_hit_ents]);
			//remember the normal of the face we hit
			VectorCopy(coll.mCollisionNormal, hit_ent_normal[num_hit_ents]);
			VectorNormalize(hit_ent_normal[num_hit_ents]);

			//do the effect

			//FIXME: check material rather than team?
			hit_ent = &g_entities[hit_ent_num[num_hit_ents]];
			if (hit_ent
				&& hit_ent->client
				&& coll.mModelIndex > 0)
			{
				//hit a submodel on the enemy, not their actual body!
				if (!WP_SaberBladeUseSecondBladeStyle(saber, blade_num)
					&& saber->hitOtherEffect)
				{
					hit_effect = saber->hitOtherEffect;
				}
				else if (WP_SaberBladeUseSecondBladeStyle(saber, blade_num)
					&& saber->hitOtherEffect2)
				{
					hit_effect = saber->hitOtherEffect2;
				}
				else
				{
					if (hit_ent && hit_ent->client &&
						(hit_ent->client->NPC_class == CLASS_ATST
							|| hit_ent->client->NPC_class == CLASS_GONK
							|| hit_ent->client->NPC_class == CLASS_INTERROGATOR
							|| hit_ent->client->NPC_class == CLASS_MARK1
							|| hit_ent->client->NPC_class == CLASS_MARK2
							|| hit_ent->client->NPC_class == CLASS_MOUSE
							|| hit_ent->client->NPC_class == CLASS_PROBE
							|| hit_ent->client->NPC_class == CLASS_PROTOCOL
							|| hit_ent->client->NPC_class == CLASS_R2D2
							|| hit_ent->client->NPC_class == CLASS_R5D2
							|| hit_ent->client->NPC_class == CLASS_SEEKER
							|| hit_ent->client->NPC_class == CLASS_SENTRY
							|| hit_ent->client->NPC_class == CLASS_SBD
							|| hit_ent->client->NPC_class == CLASS_BATTLEDROID
							|| hit_ent->client->NPC_class == CLASS_DROIDEKA
							|| hit_ent->client->NPC_class == CLASS_OBJECT
							|| hit_ent->client->NPC_class == CLASS_ASSASSIN_DROID
							|| hit_ent->client->NPC_class == CLASS_SABER_DROID))
					{
						hit_effect = G_EffectIndex(hit_saber_cut_droid);
					}
					else
					{
						if (g_SerenityJediEngineMode->integer)
						{
							if (g_SerenityJediEngineMode->integer == 2)
							{
								hit_effect = G_EffectIndex(hit_saber_cut_AMD);
							}
							else
							{
								hit_effect = G_EffectIndex(hit_saber_cut_MD);
							}
						}
						else
						{
							hit_effect = G_EffectIndex(hit_saber_cut);
						}
					}
				}
			}
			else
			{
				if (!WP_SaberBladeUseSecondBladeStyle(saber, blade_num)
					&& saber->hitPersonEffect)
				{
					hit_effect = saber->hitPersonEffect;
				}
				else if (WP_SaberBladeUseSecondBladeStyle(saber, blade_num)
					&& saber->hitPersonEffect2)
				{
					hit_effect = saber->hitPersonEffect2;
				}
				else
				{
					if (hit_ent && hit_ent->client &&
						(hit_ent->client->NPC_class == CLASS_ATST
							|| hit_ent->client->NPC_class == CLASS_GONK
							|| hit_ent->client->NPC_class == CLASS_INTERROGATOR
							|| hit_ent->client->NPC_class == CLASS_MARK1
							|| hit_ent->client->NPC_class == CLASS_MARK2
							|| hit_ent->client->NPC_class == CLASS_MOUSE
							|| hit_ent->client->NPC_class == CLASS_PROBE
							|| hit_ent->client->NPC_class == CLASS_PROTOCOL
							|| hit_ent->client->NPC_class == CLASS_R2D2
							|| hit_ent->client->NPC_class == CLASS_R5D2
							|| hit_ent->client->NPC_class == CLASS_SEEKER
							|| hit_ent->client->NPC_class == CLASS_SENTRY
							|| hit_ent->client->NPC_class == CLASS_SBD
							|| hit_ent->client->NPC_class == CLASS_BATTLEDROID
							|| hit_ent->client->NPC_class == CLASS_DROIDEKA
							|| hit_ent->client->NPC_class == CLASS_OBJECT
							|| hit_ent->client->NPC_class == CLASS_ASSASSIN_DROID
							|| hit_ent->client->NPC_class == CLASS_SABER_DROID))
					{
						hit_effect = G_EffectIndex(hit_saber_cut_droid);
					}
					else
					{
						if (g_SerenityJediEngineMode->integer)
						{
							if (g_SerenityJediEngineMode->integer == 2)
							{
								hit_effect = G_EffectIndex(hit_blood_sparks_AMD);
							}
							else
							{
								hit_effect = G_EffectIndex(hit_blood_sparks_MD);
							}
						}
						else
						{
							hit_effect = G_EffectIndex(hit_blood_sparks);
						}
					}
				}
			}
			if (hit_ent != nullptr)
			{
				if (hit_ent->client)
				{
					if (hit_ent->client->NPC_class == CLASS_ATST
						|| hit_ent->client->NPC_class == CLASS_GONK
						|| hit_ent->client->NPC_class == CLASS_INTERROGATOR
						|| hit_ent->client->NPC_class == CLASS_MARK1
						|| hit_ent->client->NPC_class == CLASS_MARK2
						|| hit_ent->client->NPC_class == CLASS_MOUSE
						|| hit_ent->client->NPC_class == CLASS_PROBE
						|| hit_ent->client->NPC_class == CLASS_PROTOCOL
						|| hit_ent->client->NPC_class == CLASS_R2D2
						|| hit_ent->client->NPC_class == CLASS_R5D2
						|| hit_ent->client->NPC_class == CLASS_SEEKER
						|| hit_ent->client->NPC_class == CLASS_SENTRY
						|| hit_ent->client->NPC_class == CLASS_SBD
						|| hit_ent->client->NPC_class == CLASS_BATTLEDROID
						|| hit_ent->client->NPC_class == CLASS_DROIDEKA
						|| hit_ent->client->NPC_class == CLASS_OBJECT
						|| hit_ent->client->NPC_class == CLASS_ASSASSIN_DROID
						|| hit_ent->client->NPC_class == CLASS_SABER_DROID)
					{
						if (!WP_SaberBladeUseSecondBladeStyle(saber, blade_num)
							&& saber->hitOtherEffect)
						{
							hit_effect = saber->hitOtherEffect;
						}
						else if (WP_SaberBladeUseSecondBladeStyle(saber, blade_num)
							&& saber->hitOtherEffect2)
						{
							hit_effect = saber->hitOtherEffect2;
						}
						else
						{
							hit_effect = G_EffectIndex(hit_saber_touch_droid);
						}
					}
				}
				else
				{
					// So sue me, this is the easiest way to check to see if this is the turbo laser from t2_wedge,
					// in which case I don't want the saber effects going off on it.
					if (hit_ent->flags & FL_DMG_BY_HEAVY_WEAP_ONLY
						&& hit_ent->takedamage == qfalse
						&& Q_stricmp(hit_ent->classname, "misc_turret") == 0)
					{
						continue;
					}
					if (dmg)
					{
						//only do these effects if actually trying to damage the thing...
						if (hit_ent->svFlags & SVF_BBRUSH //a breakable brush
							&& (hit_ent->spawnflags & 1 //INVINCIBLE
								|| hit_ent->flags & FL_DMG_BY_HEAVY_WEAP_ONLY) //HEAVY weapon damage only
							)
						{
							//no hit effect (besides regular client-side one)
							hit_effect = 0;
						}
						else
						{
							if (!WP_SaberBladeUseSecondBladeStyle(saber, blade_num)
								&& saber->hitOtherEffect)
							{
								hit_effect = saber->hitOtherEffect;
							}
							else if (WP_SaberBladeUseSecondBladeStyle(saber, blade_num)
								&& saber->hitOtherEffect2)
							{
								hit_effect = saber->hitOtherEffect2;
							}
							else
							{
								if (hit_ent && hit_ent->client &&
									(hit_ent->client->NPC_class == CLASS_ATST
										|| hit_ent->client->NPC_class == CLASS_GONK
										|| hit_ent->client->NPC_class == CLASS_INTERROGATOR
										|| hit_ent->client->NPC_class == CLASS_MARK1
										|| hit_ent->client->NPC_class == CLASS_MARK2
										|| hit_ent->client->NPC_class == CLASS_MOUSE
										|| hit_ent->client->NPC_class == CLASS_PROBE
										|| hit_ent->client->NPC_class == CLASS_PROTOCOL
										|| hit_ent->client->NPC_class == CLASS_R2D2
										|| hit_ent->client->NPC_class == CLASS_R5D2
										|| hit_ent->client->NPC_class == CLASS_SEEKER
										|| hit_ent->client->NPC_class == CLASS_SENTRY
										|| hit_ent->client->NPC_class == CLASS_SBD
										|| hit_ent->client->NPC_class == CLASS_BATTLEDROID
										|| hit_ent->client->NPC_class == CLASS_DROIDEKA
										|| hit_ent->client->NPC_class == CLASS_OBJECT
										|| hit_ent->client->NPC_class == CLASS_ASSASSIN_DROID
										|| hit_ent->client->NPC_class == CLASS_SABER_DROID))
								{
									hit_effect = G_EffectIndex(hit_saber_cut_droid);
								}
								else
								{
									if (g_SerenityJediEngineMode->integer)
									{
										if (g_SerenityJediEngineMode->integer == 2)
										{
											hit_effect = G_EffectIndex(hit_saber_cut_AMD);
										}
										else
										{
											hit_effect = G_EffectIndex(hit_saber_cut_MD);
										}
									}
									else
									{
										hit_effect = G_EffectIndex(hit_saber_cut);
									}
								}
							}
						}
					}
				}
			}

			//FIXME: play less if damage is less?
			if (!g_saberNoEffects)
			{
				if (hit_effect != 0)
				{
					//FIXME: when you have multiple blades hitting someone for many sequential server frames, this can get a bit chuggy!
					G_PlayEffect(hit_effect, coll.mCollisionPosition, coll.mCollisionNormal);
				}
			}

			//Get the hit location based on surface name
			if (hit_loc[hit_ent_num[num_hit_ents]] == HL_NONE && tr_hit_loc[num_hit_ents] == HL_NONE
				|| hitDismemberLoc[hit_ent_num[num_hit_ents]] == HL_NONE && tr_dismember_loc[num_hit_ents] == HL_NONE
				|| !hitDismember[hit_ent_num[num_hit_ents]] && !tr_dismember[num_hit_ents])
			{
				//no hit loc set for this ent this damage cycle yet
				//FIXME: find closest impact surf *first* (per ent), then call G_GetHitLocFromSurfName?
				//FIXED: if hit multiple ents in this collision record, these trSurfName, trDismember and trDismemberLoc will get stomped/confused over the multiple ents I hit
				const char* tr_surf_name = gi.G2API_GetSurfaceName(
					&g_entities[coll.mEntityNum].ghoul2[coll.mModelIndex],
					coll.mSurfaceIndex);
				tr_dismember[num_hit_ents] = G_GetHitLocFromSurfName(&g_entities[coll.mEntityNum], tr_surf_name,
					&tr_hit_loc[num_hit_ents], coll.mCollisionPosition,
					dmg_dir, blade_dir, MOD_SABER, saber_type);
				if (tr_dismember[num_hit_ents])
				{
					tr_dismember_loc[num_hit_ents] = tr_hit_loc[num_hit_ents];
				}
			}
			num_hit_ents++;
		}
	}

	//now go through all the ents we hit and do the damage
	for (i = 0; i < num_hit_ents; i++)
	{
		float do_dmg = dmg;
		if (hit_ent_num[i] != ENTITYNUM_NONE)
		{
			if (do_dmg < 10)
			{
				//base damage is less than 10
				if (hit_ent_num[i] != 0)
				{
					//not the player
					hit_ent = &g_entities[hit_ent_num[i]];
					if (!hit_ent->client || hit_ent->client->ps.weapon != WP_SABER && hit_ent->client->NPC_class !=
						CLASS_GALAKMECH && hit_ent->client->playerTeam == enemy_team)
					{
						//did *not* hit a jedi and did *not* hit the player
						//make sure the base damage is high against non-jedi, feels better
						do_dmg = 10;
					}
				}
			}
			if (!hit_ent_dmg_add[i] && !hit_ent_dmg_sub[i])
			{
				//spent entire time in model
				//NOTE: will we even get a collision then?
				do_dmg *= length;
			}
			else if (hit_ent_dmg_add[i] && hit_ent_dmg_sub[i])
			{
				//we did enter and exit
				do_dmg *= hit_ent_dmg_add[i] - hit_ent_dmg_sub[i];
			}
			else if (!hit_ent_dmg_add[i])
			{
				//we didn't exit, just entered
				do_dmg *= length - hit_ent_dmg_sub[i];
			}
			else if (!hit_ent_dmg_sub[i])
			{
				//we didn't enter, only exited
				do_dmg *= hit_ent_dmg_add[i];
			}
			if (do_dmg > 0)
			{
				WP_SaberDamageAdd(1.0, hit_ent_num[i], dmg_dir, blade_vec, hit_ent_normal[i], hit_ent_point[i],
					ceil(do_dmg),
					hit_ent_start_frac[i], tr_hit_loc[i], tr_dismember[i], tr_dismember_loc[i]);
			}
		}
	}
	return static_cast<qboolean>(num_hit_ents > 0);
}

static void WP_SaberBlockEffect(const gentity_t* attacker, const int saber_num, const int blade_num, vec3_t position,
	vec3_t normal, const qboolean cut_not_block)
{
	const saberInfo_t* saber = nullptr;

	if (attacker && attacker->client)
	{
		saber = &attacker->client->ps.saber[saber_num];
	}

	if (saber
		&& !WP_SaberBladeUseSecondBladeStyle(saber, blade_num)
		&& saber->blockEffect)
	{
		if (normal)
		{
			G_PlayEffect(saber->blockEffect, position, normal);
		}
		else
		{
			G_PlayEffect(saber->blockEffect, position);
		}
	}
	else if (saber
		&& WP_SaberBladeUseSecondBladeStyle(saber, blade_num)
		&& saber->blockEffect2)
	{
		if (normal)
		{
			G_PlayEffect(saber->blockEffect2, position, normal);
		}
		else
		{
			G_PlayEffect(saber->blockEffect2, position);
		}
	}
	else if (cut_not_block)
	{
		if (normal)
		{
			if (g_SerenityJediEngineMode->integer)
			{
				if (g_SerenityJediEngineMode->integer == 2)
				{
					G_PlayEffect("saber/saber_cut_AMD", position, normal);
				}
				else
				{
					G_PlayEffect("saber/saber_cut_MD", position, normal);
				}
			}
			else
			{
				G_PlayEffect("saber/saber_cut", position, normal);
			}
		}
		else
		{
			if (g_SerenityJediEngineMode->integer)
			{
				if (g_SerenityJediEngineMode->integer == 2)
				{
					G_PlayEffect("saber/saber_cut_AMD", position);
				}
				else
				{
					G_PlayEffect("saber/saber_cut_MD", position);
				}
			}
			else
			{
				G_PlayEffect("saber/saber_cut", position);
			}
		}
	}
	else
	{
		if (normal)
		{
			if (g_SerenityJediEngineMode->integer)
			{
				if (g_SerenityJediEngineMode->integer == 2)
				{
					G_PlayEffect("saber/saber_block_AMD", position, normal);
				}
				else
				{
					G_PlayEffect("saber/saber_block_MD", position, normal);
				}
			}
			else
			{
				G_PlayEffect("saber/saber_block", position, normal);
			}
		}
		else
		{
			if (g_SerenityJediEngineMode->integer)
			{
				if (g_SerenityJediEngineMode->integer == 2)
				{
					G_PlayEffect("saber/saber_block_AMD", position);
				}
				else
				{
					G_PlayEffect("saber/saber_block_MD", position);
				}
			}
			else
			{
				G_PlayEffect("saber/saber_block", position);
			}
		}
	}
}

static void WP_SaberMBlockEffect(const gentity_t* blocker, const int saber_num, const int blade_num, vec3_t position,
	vec3_t normal,
	const qboolean cut_not_block)
{
	const saberInfo_t* saber = nullptr;

	if (blocker && blocker->client)
	{
		saber = &blocker->client->ps.saber[saber_num];
	}

	if (saber
		&& !WP_SaberBladeUseSecondBladeStyle(saber, blade_num)
		&& saber->blockEffect)
	{
		if (normal)
		{
			G_PlayEffect(saber->blockEffect, position, normal);
		}
		else
		{
			G_PlayEffect(saber->blockEffect, position);
		}
	}
	else if (saber
		&& WP_SaberBladeUseSecondBladeStyle(saber, blade_num)
		&& saber->blockEffect2)
	{
		if (normal)
		{
			G_PlayEffect(saber->blockEffect2, position, normal);
		}
		else
		{
			G_PlayEffect(saber->blockEffect2, position);
		}
	}
	else if (cut_not_block)
	{
		if (normal)
		{
			G_PlayEffect("saber/saber_cut_AMD", position, normal);
		}
		else
		{
			G_PlayEffect("saber/saber_cut_AMD", position);
		}
	}
	else
	{
		if (normal)
		{
			G_PlayEffect("saber/saber_goodparry", position, normal);
		}
		else
		{
			G_PlayEffect("saber/saber_goodparry", position);
		}
	}
}

static void WP_SaberKnockSound(const gentity_t* ent, const int saber_num, const int blade_num)
{
	if (!ent || !ent->client)
	{
		return;
	}
	const int index = Q_irand(1, 4);
	const int classicindex = Q_irand(1, 30);

	if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
		&& ent->client->ps.saber[saber_num].blockSound[0])
	{
		G_Sound(ent, ent->client->ps.saber[saber_num].blockSound[Q_irand(0, 2)]);
	}
	else if (WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
		&& ent->client->ps.saber[saber_num].block2Sound[0])
	{
		G_Sound(ent, ent->client->ps.saber[saber_num].block2Sound[Q_irand(0, 2)]);
	}
	else
	{
		if (ent->client->ps.saber[saber_num].type == SABER_SINGLE_CLASSIC)
		{
			G_Sound(ent, G_SoundIndex(va("sound/weapons/saber/classicblock%d.mp3", classicindex)));
		}
		else
		{
			G_Sound(ent, G_SoundIndex(va("sound/weapons/saber/saberknock%d.mp3", index)));
		}
	}
}

static void WP_SaberKnockaway(const gentity_t* attacker, trace_t* tr)
{
	WP_SaberDrop(attacker, &g_entities[attacker->client->ps.saberEntityNum]);

	if (attacker->client->ps.blockPoints < BLOCKPOINTS_HALF || attacker->client->ps.forcePower < BLOCKPOINTS_HALF)
	{
		WP_SaberKnockSound(attacker, 0, 0);
	}
	else
	{
		WP_SaberBlockSound(attacker, 0, 0);
	}
	WP_SaberBlockEffect(attacker, 0, 0, tr->endpos, nullptr, qfalse);
	saberHitFraction = tr->fraction;
#ifndef FINAL_BUILD
	if (d_saberCombat->integer)
	{
		gi.Printf(S_COLOR_MAGENTA"WP_SaberKnockaway: saberHitFraction %4.2f\n", saberHitFraction);
	}
#endif
	VectorCopy(tr->endpos, saberHitLocation);
	saberHitEntity = tr->entityNum;
	if (!g_noClashFlare)
	{
		g_saberFlashTime = level.time - 50;
		VectorCopy(saberHitLocation, g_saberFlashPos);
	}
}

qboolean G_InCinematicSaberAnim(const gentity_t* self)
{
	if (self->NPC
		&& self->NPC->behaviorState == BS_CINEMATIC
		&& (self->client->ps.torsoAnim == BOTH_CIN_16 || self->client->ps.torsoAnim == BOTH_CIN_17))
	{
		return qtrue;
	}
	if (self->NPC
		&& self->NPC->behaviorState == BS_CINEMATIC
		&& com_outcast->integer == 0 && self->client->saberCollisions)
	{
		return qtrue;
	}
	return qfalse;
}

qboolean G_InScriptedCinematicSaberAnim(const gentity_t* self)
{
	if (self->NPC
		&& self->NPC->behaviorState == BS_CINEMATIC)
	{
		return qtrue;
	}
	return qfalse;
}

constexpr auto SABER_COLLISION_BLOCKING_DIST = 10; //was 2//was 4//was 8//was 16;
constexpr auto SABER_COLLISION_DIST_MD = 8; //was 2//was 4//was 8//was 16;
constexpr auto SABER_RADIUS_DAMAGE_DIST = 2;
constexpr auto SABER_COLLISION_DIST = 6;
extern qboolean InFront(vec3_t spot, vec3_t from, vec3_t fromAngles, float threshHold = 0.0f);

static qboolean WP_SaberDamageForTrace(const int ignore, vec3_t start, vec3_t end, float dmg, vec3_t blade_dir,
	const qboolean no_ghoul, const saberType_t saber_type, const qboolean extrapolate,
	const int saber_num, const int blade_num)
{
	trace_t tr;
	constexpr int mask = MASK_SHOT | CONTENTS_LIGHTSABER;
	gentity_t* attacker = &g_entities[ignore];
	vec3_t end2;
	VectorCopy(end, end2);

	if (extrapolate)
	{
		vec3_t diff;
		VectorSubtract(end, start, diff);
		VectorNormalize(diff);
		VectorMA(end2, SABER_EXTRAPOLATE_DIST, diff, end2);
	}

	if (!no_ghoul)
	{
		float use_radius_for_damage = 0;

		if (attacker
			&& attacker->client)
		{
			//see if we're not drawing the blade, if so, do a trace based on radius of blade (because the radius is being used to simulate a larger/smaller piece of a solid weapon)...
			if (!WP_SaberBladeUseSecondBladeStyle(&attacker->client->ps.saber[saber_num], blade_num)
				&& attacker->client->ps.saber[saber_num].saberFlags2 & SFL2_NO_BLADE)
			{
				//not drawing blade
				use_radius_for_damage = attacker->client->ps.saber[saber_num].blade[blade_num].radius;
			}
			else if (WP_SaberBladeUseSecondBladeStyle(&attacker->client->ps.saber[saber_num], blade_num)
				&& attacker->client->ps.saber[saber_num].saberFlags2 & SFL2_NO_BLADE2)
			{
				//not drawing blade
				use_radius_for_damage = attacker->client->ps.saber[saber_num].blade[blade_num].radius;
			}
		}
		if (!use_radius_for_damage)
		{
			//do normal check for larger-size saber traces
			if (!attacker->s.number
				|| attacker->client
				&& (attacker->client->playerTeam == TEAM_PLAYER
					|| attacker->client->NPC_class == CLASS_SHADOWTROOPER
					|| attacker->client->NPC_class == CLASS_ALORA
					|| attacker->NPC && (attacker->NPC->aiFlags & NPCAI_BOSS_CHARACTER || attacker->NPC->aiFlags &
						NPCAI_BOSS_SERENITYJEDIENGINE)))
			{
				use_radius_for_damage = SABER_RADIUS_DAMAGE_DIST;
			}
		}

		if (use_radius_for_damage > 0)
		{
			//player,. player allies, shadowtroopers, tavion and desann use larger traces
			const vec3_t trace_mins = {
							 -use_radius_for_damage, -use_radius_for_damage, -use_radius_for_damage
			}, trace_maxs = {
				use_radius_for_damage, use_radius_for_damage, use_radius_for_damage
			};
			gi.trace(&tr, start, trace_mins, trace_maxs, end2, ignore, mask, G2_COLLIDE, 10); //G2_SUPERSIZEDBBOX
		}
		else
		{
			//reborn use smaller traces
			gi.trace(&tr, start, nullptr, nullptr, end2, ignore, mask, G2_COLLIDE, 10); //G2_SUPERSIZEDBBOX
		}
	}
	else
	{
		gi.trace(&tr, start, nullptr, nullptr, end2, ignore, mask, G2_NOCOLLIDE, 10);
	}

#ifndef FINAL_BUILD
	if (d_saberCombat->integer > 1)
	{
		if (attacker != nullptr && attacker->client != nullptr)
		{
			G_DebugLine(start, end2, FRAMETIME, WPDEBUG_SaberColor(attacker->client->ps.saber[0].blade[0].color), qtrue);
		}
	}
#endif

	if (tr.entityNum == ENTITYNUM_NONE)
	{
		return qfalse;
	}

	if (tr.entityNum == ENTITYNUM_WORLD)
	{
		if (attacker && attacker->client && (attacker->client->ps.saber[saber_num].saberFlags & SFL_BOUNCE_ON_WALLS || g_SaberBounceOnWalls->integer))
		{
			VectorCopy(tr.endpos, saberHitLocation);
			VectorCopy(tr.plane.normal, saberHitNormal);
		}
		return qtrue;
	}

	if (&g_entities[tr.entityNum])
	{
		const gentity_t* hit_ent = &g_entities[tr.entityNum];
		const gentity_t* owner = g_entities[tr.entityNum].owner;

		if (hit_ent->contents & CONTENTS_LIGHTSABER)
		{
			if (attacker && attacker->client && attacker->client->ps.saberInFlight)
			{
				//thrown saber hit something
				if (owner
					&& owner->s.number
					&& owner->client
					&& owner->NPC
					&& owner->health > 0)
				{
					if (owner->client->NPC_class == CLASS_ALORA)
					{
						//alora takes less damage
						dmg *= 0.25f;
					}
					else if (owner->client->NPC_class == CLASS_PLAYER)
					{
						//player takes less damage
						dmg *= 0.25f;
					}
					else if (owner->client->NPC_class == CLASS_TAVION)
					{
						//Tavion can toss a blocked thrown saber aside
						WP_SaberKnockaway(attacker, &tr);
						jedi_play_deflect_sound(owner);
						return qfalse;
					}
					else if (owner->client->NPC_class == CLASS_YODA)
					{
						//Tavion can toss a blocked thrown saber aside
						WP_SaberKnockaway(attacker, &tr);
						jedi_play_deflect_sound(owner);
						return qfalse;
					}
					else if (owner->client->NPC_class == CLASS_GALEN)
					{
						//Tavion can toss a blocked thrown saber aside
						WP_SaberKnockaway(attacker, &tr);
						jedi_play_deflect_sound(owner);
						return qfalse;
					}
					else if (owner->client->NPC_class == CLASS_VADER)
					{
						//vader can toss a blocked thrown saber aside
						WP_SaberKnockaway(attacker, &tr);
						jedi_play_deflect_sound(owner);
						return qfalse;
					}
					else if (owner->client->NPC_class == CLASS_DESANN)
					{
						//vader can toss a blocked thrown saber aside
						WP_SaberKnockaway(attacker, &tr);
						jedi_play_deflect_sound(owner);
						return qfalse;
					}
				}
				else if (owner
					&& owner->s.number
					&& owner->client
					&& owner->health > 0)
				{
					if (g_SerenityJediEngineMode->integer && owner->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCK)
					{
						//player takes less damage
						dmg *= 0.25f;
					}
				}
			}
			qboolean sabers_intersect = WP_SabersIntersect(attacker, saber_num, blade_num, owner, qfalse); //qtrue );

			float sabers_dist;

			if (attacker && attacker->client && attacker->client->ps.saberInFlight
				&& owner && owner->s.number == 0 && (g_saberAutoBlocking->integer || attacker->client->ps.
					saberBlockingTime > level.time)) //NPC flying saber hit player's saber bounding box
			{
				sabers_dist = 0;
			}
			else
			{
				//sabers must actually collide with the attacking saber
				sabers_dist = WP_SabersDistance(attacker, owner);
				if (attacker && attacker->client && attacker->client->ps.saberInFlight)
				{
					sabers_dist /= 2.0f;
					if (sabers_dist <= 16.0f)
					{
						sabers_intersect = qtrue;
					}
				}
#ifndef FINAL_BUILD
				if (d_saberCombat->integer > 1)
				{
					gi.Printf("sabersDist: %4.2f\n", sabersDist);
				}
#endif//FINAL_BUILD
			}
			if (sabersCrossed == -1 || sabersCrossed > sabers_dist)
			{
				sabersCrossed = sabers_dist;
			}

			float collision_dist;

			if (g_saberRealisticCombat->integer)
			{
				collision_dist = SABER_COLLISION_DIST;
			}
			else
			{
				collision_dist = SABER_COLLISION_DIST + 6 + g_spskill->integer * 4;
			}
			{
				if (G_InCinematicSaberAnim(owner) && G_InCinematicSaberAnim(attacker))
				{
					sabers_intersect = qtrue;
				}
			}
			if (owner && owner->client && attacker != nullptr
				&& sabers_dist > collision_dist
				&& !sabers_intersect)
			{
				//swing came from behind and/or was not stopped by a lightsaber
				gi.trace(&tr, start, nullptr, nullptr, end2, ignore, mask & ~CONTENTS_LIGHTSABER, G2_NOCOLLIDE, 10);

				if (tr.entityNum == ENTITYNUM_WORLD)
				{
					return qtrue;
				}
				if (tr.entityNum == ENTITYNUM_NONE || &g_entities[tr.entityNum] == nullptr)
				{
					//didn't hit the owner
					return qfalse; // Exit, but we didn't hit the wall.
				}
#ifndef FINAL_BUILD
				if (d_saberCombat->integer > 1)
				{
					if (!attacker->s.number)
					{
						gi.Printf(S_COLOR_MAGENTA"%d saber hit owner through saber %4.2f, dist = %4.2f\n", level.time, saberHitFraction, sabersDist);
					}
				}
#endif//FINAL_BUILD
				hit_ent = &g_entities[tr.entityNum];
				owner = g_entities[tr.entityNum].owner;
			}
			else
			{
				//hit a lightsaber
				if ((tr.fraction < saberHitFraction || tr.startsolid)
					&& sabers_dist < (8.0f + g_spskill->value) * 4.0f
					&& (sabers_intersect || sabers_dist < (4.0f + g_spskill->value) * 2.0f))
				{
					// This saber hit closer than the last one.
					if ((tr.allsolid || tr.startsolid) && owner && owner->client)
					{
						//tr.fraction will be 0, unreliable... so calculate actual
						const float dist = Distance(start, end2);
						if (dist)
						{
							float hit_frac = WP_SabersDistance(attacker, owner) / dist;
							if (hit_frac > 1.0f)
							{
								//umm... minimum distance between sabers was longer than trace...?
								hit_frac = 1.0f;
							}
							if (hit_frac < saberHitFraction)
							{
								saberHitFraction = hit_frac;
							}
						}
						else
						{
							saberHitFraction = 0.0f;
						}
#ifndef FINAL_BUILD
						if (d_saberCombat->integer > 1)
						{
							if (!attacker->s.number)
							{
								gi.Printf(S_COLOR_GREEN"%d saber hit saber dist %4.2f allsolid %4.2f\n", level.time, sabersDist, saberHitFraction);
							}
						}
#endif//FINAL_BUILD
					}
					else
					{
#ifndef FINAL_BUILD
						if (d_saberCombat->integer > 1)
						{
							if (!attacker->s.number)
							{
								gi.Printf(S_COLOR_BLUE"%d saber hit saber dist %4.2f, frac %4.2f\n", level.time, sabersDist, saberHitFraction);
							}
							saberHitFraction = tr.fraction;
						}
#endif//FINAL_BUILD
					}
#ifndef FINAL_BUILD
					if (d_saberCombat->integer)
					{
						gi.Printf(S_COLOR_MAGENTA"hit saber: saberHitFraction %4.2f, allsolid %d, startsolid %d\n", saberHitFraction, tr.allsolid, tr.startsolid);
					}
#endif//FINAL_BUILD
					VectorCopy(tr.endpos, saberHitLocation);
					saberHitEntity = tr.entityNum;
				}
				return qfalse; // Exit, but we didn't hit the wall.
			}
		}
		else
		{
#ifndef FINAL_BUILD
			if (d_saberCombat->integer > 1)
			{
				if (!attacker->s.number)
				{
					gi.Printf(S_COLOR_RED"%d saber hit owner directly %4.2f\n", level.time, saberHitFraction);
				}
			}
#endif//FINAL_BUILD
		}

		if (attacker && attacker->client && attacker->client->ps.saberInFlight)
		{
			//thrown saber hit something
			if (hit_ent && hit_ent->client && hit_ent->health > 0
				&& (hit_ent->client->NPC_class == CLASS_DESANN
					|| hit_ent->client->NPC_class == CLASS_SITHLORD
					|| hit_ent->client->NPC_class == CLASS_VADER
					|| !Q_stricmp("Yoda", hit_ent->NPC_type)
					|| hit_ent->client->NPC_class == CLASS_LUKE
					|| hit_ent->client->NPC_class == CLASS_BOBAFETT
					//|| hit_ent->client->NPC_class == CLASS_MANDALORIAN
					|| hit_ent->client->NPC_class == CLASS_JANGO
					|| hit_ent->client->NPC_class == CLASS_JANGODUAL
					|| hit_ent->client->NPC_class == CLASS_GALAKMECH && hit_ent->client->ps.powerups[PW_GALAK_SHIELD] >
					0
					|| hit_ent->client->ps.powerups[PW_GALAK_SHIELD] > 0) ||
				owner && owner->client && owner->health > 0
				&& (owner->client->NPC_class == CLASS_DESANN
					|| owner->client->NPC_class == CLASS_SITHLORD
					|| owner->client->NPC_class == CLASS_VADER
					|| !Q_stricmp("Yoda", owner->NPC_type)
					|| owner->client->NPC_class == CLASS_LUKE
					|| owner->client->NPC_class == CLASS_GALAKMECH && owner->client->ps.powerups[PW_GALAK_SHIELD] > 0
					|| owner->client->ps.powerups[PW_GALAK_SHIELD] > 0))
			{
				//Luke and Desann slap thrown sabers aside
				WP_SaberKnockaway(attacker, &tr);

				if (hit_ent->client)
				{
					jedi_play_deflect_sound(hit_ent);
				}
				else
				{
					jedi_play_deflect_sound(owner);
				}
				return qfalse; // Exit, but we didn't hit the wall.
			}
		}

		if (hit_ent->takedamage)
		{
			vec3_t dir;
			vec3_t blade_vec = { 0 };
			if (attacker && attacker->client)
			{
				VectorScale(blade_dir, attacker->client->ps.saber[saber_num].blade[blade_num].length, blade_vec);
			}
			//multiply the damage by the total distance of the swipe
			VectorSubtract(end2, start, dir);
			const float len = VectorNormalize(dir); //VectorLength( dir );
			if (no_ghoul || !hit_ent->ghoul2.size())
			{
				//we weren't doing a ghoul trace
				int hit_effect = 0;
				if (dmg >= 1.0 && hit_ent->bmodel)
				{
					dmg = 1.0;
				}
				if (len > 1)
				{
					dmg *= len;
				}
#ifndef FINAL_BUILD
				if (d_saberCombat->integer > 1)
				{
					if (!(hit_ent->contents & CONTENTS_LIGHTSABER))
					{
						gi.Printf(S_COLOR_GREEN"Hit ent, but no ghoul collisions\n");
					}
				}
#endif
				float tr_frac, dmg_frac;
				if (tr.allsolid)
				{
					//totally inside them
					tr_frac = 1.0;
					dmg_frac = 0.0;
				}
				else if (tr.startsolid)
				{
					//started inside them
					//we don't know how much was inside, we know it's less than all, so use half?
					tr_frac = 0.5;
					dmg_frac = 0.0;
				}
				else
				{
					//started outside them and hit them
					//yeah. this doesn't account for coming out the other wide, but we can worry about that later (use ghoul2)
					tr_frac = 1.0f - tr.fraction;
					dmg_frac = tr.fraction;
				}
				vec3_t backdir;
				VectorScale(dir, -1, backdir);
				WP_SaberDamageAdd(tr_frac, tr.entityNum, dir, blade_vec, backdir, tr.endpos, dmg, dmg_frac, HL_NONE,
					qfalse, HL_NONE);
				if (!tr.allsolid && !tr.startsolid)
				{
					VectorScale(dir, -1, dir);
				}
				if (hit_ent != nullptr)
				{
					if (hit_ent->client)
					{
						//don't do blood sparks on non-living things
						const class_t npc_class = hit_ent->client->NPC_class;

						if (npc_class == CLASS_ATST || npc_class == CLASS_GONK ||
							npc_class == CLASS_INTERROGATOR || npc_class == CLASS_MARK1 ||
							npc_class == CLASS_MARK2 || npc_class == CLASS_MOUSE ||
							npc_class == CLASS_PROBE || npc_class == CLASS_PROTOCOL ||
							npc_class == CLASS_R2D2 || npc_class == CLASS_R5D2 ||
							npc_class == CLASS_SEEKER || npc_class == CLASS_SENTRY ||
							npc_class == CLASS_SBD || npc_class == CLASS_BATTLEDROID ||
							npc_class == CLASS_DROIDEKA || npc_class == CLASS_OBJECT ||
							npc_class == CLASS_ASSASSIN_DROID || npc_class == CLASS_SABER_DROID)
						{
							if (!WP_SaberBladeUseSecondBladeStyle(&attacker->client->ps.saber[saber_num], blade_num)
								&& attacker->client->ps.saber[saber_num].hitOtherEffect)
							{
								hit_effect = attacker->client->ps.saber[saber_num].hitOtherEffect;
							}
							else if (WP_SaberBladeUseSecondBladeStyle(&attacker->client->ps.saber[saber_num], blade_num)
								&& attacker->client->ps.saber[saber_num].hitOtherEffect2)
							{
								hit_effect = attacker->client->ps.saber[saber_num].hitOtherEffect2;
							}
							else
							{
								if (g_SerenityJediEngineMode->integer)
								{
									if (g_SerenityJediEngineMode->integer == 2)
									{
										hit_effect = G_EffectIndex(hit_saber_cut_AMD);
									}
									else
									{
										hit_effect = G_EffectIndex(hit_saber_cut_MD);
									}
								}
								else
								{
									hit_effect = G_EffectIndex(hit_saber_cut);
								}
							}
						}
					}
					else
					{
						if (dmg)
						{
							//only do these effects if actually trying to damage the thing...
							if (hit_ent->svFlags & SVF_BBRUSH //a breakable brush
								&& (hit_ent->spawnflags & 1 //INVINCIBLE
									|| hit_ent->flags & FL_DMG_BY_HEAVY_WEAP_ONLY //HEAVY weapon damage only
									|| hit_ent->NPC_targetname && attacker && attacker->targetname && Q_stricmp(
										attacker->targetname, hit_ent->NPC_targetname)))
								//only breakable by an entity who is not the attacker
							{
								//no hit effect (besides regular client-side one)
							}
							else
							{
								if (attacker->client->ps.saber[saber_num].hitOtherEffect
									&& !WP_SaberBladeUseSecondBladeStyle(
										&attacker->client->ps.saber[saber_num], blade_num))
								{
									hit_effect = attacker->client->ps.saber[saber_num].hitOtherEffect;
								}
								else if (WP_SaberBladeUseSecondBladeStyle(
									&attacker->client->ps.saber[saber_num], blade_num)
									&& attacker->client->ps.saber[saber_num].hitOtherEffect2)
								{
									hit_effect = attacker->client->ps.saber[saber_num].hitOtherEffect2;
								}
								else
								{
									if (g_SerenityJediEngineMode->integer)
									{
										if (g_SerenityJediEngineMode->integer == 2)
										{
											hit_effect = G_EffectIndex(hit_saber_cut_AMD);
										}
										else
										{
											hit_effect = G_EffectIndex(hit_saber_cut_MD);
										}
									}
									else
									{
										hit_effect = G_EffectIndex(hit_saber_cut);
									}
								}
							}
						}
					}
				}

				if (!g_saberNoEffects && hit_effect != 0)
				{
					G_PlayEffect(hit_effect, tr.endpos, dir);
				}
			}
			else
			{
				//we were doing a ghoul trace
				if (!attacker
					|| !attacker->client
					|| attacker->client->ps.saberLockTime < level.time)
				{
					if (!WP_SaberDamageEffects(&tr, len, dmg, dir, blade_vec, attacker->client->enemyTeam, saber_type,
						&attacker->client->ps.saber[saber_num], blade_num))
					{
						//didn't hit a ghoul ent
					}
				}
			}
		}
	}

	return qfalse;
}

constexpr auto LOCK_IDEAL_DIST_TOP = 32.0f;
constexpr auto LOCK_IDEAL_DIST_CIRCLE = 48.0f;
constexpr auto LOCK_IDEAL_DIST_JKA = 46.0f;
//all of the new saberlocks are 46.08 from each other because Richard is da MAN;
extern void PM_SetAnimFrame(gentity_t* gent, int frame, qboolean torso, qboolean legs);
extern qboolean ValidAnimFileIndex(int index);

int G_SaberLockAnim(const int attacker_saber_style, const int defender_saber_style, const int top_or_side,
	const int lock_or_break_or_super_break,
	const int win_or_lose)
{
	int base_anim = -1;
	if (lock_or_break_or_super_break == SABERLOCK_LOCK)
	{
		//special case: if we're using the same style and locking
		if (attacker_saber_style == defender_saber_style
			|| attacker_saber_style >= SS_FAST && attacker_saber_style <= SS_TAVION && defender_saber_style >= SS_FAST
			&&
			defender_saber_style <= SS_TAVION)
		{
			//using same style
			if (win_or_lose == SABERLOCK_LOSE)
			{
				//you want the defender's stance...
				switch (defender_saber_style)
				{
				case SS_DUAL:
					if (top_or_side == SABERLOCK_TOP)
					{
						base_anim = BOTH_LK_DL_DL_T_L_2;
					}
					else
					{
						base_anim = BOTH_LK_DL_DL_S_L_2;
					}
					break;
				case SS_STAFF:
					if (top_or_side == SABERLOCK_TOP)
					{
						base_anim = BOTH_LK_ST_ST_T_L_2;
					}
					else
					{
						base_anim = BOTH_LK_ST_ST_S_L_2;
					}
					break;
				default:
					if (top_or_side == SABERLOCK_TOP)
					{
						base_anim = BOTH_LK_S_S_T_L_2;
					}
					else
					{
						base_anim = BOTH_LK_S_S_S_L_2;
					}
					break;
				}
			}
		}
	}
	if (base_anim == -1)
	{
		switch (attacker_saber_style)
		{
		case SS_DUAL:
			switch (defender_saber_style)
			{
			case SS_DUAL:
				base_anim = BOTH_LK_DL_DL_S_B_1_L;
				break;
			case SS_STAFF:
				base_anim = BOTH_LK_DL_ST_S_B_1_L;
				break;
			default: //single
				base_anim = BOTH_LK_DL_S_S_B_1_L;
				break;
			}
			break;
		case SS_STAFF:
			switch (defender_saber_style)
			{
			case SS_DUAL:
				base_anim = BOTH_LK_ST_DL_S_B_1_L;
				break;
			case SS_STAFF:
				base_anim = BOTH_LK_ST_ST_S_B_1_L;
				break;
			default: //single
				base_anim = BOTH_LK_ST_S_S_B_1_L;
				break;
			}
			break;
		default: //single
			switch (defender_saber_style)
			{
			case SS_DUAL:
				base_anim = BOTH_LK_S_DL_S_B_1_L;
				break;
			case SS_STAFF:
				base_anim = BOTH_LK_S_ST_S_B_1_L;
				break;
			default: //single
				base_anim = BOTH_LK_S_S_S_B_1_L;
				break;
			}
			break;
		}
		//side lock or top lock?
		if (top_or_side == SABERLOCK_TOP)
		{
			base_anim += 5;
		}
		//lock, break or superbreak?
		if (lock_or_break_or_super_break == SABERLOCK_LOCK)
		{
			base_anim += 2;
		}
		else
		{
			//a break or superbreak
			if (lock_or_break_or_super_break == SABERLOCK_SUPERBREAK)
			{
				base_anim += 3;
			}
			//winner or loser?
			if (win_or_lose == SABERLOCK_WIN)
			{
				base_anim += 1;
			}
		}
	}
	return base_anim;
}

qboolean G_CheckIncrementLockAnim(int anim, const int win_or_lose)
{
	qboolean increment = qfalse; //???
	//RULE: if you are the first style in the lock anim, you advance from LOSING position to WINNING position
	//		if you are the second style in the lock anim, you advance from WINNING position to LOSING position
	switch (anim)
	{
		//increment to win:
	case BOTH_LK_DL_DL_S_L_1: //lock if I'm using dual vs. dual and I initiated
	case BOTH_LK_DL_DL_S_L_2: //lock if I'm using dual vs. dual and other initiated
	case BOTH_LK_DL_DL_T_L_1: //lock if I'm using dual vs. dual and I initiated
	case BOTH_LK_DL_DL_T_L_2: //lock if I'm using dual vs. dual and other initiated
	case BOTH_LK_DL_S_S_L_1: //lock if I'm using dual vs. a single
	case BOTH_LK_DL_S_T_L_1: //lock if I'm using dual vs. a single
	case BOTH_LK_DL_ST_S_L_1: //lock if I'm using dual vs. a staff
	case BOTH_LK_DL_ST_T_L_1: //lock if I'm using dual vs. a staff
	case BOTH_LK_S_S_S_L_1: //lock if I'm using single vs. a single and I initiated
	case BOTH_LK_S_S_T_L_2: //lock if I'm using single vs. a single and other initiated
	case BOTH_LK_ST_S_S_L_1: //lock if I'm using staff vs. a single
	case BOTH_LK_ST_S_T_L_1: //lock if I'm using staff vs. a single
	case BOTH_LK_ST_ST_T_L_1: //lock if I'm using staff vs. a staff and I initiated
	case BOTH_LK_ST_ST_T_L_2: //lock if I'm using staff vs. a staff and other initiated
		if (win_or_lose == SABERLOCK_WIN)
		{
			increment = qtrue;
		}
		else
		{
			increment = qfalse;
		}
		break;

		//decrement to win:
	case BOTH_LK_S_DL_S_L_1: //lock if I'm using single vs. a dual
	case BOTH_LK_S_DL_T_L_1: //lock if I'm using single vs. a dual
	case BOTH_LK_S_S_S_L_2: //lock if I'm using single vs. a single and other initiated
	case BOTH_LK_S_S_T_L_1: //lock if I'm using single vs. a single and I initiated
	case BOTH_LK_S_ST_S_L_1: //lock if I'm using single vs. a staff
	case BOTH_LK_S_ST_T_L_1: //lock if I'm using single vs. a staff
	case BOTH_LK_ST_DL_S_L_1: //lock if I'm using staff vs. dual
	case BOTH_LK_ST_DL_T_L_1: //lock if I'm using staff vs. dual
	case BOTH_LK_ST_ST_S_L_1: //lock if I'm using staff vs. a staff and I initiated
	case BOTH_LK_ST_ST_S_L_2: //lock if I'm using staff vs. a staff and other initiated
		if (win_or_lose == SABERLOCK_WIN)
		{
			increment = qfalse;
		}
		else
		{
			increment = qtrue;
		}
		break;
	default:
#ifndef FINAL_BUILD
		Com_Printf(S_COLOR_RED"ERROR: unknown Saber Lock Anim: %s!!!\n", anim_table[anim].name);
#endif
		break;
	}
	return increment;
}

qboolean WP_SabersCheckLock2(gentity_t* attacker, gentity_t* defender, sabersLockMode_t lock_mode)
{
	animation_t* anim;
	int att_anim, def_anim, advance = 0;
	float att_start = 0.5f, defStart = 0.5f;
	float ideal_dist = 48.0f;
	//FIXME: this distances need to be modified by the lengths of the sabers involved...
	//MATCH ANIMS

	if (lock_mode == LOCK_KYLE_GRAB1
		|| lock_mode == LOCK_KYLE_GRAB2
		|| lock_mode == LOCK_KYLE_GRAB3)
	{
		float numSpins = 1.0f;
		ideal_dist = 46.0f; //42.0f;
		att_start = defStart = 0.0f;

		switch (lock_mode)
		{
		default:
		case LOCK_KYLE_GRAB1:
			att_anim = BOTH_KYLE_PA_1;
			def_anim = BOTH_PLAYER_PA_1;
			numSpins = 2.0f;
			break;
		case LOCK_KYLE_GRAB2:
			att_anim = BOTH_KYLE_PA_3;
			def_anim = BOTH_PLAYER_PA_3;
			numSpins = 1.0f;
			break;
		case LOCK_KYLE_GRAB3:
			att_anim = BOTH_KYLE_PA_2;
			def_anim = BOTH_PLAYER_PA_2;
			defender->forcePushTime = level.time + PM_AnimLength(defender->client->clientInfo.animFileIndex,
				BOTH_PLAYER_PA_2);
			numSpins = 3.0f;
			break;
		}
		attacker->client->ps.SaberDeactivate();
		defender->client->ps.SaberDeactivate();
		if (d_slowmodeath->integer > 3
			&& (defender->s.number < MAX_CLIENTS
				|| attacker->s.number < MAX_CLIENTS))
		{
			if (ValidAnimFileIndex(attacker->client->clientInfo.animFileIndex))
			{
				int effect_time = PM_AnimLength(attacker->client->clientInfo.animFileIndex,
					static_cast<animNumber_t>(att_anim));
				int spin_time = floor(static_cast<float>(effect_time) / numSpins);
				int me_flags = MEF_MULTI_SPIN; //MEF_NO_TIMESCALE|MEF_NO_VERTBOB|
				if (Q_irand(0, 1))
				{
					me_flags |= MEF_REVERSE_SPIN;
				}
				G_StartMatrixEffect(attacker, me_flags, effect_time, 0.75f, spin_time);
			}
		}
	}
	else if (lock_mode == LOCK_FORCE_DRAIN)
	{
		ideal_dist = 46.0f; //42.0f;
		att_start = defStart = 0.0f;

		att_anim = BOTH_FORCE_DRAIN_GRAB_START;
		def_anim = BOTH_FORCE_DRAIN_GRABBED;
		attacker->client->ps.SaberDeactivate();
		defender->client->ps.SaberDeactivate();
	}
	else
	{
		const int index_start = Q_irand(1, 5);
		if (lock_mode == LOCK_RANDOM)
		{
			lock_mode = static_cast<sabersLockMode_t>(Q_irand(LOCK_FIRST, static_cast<int>(LOCK_RANDOM) - 1));
		}
		//FIXME: attStart% and idealDist will change per saber lock anim pairing... do we need a big table like in bg_panimate.cpp?
		if (attacker->client->ps.saber_anim_level >= SS_FAST
			&& attacker->client->ps.saber_anim_level <= SS_TAVION
			&& defender->client->ps.saber_anim_level >= SS_FAST
			&& defender->client->ps.saber_anim_level <= SS_TAVION)
		{
			//2 single sabers?  Just do it the old way...
			switch (lock_mode)
			{
			case LOCK_TOP:
				att_anim = BOTH_BF2LOCK; // - starts in middle
				def_anim = BOTH_BF1LOCK; // - starts in middle
				att_start = defStart = 0.5f;
				ideal_dist = LOCK_IDEAL_DIST_TOP;
				break;
			case LOCK_DIAG_TR:
				att_anim = BOTH_CCWCIRCLELOCK; //- starts in middle
				def_anim = BOTH_CWCIRCLELOCK; // - starts in middle
				att_start = defStart = 0.5f;
				ideal_dist = LOCK_IDEAL_DIST_CIRCLE;
				break;
			case LOCK_DIAG_TL:
				att_anim = BOTH_CWCIRCLELOCK; // - starts in middle
				def_anim = BOTH_CCWCIRCLELOCK; // - starts in middle
				att_start = defStart = 0.5f;
				ideal_dist = LOCK_IDEAL_DIST_CIRCLE;
				break;
			case LOCK_DIAG_BR:
				att_anim = BOTH_CWCIRCLELOCK; // - starts on left, to right
				def_anim = BOTH_CCWCIRCLELOCK; // - starts on right, to left
				att_start = defStart = 0.15f; //move to end of anim
				ideal_dist = LOCK_IDEAL_DIST_CIRCLE;
				break;
			case LOCK_DIAG_BL:
				att_anim = BOTH_CCWCIRCLELOCK; // - starts on right, to left
				def_anim = BOTH_CWCIRCLELOCK; // - starts on left, to right
				att_start = defStart = 0.15f; //move to end of anim
				ideal_dist = LOCK_IDEAL_DIST_CIRCLE;
				break;
			case LOCK_R:
				att_anim = BOTH_CWCIRCLELOCK; // - starts on left, to right
				def_anim = BOTH_CCWCIRCLELOCK; // - starts on right, to left
				att_start = defStart = 0.25f; //move to end of anim
				ideal_dist = LOCK_IDEAL_DIST_CIRCLE;
				break;
			case LOCK_L:
				att_anim = BOTH_CCWCIRCLELOCK; // - starts on right, to left
				def_anim = BOTH_CWCIRCLELOCK; // - starts on left, to right
				att_start = defStart = 0.25f; //move to end of anim
				ideal_dist = LOCK_IDEAL_DIST_CIRCLE;
				break;
			default:
				return qfalse;
			}
			G_Sound(attacker, G_SoundIndex(va("sound/weapons/saber/saber_locking_start%d.mp3", index_start)));
		}
		else
		{
			//use the new system
			ideal_dist = LOCK_IDEAL_DIST_JKA;
			//all of the new saberlocks are 46.08 from each other because Richard is da MAN
			if (lock_mode == LOCK_TOP)
			{
				//top lock
				att_anim = G_SaberLockAnim(attacker->client->ps.saber_anim_level, defender->client->ps.saber_anim_level,
					SABERLOCK_TOP, SABERLOCK_LOCK, SABERLOCK_WIN);
				def_anim = G_SaberLockAnim(defender->client->ps.saber_anim_level, attacker->client->ps.saber_anim_level,
					SABERLOCK_TOP, SABERLOCK_LOCK, SABERLOCK_LOSE);
				att_start = defStart = 0.5f;
			}
			else
			{
				//side lock
				switch (lock_mode)
				{
				case LOCK_DIAG_TR:
					att_anim = G_SaberLockAnim(attacker->client->ps.saber_anim_level, defender->client->ps.saber_anim_level,
						SABERLOCK_SIDE, SABERLOCK_LOCK, SABERLOCK_WIN);
					def_anim = G_SaberLockAnim(defender->client->ps.saber_anim_level, attacker->client->ps.saber_anim_level,
						SABERLOCK_SIDE, SABERLOCK_LOCK, SABERLOCK_LOSE);
					att_start = defStart = 0.5f;
					break;
				case LOCK_DIAG_TL:
					att_anim = G_SaberLockAnim(attacker->client->ps.saber_anim_level, defender->client->ps.saber_anim_level,
						SABERLOCK_SIDE, SABERLOCK_LOCK, SABERLOCK_LOSE);
					def_anim = G_SaberLockAnim(defender->client->ps.saber_anim_level, attacker->client->ps.saber_anim_level,
						SABERLOCK_SIDE, SABERLOCK_LOCK, SABERLOCK_WIN);
					att_start = defStart = 0.5f;
					break;
				case LOCK_DIAG_BR:
					att_anim = G_SaberLockAnim(attacker->client->ps.saber_anim_level, defender->client->ps.saber_anim_level,
						SABERLOCK_SIDE, SABERLOCK_LOCK, SABERLOCK_WIN);
					def_anim = G_SaberLockAnim(defender->client->ps.saber_anim_level, attacker->client->ps.saber_anim_level,
						SABERLOCK_SIDE, SABERLOCK_LOCK, SABERLOCK_LOSE);
					if (G_CheckIncrementLockAnim(att_anim, SABERLOCK_WIN))
					{
						att_start = 0.85f; //move to end of anim
					}
					else
					{
						att_start = 0.15f; //start at beginning of anim
					}
					if (G_CheckIncrementLockAnim(def_anim, SABERLOCK_LOSE))
					{
						defStart = 0.85f; //start at end of anim
					}
					else
					{
						defStart = 0.15f; //start at beginning of anim
					}
					break;
				case LOCK_DIAG_BL:
					att_anim = G_SaberLockAnim(attacker->client->ps.saber_anim_level, defender->client->ps.saber_anim_level,
						SABERLOCK_SIDE, SABERLOCK_LOCK, SABERLOCK_LOSE);
					def_anim = G_SaberLockAnim(defender->client->ps.saber_anim_level, attacker->client->ps.saber_anim_level,
						SABERLOCK_SIDE, SABERLOCK_LOCK, SABERLOCK_WIN);
					if (G_CheckIncrementLockAnim(att_anim, SABERLOCK_WIN))
					{
						att_start = 0.85f; //move to end of anim
					}
					else
					{
						att_start = 0.15f; //start at beginning of anim
					}
					if (G_CheckIncrementLockAnim(def_anim, SABERLOCK_LOSE))
					{
						defStart = 0.85f; //start at end of anim
					}
					else
					{
						defStart = 0.15f; //start at beginning of anim
					}
					break;
				case LOCK_R:
					att_anim = G_SaberLockAnim(attacker->client->ps.saber_anim_level, defender->client->ps.saber_anim_level,
						SABERLOCK_SIDE, SABERLOCK_LOCK, SABERLOCK_LOSE);
					def_anim = G_SaberLockAnim(defender->client->ps.saber_anim_level, attacker->client->ps.saber_anim_level,
						SABERLOCK_SIDE, SABERLOCK_LOCK, SABERLOCK_WIN);
					if (G_CheckIncrementLockAnim(att_anim, SABERLOCK_WIN))
					{
						att_start = 0.75f; //move to end of anim
					}
					else
					{
						att_start = 0.25f; //start at beginning of anim
					}
					if (G_CheckIncrementLockAnim(def_anim, SABERLOCK_LOSE))
					{
						defStart = 0.75f; //start at end of anim
					}
					else
					{
						defStart = 0.25f; //start at beginning of anim
					}
					break;
				case LOCK_L:
					att_anim = G_SaberLockAnim(attacker->client->ps.saber_anim_level, defender->client->ps.saber_anim_level,
						SABERLOCK_SIDE, SABERLOCK_LOCK, SABERLOCK_WIN);
					def_anim = G_SaberLockAnim(defender->client->ps.saber_anim_level, attacker->client->ps.saber_anim_level,
						SABERLOCK_SIDE, SABERLOCK_LOCK, SABERLOCK_LOSE);
					//attacker starts with advantage
					if (G_CheckIncrementLockAnim(att_anim, SABERLOCK_WIN))
					{
						att_start = 0.75f; //move to end of anim
					}
					else
					{
						att_start = 0.25f; //start at beginning of anim
					}
					if (G_CheckIncrementLockAnim(def_anim, SABERLOCK_LOSE))
					{
						defStart = 0.75f; //start at end of anim
					}
					else
					{
						defStart = 0.25f; //start at beginning of anim
					}
					break;
				default:
					return qfalse;
				}
			}
			G_Sound(attacker, G_SoundIndex(va("sound/weapons/saber/saber_locking_start%d.mp3", index_start)));
		}
	}
	//set the proper anims
	NPC_SetAnim(attacker, SETANIM_BOTH, att_anim, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
	NPC_SetAnim(defender, SETANIM_BOTH, def_anim, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
	//don't let them store a kick for the whole saberlock....
	attacker->client->ps.saberMoveNext = defender->client->ps.saberMoveNext = LS_NONE;
	//
	if (att_start > 0.0f)
	{
		if (ValidAnimFileIndex(attacker->client->clientInfo.animFileIndex))
		{
			anim = &level.knownAnimFileSets[attacker->client->clientInfo.animFileIndex].animations[att_anim];
			advance = floor(anim->numFrames * att_start);
			PM_SetAnimFrame(attacker, anim->firstFrame + advance, qtrue, qtrue);
#ifndef FINAL_BUILD
			if (d_saberCombat->integer)
			{
				Com_Printf("%s starting saber lock, anim = %s, %d frames to go!\n", attacker->NPC_type, anim_table[attAnim].name, anim->numFrames - advance);
			}
#endif
		}
	}
	if (defStart > 0.0f)
	{
		if (ValidAnimFileIndex(defender->client->clientInfo.animFileIndex))
		{
			anim = &level.knownAnimFileSets[defender->client->clientInfo.animFileIndex].animations[def_anim];
			advance = ceil(anim->numFrames * defStart);
			PM_SetAnimFrame(defender, anim->firstFrame + advance, qtrue, qtrue);
			//was anim->firstFrame + anim->numFrames - advance, but that's wrong since they are matched anims
#ifndef FINAL_BUILD
			if (d_saberCombat->integer)
			{
				Com_Printf("%s starting saber lock, anim = %s, %d frames to go!\n", defender->NPC_type, anim_table[defAnim].name, advance);
			}
#endif
		}
	}
	VectorClear(attacker->client->ps.velocity);
	VectorClear(attacker->client->ps.moveDir);
	VectorClear(defender->client->ps.velocity);
	VectorClear(defender->client->ps.moveDir);

	if (lock_mode == LOCK_KYLE_GRAB1
		|| lock_mode == LOCK_KYLE_GRAB2
		|| lock_mode == LOCK_KYLE_GRAB3
		|| lock_mode == LOCK_FORCE_DRAIN)
	{
		//not a real lock, just freeze them both in place
		//can't move or attack
		attacker->client->ps.pm_time = attacker->client->ps.weaponTime = attacker->client->ps.legsAnimTimer;
		attacker->client->ps.pm_flags |= PMF_TIME_KNOCKBACK;
		attacker->painDebounceTime = level.time + attacker->client->ps.pm_time;
		if (lock_mode != LOCK_FORCE_DRAIN)
		{
			defender->client->ps.torsoAnimTimer += 200;
			defender->client->ps.legsAnimTimer += 200;
		}
		defender->client->ps.pm_time = defender->client->ps.weaponTime = defender->client->ps.legsAnimTimer;
		defender->client->ps.pm_flags |= PMF_TIME_KNOCKBACK;
		if (lock_mode != LOCK_FORCE_DRAIN)
		{
			attacker->aimDebounceTime = level.time + attacker->client->ps.pm_time;
		}
	}
	else
	{
		attacker->client->ps.saberLockTime = defender->client->ps.saberLockTime = level.time + SABER_LOCK_TIME;
		attacker->client->ps.legsAnimTimer = attacker->client->ps.torsoAnimTimer = defender->client->ps.legsAnimTimer =
			defender->client->ps.torsoAnimTimer = SABER_LOCK_TIME;
		attacker->client->ps.saberLockEnemy = defender->s.number;
		defender->client->ps.saberLockEnemy = attacker->s.number;
	}

	//MATCH ANGLES
	if (lock_mode == LOCK_KYLE_GRAB1
		|| lock_mode == LOCK_KYLE_GRAB2
		|| lock_mode == LOCK_KYLE_GRAB3)
	{
		//not a real lock, just set pitch to 0
		attacker->client->ps.viewangles[PITCH] = defender->client->ps.viewangles[PITCH] = 0;
	}
	else
	{
		//FIXME: if zDiff in elevation, make lower look up and upper look down and move them closer?
		float def_pitch_add = 0, zDiff = attacker->currentOrigin[2] + attacker->client->standheight - (defender->
			currentOrigin[2] + defender->client->standheight);
		if (zDiff > 24)
		{
			def_pitch_add = -30;
		}
		else if (zDiff < -24)
		{
			def_pitch_add = 30;
		}
		else
		{
			def_pitch_add = zDiff / 24.0f * -30.0f;
		}
		if (attacker->NPC && defender->NPC)
		{
			//if 2 NPCs, just set pitch to 0
			attacker->client->ps.viewangles[PITCH] = -def_pitch_add;
			defender->client->ps.viewangles[PITCH] = def_pitch_add;
		}
		else
		{
			//if a player is involved, clamp player's pitch and match NPC's to player
			if (!attacker->s.number)
			{
				//clamp to defPitch
				if (attacker->client->ps.viewangles[PITCH] > -def_pitch_add + 10)
				{
					attacker->client->ps.viewangles[PITCH] = -def_pitch_add + 10;
				}
				else if (attacker->client->ps.viewangles[PITCH] < -def_pitch_add - 10)
				{
					attacker->client->ps.viewangles[PITCH] = -def_pitch_add - 10;
				}
				//clamp to sane numbers
				if (attacker->client->ps.viewangles[PITCH] > 50)
				{
					attacker->client->ps.viewangles[PITCH] = 50;
				}
				else if (attacker->client->ps.viewangles[PITCH] < -50)
				{
					attacker->client->ps.viewangles[PITCH] = -50;
				}
				defender->client->ps.viewangles[PITCH] = attacker->client->ps.viewangles[PITCH] * -1;
				def_pitch_add = defender->client->ps.viewangles[PITCH];
			}
			else if (!defender->s.number)
			{
				//clamp to defPitch
				if (defender->client->ps.viewangles[PITCH] > def_pitch_add + 10)
				{
					defender->client->ps.viewangles[PITCH] = def_pitch_add + 10;
				}
				else if (defender->client->ps.viewangles[PITCH] < def_pitch_add - 10)
				{
					defender->client->ps.viewangles[PITCH] = def_pitch_add - 10;
				}
				//clamp to sane numbers
				if (defender->client->ps.viewangles[PITCH] > 50)
				{
					defender->client->ps.viewangles[PITCH] = 50;
				}
				else if (defender->client->ps.viewangles[PITCH] < -50)
				{
					defender->client->ps.viewangles[PITCH] = -50;
				}
				def_pitch_add = defender->client->ps.viewangles[PITCH];
				attacker->client->ps.viewangles[PITCH] = defender->client->ps.viewangles[PITCH] * -1;
			}
		}
	}
	vec3_t att_angles, def_angles{}, def_dir;
	VectorSubtract(defender->currentOrigin, attacker->currentOrigin, def_dir);
	VectorCopy(attacker->client->ps.viewangles, att_angles);
	att_angles[YAW] = vectoyaw(def_dir);
	SetClientViewAngle(attacker, att_angles);
	def_angles[PITCH] = att_angles[PITCH] * -1;
	def_angles[YAW] = AngleNormalize180(att_angles[YAW] + 180);
	def_angles[ROLL] = 0;
	SetClientViewAngle(defender, def_angles);

	//MATCH POSITIONS
	vec3_t new_org;
	float scale = (attacker->s.modelScale[0] + attacker->s.modelScale[1]) * 0.5f;
	if (scale && scale != 1.0f)
	{
		ideal_dist += 8 * (scale - 1.0f);
	}
	scale = (defender->s.modelScale[0] + defender->s.modelScale[1]) * 0.5f;
	if (scale && scale != 1.0f)
	{
		ideal_dist += 8 * (scale - 1.0f);
	}

	float diff = VectorNormalize(def_dir) - ideal_dist; //diff will be the total error in dist
	//try to move attacker half the diff towards the defender
	VectorMA(attacker->currentOrigin, diff * 0.5f, def_dir, new_org);
	trace_t trace;
	gi.trace(&trace, attacker->currentOrigin, attacker->mins, attacker->maxs, new_org, attacker->s.number,
		attacker->clipmask, static_cast<EG2_Collision>(0), 0);
	if (!trace.startsolid && !trace.allsolid)
	{
		G_SetOrigin(attacker, trace.endpos);
		gi.linkentity(attacker);
	}
	//now get the defender's dist and do it for him too
	vec3_t att_dir;
	VectorSubtract(attacker->currentOrigin, defender->currentOrigin, att_dir);
	diff = VectorNormalize(att_dir) - ideal_dist; //diff will be the total error in dist
	//try to move defender all of the remaining diff towards the attacker
	VectorMA(defender->currentOrigin, diff, att_dir, new_org);
	gi.trace(&trace, defender->currentOrigin, defender->mins, defender->maxs, new_org, defender->s.number,
		defender->clipmask, static_cast<EG2_Collision>(0), 0);
	if (!trace.startsolid && !trace.allsolid)
	{
		G_SetOrigin(defender, trace.endpos);
		gi.linkentity(defender);
	}

	//DONE!

	return qtrue;
}

qboolean WP_SabersCheckLock(gentity_t* ent1, gentity_t* ent2)
{
	int lock_quad;

	if (ent1->client->playerTeam == ent2->client->playerTeam)
	{
		return qfalse;
	}

	if (in_camera)
	{
		return qfalse;
	}

	if (ent1->client->NPC_class == CLASS_SABER_DROID
		|| ent2->client->NPC_class == CLASS_SABER_DROID)
	{
		//they don't have saberlock anims
		return qfalse;
	}
	if (ent1->client->ps.groundEntityNum == ENTITYNUM_NONE ||
		ent2->client->ps.groundEntityNum == ENTITYNUM_NONE)
	{
		return qfalse;
	}
	if (ent1->client->ps.saber[0].saberFlags & SFL_NOT_LOCKABLE
		|| ent2->client->ps.saber[0].saberFlags & SFL_NOT_LOCKABLE)
	{
		//one of these sabers cannot lock (like a lance)
		return qfalse;
	}
	if (ent1->client->ps.dualSabers
		&& ent1->client->ps.saber[1].Active()
		&& ent1->client->ps.saber[1].saberFlags & SFL_NOT_LOCKABLE)
	{
		//one of these sabers cannot lock (like a lance)
		return qfalse;
	}
	if (ent2->client->ps.dualSabers
		&& ent2->client->ps.saber[1].Active()
		&& ent2->client->ps.saber[1].saberFlags & SFL_NOT_LOCKABLE)
	{
		//one of these sabers cannot lock (like a lance)
		return qfalse;
	}
	if (ent1->painDebounceTime > level.time - 1000 || ent2->painDebounceTime > level.time - 1000)
	{
		//can't saberlock if you're not ready
		return qfalse;
	}
	if (fabs(ent1->currentOrigin[2] - ent2->currentOrigin[2]) > 18)
	{
		return qfalse;
	}
	const float dist = DistanceSquared(ent1->currentOrigin, ent2->currentOrigin);
	if (dist < 64 || dist > 6400) //( dist < 128 || dist > 2304 )
	{
		//between 8 and 80 from each other//was 16 and 48
		return qfalse;
	}
	if (!InFOV(ent1, ent2, 40, 180) || !InFOV(ent2, ent1, 40, 180))
	{
		return qfalse;
	}
	//Check for certain anims that *cannot* lock
	if (ent1->client->ps.torsoAnim == BOTH_A2_STABBACK1 && ent1->client->ps.torsoAnimTimer > 300)
	{
		//can't lock when saber is behind you
		return qfalse;
	}
	if (ent2->client->ps.torsoAnim == BOTH_A2_STABBACK1 && ent2->client->ps.torsoAnimTimer > 300)
	{
		//can't lock when saber is behind you
		return qfalse;
	}
	if (PM_LockedAnim(ent1->client->ps.torsoAnim)
		|| PM_LockedAnim(ent2->client->ps.torsoAnim))
	{
		//stuck doing something else
		return qfalse;
	}
	if (PM_SaberLockBreakAnim(ent1->client->ps.torsoAnim)
		|| PM_SaberLockBreakAnim(ent2->client->ps.torsoAnim))
	{
		//still finishing the last lock break!
		return qfalse;
	}
	if (PM_InSlowBounce(&ent1->client->ps) || PM_InSlowBounce(&ent2->client->ps))
	{
		return qfalse;
	}

	if (PM_SaberInParry(ent1->client->ps.saber_move))
	{
		//use the endquad of the move
		lock_quad = saber_moveData[ent1->client->ps.saber_move].endQuad;
	}
	else
	{
		//use the startquad of the move
		lock_quad = saber_moveData[ent1->client->ps.saber_move].startQuad;
	}

	switch (lock_quad)
	{
	case Q_BR:
		return WP_SabersCheckLock2(ent1, ent2, LOCK_DIAG_BR);
	case Q_R:
		return WP_SabersCheckLock2(ent1, ent2, LOCK_R);
	case Q_TR:
		return WP_SabersCheckLock2(ent1, ent2, LOCK_DIAG_TR);
	case Q_T:
		return WP_SabersCheckLock2(ent1, ent2, LOCK_TOP);
	case Q_TL:
		return WP_SabersCheckLock2(ent1, ent2, LOCK_DIAG_TL);
	case Q_L:
		return WP_SabersCheckLock2(ent1, ent2, LOCK_L);
	case Q_BL:
		return WP_SabersCheckLock2(ent1, ent2, LOCK_DIAG_BL);
	case Q_B:
		return WP_SabersCheckLock2(ent1, ent2, LOCK_TOP);
	default:
		//this shouldn't happen.  just wing it
		return qfalse;
	}
}

qboolean WP_SaberParry(gentity_t* victim, gentity_t* attacker, const int saber_num, const int blade_num)
{
	const qboolean npc_blocking = victim->client->ps.ManualBlockingFlags & 1 << MBF_NPCBLOCKING ? qtrue : qfalse;
	const qboolean blocking = victim->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCK ? qtrue : qfalse;
	//Normal Blocking
	const qboolean m_blocking = victim->client->ps.ManualBlockingFlags & 1 << PERFECTBLOCKING ? qtrue : qfalse;
	//perfect Blocking
	const qboolean active_blocking = victim->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCKANDATTACK ? qtrue : qfalse;
	//Active Blocking

	if (!victim || !victim->client || !attacker)
	{
		return qfalse;
	}
	if (rosh_being_healed(victim))
	{
		return qfalse;
	}
	if (G_InCinematicSaberAnim(victim))
	{
		return qfalse;
	}
	if (PM_SuperBreakLoseAnim(victim->client->ps.torsoAnim)
		|| PM_SuperBreakWinAnim(victim->client->ps.torsoAnim)
		|| PM_InKnockDown(&victim->client->ps))
	{
		return qfalse;
	}

	if (victim->s.number
		|| (g_saberAutoBlocking->integer || npc_blocking) && victim->NPC && !G_ControlledByPlayer(victim) //all npc,s
		|| g_saberAutoBlocking->integer && g_SerenityJediEngineMode->integer < 1 // jka mode players
		|| g_SerenityJediEngineMode->integer > 0 && (blocking || m_blocking || active_blocking)
		//AMD / MD Mode blocking flag is on
		|| victim->client->ps.saberBlockingTime > level.time) // All modes already blocking
	{
		//either an NPC or a player who is blocking
		if (!PM_SaberInTransitionAny(victim->client->ps.saber_move)
			&& !PM_SaberInBounce(victim->client->ps.saber_move)
			&& !PM_SaberInKnockaway(victim->client->ps.saber_move)
			&& !BG_InKnockDown(victim->client->ps.legsAnim)
			&& !BG_InKnockDown(victim->client->ps.torsoAnim)
			&& !PM_InKnockDown(&victim->client->ps))
		{
			//I'm not attacking, in transition or in a bounce or knockaway, so play a parry
			if (g_SerenityJediEngineMode->integer)
			{
				WP_SaberBlockNonRandom_MD(victim, saberHitLocation, qfalse);
			}
			else
			{
				WP_SaberBlockNonRandom(victim, saberHitLocation, qfalse);
			}
		}
		victim->client->ps.saberEventFlags |= SEF_PARRIED;

		//since it was parried, take away any damage done
		wp_saber_clear_damage_for_ent_num(attacker, victim->s.number, saber_num, blade_num);

		//tell the victim to get mad at me
		if (victim->enemy != attacker && victim->client->playerTeam != attacker->client->playerTeam)
		{
			//they're not mad at me and they're not on my team
			G_ClearEnemy(victim);
			G_SetEnemy(victim, attacker);
		}
		return qtrue;
	}
	return qfalse;
}

qboolean WP_SaberBlockedBounceBlock(gentity_t* victim, gentity_t* attacker, const int saber_num, const int blade_num,
	vec3_t hit_loc)
{
	const qboolean npc_blocking = victim->client->ps.ManualBlockingFlags & 1 << MBF_NPCBLOCKING ? qtrue : qfalse;
	const qboolean blocking = victim->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCK ? qtrue : qfalse;
	//Normal Blocking
	const qboolean m_blocking = victim->client->ps.ManualBlockingFlags & 1 << PERFECTBLOCKING ? qtrue : qfalse;
	//perfect Blocking
	const qboolean active_blocking = victim->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCKANDATTACK ? qtrue : qfalse;
	//Active Blocking

	if (!victim || !victim->client || !attacker)
	{
		return qfalse;
	}
	if (rosh_being_healed(victim))
	{
		return qfalse;
	}
	if (G_InCinematicSaberAnim(victim))
	{
		return qfalse;
	}
	if (PM_SuperBreakLoseAnim(victim->client->ps.torsoAnim)
		|| PM_SuperBreakWinAnim(victim->client->ps.torsoAnim)
		|| PM_InKnockDown(&victim->client->ps))
	{
		return qfalse;
	}

	if (victim->s.number
		|| (g_saberAutoBlocking->integer || npc_blocking) && victim->NPC && !G_ControlledByPlayer(victim) //all npc,s
		|| g_saberAutoBlocking->integer && g_SerenityJediEngineMode->integer < 1 // jka mode players
		|| g_SerenityJediEngineMode->integer > 0 && (blocking || m_blocking || active_blocking)
		//AMD / MD Mode blocking flag is on
		|| victim->client->ps.saberBlockingTime > level.time) // All modes already blocking
	{
		//either an NPC or a player who is blocking
		if (!PM_SaberInTransitionAny(victim->client->ps.saber_move)
			&& !PM_SaberInBounce(victim->client->ps.saber_move)
			&& !PM_SaberInKnockaway(victim->client->ps.saber_move)
			&& !BG_InKnockDown(victim->client->ps.legsAnim)
			&& !BG_InKnockDown(victim->client->ps.torsoAnim)
			&& !PM_InKnockDown(&victim->client->ps))
		{
			//I'm not attacking, in transition or in a bounce or knockaway, so play a parry
			WP_SaberBlockBolt_MD(victim, hit_loc, qfalse);
		}

		victim->client->ps.saberEventFlags |= SEF_PARRIED;

		//since it was parried, take away any damage done
		wp_saber_clear_damage_for_ent_num(attacker, victim->s.number, saber_num, blade_num);

		//tell the victim to get mad at me
		if (victim->enemy != attacker && victim->client->playerTeam != attacker->client->playerTeam)
		{
			//they're not mad at me and they're not on my team
			G_ClearEnemy(victim);
			G_SetEnemy(victim, attacker);
		}
		return qtrue;
	}
	return qfalse;
}

qboolean WP_SaberNPCParry(gentity_t* victim, gentity_t* attacker, const int saber_num, const int blade_num,
	vec3_t hit_loc)
{
	const qboolean npc_blocking = victim->client->ps.ManualBlockingFlags & 1 << MBF_NPCBLOCKING ? qtrue : qfalse;
	const qboolean blocking = victim->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCK ? qtrue : qfalse;
	//Normal Blocking
	const qboolean m_blocking = victim->client->ps.ManualBlockingFlags & 1 << PERFECTBLOCKING ? qtrue : qfalse;
	//perfect Blocking
	const qboolean active_blocking = victim->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCKANDATTACK ? qtrue : qfalse;
	//Active Blocking

	if (!victim || !victim->client || !attacker)
	{
		return qfalse;
	}
	if (rosh_being_healed(victim))
	{
		return qfalse;
	}
	if (G_InCinematicSaberAnim(victim))
	{
		return qfalse;
	}
	if (PM_SuperBreakLoseAnim(victim->client->ps.torsoAnim)
		|| PM_SuperBreakWinAnim(victim->client->ps.torsoAnim)
		|| PM_InKnockDown(&victim->client->ps))
	{
		return qfalse;
	}

	if (victim->s.number
		|| (g_saberAutoBlocking->integer || npc_blocking) && victim->NPC && !G_ControlledByPlayer(victim) //all npc,s
		|| g_saberAutoBlocking->integer && g_SerenityJediEngineMode->integer < 1 // jka mode players
		|| g_SerenityJediEngineMode->integer > 0 && (blocking || m_blocking || active_blocking)
		//AMD / MD Mode blocking flag is on
		|| victim->client->ps.saberBlockingTime > level.time) // All modes already blocking
	{
		//either an NPC or a player who is blocking
		if (!PM_SaberInTransitionAny(victim->client->ps.saber_move)
			&& !PM_SaberInBounce(victim->client->ps.saber_move)
			&& !PM_SaberInKnockaway(victim->client->ps.saber_move)
			&& !BG_InKnockDown(victim->client->ps.legsAnim)
			&& !BG_InKnockDown(victim->client->ps.torsoAnim)
			&& !PM_InKnockDown(&victim->client->ps))
		{
			//I'm not attacking, in transition or in a bounce or knockaway, so play a parry
			WP_SaberBlockNonRandom_MD(victim, hit_loc, qfalse);
		}

		victim->client->ps.saberEventFlags |= SEF_PARRIED;

		//since it was parried, take away any damage done
		wp_saber_clear_damage_for_ent_num(attacker, victim->s.number, saber_num, blade_num);

		//tell the victim to get mad at me
		if (victim->enemy != attacker && victim->client->playerTeam != attacker->client->playerTeam)
		{
			//they're not mad at me and they're not on my team
			G_ClearEnemy(victim);
			G_SetEnemy(victim, attacker);
		}
		return qtrue;
	}
	return qfalse;
}

qboolean WP_SaberMBlock(gentity_t* victim, gentity_t* attacker, const int saber_num, const int blade_num,
	vec3_t hit_loc)
{
	const qboolean npc_blocking = victim->client->ps.ManualBlockingFlags & 1 << MBF_NPCBLOCKING ? qtrue : qfalse;
	const qboolean blocking = victim->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCK ? qtrue : qfalse;
	//Normal Blocking
	const qboolean m_blocking = victim->client->ps.ManualBlockingFlags & 1 << PERFECTBLOCKING ? qtrue : qfalse;
	//perfect Blocking
	const qboolean active_blocking = victim->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCKANDATTACK ? qtrue : qfalse;
	//Active Blocking

	if (!victim || !victim->client || !attacker)
	{
		return qfalse;
	}
	if (rosh_being_healed(victim))
	{
		return qfalse;
	}
	if (G_InCinematicSaberAnim(victim))
	{
		return qfalse;
	}
	if (PM_SuperBreakLoseAnim(victim->client->ps.torsoAnim)
		|| PM_SuperBreakWinAnim(victim->client->ps.torsoAnim)
		|| PM_InKnockDown(&victim->client->ps))
	{
		return qfalse;
	}

	if (victim->s.number
		|| (g_saberAutoBlocking->integer || npc_blocking) && victim->NPC && !G_ControlledByPlayer(victim) //all npc,s
		|| g_saberAutoBlocking->integer && g_SerenityJediEngineMode->integer < 1 // jka mode players
		|| g_SerenityJediEngineMode->integer > 0 && (blocking || m_blocking || active_blocking)
		//AMD / MD Mode blocking flag is on
		|| victim->client->ps.saberBlockingTime > level.time) // All modes already blocking
	{
		//either an NPC or a player who is blocking
		if (!PM_SaberInTransitionAny(victim->client->ps.saber_move)
			&& !PM_SaberInBounce(victim->client->ps.saber_move)
			&& !PM_SaberInKnockaway(victim->client->ps.saber_move)
			&& !BG_InKnockDown(victim->client->ps.legsAnim)
			&& !BG_InKnockDown(victim->client->ps.torsoAnim)
			&& !PM_InKnockDown(&victim->client->ps))
		{
			//I'm not attacking, in transition or in a bounce or knockaway, so play a parry
			WP_SaberMBlockDirection(victim, hit_loc, qfalse);
		}

		victim->client->ps.saberEventFlags |= SEF_PARRIED;

		//since it was parried, take away any damage done
		wp_saber_clear_damage_for_ent_num(attacker, victim->s.number, saber_num, blade_num);

		//tell the victim to get mad at me
		if (victim->enemy != attacker && victim->client->playerTeam != attacker->client->playerTeam)
		{
			//they're not mad at me and they're not on my team
			G_ClearEnemy(victim);
			G_SetEnemy(victim, attacker);
		}
		return qtrue;
	}
	return qfalse;
}

qboolean WP_SaberNPCMBlock(gentity_t* victim, gentity_t* attacker, const int saber_num, const int blade_num,
	vec3_t hit_loc)
{
	const qboolean npc_blocking = victim->client->ps.ManualBlockingFlags & 1 << MBF_NPCBLOCKING ? qtrue : qfalse;
	const qboolean blocking = victim->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCK ? qtrue : qfalse;
	//Normal Blocking
	const qboolean m_blocking = victim->client->ps.ManualBlockingFlags & 1 << PERFECTBLOCKING ? qtrue : qfalse;
	//perfect Blocking
	const qboolean active_blocking = victim->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCKANDATTACK ? qtrue : qfalse;
	//Active Blocking

	if (!victim || !victim->client || !attacker)
	{
		return qfalse;
	}
	if (rosh_being_healed(victim))
	{
		return qfalse;
	}
	if (G_InCinematicSaberAnim(victim))
	{
		return qfalse;
	}
	if (PM_SuperBreakLoseAnim(victim->client->ps.torsoAnim)
		|| PM_SuperBreakWinAnim(victim->client->ps.torsoAnim)
		|| PM_InKnockDown(&victim->client->ps))
	{
		return qfalse;
	}

	if (victim->s.number
		|| (g_saberAutoBlocking->integer || npc_blocking) && victim->NPC && !G_ControlledByPlayer(victim) //all npc,s
		|| g_saberAutoBlocking->integer && g_SerenityJediEngineMode->integer < 1 // jka mode players
		|| g_SerenityJediEngineMode->integer > 0 && (blocking || m_blocking || active_blocking)
		//AMD / MD Mode blocking flag is on
		|| victim->client->ps.saberBlockingTime > level.time) // All modes already blocking
	{
		//either an NPC or a player who is blocking
		if (!PM_SaberInTransitionAny(victim->client->ps.saber_move)
			&& !PM_SaberInBounce(victim->client->ps.saber_move)
			&& !PM_SaberInKnockaway(victim->client->ps.saber_move)
			&& !BG_InKnockDown(victim->client->ps.legsAnim)
			&& !BG_InKnockDown(victim->client->ps.torsoAnim)
			&& !PM_InKnockDown(&victim->client->ps))
		{
			//I'm not attacking, in transition or in a bounce or knockaway, so play a parry
			WP_SaberMBlockDirectionNPC(victim, hit_loc, qfalse);
		}

		victim->client->ps.saberEventFlags |= SEF_PARRIED;

		//since it was parried, take away any damage done
		wp_saber_clear_damage_for_ent_num(attacker, victim->s.number, saber_num, blade_num);

		//tell the victim to get mad at me
		if (victim->enemy != attacker && victim->client->playerTeam != attacker->client->playerTeam)
		{
			//they're not mad at me and they're not on my team
			G_ClearEnemy(victim);
			G_SetEnemy(victim, attacker);
		}
		return qtrue;
	}
	return qfalse;
}

qboolean WP_SaberNPCFatiguedParry(gentity_t* victim, gentity_t* attacker, const int saber_num, const int blade_num,
	vec3_t hit_loc)
{
	const qboolean npc_blocking = victim->client->ps.ManualBlockingFlags & 1 << MBF_NPCBLOCKING ? qtrue : qfalse;
	const qboolean blocking = victim->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCK ? qtrue : qfalse;
	//Normal Blocking
	const qboolean m_blocking = victim->client->ps.ManualBlockingFlags & 1 << PERFECTBLOCKING ? qtrue : qfalse;
	//perfect Blocking
	const qboolean active_blocking = victim->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCKANDATTACK ? qtrue : qfalse;
	//Active Blocking

	if (!victim || !victim->client || !attacker)
	{
		return qfalse;
	}
	if (rosh_being_healed(victim))
	{
		return qfalse;
	}
	if (G_InCinematicSaberAnim(victim))
	{
		return qfalse;
	}
	if (PM_SuperBreakLoseAnim(victim->client->ps.torsoAnim)
		|| PM_SuperBreakWinAnim(victim->client->ps.torsoAnim)
		|| PM_InKnockDown(&victim->client->ps))
	{
		return qfalse;
	}

	if (victim->s.number
		|| (g_saberAutoBlocking->integer || npc_blocking) && victim->NPC && !G_ControlledByPlayer(victim) //all npc,s
		|| g_saberAutoBlocking->integer && g_SerenityJediEngineMode->integer < 1 // jka mode players
		|| g_SerenityJediEngineMode->integer > 0 && (blocking || m_blocking || active_blocking)
		//AMD / MD Mode blocking flag is on
		|| victim->client->ps.saberBlockingTime > level.time) // All modes already blocking
	{
		//either an NPC or a player who is blocking
		if (!PM_SaberInTransitionAny(victim->client->ps.saber_move)
			&& !PM_SaberInBounce(victim->client->ps.saber_move)
			&& !PM_SaberInKnockaway(victim->client->ps.saber_move)
			&& !BG_InKnockDown(victim->client->ps.legsAnim)
			&& !BG_InKnockDown(victim->client->ps.torsoAnim)
			&& !PM_InKnockDown(&victim->client->ps))
		{
			//I'm not attacking, in transition or in a bounce or knockaway, so play a parry
			WP_SaberFatigueDirection(victim, hit_loc, qfalse);
		}

		victim->client->ps.saberEventFlags |= SEF_PARRIED;

		//since it was parried, take away any damage done
		wp_saber_clear_damage_for_ent_num(attacker, victim->s.number, saber_num, blade_num);

		//tell the victim to get mad at me
		if (victim->enemy != attacker && victim->client->playerTeam != attacker->client->playerTeam)
		{
			//they're not mad at me and they're not on my team
			G_ClearEnemy(victim);
			G_SetEnemy(victim, attacker);
		}
		return qtrue;
	}
	return qfalse;
}

qboolean WP_SaberSlowBounceBlock(gentity_t* victim, gentity_t* attacker, const int saber_num, const int blade_num,
	vec3_t hit_loc)
{
	const qboolean npc_blocking = victim->client->ps.ManualBlockingFlags & 1 << MBF_NPCBLOCKING ? qtrue : qfalse;
	const qboolean blocking = victim->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCK ? qtrue : qfalse;
	//Normal Blocking
	const qboolean m_blocking = victim->client->ps.ManualBlockingFlags & 1 << PERFECTBLOCKING ? qtrue : qfalse;
	//perfect Blocking
	const qboolean active_blocking = victim->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCKANDATTACK ? qtrue : qfalse;
	//Active Blocking

	if (!victim || !victim->client || !attacker)
	{
		return qfalse;
	}
	if (rosh_being_healed(victim))
	{
		return qfalse;
	}
	if (G_InCinematicSaberAnim(victim))
	{
		return qfalse;
	}
	if (PM_SuperBreakLoseAnim(victim->client->ps.torsoAnim)
		|| PM_SuperBreakWinAnim(victim->client->ps.torsoAnim)
		|| PM_InKnockDown(&victim->client->ps))
	{
		return qfalse;
	}

	if (victim->s.number
		|| (g_saberAutoBlocking->integer || npc_blocking) && victim->NPC && !G_ControlledByPlayer(victim) //all npc,s
		|| g_saberAutoBlocking->integer && g_SerenityJediEngineMode->integer < 1 // jka mode players
		|| g_SerenityJediEngineMode->integer > 0 && (blocking || m_blocking || active_blocking)
		//AMD / MD Mode blocking flag is on
		|| victim->client->ps.saberBlockingTime > level.time) // All modes already blocking
	{
		//either an NPC or a player who is blocking
		if (!PM_SaberInTransitionAny(victim->client->ps.saber_move)
			&& !PM_SaberInBounce(victim->client->ps.saber_move)
			&& !PM_SaberInKnockaway(victim->client->ps.saber_move)
			&& !BG_InKnockDown(victim->client->ps.legsAnim)
			&& !BG_InKnockDown(victim->client->ps.torsoAnim)
			&& !PM_InKnockDown(&victim->client->ps))
		{
			//I'm not attacking, in transition or in a bounce or knockaway, so play a parry
			WP_SaberBounceDirection(victim, hit_loc, qfalse);
		}

		victim->client->ps.saberEventFlags |= SEF_PARRIED;

		//since it was parried, take away any damage done
		wp_saber_clear_damage_for_ent_num(attacker, victim->s.number, saber_num, blade_num);

		//tell the victim to get mad at me
		if (victim->enemy != attacker && victim->client->playerTeam != attacker->client->playerTeam)
		{
			//they're not mad at me and they're not on my team
			G_ClearEnemy(victim);
			G_SetEnemy(victim, attacker);
		}
		return qtrue;
	}
	return qfalse;
}

qboolean WP_SaberFatiguedParry(gentity_t* victim, gentity_t* attacker, const int saber_num, const int blade_num,
	vec3_t hit_loc)
{
	const qboolean npc_blocking = victim->client->ps.ManualBlockingFlags & 1 << MBF_NPCBLOCKING ? qtrue : qfalse;
	const qboolean blocking = victim->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCK ? qtrue : qfalse;
	//Normal Blocking
	const qboolean m_blocking = victim->client->ps.ManualBlockingFlags & 1 << PERFECTBLOCKING ? qtrue : qfalse;
	//perfect Blocking
	const qboolean active_blocking = victim->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCKANDATTACK ? qtrue : qfalse;
	//Active Blocking

	if (!victim || !victim->client || !attacker)
	{
		return qfalse;
	}
	if (rosh_being_healed(victim))
	{
		return qfalse;
	}
	if (G_InCinematicSaberAnim(victim))
	{
		return qfalse;
	}
	if (PM_SuperBreakLoseAnim(victim->client->ps.torsoAnim)
		|| PM_SuperBreakWinAnim(victim->client->ps.torsoAnim)
		|| PM_InKnockDown(&victim->client->ps))
	{
		return qfalse;
	}

	if (victim->s.number
		|| (g_saberAutoBlocking->integer || npc_blocking) && victim->NPC && !G_ControlledByPlayer(victim) //all npc,s
		|| g_saberAutoBlocking->integer && g_SerenityJediEngineMode->integer < 1 // jka mode players
		|| g_SerenityJediEngineMode->integer > 0 && (blocking || m_blocking || active_blocking)
		//AMD / MD Mode blocking flag is on
		|| victim->client->ps.saberBlockingTime > level.time) // All modes already blocking
	{
		//either an NPC or a player who is blocking
		if (!PM_SaberInTransitionAny(victim->client->ps.saber_move)
			&& !PM_SaberInBounce(victim->client->ps.saber_move)
			&& !PM_SaberInKnockaway(victim->client->ps.saber_move)
			&& !BG_InKnockDown(victim->client->ps.legsAnim)
			&& !BG_InKnockDown(victim->client->ps.torsoAnim)
			&& !PM_InKnockDown(&victim->client->ps))
		{
			//I'm not attacking, in transition or in a bounce or knockaway, so play a parry
			WP_SaberFatiguedParryDirection(victim, hit_loc, qfalse);
		}

		victim->client->ps.saberEventFlags |= SEF_PARRIED;

		//since it was parried, take away any damage done
		wp_saber_clear_damage_for_ent_num(attacker, victim->s.number, saber_num, blade_num);

		//tell the victim to get mad at me
		if (victim->enemy != attacker && victim->client->playerTeam != attacker->client->playerTeam)
		{
			//they're not mad at me and they're not on my team
			G_ClearEnemy(victim);
			G_SetEnemy(victim, attacker);
		}
		return qtrue;
	}
	return qfalse;
}

static qboolean WP_BrokenParryKnockDown(gentity_t* victim)
{
	if (!victim || !victim->client)
	{
		return qfalse;
	}
	if (PM_SuperBreakLoseAnim(victim->client->ps.torsoAnim)
		|| PM_SuperBreakWinAnim(victim->client->ps.torsoAnim))
	{
		return qfalse;
	}
	if (victim->client->ps.saber_move == LS_PARRY_UP
		|| victim->client->ps.saber_move == LS_PARRY_UR
		|| victim->client->ps.saber_move == LS_PARRY_UL
		|| victim->client->ps.saber_move == LS_H1_BR
		|| victim->client->ps.saber_move == LS_H1_B_
		|| victim->client->ps.saber_move == LS_H1_BL)
	{
		//knock their asses down!
		int knock_anim = BOTH_KNOCKDOWN1;
		if (PM_CrouchAnim(victim->client->ps.legsAnim))
		{
			knock_anim = BOTH_KNOCKDOWN4;
		}
		NPC_SetAnim(victim, SETANIM_BOTH, knock_anim, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
		G_AddEvent(victim, EV_PAIN, victim->health);
		return qtrue;
	}
	return qfalse;
}

qboolean WP_SaberDisarmed(gentity_t* self, vec3_t throw_dir);
void G_Stagger(gentity_t* hit_ent);

qboolean WP_BoltBlockVictimFatigued(gentity_t* victim)
{
	if (!victim || !victim->client)
	{
		return qfalse;
	}

	if (victim->s.weapon == WP_SABER && victim->client->ps.SaberActive() && victim->client->ps.blockPoints <=
		BLOCKPOINTS_TEN
		|| victim->s.weapon == WP_SABER && victim->client->ps.SaberActive() && victim->client->ps.forcePower <=
		BLOCKPOINTS_TEN)
	{
		//knock their asses down!!
		G_Stagger(victim);

		vec3_t throw_dir = { 0, 0, 350 };

		WP_SaberDisarmed(victim, throw_dir);

		G_AddEvent(victim, EV_PAIN, victim->health);
		return qtrue;
	}
	G_Stagger(victim);
	return qtrue;
}

qboolean wp_bolt_block_victim_reflected(gentity_t* victim)
{
	if (!victim || !victim->client)
	{
		return qfalse;
	}

	if (victim->s.weapon == WP_SABER && victim->client->ps.SaberActive() && g_SerenityJediEngineMode->integer == 2 &&
		victim->client->ps.blockPoints <= BLOCKPOINTS_TWENTYFIVE
		|| victim->s.weapon == WP_SABER && victim->client->ps.SaberActive() && g_SerenityJediEngineMode->integer == 1 &&
		victim->client->ps.forcePower <= BLOCKPOINTS_TWENTYFIVE)
	{
		if (victim->s.weapon == WP_SABER && victim->client->ps.SaberActive() && g_SerenityJediEngineMode->integer == 2
			&& victim->client->ps.blockPoints <= BLOCKPOINTS_TEN
			|| victim->s.weapon == WP_SABER && victim->client->ps.SaberActive() && g_SerenityJediEngineMode->integer ==
			1 && victim->client->ps.forcePower <= BLOCKPOINTS_TEN)
		{
			//knock their asses down!!
			G_Stagger(victim);

			vec3_t throw_dir = { 0, 0, 350 };

			WP_SaberDisarmed(victim, throw_dir);

			G_AddEvent(victim, EV_PAIN, victim->health);
			return qtrue;
		}
		//knock their asses down!!
		G_Stagger(victim);
		return qtrue;
	}

	return qtrue;
}

qboolean G_TryingKataAttack(const usercmd_t* cmd)
{
	if (g_saberNewControlScheme->integer)
	{
		//use the new control scheme: force focus button
		if (cmd->buttons & BUTTON_FORCE_FOCUS)
		{
			return qtrue;
		}
		return qfalse;
	}
	//if ( self && self->client )
	//use the old control scheme
	if (cmd->buttons & BUTTON_ALT_ATTACK)
	{
		//pressing alt-attack
		//if ( !(self->client->ps.pm_flags&PMF_ALT_ATTACK_HELD) )
		{
			//haven't been holding alt-attack
			if (cmd->buttons & BUTTON_ATTACK)
			{
				//pressing attack
				return qtrue;
			}
		}
	}
	return qfalse;
}

qboolean G_TryingPullAttack(const gentity_t* self, const usercmd_t* cmd, const qboolean am_pulling)
{
	if (g_saberNewControlScheme->integer)
	{
		//use the new control scheme: force focus button
		if (cmd->buttons & BUTTON_FORCE_FOCUS)
		{
			if (self && self->client)
			{
				if (self->client->ps.forcePowerLevel[FP_PULL] >= FORCE_LEVEL_3)
				{
					//force pull 3
					if (am_pulling
						|| self->client->ps.forcePowersActive & 1 << FP_PULL
						|| self->client->ps.forcePowerDebounce[FP_PULL] > level.time) //force-pulling
					{
						//pulling
						return qtrue;
					}
				}
			}
		}
		else
		{
			return qfalse;
		}
	}
	else
	{
		//use the old control scheme
		if (cmd->buttons & BUTTON_ATTACK)
		{
			//pressing attack
			if (self && self->client)
			{
				if (self->client->ps.forcePowerLevel[FP_PULL] >= FORCE_LEVEL_3)
				{
					//force pull 3
					if (am_pulling
						|| self->client->ps.forcePowersActive & 1 << FP_PULL
						|| self->client->ps.forcePowerDebounce[FP_PULL] > level.time) //force-pulling
					{
						//pulling
						return qtrue;
					}
				}
			}
		}
	}
	return qfalse;
}

qboolean G_TryingCartwheel(const gentity_t* self, const usercmd_t* cmd)
{
	if (g_saberNewControlScheme->integer)
	{
		//use the new control scheme: force focus button
		if (cmd->buttons & BUTTON_FORCE_FOCUS)
		{
			return qtrue;
		}
		return qfalse;
	}
	//use the old control scheme
	if (cmd->buttons & BUTTON_ATTACK)
	{
		//pressing attack
		if (cmd->rightmove)
		{
			if (self && self->client)
			{
				if (cmd->upmove > 0 //)
					&& self->client->ps.groundEntityNum != ENTITYNUM_NONE)
				{
					//on ground, pressing jump
					return qtrue;
				}
				//just jumped?
				if (self->client->ps.groundEntityNum == ENTITYNUM_NONE
					&& level.time - self->client->ps.lastOnGround <= 50 //250
					&& self->client->ps.pm_flags & PMF_JUMPING) //jumping
				{
					//just jumped this or last frame
					return qtrue;
				}
			}
		}
	}
	return qfalse;
}

qboolean G_TryingSpecial(const usercmd_t* cmd)
{
	if (g_saberNewControlScheme->integer)
	{
		//use the new control scheme: force focus button
		if (cmd->buttons & BUTTON_FORCE_FOCUS)
		{
			return qtrue;
		}
		return qfalse;
	}
	//use the old control scheme
	return qfalse;
}

qboolean G_TryingJumpAttack(const gentity_t* self, const usercmd_t* cmd)
{
	if (g_saberNewControlScheme->integer)
	{
		//use the new control scheme: force focus button
		if (cmd->buttons & BUTTON_FORCE_FOCUS)
		{
			return qtrue;
		}
		return qfalse;
	}
	//use the old control scheme
	if (cmd->buttons & BUTTON_ATTACK)
	{
		//pressing attack
		if (cmd->upmove > 0)
		{
			//pressing jump
			return qtrue;
		}
		if (self && self->client)
		{
			//just jumped?
			if (self->client->ps.groundEntityNum == ENTITYNUM_NONE
				&& level.time - self->client->ps.lastOnGround <= 250
				&& self->client->ps.pm_flags & PMF_JUMPING) //jumping
			{
				//jumped within the last quarter second
				return qtrue;
			}
		}
	}
	return qfalse;
}

qboolean G_TryingJumpForwardAttack(const gentity_t* self, const usercmd_t* cmd)
{
	if (g_saberNewControlScheme->integer)
	{
		//use the new control scheme: force focus button
		if (cmd->buttons & BUTTON_FORCE_FOCUS)
		{
			return qtrue;
		}
		return qfalse;
	}
	//use the old control scheme
	if (cmd->buttons & BUTTON_ATTACK)
	{
		//pressing attack
		if (cmd->forwardmove > 0)
		{
			//moving forward
			if (self && self->client)
			{
				if (cmd->upmove > 0
					&& self->client->ps.groundEntityNum != ENTITYNUM_NONE)
				{
					//pressing jump
					return qtrue;
				}
				//no slop on forward jumps - must be precise!
				if (self->client->ps.groundEntityNum == ENTITYNUM_NONE
					&& level.time - self->client->ps.lastOnGround <= 50
					&& self->client->ps.pm_flags & PMF_JUMPING) //jumping
				{
					//just jumped this or last frame
					return qtrue;
				}
			}
		}
	}
	return qfalse;
}

qboolean G_TryingLungeAttack(const gentity_t* self, const usercmd_t* cmd)
{
	if (g_saberNewControlScheme->integer)
	{
		//use the new control scheme: force focus button
		if (cmd->buttons & BUTTON_FORCE_FOCUS)
		{
			return qtrue;
		}
		return qfalse;
	}
	//use the old control scheme
	if (cmd->buttons & BUTTON_ATTACK)
	{
		//pressing attack
		if (cmd->upmove < 0)
		{
			//pressing crouch
			return qtrue;
		}
		if (self && self->client)
		{
			//just un ducked?
			if (self->client->ps.pm_flags & PMF_DUCKED)
			{
				//just un ducking
				return qtrue;
			}
		}
	}
	return qfalse;
}

//FIXME: for these below funcs, maybe in the old control scheme some moves should still cost power... if so, pass in the saber_move and use a switch statement
qboolean G_EnoughPowerForSpecialMove(const int force_power, const int cost, const qboolean kata_move, const qboolean play_sound)
{
	if (g_saberNewControlScheme->integer || kata_move)
	{
		//special moves cost power
		if (force_power >= cost)
		{
			return qtrue;
		}
		if (play_sound)
		{
			cg.forceHUDTotalFlashTime = level.time + 500;
			cg.mishapHUDTotalFlashTime = level.time + 500;
			cg.blockHUDTotalFlashTime = level.time + 500;
		}
		return qfalse;
	}
	//old control scheme: uses no power, so just do it
	return qtrue;
}

void G_DrainPowerForSpecialMove(const gentity_t* self, const forcePowers_t fp, const int cost, const qboolean kata_move)
{
	if (!self || !self->client || self->s.number >= MAX_CLIENTS)
	{
		return;
	}
	if (g_saberNewControlScheme->integer || kata_move)
	{
		//special moves cost power
		WP_ForcePowerDrain(self, fp, cost); //drain the required force power
	}
	else
	{
		//old control scheme: uses no power, so just do it
	}
}

int G_CostForSpecialMove(const int cost, const qboolean kata_move)
{
	if (g_saberNewControlScheme->integer || kata_move)
	{
		//special moves cost power
		return cost;
	}
	//old control scheme: uses no power, so just do it
	return 0;
}

extern qboolean G_EntIsBreakable(int entityNum, const gentity_t* breaker);

static void WP_SaberRadiusDamage(gentity_t* ent, vec3_t point, const float radius, const int damage, const float knock_back)
{
	if (!ent || !ent->client)
	{
		return;
	}
	if (radius <= 0.0f || damage <= 0 && knock_back <= 0)
	{
		return;
	}
	vec3_t mins{}, maxs{}, ent_dir;
	gentity_t* radius_ents[128];
	int i;

	//Setup the bbox to search in
	for (i = 0; i < 3; i++)
	{
		mins[i] = point[i] - radius;
		maxs[i] = point[i] + radius;
	}

	//Get the number of entities in a given space
	const int num_ents = gi.EntitiesInBox(mins, maxs, radius_ents, 128);

	for (i = 0; i < num_ents; i++)
	{
		if (!radius_ents[i]->inuse)
		{
			continue;
		}

		if (radius_ents[i] == ent)
		{
			//Skip myself
			continue;
		}

		if (radius_ents[i]->client == nullptr)
		{
			//must be a client
			if (G_EntIsBreakable(radius_ents[i]->s.number, ent))
			{
				//damage breakables within range, but not as much
				G_Damage(radius_ents[i], ent, ent, vec3_origin, radius_ents[i]->currentOrigin, 10, 0,
					MOD_EXPLOSIVE_SPLASH);
			}
			continue;
		}

		if (radius_ents[i]->client->ps.eFlags & EF_HELD_BY_RANCOR
			|| radius_ents[i]->client->ps.eFlags & EF_HELD_BY_WAMPA)
		{
			//can't be one being held
			continue;
		}

		VectorSubtract(radius_ents[i]->currentOrigin, point, ent_dir);
		const float dist = VectorNormalize(ent_dir);
		if (dist <= radius)
		{
			//in range
			if (damage > 0)
			{
				//do damage
				const int points = ceil(static_cast<float>(damage) * dist / radius);
				G_Damage(radius_ents[i], ent, ent, vec3_origin, radius_ents[i]->currentOrigin, points,
					DAMAGE_NO_KNOCKBACK, MOD_EXPLOSIVE_SPLASH);
			}
			if (knock_back > 0)
			{
				//do knockback
				if (radius_ents[i]->client
					&& radius_ents[i]->client->NPC_class != CLASS_RANCOR
					&& radius_ents[i]->client->NPC_class != CLASS_ATST
					&& !(radius_ents[i]->flags & FL_NO_KNOCKBACK)) //don't throw them back
				{
					const float knockback_str = knock_back * dist / radius;
					ent_dir[2] += 0.1f;
					VectorNormalize(ent_dir);
					G_Throw(radius_ents[i], ent_dir, knockback_str);
					if (radius_ents[i]->health > 0)
					{
						//still alive
						if (knockback_str > 50)
						{
							//close enough and knockback high enough to possibly knock down
							if (dist < radius * 0.5f
								|| radius_ents[i]->client->ps.groundEntityNum != ENTITYNUM_NONE)
							{
								//within range of my fist or within ground-shaking range and not in the air
								G_Knockdown(radius_ents[i], ent, ent_dir, 500, qtrue);
							}
						}
					}
				}
			}
		}
	}
}

/*
---------------------------------------------------------
void WP_SaberDamageTrace( gentity_t *ent, int saber_num, int blade_num )

  Constantly trace from the old blade pos to new, down the saber beam and do damage

  FIXME: if the dot product of the old muzzle dir and the new muzzle dir is < 0.75, subdivide it and do multiple traces so we don't flatten out the arc!
---------------------------------------------------------
*/
constexpr auto MAX_SABER_SWING_INC = 0.33f;

static void WP_SaberDamageTrace(gentity_t* ent, int saber_num, int blade_num)
{
	vec3_t mp1, mp2, md1, md2, base_old, base_new, end_old, end_new;
	float base_damage;
	int base_d_flags = 0;
	qboolean hit_wall = qfalse;
	qboolean broken_parry = qfalse;

	for (int& ven : victimEntityNum)
	{
		ven = ENTITYNUM_NONE;
	}
	memset(totalDmg, 0, sizeof totalDmg);
	memset(dmgDir, 0, sizeof dmgDir);
	memset(dmgNormal, 0, sizeof dmgNormal);
	memset(dmgSpot, 0, sizeof dmgSpot);
	memset(dmgFraction, 0, sizeof dmgFraction);
	memset(hit_loc, HL_NONE, sizeof hit_loc);
	memset(hitDismemberLoc, HL_NONE, sizeof hitDismemberLoc);
	memset(hitDismember, qfalse, sizeof hitDismember);
	numVictims = 0;
	VectorClear(saberHitLocation);
	VectorClear(saberHitNormal);
	saberHitFraction = 1.0; // Closest saber hit.  The saber can do no damage past this point.
	saberHitEntity = ENTITYNUM_NONE;
	sabersCrossed = -1;

	if (!ent->client)
	{
		return;
	}

	if (!ent->s.number)
	{
		//player never uses these
		ent->client->ps.saberEventFlags &= ~SEF_EVENTS;
	}

	if (ent->client->ps.saber[saber_num].blade[blade_num].length <= 1) //cen get down to 1 when in a wall
	{
		//saber is not on
		return;
	}

	if (VectorCompare(ent->client->renderInfo.muzzlePointOld, vec3_origin) || VectorCompare(
		ent->client->renderInfo.muzzleDirOld, vec3_origin))
	{
		//just started up the saber?
		return;
	}

	int saber_contents = 0;
	if (!(ent->client->ps.saber[saber_num].saberFlags & SFL_ON_IN_WATER))
	{
		//saber can't stay on underwater
		saber_contents = gi.pointcontents(ent->client->renderInfo.muzzlePoint, ent->client->ps.saberEntityNum);
	}
	if (saber_contents & CONTENTS_WATER ||
		saber_contents & CONTENTS_SLIME ||
		saber_contents & CONTENTS_LAVA)
	{
		//um... turn off?  Or just set length to 1?
		//FIXME: short-out effect/sound?
		ent->client->ps.saber[saber_num].blade[blade_num].active = qfalse;
		return;
	}
	if (!g_saberNoEffects && gi.WE_IsOutside(ent->client->renderInfo.muzzlePoint))
	{
		float chance_of_fizz = gi.WE_GetChanceOfSaberFizz();
		if (chance_of_fizz > 0 && Q_flrand(0.0f, 1.0f) < chance_of_fizz)
		{
			vec3_t end; /*normal = {0,0,1};//FIXME: opposite of rain angles?*/
			VectorMA(ent->client->ps.saber[saber_num].blade[blade_num].muzzlePoint,
				ent->client->ps.saber[saber_num].blade[blade_num].length * Q_flrand(0, 1),
				ent->client->ps.saber[saber_num].blade[blade_num].muzzleDir, end);
			G_PlayEffect("saber/fizz", end);
		}
	}

	//FIXMEFIXMEFIXME: When in force speed (esp. lvl 3), need to interpolate this because
	//		we animate so much faster that the arc is pretty much flat...

	int ent_power_level = 0;
	if (ent->client->NPC_class == CLASS_SABER_DROID)
	{
		ent_power_level = SaberDroid_PowerLevelForSaberAnim(ent);
	}
	else if (!ent->s.number && ent->client->ps.forcePowersActive & 1 << FP_SPEED)
	{
		ent_power_level = FORCE_LEVEL_3;
	}
	else
	{
		ent_power_level = PM_PowerLevelForSaberAnim(&ent->client->ps, saber_num);
	}

	if (ent_power_level)
	{
		if (ent->client->ps.forceRageRecoveryTime > level.time)
		{
			ent_power_level = FORCE_LEVEL_1;
		}
		else if (ent->client->ps.forcePowersActive & 1 << FP_RAGE)
		{
			ent_power_level += ent->client->ps.forcePowerLevel[FP_RAGE];
		}
	}

	if (ent->client->ps.saberInFlight)
	{
		//flying sabers are much more deadly
		//unless you're dead
		if (ent->health <= 0 && g_saberRealisticCombat->integer < 2)
		{
			//so enemies don't keep trying to block it
			return;
		}
		//or unless returning
		if (ent->client->ps.saberEntityState == SES_RETURNING
			&& !(ent->client->ps.saber[0].saberFlags & SFL_RETURN_DAMAGE))
		{
			//special case, since we're returning, chances are if we hit something
			base_damage = 0.1f;
		}
		else
		{
			if (!ent->s.number)
			{
				//cheat for player
				base_damage = 10.0f;
			}
			else
			{
				base_damage = 2.5f;
			}
		}
		//Use old to current since can't predict it
		VectorCopy(ent->client->ps.saber[saber_num].blade[blade_num].muzzlePointOld, mp1);
		VectorCopy(ent->client->ps.saber[saber_num].blade[blade_num].muzzleDirOld, md1);
		VectorCopy(ent->client->ps.saber[saber_num].blade[blade_num].muzzlePoint, mp2);
		VectorCopy(ent->client->ps.saber[saber_num].blade[blade_num].muzzleDir, md2);
	}
	else
	{
		if (ent->client->ps.torsoAnim == BOTH_A7_HILT)
		{
			//no effects, no damage
			return;
		}
		if (ent->client->ps.torsoAnim == BOTH_CIN_70)
		{
			//no effects, no damage
			return;
		}
		if (ent->client->ps.torsoAnim == BOTH_CIN_50)
		{
			//no effects, no damage
			return;
		}
		if (ent->client->ps.torsoAnim == BOTH_MD_CIN_1)
		{
			//no effects, no damage
			return;
		}
		if (G_InCinematicSaberAnim(ent))
		{
			base_d_flags = DAMAGE_NO_KILL;
			base_damage = 0.1f;
		}
		else if (ent->client->ps.saber_move == LS_READY
			&& !pm_saber_in_special_attack(ent->client->ps.torsoAnim))
		{
			//just do effects
			if (g_saberRealisticCombat->integer < 2)
			{
				//don't kill with this hit
				base_d_flags = DAMAGE_NO_KILL;
			}
			if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
				&& ent->client->ps.saber[saber_num].saberFlags2 & SFL2_NO_IDLE_EFFECT
				|| WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
				&& ent->client->ps.saber[saber_num].saberFlags2 & SFL2_NO_IDLE_EFFECT2)
			{
				//do nothing at all when idle
				return;
			}
			base_damage = 0;
		}
		else if (ent->client->ps.saberLockTime > level.time)
		{
			//just do effects
			if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
				&& ent->client->ps.saber[saber_num].saberFlags2 & SFL2_NO_IDLE_EFFECT
				|| WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
				&& ent->client->ps.saber[saber_num].saberFlags2 & SFL2_NO_IDLE_EFFECT2)
			{
				//do nothing at all when idle
				return;
			}
			base_damage = 0;
		}
		else if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
			&& ent->client->ps.saber[saber_num].damageScale <= 0.0f
			&& ent->client->ps.saber[saber_num].knockbackScale <= 0.0f)
		{
			//this blade does no damage and no knockback (only for blocking?)
			base_damage = 0;
		}
		else if (WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
			&& ent->client->ps.saber[saber_num].damageScale2 <= 0.0f
			&& ent->client->ps.saber[saber_num].knockbackScale2 <= 0.0f)
		{
			//this blade does no damage and no knockback (only for blocking?)
			base_damage = 0;
		}
		else if (ent->client->ps.saberBlocked > BLOCKED_NONE
			|| !PM_SaberInAttack(ent->client->ps.saber_move)
			&& !pm_saber_in_special_attack(ent->client->ps.torsoAnim)
			&& !PM_SaberInTransitionAny(ent->client->ps.saber_move)
			)
		{
			//don't do damage if parrying/reflecting/bouncing/deflecting or not actually attacking or in a transition to/from/between attacks
			if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
				&& ent->client->ps.saber[saber_num].saberFlags2 & SFL2_NO_IDLE_EFFECT
				|| WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
				&& ent->client->ps.saber[saber_num].saberFlags2 & SFL2_NO_IDLE_EFFECT2
				)
			{
				//do nothing at all when idle
				return;
			}
			base_damage = 0;
		}
		else
		{
			//okay, in a saber_move that does damage
			//make sure we're in the right anim
			if (!pm_saber_in_special_attack(ent->client->ps.torsoAnim)
				&& !PM_InAnimForSaberMove(ent->client->ps.torsoAnim, ent->client->ps.saber_move))
			{
				//forced into some other animation somehow, like a pain or death?
				if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
					&& ent->client->ps.saber[saber_num].saberFlags2 & SFL2_NO_IDLE_EFFECT
					|| WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
					&& ent->client->ps.saber[saber_num].saberFlags2 & SFL2_NO_IDLE_EFFECT2
					)
				{
					//do nothing at all when idle
					return;
				}
				base_damage = 0;
			}
			else if (ent->client->ps.weaponstate == WEAPON_FIRING && ent->client->ps.saberBlocked == BLOCKED_NONE &&
				(PM_SaberInAttack(ent->client->ps.saber_move) || pm_saber_in_special_attack(ent->client->ps.torsoAnim) ||
					PM_SpinningSaberAnim(ent->client->ps.torsoAnim) || ent_power_level > FORCE_LEVEL_2 ||
					WP_SaberBladeDoTransitionDamage(&ent->client->ps.saber[saber_num], blade_num) &&
					PM_SaberInTransitionAny(ent->client->ps.saber_move)))
				// || ent->client->ps.saber_anim_level == SS_STAFF ) )
			{
				//normal attack swing swinging/spinning (or if using strong set), do normal damage //FIXME: or if using staff?
				//FIXME: more damage for higher attack power levels?
				//		More damage based on length/color of saber?
				//FIXME: Desann does double damage?
				if (g_saberRealisticCombat->integer)
				{
					switch (ent_power_level)
					{
					default:
					case FORCE_LEVEL_3:
						base_damage = 10.0f;
						break;
					case FORCE_LEVEL_2:
						base_damage = 5.0f;
						break;
					case FORCE_LEVEL_0:
					case FORCE_LEVEL_1:
						base_damage = 2.5f;
						break;
					}
				}
				else
				{
					if (g_spskill->integer > 0
						&& ent->s.number < MAX_CLIENTS
						&& (ent->client->ps.torsoAnim == BOTH_ROLL_STAB
							|| ent->client->ps.torsoAnim == BOTH_SPINATTACK6
							|| ent->client->ps.torsoAnim == BOTH_SPINATTACK7
							|| ent->client->ps.torsoAnim == BOTH_LUNGE2_B__T_))
					{
						//*sigh*, these anim do less damage since they're so easy to do
						base_damage = 2.5f;
					}
					else
					{
						base_damage = 2.5f * static_cast<float>(ent_power_level);
					}
				}
			}
			else
			{
				//saber is transitioning, defending or idle, don't do as much damage
				//FIXME: strong attacks and returns should do damage and be unblockable
				if (g_timescale->value < 1.0)
				{
					//in slow mo or force speed, we need to do damage during the transitions
					if (g_saberRealisticCombat->integer)
					{
						switch (ent_power_level)
						{
						case FORCE_LEVEL_3:
							base_damage = 10.0f;
							break;
						case FORCE_LEVEL_2:
							base_damage = 5.0f;
							break;
						default:
						case FORCE_LEVEL_1:
							base_damage = 2.5f;
							break;
						}
					}
					else
					{
						base_damage = 2.5f * static_cast<float>(ent_power_level);
					}
				}
				else // if ( !ent->s.number )
				{
					//I have to do *some* damage in transitions or else you feel like a total gimp
					base_damage = 0.1f;
				}
				/*
				else
				{
					baseDamage = 0;//was 1.0f;//was 0.25
				}
				*/
			}
		}

		//Use current to next since can predict it
		//FIXME: if they're closer than the saber blade start, we don't want the
		//		arm to pass through them without any damage... so check the radius
		//		and push them away (do pain & knockback)
		//FIXME: if going into/coming from a parry/reflection or going into a deflection, don't use old mp & dir?  Otherwise, deflections will cut through?
		//VectorCopy( ent->client->renderInfo.muzzlePoint, mp1 );
		//VectorCopy( ent->client->renderInfo.muzzleDir, md1 );
		//VectorCopy( ent->client->renderInfo.muzzlePointNext, mp2 );
		//VectorCopy( ent->client->renderInfo.muzzleDirNext, md2 );
		//prediction was causing gaps in swing (G2 problem) so *don't* predict
		if (ent->client->ps.saberDamageDebounceTime > level.time)
		{
			//really only used when a saber attack start anim starts, not actually for stopping damage
			//we just want to not use the old position to trace the attack from...
			VectorCopy(ent->client->ps.saber[saber_num].blade[blade_num].muzzlePoint,
				ent->client->ps.saber[saber_num].blade[blade_num].muzzlePointOld);
			VectorCopy(ent->client->ps.saber[saber_num].blade[blade_num].muzzleDir,
				ent->client->ps.saber[saber_num].blade[blade_num].muzzleDirOld);
		}
		//do the damage trace from the last position...
		VectorCopy(ent->client->ps.saber[saber_num].blade[blade_num].muzzlePointOld, mp1);
		VectorCopy(ent->client->ps.saber[saber_num].blade[blade_num].muzzleDirOld, md1);
		//...to the current one.
		VectorCopy(ent->client->ps.saber[saber_num].blade[blade_num].muzzlePoint, mp2);
		VectorCopy(ent->client->ps.saber[saber_num].blade[blade_num].muzzleDir, md2);

		//NOTE: this is a test, may not be necc, as I can still swing right through someone without hitting them, somehow...
		//see if anyone is so close that they're within the dist from my origin to the start of the saber
		if (ent->health > 0 && !ent->client->ps.saberLockTime && saber_num == 0 && blade_num == 0
			&& !G_InCinematicSaberAnim(ent))
		{
			//only do once - for first blade
			trace_t trace;
			gi.trace(&trace, ent->currentOrigin, vec3_origin, vec3_origin, mp1, ent->s.number,
				MASK_SHOT & ~(CONTENTS_CORPSE | CONTENTS_ITEM), static_cast<EG2_Collision>(0), 0);
			if (trace.entityNum < ENTITYNUM_WORLD && (trace.entityNum > 0 || ent->client->NPC_class == CLASS_DESANN))
				//NPCs don't push player away, unless it's Desann
			{
				//a valid ent
				gentity_t* traceEnt = &g_entities[trace.entityNum];
				if (traceEnt
					&& traceEnt->client
					&& traceEnt->client->NPC_class != CLASS_RANCOR
					&& traceEnt->client->NPC_class != CLASS_ATST
					&& traceEnt->client->NPC_class != CLASS_WAMPA
					&& traceEnt->client->NPC_class != CLASS_SAND_CREATURE
					&& traceEnt->health > 0
					&& traceEnt->client->playerTeam != ent->client->playerTeam
					&& !PM_SuperBreakLoseAnim(traceEnt->client->ps.legsAnim)
					&& !PM_SuperBreakLoseAnim(traceEnt->client->ps.torsoAnim)
					&& !PM_SuperBreakWinAnim(traceEnt->client->ps.legsAnim)
					&& !PM_SuperBreakWinAnim(traceEnt->client->ps.torsoAnim)
					&& !PM_InKnockDown(&traceEnt->client->ps)
					&& !PM_LockedAnim(traceEnt->client->ps.legsAnim)
					&& !PM_LockedAnim(traceEnt->client->ps.torsoAnim)
					&& !G_InCinematicSaberAnim(traceEnt))
				{
					//enemy client, push them away
					if (!traceEnt->client->ps.saberLockTime
						&& !traceEnt->message
						&& !(traceEnt->flags & FL_NO_KNOCKBACK)
						&& (!traceEnt->NPC || traceEnt->NPC->jumpState != JS_JUMPING))
					{
						//don't push people in saberlock or with security keys or who are in BS_JUMP
						vec3_t hit_dir;
						VectorSubtract(trace.endpos, ent->currentOrigin, hit_dir);
						float total_dist = Distance(mp1, ent->currentOrigin);
						float knockback = (total_dist - VectorNormalize(hit_dir)) / total_dist * 200.0f;
						hit_dir[2] = 0;
						//FIXME: do we need to call G_Throw?  Seems unfair to put actual knockback on them, stops the attack
						//G_Throw( traceEnt, hitDir, knockback );
						VectorMA(traceEnt->client->ps.velocity, knockback, hit_dir, traceEnt->client->ps.velocity);
						traceEnt->client->ps.pm_time = 200;
						traceEnt->client->ps.pm_flags |= PMF_TIME_NOFRICTION;
#ifndef FINAL_BUILD
						if (d_saberCombat->integer)
						{
							gi.Printf("%s pushing away %s at %s\n", ent->NPC_type, traceEnt->NPC_type, vtos(traceEnt->client->ps.velocity));
						}
#endif
					}
				}
			}
		}
	}

	//the thicker the blade, the more damage... the thinner, the less damage
	base_damage *= ent->client->ps.saber[saber_num].blade[blade_num].radius / SABER_RADIUS_STANDARD;

	if (g_saberRealisticCombat->integer > 1)
	{
		//always do damage, and lots of it
		if (g_saberRealisticCombat->integer > 2)
		{
			//always do damage, and lots of it
			base_damage = 25.0f;
		}
		else if (base_damage > 0.1f)
		{
			//only do super damage if we would have done damage according to normal rules
			base_damage = 25.0f;
		}
	}
	else if ((!ent->s.number && ent->client->ps.forcePowersActive & 1 << FP_SPEED || ent->client->ps.forcePowersActive &
		1 << FP_RAGE)
		&& g_timescale->value < 1.0f)
	{
		base_damage *= 1.0f - g_timescale->value;
	}
	if (base_damage > 0.1f)
	{
		if (ent->client->ps.forcePowersActive & 1 << FP_RAGE)
		{
			//add some damage if raged
			base_damage += ent->client->ps.forcePowerLevel[FP_RAGE] * 5.0f;
		}
		else if (ent->client->ps.forceRageRecoveryTime)
		{
			//halve it if recovering
			base_damage *= 0.5f;
		}
	}
	// Get the old state of the blade
	VectorCopy(mp1, base_old);
	VectorMA(base_old, ent->client->ps.saber[saber_num].blade[blade_num].length, md1, end_old);
	// Get the future state of the blade
	VectorCopy(mp2, base_new);
	VectorMA(base_new, ent->client->ps.saber[saber_num].blade[blade_num].length, md2, end_new);

	sabersCrossed = -1;
	if (VectorCompare2(base_old, base_new) && VectorCompare2(end_old, end_new))
	{
		hit_wall = WP_SaberDamageForTrace(ent->s.number, mp2, end_new, base_damage * 4, md2,
			qfalse, ent->client->ps.saber[saber_num].type, qfalse, saber_num,
			blade_num);
	}
	else
	{
		float tip_dmg_mod = 1.0f;
		vec3_t base_diff;
		float aveLength, step = 8, stepsize = 8;
		vec3_t ma1, ma2, md2_ang{}, cur_base2;
		int xx;
		//do the trace at the base first
		hit_wall = WP_SaberDamageForTrace(ent->s.number, base_old, base_new, base_damage, md2,
			qfalse, ent->client->ps.saber[saber_num].type, qtrue, saber_num,
			blade_num);

		//if hit a saber, shorten rest of traces to match
		if (saberHitFraction < 1.0)
		{
			//adjust muzzleDir...
			vec3_t vec3, angles;
			vectoangles(md1, vec3);
			vectoangles(md2, angles);
			for (xx = 0; xx < 3; xx++)
			{
				md2_ang[xx] = LerpAngle(vec3[xx], angles[xx], saberHitFraction);
			}
			AngleVectors(md2_ang, md2, nullptr, nullptr);
			//shorten the base pos
			VectorSubtract(mp2, mp1, base_diff);
			VectorMA(mp1, saberHitFraction, base_diff, base_new);
			VectorMA(base_new, ent->client->ps.saber[saber_num].blade[blade_num].length, md2, end_new);
		}

		//If the angle diff in the blade is high, need to do it in chunks of 33 to avoid flattening of the arc
		float dir_inc, curDirFrac;
		if (PM_SaberInAttack(ent->client->ps.saber_move)
			|| pm_saber_in_special_attack(ent->client->ps.torsoAnim)
			|| PM_SpinningSaberAnim(ent->client->ps.torsoAnim)
			|| PM_InSpecialJump(ent->client->ps.torsoAnim)
			|| g_timescale->value < 1.0f && PM_SaberInTransitionAny(ent->client->ps.saber_move))
		{
			curDirFrac = DotProduct(md1, md2);
		}
		else
		{
			curDirFrac = 1.0f;
		}
		//NOTE: if saber spun at least 180 degrees since last damage trace, this is not reliable...!
		if (fabs(curDirFrac) < 1.0f - MAX_SABER_SWING_INC)
		{
			//the saber blade spun more than 33 degrees since the last damage trace
			curDirFrac = dir_inc = 1.0f / ((1.0f - curDirFrac) / MAX_SABER_SWING_INC);
		}
		else
		{
			curDirFrac = 1.0f;
			dir_inc = 0.0f;
		}
		qboolean hit_saber = qfalse;

		vectoangles(md1, ma1);
		vectoangles(md2, ma2);

		vec3_t curMD2;
		VectorCopy(md1, curMD2);
		VectorCopy(base_old, cur_base2);

		while (true)
		{
			vec3_t cur_md1;
			vec3_t cur_base1;
			VectorCopy(curMD2, cur_md1);
			VectorCopy(cur_base2, cur_base1);
			if (curDirFrac >= 1.0f)
			{
				VectorCopy(md2, curMD2);
				VectorCopy(base_new, cur_base2);
			}
			else
			{
				for (xx = 0; xx < 3; xx++)
				{
					md2_ang[xx] = LerpAngle(ma1[xx], ma2[xx], curDirFrac);
				}
				AngleVectors(md2_ang, curMD2, nullptr, nullptr);
				VectorSubtract(base_new, base_old, base_diff);
				VectorMA(base_old, curDirFrac, base_diff, cur_base2);
			}
			// Move up the blade in intervals of stepsize
			for (step = stepsize; step < ent->client->ps.saber[saber_num].blade[blade_num].length && step < ent->client
				->ps.saber[saber_num].blade[blade_num].lengthOld; step += 12)
			{
				vec3_t blade_point_new;
				vec3_t blade_point_old;
				VectorMA(cur_base1, step, cur_md1, blade_point_old);
				VectorMA(cur_base2, step, curMD2, blade_point_new);
				if (WP_SaberDamageForTrace(ent->s.number, blade_point_old, blade_point_new, base_damage, curMD2,
					qfalse, ent->client->ps.saber[saber_num].type, qtrue, saber_num,
					blade_num))
				{
					hit_wall = qtrue;
				}

				//if hit a saber, shorten rest of traces to match
				if (saberHitFraction < 1.0)
				{
					//adjust muzzle endpoint
					VectorSubtract(mp2, mp1, base_diff);
					VectorMA(mp1, saberHitFraction, base_diff, base_new);
					VectorMA(base_new, ent->client->ps.saber[saber_num].blade[blade_num].length, curMD2, end_new);
					//adjust muzzleDir...
					vec3_t cur_ma1, cur_ma2;
					vectoangles(cur_md1, cur_ma1);
					vectoangles(curMD2, cur_ma2);
					for (xx = 0; xx < 3; xx++)
					{
						md2_ang[xx] = LerpAngle(cur_ma1[xx], cur_ma2[xx], saberHitFraction);
					}
					AngleVectors(md2_ang, curMD2, nullptr, nullptr);
					hit_saber = qtrue;
				}
				if (hit_wall)
				{
					break;
				}
			}
			if (hit_wall || hit_saber)
			{
				break;
			}
			if (curDirFrac >= 1.0f)
			{
				break;
			}
			curDirFrac += dir_inc;
			if (curDirFrac >= 1.0f)
			{
				curDirFrac = 1.0f;
			}
		}

		//do the trace at the end last
		//Special check- adjust for length of blade not being a multiple of 12
		aveLength = (ent->client->ps.saber[saber_num].blade[blade_num].lengthOld + ent->client->ps.saber[saber_num].
			blade[blade_num].length) / 2;
		if (step > aveLength)
		{
			//less dmg if the last interval was not stepsize
			tip_dmg_mod = (stepsize - (step - aveLength)) / stepsize;
		}
		//NOTE: since this is the tip, we do not extrapolate the extra 16
		if (WP_SaberDamageForTrace(ent->s.number, end_old, end_new, tip_dmg_mod * base_damage, md2,
			qfalse, ent->client->ps.saber[saber_num].type, qfalse, saber_num,
			blade_num))
		{
			hit_wall = qtrue;
		}
	}

	if ((saberHitFraction < 1.0f || sabersCrossed >= 0 && sabersCrossed <= 32.0f) && (ent->client->ps.weaponstate ==
		WEAPON_FIRING || ent->client->ps.saberInFlight || G_InCinematicSaberAnim(ent)))
	{
		// The saber (in-hand) hit another saber, mano.
		qboolean in_flight_saber_blocked = qfalse;
		qboolean collision_resolved = qfalse;
		qboolean deflected = qfalse;

		gentity_t* hit_ent = &g_entities[saberHitEntity];
		gentity_t* hit_owner = nullptr;
		int hit_owner_power_level = FORCE_LEVEL_0;

		if (hit_ent)
		{
			hit_owner = hit_ent->owner;
		}
		if (hit_owner && hit_owner->client)
		{
			hit_owner_power_level = PM_PowerLevelForSaberAnim(&hit_owner->client->ps);
		}

		//FIXME: check for certain anims, facing, etc, to make them lock into a sabers-locked pose
		//SEF_LOCKED

		if (ent->client->ps.saberInFlight && saber_num == 0 &&
			ent->client->ps.saber[saber_num].blade[blade_num].active &&
			ent->client->ps.saberEntityNum != ENTITYNUM_NONE &&
			ent->client->ps.saberEntityState != SES_RETURNING)
		{
			//saber was blocked, return it
			in_flight_saber_blocked = qtrue;
		}

		//FIXME: based on strength, position and angle of attack & defense, decide if:
		//	defender and attacker lock sabers
		//	*defender's parry should hold and attack bounces (or deflects, based on angle of sabers)
		//	*defender's parry is somewhat broken and both bounce (or deflect)
		//	*defender's parry is broken and they bounce while attacker's attack deflects or carries through (especially if they're dead)
		//	defender is knocked down and attack goes through

		//Check deflections and broken parries
		if (hit_owner && hit_owner->health > 0 && ent->health > 0 //both are alive
			&& !in_flight_saber_blocked && hit_owner->client && !hit_owner->client->ps.saberInFlight && !ent->client->ps
			.saberInFlight //both have sabers in-hand
			&& ent->client->ps.saberBlocked != BLOCKED_PARRY_BROKEN
			&& ent->client->ps.saberLockTime < level.time
			&& hit_owner->client->ps.saberLockTime < level.time)
		{
			//2 in-hand sabers hit
			//FIXME: defender should not parry or block at all if not in a saber anim... like, if in a roll or knockdown...
			if (base_damage)
			{
				//there is damage involved, not just effects
				qboolean ent_attacking = qfalse;
				qboolean hit_owner_attacking = qfalse;
				qboolean ent_defending = qfalse;
				qboolean hit_owner_defending = qfalse;
				qboolean force_lock = qfalse;

				if (ent->client->NPC_class == CLASS_KYLE && ent->spawnflags & 1 && hit_owner->s.number < MAX_CLIENTS
					|| hit_owner->client->NPC_class == CLASS_KYLE && hit_owner->spawnflags & 1 && ent->s.number <
					MAX_CLIENTS)
				{
					//Player vs. Kyle Boss == lots of saberlocks
					if (Q_irand(1, 5) <= g_saberLockRandomNess->integer)
					{
						force_lock = qtrue;
					}
				}

				if (PM_SaberInAttack(ent->client->ps.saber_move) || pm_saber_in_special_attack(ent->client->ps.torsoAnim))
				{
					ent_attacking = qtrue;
				}
				else if (ent_power_level > FORCE_LEVEL_2)
				{
					//stronger styles count as attacking even if in a transition
					if (PM_SaberInTransitionAny(ent->client->ps.saber_move))
					{
						ent_attacking = qtrue;
					}
				}
				if (PM_SaberInParry(ent->client->ps.saber_move)
					|| ent->client->ps.saber_move == LS_READY)
				{
					ent_defending = qtrue;
				}

				if (ent->client->ps.torsoAnim == BOTH_A1_SPECIAL
					|| ent->client->ps.torsoAnim == BOTH_A2_SPECIAL
					|| ent->client->ps.torsoAnim == BOTH_A3_SPECIAL)
				{
					//parry/block/break-parry bonus for single-style kata moves
					ent_power_level++;
				}
				if (ent_attacking)
				{
					//add twoHanded bonus and breakParryBonus to entPowerLevel here
					//This makes staff too powerful
					if (ent->client->ps.saber[saber_num].saberFlags & SFL_TWO_HANDED)
					{
						ent_power_level++;
					}
					//FIXME: what if dualSabers && both sabers are hitting at same time?
					if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num))
					{
						ent_power_level += ent->client->ps.saber[saber_num].breakParryBonus;
					}
					else if (WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num))
					{
						ent_power_level += ent->client->ps.saber[saber_num].breakParryBonus2;
					}
				}
				else if (ent_defending)
				{
					//add twoHanded bonus and dualSaber bonus and parryBonus to entPowerLevel here
					if (ent->client->ps.saber[saber_num].saberFlags & SFL_TWO_HANDED
						|| ent->client->ps.dualSabers && ent->client->ps.saber[1].Active())
					{
						ent_power_level++;
					}
					//FIXME: what about second saber if dualSabers?
					ent_power_level += ent->client->ps.saber[saber_num].parryBonus;
				}

				if (PM_SaberInAttack(hit_owner->client->ps.saber_move) || pm_saber_in_special_attack(
					hit_owner->client->ps.torsoAnim))
				{
					hit_owner_attacking = qtrue;
				}
				else if (hit_owner_power_level > FORCE_LEVEL_2)
				{
					//stronger styles count as attacking even if in a transition
					if (PM_SaberInTransitionAny(hit_owner->client->ps.saber_move))
					{
						hit_owner_attacking = qtrue;
					}
				}
				if (PM_SaberInParry(hit_owner->client->ps.saber_move)
					|| hit_owner->client->ps.saber_move == LS_READY)
				{
					hit_owner_defending = qtrue;
				}

				if (hit_owner->client->ps.torsoAnim == BOTH_A1_SPECIAL
					|| hit_owner->client->ps.torsoAnim == BOTH_A2_SPECIAL
					|| hit_owner->client->ps.torsoAnim == BOTH_A3_SPECIAL)
				{
					//parry/block/break-parry bonus for single-style kata moves
					hit_owner_power_level++;
				}
				if (hit_owner_attacking)
				{
					//add twoHanded bonus and breakParryBonus to entPowerLevel here
					if (hit_owner->client->ps.saber[0].saberFlags & SFL_TWO_HANDED)
					{
						hit_owner_power_level++;
					}
					hit_owner_power_level += hit_owner->client->ps.saber[0].breakParryBonus;
					if (hit_owner->client->ps.dualSabers && Q_irand(0, 1))
					{
						//FIXME: assumes both sabers are hitting at same time...?
						hit_owner_power_level += 1 + hit_owner->client->ps.saber[1].breakParryBonus;
					}
				}
				else if (hit_owner_defending)
				{
					//add twoHanded bonus and dualSaber bonus and parryBonus to entPowerLevel here
					if (hit_owner->client->ps.saber[0].saberFlags & SFL_TWO_HANDED
						|| hit_owner->client->ps.dualSabers && hit_owner->client->ps.saber[1].Active())
					{
						hit_owner_power_level++;
					}
					hit_owner_power_level += hit_owner->client->ps.saber[0].parryBonus;
					if (hit_owner->client->ps.dualSabers && Q_irand(0, 1))
					{
						//FIXME: assumes both sabers are defending at same time...?
						hit_owner_power_level += 1 + hit_owner->client->ps.saber[1].parryBonus;
					}
				}

				if (PM_SuperBreakLoseAnim(ent->client->ps.torsoAnim)
					|| PM_SuperBreakWinAnim(ent->client->ps.torsoAnim)
					|| PM_SuperBreakLoseAnim(hit_owner->client->ps.torsoAnim)
					|| PM_SuperBreakWinAnim(hit_owner->client->ps.torsoAnim))
				{
					//don't mess with this
					collision_resolved = qtrue;
				}
				else if (ent_attacking
					&& hit_owner_attacking
					&& Q_irand(1, 5) <= g_saberLockRandomNess->integer
					&& (g_debugSaberLock->integer || force_lock
						|| ent_power_level == hit_owner_power_level
						|| ent_power_level > FORCE_LEVEL_2 && hit_owner_power_level > FORCE_LEVEL_2
						|| ent_power_level < FORCE_LEVEL_3 && hit_owner_power_level < FORCE_LEVEL_3 && hit_owner->client
						->ps.forcePowerLevel[FP_SABER_OFFENSE] > FORCE_LEVEL_2 && Q_irand(0, 3)
						|| ent_power_level < FORCE_LEVEL_2 && hit_owner_power_level < FORCE_LEVEL_3 && hit_owner->client
						->ps.forcePowerLevel[FP_SABER_OFFENSE] > FORCE_LEVEL_1 && Q_irand(0, 2)
						|| hit_owner_power_level < FORCE_LEVEL_3 && ent_power_level < FORCE_LEVEL_3 && ent->client->ps.
						forcePowerLevel[FP_SABER_OFFENSE] > FORCE_LEVEL_2 && !Q_irand(0, 1)
						|| hit_owner_power_level < FORCE_LEVEL_2 && ent_power_level < FORCE_LEVEL_3 && ent->client->ps.
						forcePowerLevel[FP_SABER_OFFENSE] > FORCE_LEVEL_1 && !Q_irand(0, 1))
					&& WP_SabersCheckLock(ent, hit_owner))
				{
					collision_resolved = qtrue;
				}
				else if (hit_owner_attacking
					&& ent_defending
					&& Q_irand(1, 5) <= g_saberLockRandomNess->integer
					&& (g_debugSaberLock->integer || force_lock ||
						(ent->client->ps.saber_move != LS_READY || hit_owner_power_level - ent->client->ps.
							forcePowerLevel[FP_SABER_DEFENSE] < Q_irand(-6, 0))
						&& (hit_owner_power_level < FORCE_LEVEL_3 && ent->client->ps.forcePowerLevel[FP_SABER_DEFENSE] >
							FORCE_LEVEL_2 ||
							hit_owner_power_level < FORCE_LEVEL_2 && ent->client->ps.forcePowerLevel[FP_SABER_DEFENSE] >
							FORCE_LEVEL_1 ||
							hit_owner_power_level < FORCE_LEVEL_3 && ent->client->ps.forcePowerLevel[FP_SABER_DEFENSE] >
							FORCE_LEVEL_0 && !Q_irand(
								0, (hit_owner_power_level - ent->client->ps.forcePowerLevel[FP_SABER_DEFENSE] + 1) *
								2)))
					&& WP_SabersCheckLock(hit_owner, ent))
				{
					collision_resolved = qtrue;
				}
				else if (ent_attacking && hit_owner_defending)
				{
					//I'm attacking hit, they're parrying
					auto active_defense = static_cast<qboolean>(hit_owner->s.number || g_saberAutoBlocking->integer ||
						hit_owner->client->ps.saberBlockingTime > level.time);

					if (g_saberLockRandomNess->integer >= 1 && Q_irand(1, 5) <= g_saberLockRandomNess->integer
						&& active_defense
						&& (g_debugSaberLock->integer
							|| force_lock
							|| (hit_owner->client->ps.saber_move != LS_READY || ent_power_level - hit_owner->client->ps.
								forcePowerLevel[FP_SABER_DEFENSE] < Q_irand(-6, 0))
							&& (ent_power_level < FORCE_LEVEL_3 && hit_owner->client->ps.forcePowerLevel[
								FP_SABER_DEFENSE] > FORCE_LEVEL_2
								|| ent_power_level < FORCE_LEVEL_2 && hit_owner->client->ps.forcePowerLevel[
									FP_SABER_DEFENSE] > FORCE_LEVEL_1
									|| ent_power_level < FORCE_LEVEL_3 && hit_owner->client->ps.forcePowerLevel[
										FP_SABER_DEFENSE] > FORCE_LEVEL_0 && !Q_irand(
											0, (ent_power_level - hit_owner->client->ps.forcePowerLevel[FP_SABER_DEFENSE] + 1) *
											2)))
						&& WP_SabersCheckLock(ent, hit_owner))
					{
						collision_resolved = qtrue;
					}
					else if (saberHitFraction < 1.0f)
					{
						//an actual collision
						if (ent_power_level < FORCE_LEVEL_3 && active_defense)
						{
							//strong attacks cannot be deflected
							//based on angle of attack & angle of defensive saber, see if I should deflect off in another dir rather than bounce back
							deflected = WP_GetSaberDeflectionAngle(ent, hit_owner);
							//just so Jedi knows that he was blocked
							ent->client->ps.saberEventFlags |= SEF_BLOCKED;
						}
						//base parry breaks on animation (saber attack level), not FP_SABER_OFFENSE
						if (ent_power_level < FORCE_LEVEL_3
							//&& ent->client->ps.forcePowerLevel[FP_SABER_OFFENSE] < FORCE_LEVEL_3//if you have high saber offense, you cannot have your attack knocked away, regardless of what style you're using?
							//&& hitOwner->client->ps.saber_anim_level != FORCE_LEVEL_5
							&& active_defense
							&& (hit_owner_power_level > FORCE_LEVEL_2 || hit_owner->client->ps.forcePowerLevel[
								FP_SABER_DEFENSE] > FORCE_LEVEL_2 && Q_irand(
									0, hit_owner->client->ps.forcePowerLevel[FP_SABER_OFFENSE])))
						{
							//knockaways can make fast-attacker go into a broken parry anim if the ent is using fast or med (but not Tavion)
							//make me parry
							WP_SaberParry(hit_owner, ent, saber_num, blade_num);
							//turn the parry into a knockaway
							hit_owner->client->ps.saberBounceMove = PM_KnockawayForParry(
								hit_owner->client->ps.saberBlocked);
							//make them go into a broken parry
							ent->client->ps.saberBounceMove = PM_BrokenParryForAttack(ent->client->ps.saber_move);
							ent->client->ps.saberBlocked = BLOCKED_PARRY_BROKEN;
							if (saber_num == 0)
							{
								//FIXME: can only lose right-hand saber for now
								if (!(ent->client->ps.saber[saber_num].saberFlags & SFL_NOT_DISARMABLE)
									&& ent->client->ps.forcePowerLevel[FP_SABER_DEFENSE] < FORCE_LEVEL_2
									//&& (ent->s.number||g_saberRealisticCombat->integer)
									&& Q_irand(0, hit_owner->client->ps.SaberDisarmBonus(0)) > 0
									&& (hit_owner->s.number || g_saberAutoBlocking->integer || !Q_irand(0, 2)))
									//if player defending and autoblocking is on, this is less likely to happen, so don't do the random check
								{
									//knocked the saber right out of his hand! (never happens to player)
									//Get a good velocity to send the saber in based on my parry move
									vec3_t throw_dir;
									if (!PM_VelocityForBlockedMove(&hit_owner->client->ps, throw_dir))
									{
										PM_VelocityForSaberMove(&ent->client->ps, throw_dir);
									}
									WP_SaberLose(ent, throw_dir);
								}
							}
							//just so Jedi knows that he was blocked
							ent->client->ps.saberEventFlags |= SEF_BLOCKED;
#ifndef FINAL_BUILD
							if (d_saberCombat->integer)
							{
								gi.Printf(S_COLOR_RED"%s knockaway %s's attack, new move = %s, anim = %s\n", hitOwner->NPC_type, ent->NPC_type, saber_moveData[ent->client->ps.saberBounceMove].name, anim_table[saber_moveData[ent->client->ps.saberBounceMove].animToUse].name);
							}
#endif
						}
						else if (!active_defense //they're not defending
							|| ent_power_level > FORCE_LEVEL_2 //I hit hard
							&& hit_owner_power_level < ent_power_level
							//they are defending, but their defense strength is lower than my attack...
							|| !deflected && Q_irand(
								0, Q_max(
									0, PM_PowerLevelForSaberAnim(&ent->client->ps, saber_num) - hit_owner->client->ps.
									forcePowerLevel[FP_SABER_DEFENSE])
							/*PM_PowerLevelForSaberAnim( &hitOwner->client->ps )*/) > 0)
						{
							//broke their parry altogether
							if (ent_power_level > FORCE_LEVEL_2 || Q_irand(
								0, Q_max(
									0, ent->client->ps.forcePowerLevel[FP_SABER_OFFENSE] - hit_owner->client->ps.
									forcePowerLevel[FP_SABER_DEFENSE])))
							{
								//chance of continuing with the attack (not bouncing back)
								ent->client->ps.saberEventFlags &= ~SEF_BLOCKED;
								ent->client->ps.saberBounceMove = LS_NONE;
								broken_parry = qtrue;
							}
							//do some time-consuming saber-knocked-aside broken parry anim
							hit_owner->client->ps.saberBlocked = BLOCKED_PARRY_BROKEN;
							hit_owner->client->ps.saberBounceMove = LS_NONE;
							//FIXME: for now, you always disarm the right-hand saber
							if (!(hit_owner->client->ps.saber[0].saberFlags & SFL_NOT_DISARMABLE)
								&& hit_owner->client->ps.forcePowerLevel[FP_SABER_DEFENSE] < FORCE_LEVEL_2
								//&& (ent->s.number||g_saberRealisticCombat->integer)
								&& Q_irand(0, 2 - ent->client->ps.SaberDisarmBonus(blade_num)) <= 0)
							{
								//knocked the saber right out of his hand!
								//get the right velocity for my attack direction
								vec3_t throw_dir;
								PM_VelocityForSaberMove(&ent->client->ps, throw_dir);
								WP_SaberLose(hit_owner, throw_dir);
								if (ent->client->ps.saber_anim_level == SS_STRONG && !Q_irand(0, 3)
									|| ent->client->ps.saber_anim_level == SS_DESANN && !Q_irand(0, 1))
								{
									// a strong attack
									if (WP_BrokenParryKnockDown(hit_owner))
									{
										hit_owner->client->ps.saberBlocked = BLOCKED_NONE;
										hit_owner->client->ps.saberBounceMove = LS_NONE;
									}
								}
							}
							else
							{
								if (ent->client->ps.saber_anim_level == SS_STRONG && !Q_irand(0, 5)
									|| ent->client->ps.saber_anim_level == SS_DESANN && !Q_irand(0, 3))
								{
									// a strong attack
									if (WP_BrokenParryKnockDown(hit_owner))
									{
										hit_owner->client->ps.saberBlocked = BLOCKED_NONE;
										hit_owner->client->ps.saberBounceMove = LS_NONE;
									}
								}
							}
#ifndef FINAL_BUILD
							if (d_saberCombat->integer)
							{
								if (ent->client->ps.saberEventFlags & SEF_BLOCKED)
								{
									gi.Printf(S_COLOR_RED"%s parry broken (bounce/deflect)!\n", hitOwner->targetname);
								}
								else
								{
									gi.Printf(S_COLOR_RED"%s parry broken (follow-through)!\n", hitOwner->targetname);
								}
							}
#endif
						}
						else
						{
							//just a parry, possibly the hitOwner can knockaway the ent
							WP_SaberParry(hit_owner, ent, saber_num, blade_num);
							if (PM_SaberInBounce(ent->client->ps.saber_move) //FIXME: saber_move not set until pmove!
								&& active_defense
								&& hit_owner->client->ps.saber_anim_level != SS_FAST
								//&& hitOwner->client->ps.saber_anim_level != FORCE_LEVEL_5
								&& hit_owner->client->ps.forcePowerLevel[FP_SABER_DEFENSE] > FORCE_LEVEL_2)
							{
								//attacker bounced off, and defender has ability to do knockaways, so do one unless we're using fast attacks
								//turn the parry into a knockaway
								hit_owner->client->ps.saberBounceMove = PM_KnockawayForParry(
									hit_owner->client->ps.saberBlocked);
							}
							else if (ent->client->ps.saber_anim_level == SS_STRONG && !Q_irand(0, 6)
								|| ent->client->ps.saber_anim_level == SS_DESANN && !Q_irand(0, 3))
							{
								// a strong attack can sometimes do a knockdown
								//HMM... maybe only if they're moving backwards?
								if (WP_BrokenParryKnockDown(hit_owner))
								{
									hit_owner->client->ps.saberBlocked = BLOCKED_NONE;
									hit_owner->client->ps.saberBounceMove = LS_NONE;
								}
							}
						}
						collision_resolved = qtrue;
					}
				}
				else
				{
					//some other kind of in-hand saber collision
				}
			}
		}
		else
		{
			//some kind of in-flight collision
		}

		if (saberHitFraction < 1.0f)
		{
			if (!collision_resolved && base_damage)
			{
				//some other kind of in-hand saber collision
				//handle my reaction
				if (!ent->client->ps.saberInFlight
					&& ent->client->ps.saberLockTime < level.time)
				{
					//my saber is in hand
					if (ent->client->ps.saberBlocked != BLOCKED_PARRY_BROKEN)
					{
						if (PM_SaberInAttack(ent->client->ps.saber_move) ||
							pm_saber_in_special_attack(ent->client->ps.torsoAnim) ||
							ent_power_level > FORCE_LEVEL_2 && !PM_SaberInIdle(ent->client->ps.saber_move) && !
							PM_SaberInParry(ent->client->ps.saber_move) && !PM_SaberInReflect(ent->client->ps.saber_move))
						{
							//in the middle of attacking
							if (ent_power_level < FORCE_LEVEL_3 && hit_owner->health > 0)
							{
								//don't deflect/bounce in strong attack or when enemy is dead
								WP_GetSaberDeflectionAngle(ent, hit_owner);
								ent->client->ps.saberEventFlags |= SEF_BLOCKED;
								//since it was blocked/deflected, take away any damage done
								//FIXME: what if the damage was done before the parry?
								wp_saber_clear_damage_for_ent_num(ent, hit_owner->s.number, saber_num, blade_num);
							}
						}
						else
						{
							//saber collided when not attacking, parry it
							//since it was blocked/deflected, take away any damage done
							//FIXME: what if the damage was done before the parry?
							wp_saber_clear_damage_for_ent_num(ent, hit_owner->s.number, saber_num, blade_num);
							/*
							if ( ent->s.number || g_saberAutoBlocking->integer || ent->client->ps.saberBlockingTime > level.time )
							{//either an NPC or a player who has blocking
								if ( !PM_SaberInTransitionAny( ent->client->ps.saber_move ) && !PM_SaberInBounce( ent->client->ps.saber_move ) )
								{//I'm not attacking, in transition or in a bounce, so play a parry
									//just so Jedi knows that he parried something
									WP_SaberBlockNonRandom( ent, saberHitLocation, qfalse );
								}
								ent->client->ps.saberEventFlags |= SEF_PARRIED;
							}
							*/
						}
					}
					else
					{
						//since it was blocked/deflected, take away any damage done
						//FIXME: what if the damage was done before the parry?
						wp_saber_clear_damage_for_ent_num(ent, hit_owner->s.number, saber_num, blade_num);
					}
				}
				else
				{
					//nothing happens to *me* when my inFlight saber hits something
				}
				//handle their reaction
				if (hit_owner
					&& hit_owner->health > 0
					&& hit_owner->client
					&& !hit_owner->client->ps.saberInFlight
					&& hit_owner->client->ps.saberLockTime < level.time)
				{
					//their saber is in hand
					if (PM_SaberInAttack(hit_owner->client->ps.saber_move) || pm_saber_in_special_attack(
						hit_owner->client->ps.torsoAnim) ||
						hit_owner->client->ps.saber_anim_level > SS_MEDIUM && !
						PM_SaberInIdle(hit_owner->client->ps.saber_move) && !
						PM_SaberInParry(hit_owner->client->ps.saber_move) && !PM_SaberInReflect(
							hit_owner->client->ps.saber_move))
					{
						//in the middle of attacking
						/*
						if ( hitOwner->client->ps.saber_anim_level < SS_STRONG )
						{//don't deflect/bounce in strong attack
							WP_GetSaberDeflectionAngle( hitOwner, ent );
							hitOwner->client->ps.saberEventFlags |= SEF_BLOCKED;
						}
						*/
					}
					else
					{
						//saber collided when not attacking, parry it
						if (!PM_SaberInBrokenParry(hit_owner->client->ps.saber_move))
						{
							//not currently in a broken parry
							if (!WP_SaberParry(hit_owner, ent, saber_num, blade_num))
							{
								//FIXME: hitOwner can't parry, do some time-consuming saber-knocked-aside broken parry anim?
								//hitOwner->client->ps.saberBlocked = BLOCKED_PARRY_BROKEN;
							}
						}
					}
				}
				else
				{
					//nothing happens to *hitOwner* when their inFlight saber hits something
				}
			}

			//collision must have been handled by now
			//Set the blocked attack bounce value in saberBlocked so we actually play our saberBounceMove anim
			if (ent->client->ps.saberEventFlags & SEF_BLOCKED)
			{
				if (ent->client->ps.saberBlocked != BLOCKED_PARRY_BROKEN)
				{
					ent->client->ps.saberBlocked = BLOCKED_ATK_BOUNCE;
				}
			}
		}

		if (saberHitFraction < 1.0f || collision_resolved)
		{
			//either actually hit or locked
			if (ent->client->ps.saberLockTime < level.time)
			{
				if (in_flight_saber_blocked)
				{
					//FIXME: never hear this sound
					WP_SaberBounceSound(ent, &g_entities[ent->client->ps.saberEntityNum], 0, 0);
				}
				else
				{
					if (deflected)
					{
						WP_SaberBounceSound(ent, nullptr, saber_num, blade_num);
					}
					else
					{
						WP_SaberBlockSound(ent, saber_num, blade_num);
					}
				}
				if (!g_saberNoEffects)
				{
					WP_SaberBlockEffect(ent, saber_num, blade_num, saberHitLocation, saberHitNormal, qfalse);
				}
			}
			// Set the little screen flash - only when an attack is blocked
			if (!g_noClashFlare)
			{
				g_saberFlashTime = level.time - 50;
				VectorCopy(saberHitLocation, g_saberFlashPos);
			}
		}

		if (saberHitFraction < 1.0f)
		{
			if (in_flight_saber_blocked)
			{
				//we threw a saber and it was blocked, do any effects, etc.
				int knock_away = 5;
				if (hit_ent
					&& hit_owner
					&& hit_owner->client
					&& (PM_SaberInAttack(hit_owner->client->ps.saber_move) ||
						pm_saber_in_special_attack(hit_owner->client->ps.torsoAnim) || PM_SpinningSaberAnim(
							hit_owner->client->ps.torsoAnim)))
				{
					//if hit someone who was in an attack or spin anim, more likely to have in-flight saber knocked away
					if (hit_owner_power_level > FORCE_LEVEL_2)
					{
						//strong attacks almost always knock it aside!
						knock_away = 1;
					}
					else
					{
						//33% chance
						knock_away = 2;
					}
					knock_away -= hit_owner->client->ps.SaberDisarmBonus(0);
				}
				if (Q_irand(0, knock_away) <= 0 || //random
					hit_owner
					&& hit_owner->client
					&& hit_owner->NPC
					&& hit_owner->NPC->aiFlags & NPCAI_BOSS_CHARACTER
					//or if blocked by a Boss character FIXME: or base on defense level?
					) //FIXME: player should not auto-block a flying saber, let him override the parry with an attack to knock the saber from the air, rather than this random chance
				{
					//knock it aside and turn it off
					if (!g_saberNoEffects)
					{
						if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
							&& ent->client->ps.saber[saber_num].hitOtherEffect)
						{
							G_PlayEffect(ent->client->ps.saber[saber_num].hitOtherEffect, saberHitLocation,
								saberHitNormal);
						}
						else if (WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
							&& ent->client->ps.saber[saber_num].hitOtherEffect2)
						{
							G_PlayEffect(ent->client->ps.saber[saber_num].hitOtherEffect2, saberHitLocation,
								saberHitNormal);
						}
						else
						{
							G_PlayEffect("saber/saber_cut", saberHitLocation, saberHitNormal);
						}
					}
					if (hit_ent)
					{
						vec3_t newDir;

						VectorSubtract(g_entities[ent->client->ps.saberEntityNum].currentOrigin, hit_ent->currentOrigin,
							newDir);
						VectorNormalize(newDir);
						G_ReflectMissile_JKA(ent, &g_entities[ent->client->ps.saberEntityNum], newDir);
					}
					jedi_play_deflect_sound(hit_owner);
					WP_SaberDrop(ent, &g_entities[ent->client->ps.saberEntityNum]);
				}
				else
				{
					if (!Q_irand(0, 2) && hit_ent)
					{
						vec3_t new_dir;
						VectorSubtract(g_entities[ent->client->ps.saberEntityNum].currentOrigin, hit_ent->currentOrigin,
							new_dir);
						VectorNormalize(new_dir);
						G_ReflectMissile_JKA(ent, &g_entities[ent->client->ps.saberEntityNum], new_dir);
					}
					WP_SaberReturn(ent, &g_entities[ent->client->ps.saberEntityNum]);
				}
			}
		}
	}

	if (ent->client->ps.saberLockTime > level.time)
	{
		if (ent->s.number < ent->client->ps.saberLockEnemy
			&& !Q_irand(0, 3))
		{
			//need to make some kind of effect
			vec3_t hit_norm = { 0, 0, 1 };
			if (wp_sabers_intersection(ent, &g_entities[ent->client->ps.saberLockEnemy], g_saberFlashPos))
			{
				if (Q_irand(0, 10))
				{
					if (!g_saberNoEffects)
					{
						WP_SaberBlockEffect(ent, saber_num, blade_num, g_saberFlashPos, hit_norm, qfalse);
					}
				}
				else
				{
					if (!g_noClashFlare)
					{
						g_saberFlashTime = level.time - 50;
					}
					if (!g_saberNoEffects)
					{
						WP_SaberBlockEffect(ent, saber_num, blade_num, g_saberFlashPos, hit_norm, qtrue); //jka
					}
				}
				//WP_SaberBlockSound(ent, 0, 0);
				G_Sound(ent, G_SoundIndex(va("sound/weapons/saber/saberlock%d.mp3", Q_irand(1, 9))));
			}
		}
	}
	else
	{
		if (hit_wall
			&& (ent->client->ps.saber[saber_num].saberFlags & SFL_BOUNCE_ON_WALLS || g_SaberBounceOnWalls->integer)
			&& (PM_SaberInAttackPure(ent->client->ps.saber_move) || ent->client->ps.saber_move == LS_A_JUMP_T__B_))
		{
			//bounce off walls
			//do anim
			ent->client->ps.saberBlocked = BLOCKED_ATK_BOUNCE;
			ent->client->ps.saberBounceMove = LS_D1_BR + (saber_moveData[ent->client->ps.saber_move].startQuad - Q_BR);
			//do bounce sound & force feedback
			WP_SaberBounceOnWallSound(ent, saber_num, blade_num);
			//do hit effect
			if (!g_saberNoEffects)
			{
				if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
					&& ent->client->ps.saber[saber_num].hitOtherEffect)
				{
					G_PlayEffect(ent->client->ps.saber[saber_num].hitOtherEffect, saberHitLocation, saberHitNormal);
				}
				else if (WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
					&& ent->client->ps.saber[saber_num].hitOtherEffect2)
				{
					G_PlayEffect(ent->client->ps.saber[saber_num].hitOtherEffect2, saberHitLocation, saberHitNormal);
				}
				else
				{
					G_PlayEffect("saber/saber_cut", saberHitLocation, saberHitNormal);
				}
			}
			//do radius damage/knockback, if any
			if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num))
			{
				WP_SaberRadiusDamage(ent, saberHitLocation, ent->client->ps.saber[saber_num].splashRadius,
					ent->client->ps.saber[saber_num].splashDamage,
					ent->client->ps.saber[saber_num].splashKnockback);
			}
			else
			{
				WP_SaberRadiusDamage(ent, saberHitLocation, ent->client->ps.saber[saber_num].splashRadius2,
					ent->client->ps.saber[saber_num].splashDamage2,
					ent->client->ps.saber[saber_num].splashKnockback2);
			}
		}
	}

	if (WP_SaberApplyDamageJKA(ent, base_damage, base_d_flags, broken_parry, saber_num, blade_num,
		static_cast<qboolean>(saber_num == 0 && ent->client->ps.saberInFlight)))
	{
		//actually did damage to something
#ifndef FINAL_BUILD
		if (d_saberCombat->integer)
		{
			gi.Printf("base damage was %4.2f\n", baseDamage);
		}
#endif
		WP_SaberHitSound(ent, saber_num, blade_num);
	}

	if (hit_wall)
	{
		//just so Jedi knows that he hit a wall
		ent->client->ps.saberEventFlags |= SEF_HITWALL;
		if (ent->s.number == 0)
		{
			AddSoundEvent(ent, ent->currentOrigin, 128, AEL_DISCOVERED, qfalse, qtrue);
			//FIXME: is this impact on ground or not?
			AddSightEvent(ent, ent->currentOrigin, 256, AEL_DISCOVERED, 50);
		}
	}
}

//////SERENITYJEDIENGINE MODE //////////////////////////////////////////////////////////////////////////

void sab_beh_animate_heavy_slow_bounce_attacker(gentity_t* attacker)
{
	G_StaggerAttacker(attacker);
}

static void SabBeh_AnimateHeavySlowBounce(gentity_t* self, gentity_t* inflictor)
{
	self->client->ps.userInt3 |= 1 << FLAG_SLOWBOUNCE;
	self->client->ps.userInt3 |= 1 << FLAG_OLDSLOWBOUNCE;

	G_AddEvent(self, Q_irand(EV_PUSHED1, EV_PUSHED3), 0);
	G_AddEvent(inflictor, Q_irand(EV_DEFLECT1, EV_DEFLECT3), 0);

	self->client->ps.saberBounceMove = PM_SaberBounceForAttack(self->client->ps.saber_move);
	self->client->ps.saberBlocked = BLOCKED_PARRY_BROKEN;
}

void SabBeh_AnimateSlowBounce(gentity_t* self)
{
	self->client->ps.userInt3 |= 1 << FLAG_SLOWBOUNCE;
	self->client->ps.userInt3 |= 1 << FLAG_OLDSLOWBOUNCE;

	G_AddEvent(self, Q_irand(EV_PUSHED1, EV_PUSHED3), 0);

	self->client->ps.saberBounceMove = PM_BrokenParryForAttack(self->client->ps.saber_move);
	self->client->ps.saberBlocked = BLOCKED_PARRY_BROKEN;
}

void SabBeh_AnimateSmallBounce(const gentity_t* self)
{
	self->client->ps.userInt3 |= 1 << FLAG_SLOWBOUNCE;

	self->client->ps.saberBounceMove = PM_SaberBounceForAttack(self->client->ps.saber_move);
	self->client->ps.saberBlocked = BLOCKED_ATK_BOUNCE;
}

static int SabBeh_AnimateMassiveDualSlowBounce(const int anim)
{
	switch (anim)
	{
	case BOTH_H1_S1_T_:
		return BOTH_H6_S6_T_;
	case BOTH_H1_S1_TR:
		return BOTH_H6_S6_TR;
	case BOTH_H1_S1_TL:
		return BOTH_H6_S6_TL;
	case BOTH_H1_S1_BR:
		return BOTH_H6_S6_BR;
	case BOTH_H1_S1_BL:
		return BOTH_H6_S6_BL;
	case BOTH_H1_S1_B_:
		return BOTH_H6_S6_B_;
	default:;
	}
	return anim;
}

static int SabBeh_AnimateMassiveStaffSlowBounce(const int anim)
{
	switch (anim)
	{
	case BOTH_H1_S1_T_:
		return BOTH_H7_S7_T_;
	case BOTH_H1_S1_TR:
		return BOTH_H7_S7_TR;
	case BOTH_H1_S1_TL:
		return BOTH_H7_S7_TL;
	case BOTH_H1_S1_BR:
		return BOTH_H7_S7_BR;
	case BOTH_H1_S1_BL:
		return BOTH_H7_S7_BL;
	case BOTH_H1_S1_B_:
		return BOTH_H7_S7_B_;
	default:;
	}
	return anim;
}

void G_Stumble(gentity_t* hit_ent)
{
	if (PM_SaberInBashedAnim(hit_ent->client->ps.torsoAnim))
	{
		return;
	}

	if (PM_InGetUp(&hit_ent->client->ps) || PM_InForceGetUp(&hit_ent->client->ps))
	{
		return;
	}

	const int anim_choice = irand(0, 6);
	// this could possibly be based on animation done when the clash happend, but this should do for now.
	int use_anim;

	switch (anim_choice)
	{
	default:
	case 0:
		use_anim = BOTH_BASHED1;
		break;
	case 1:
		use_anim = BOTH_PAIN3;
		break;
	case 2:
		use_anim = BOTH_PAIN2;
		break;
	case 3:
		use_anim = BOTH_PAIN15;
		break;
	case 4:
		use_anim = BOTH_PAIN12;
		break;
	case 5:
		use_anim = BOTH_PAIN5;
		break;
	case 6:
		use_anim = BOTH_PAIN7;
		break;
	}

	if (PM_SaberInKata(static_cast<saber_moveName_t>(hit_ent->client->ps.saber_move)))
	{
		NPC_SetAnim(hit_ent, SETANIM_BOTH, use_anim, SETANIM_AFLAG_PACE);
	}
	else
	{
		NPC_SetAnim(hit_ent, SETANIM_TORSO, use_anim, SETANIM_AFLAG_PACE);
	}

	if (PM_SaberInBashedAnim(hit_ent->client->ps.torsoAnim))
	{
		hit_ent->client->ps.saber_move = LS_NONE;
		hit_ent->client->ps.saberBlocked = BLOCKED_NONE;
		hit_ent->client->ps.weaponTime = hit_ent->client->ps.torsoAnimTimer;
		hit_ent->client->MassiveBounceAnimTime = hit_ent->client->ps.torsoAnimTimer + level.time;
	}
}

void G_Stagger(gentity_t* hit_ent)
{
	if (PM_InGetUp(&hit_ent->client->ps) || PM_InForceGetUp(&hit_ent->client->ps) || hit_ent->client->ps.saberInFlight)
	{
		return;
	}

	const int anim_choice = irand(0, 6);
	// this could possibly be based on animation done when the clash happend, but this should do for now.
	int use_anim;

	switch (anim_choice)
	{
	default:
	case 0:
		use_anim = BOTH_BASHED1;
		break;
	case 1:
		use_anim = BOTH_H1_S1_T_;
		break;
	case 2:
		use_anim = BOTH_H1_S1_TR;
		break;
	case 3:
		use_anim = BOTH_H1_S1_TL;
		break;
	case 4:
		use_anim = BOTH_H1_S1_BL;
		break;
	case 5:
		use_anim = BOTH_H1_S1_B_;
		break;
	case 6:
		use_anim = BOTH_H1_S1_BR;
		break;
	}

	if (PM_SaberInKata(static_cast<saber_moveName_t>(hit_ent->client->ps.saber_move)))
	{
		NPC_SetAnim(hit_ent, SETANIM_BOTH, use_anim, SETANIM_AFLAG_PACE);
	}
	else
	{
		NPC_SetAnim(hit_ent, SETANIM_TORSO, use_anim, SETANIM_AFLAG_PACE);
	}

	if (PM_SaberInMassiveBounce(hit_ent->client->ps.torsoAnim))
	{
		hit_ent->client->ps.saber_move = LS_NONE;
		hit_ent->client->ps.saberBlocked = BLOCKED_NONE;
		hit_ent->client->ps.weaponTime = hit_ent->client->ps.torsoAnimTimer;
		hit_ent->client->MassiveBounceAnimTime = hit_ent->client->ps.torsoAnimTimer + level.time;
	}

	if (hit_ent->client->ps.saber_anim_level == SS_DUAL)
	{
		SabBeh_AnimateMassiveDualSlowBounce(use_anim);
	}
	else if (hit_ent->client->ps.saber_anim_level == SS_STAFF)
	{
		SabBeh_AnimateMassiveStaffSlowBounce(use_anim);
	}

	if (d_combatinfo->integer || g_DebugSaberCombat->integer)
	{
		gi.Printf("Hit Ent was forced in to a stagger\n");
	}
}

void G_StaggerAttacker(gentity_t* atk)
{
	if (PM_InGetUp(&atk->client->ps) || PM_InForceGetUp(&atk->client->ps) || atk->client->ps.saberInFlight)
	{
		return;
	}

	const int anim_choice = irand(0, 6);
	// this could possibly be based on animation done when the clash happend, but this should do for now.
	int use_anim;

	switch (anim_choice)
	{
	default:
	case 0:
		use_anim = BOTH_BASHED1;
		break;
	case 1:
		use_anim = BOTH_H1_S1_T_;
		break;
	case 2:
		use_anim = BOTH_H1_S1_TR;
		break;
	case 3:
		use_anim = BOTH_H1_S1_TL;
		break;
	case 4:
		use_anim = BOTH_H1_S1_BL;
		break;
	case 5:
		use_anim = BOTH_H1_S1_B_;
		break;
	case 6:
		use_anim = BOTH_H1_S1_BR;
		break;
	}

	if (PM_SaberInKata(static_cast<saber_moveName_t>(atk->client->ps.saber_move)))
	{
		NPC_SetAnim(atk, SETANIM_BOTH, use_anim, SETANIM_AFLAG_PACE);
	}
	else
	{
		NPC_SetAnim(atk, SETANIM_TORSO, use_anim, SETANIM_AFLAG_PACE);
	}

	if (PM_SaberInMassiveBounce(atk->client->ps.torsoAnim))
	{
		atk->client->ps.saber_move = LS_NONE;
		atk->client->ps.saberBlocked = BLOCKED_NONE;
		atk->client->ps.weaponTime = atk->client->ps.torsoAnimTimer;
		atk->client->MassiveBounceAnimTime = atk->client->ps.torsoAnimTimer + level.time;
	}

	if (atk->client->ps.saber_anim_level == SS_DUAL)
	{
		SabBeh_AnimateMassiveDualSlowBounce(use_anim);
	}
	else if (atk->client->ps.saber_anim_level == SS_STAFF)
	{
		SabBeh_AnimateMassiveStaffSlowBounce(use_anim);
	}
}

void G_MawStagger(gentity_t* hit_ent)
{
	const int anim_choice = irand(0, 6);
	// this could possibly be based on animation done when the clash happend, but this should do for now.
	int use_anim;

	switch (anim_choice)
	{
	default:
	case 0:
		use_anim = BOTH_BASHED1;
		break;
	case 1:
		use_anim = BOTH_H1_S1_T_;
		break;
	case 2:
		use_anim = BOTH_H1_S1_TR;
		break;
	case 3:
		use_anim = BOTH_H1_S1_TL;
		break;
	case 4:
		use_anim = BOTH_H1_S1_BL;
		break;
	case 5:
		use_anim = BOTH_H1_S1_B_;
		break;
	case 6:
		use_anim = BOTH_H1_S1_BR;
		break;
	}

	if (PM_SaberInKata(static_cast<saber_moveName_t>(hit_ent->client->ps.saber_move)))
	{
		NPC_SetAnim(hit_ent, SETANIM_BOTH, use_anim, SETANIM_AFLAG_PACE);
	}
	else
	{
		NPC_SetAnim(hit_ent, SETANIM_TORSO, use_anim, SETANIM_AFLAG_PACE);
	}

	if (PM_SaberInMassiveBounce(hit_ent->client->ps.torsoAnim))
	{
		hit_ent->client->ps.saber_move = LS_NONE;
		hit_ent->client->ps.saberBlocked = BLOCKED_NONE;
		hit_ent->client->ps.weaponTime = hit_ent->client->ps.torsoAnimTimer;
		hit_ent->client->MassiveBounceAnimTime = hit_ent->client->ps.torsoAnimTimer + level.time;
	}

	if (hit_ent->client->ps.saber_anim_level == SS_DUAL)
	{
		SabBeh_AnimateMassiveDualSlowBounce(use_anim);
	}
	else if (hit_ent->client->ps.saber_anim_level == SS_STAFF)
	{
		SabBeh_AnimateMassiveStaffSlowBounce(use_anim);
	}

	if (d_combatinfo->integer || g_DebugSaberCombat->integer)
	{
		gi.Printf("Hit Ent was forced in to a stagger\n");
	}
}

void SabBeh_SaberShouldBeDisarmedBlocker(gentity_t* blocker, const int saber_num)
{
	if (saber_num == 0 && !in_camera)
	{
		//can only lose right-hand saber for now
		if (!(blocker->client->ps.saber[saber_num].saberFlags & SFL_NOT_DISARMABLE))
		{
			//knocked the saber right out of his hand!
			vec3_t throw_dir = { 0, 0, 350 };

			WP_SaberDisarmed(blocker, throw_dir);
		}
	}
}

void sab_beh_saber_should_be_disarmed_attacker(gentity_t* attacker, const int saber_num)
{
	if (saber_num == 0 && !in_camera)
	{
		//can only lose right-hand saber for now
		if (!(attacker->client->ps.saber[saber_num].saberFlags & SFL_NOT_DISARMABLE))
		{
			//knocked the saber right out of his hand!
			vec3_t throw_dir = { 0, 0, 350 };

			WP_SaberDisarmed(attacker, throw_dir);
		}
	}
}

void sab_beh_add_balance(const gentity_t* self, int amount)
{
	if (!WalkCheck(self))
	{
		//running or moving very fast, can't balance as well
		if (amount > 0)
		{
			amount *= 2;
		}
		else
		{
			amount = amount * .5f;
		}
	}

	self->client->ps.saberFatigueChainCount += amount;

	if (self->client->ps.saberFatigueChainCount < MISHAPLEVEL_NONE)
	{
		self->client->ps.saberFatigueChainCount = MISHAPLEVEL_NONE;
	}
	else if (self->client->ps.saberFatigueChainCount >= MISHAPLEVEL_OVERLOAD)
	{
		self->client->ps.saberFatigueChainCount = MISHAPLEVEL_MAX;
	}
}

void wp_saber_damage_trace_amd(gentity_t* ent, int saber_num, int blade_num)
{
	vec3_t mp1;
	vec3_t mp2;
	vec3_t md1;
	vec3_t md2;
	vec3_t base_old;
	vec3_t base_new;
	vec3_t end_old;
	vec3_t end_new;
	float base_damage;
	int base_d_flags = 0;
	qboolean hit_wall = qfalse;
	qboolean broken_parry = qfalse;
	qboolean saber_in_special = pm_saber_in_special_attack(ent->client->ps.torsoAnim);

	for (int& ven : victimEntityNum)
	{
		ven = ENTITYNUM_NONE;
	}
	memset(totalDmg, 0, sizeof totalDmg);
	memset(dmgDir, 0, sizeof dmgDir);
	memset(dmgNormal, 0, sizeof dmgNormal);
	memset(dmgSpot, 0, sizeof dmgSpot);
	memset(dmgFraction, 0, sizeof dmgFraction);
	memset(hit_loc, HL_NONE, sizeof hit_loc);
	memset(hitDismemberLoc, HL_NONE, sizeof hitDismemberLoc);
	memset(hitDismember, qfalse, sizeof hitDismember);
	numVictims = 0;
	VectorClear(saberHitLocation);
	VectorClear(saberHitNormal);
	saberHitFraction = 1.0; // Closest saber hit.  The saber can do no damage past this point.
	saberHitEntity = ENTITYNUM_NONE;
	sabersCrossed = -1;

	if (!ent->client)
	{
		return;
	}

	if (!ent->s.number)
	{
		//player never uses these
		if (PM_SaberInAttack(ent->client->ps.saber_move))
		{
			//make sure code knows player is attacking and not doing any kind of block
			ent->client->ps.saberEventFlags &= ~SEF_PARRIED;
			ent->client->ps.saberEventFlags &= ~SEF_DEFLECTED;
		}
		ent->client->ps.saberEventFlags &= ~SEF_EVENTS;
	}

	if (ent->client->ps.saber[saber_num].blade[blade_num].length <= 1) //cen get down to 1 when in a wall
	{
		//saber is not on
		return;
	}

	if (VectorCompare(ent->client->renderInfo.muzzlePointOld, vec3_origin) || VectorCompare(
		ent->client->renderInfo.muzzleDirOld, vec3_origin))
	{
		//just started up the saber?
		return;
	}

	int saber_contents = 0;

	if (!(ent->client->ps.saber[saber_num].saberFlags & SFL_ON_IN_WATER))
	{
		//saber can't stay on underwater
		saber_contents = gi.pointcontents(ent->client->renderInfo.muzzlePoint, ent->client->ps.saberEntityNum);
	}
	if (saber_contents & CONTENTS_WATER ||
		saber_contents & CONTENTS_SLIME ||
		saber_contents & CONTENTS_LAVA)
	{
		ent->client->ps.saber[saber_num].blade[blade_num].active = qfalse;
		return;
	}
	if (!g_saberNoEffects && gi.WE_IsOutside(ent->client->renderInfo.muzzlePoint))
	{
		float chance_of_fizz = gi.WE_GetChanceOfSaberFizz();
		if (chance_of_fizz > 0 && Q_flrand(0.0f, 1.0f) < chance_of_fizz)
		{
			vec3_t end;
			VectorMA(ent->client->ps.saber[saber_num].blade[blade_num].muzzlePoint,
				ent->client->ps.saber[saber_num].blade[blade_num].length * Q_flrand(0, 1),
				ent->client->ps.saber[saber_num].blade[blade_num].muzzleDir, end);
			G_PlayEffect("saber/fizz", end);
		}
	}

	int ent_power_level = 0;
	int style_power_modifier = 0;
	int style_power_level = PM_PowerLevelForSaberAnim(&ent->client->ps, saber_num);

	switch (style_power_level) // check what the saber style is and set power modifier accordingly
	{
	case 1:
		style_power_modifier = -2;
		break;
	case 2:
		style_power_modifier = -1;
		break;
	case 3:
		style_power_modifier = 0;
		break;
	case 4:
		style_power_modifier = 1;
		break;
	case 5: //special attacks count as this in bg_panimate
		style_power_modifier = 2;
		break;
	default:;
	}

	if (PM_SaberInTransitionAny(ent->client->ps.saber_move))
		// if in a transition that still counts as attacking for stronger styles, but this is so you're not as strong quite as a regular slash
	{
		style_power_modifier -= 2;
	}

	if (ent->client->NPC_class == CLASS_SABER_DROID)
	{
		ent_power_level = SaberDroid_PowerLevelForSaberAnim(ent);
	}
	else if (!ent->s.number && ent->client->ps.forcePowersActive & 1 << FP_SPEED)
	{
		ent_power_level += 1 * ent->client->ps.forcePowerLevel[FP_SPEED];
	}
	else
	{
		ent_power_level = 2 * ent->client->ps.forcePowerLevel[FP_SABER_OFFENSE] + style_power_modifier + 1;
	}

	if (ent_power_level)
	{
		if (ent->client->ps.forceRageRecoveryTime > level.time)
		{
			ent_power_level -= 2;
		}
		else if (ent->client->ps.forcePowersActive & 1 << FP_RAGE)
		{
			ent_power_level += ent->client->ps.forcePowerLevel[FP_RAGE] + 1;
		}
	}

	if (ent->client->ps.saberInFlight)
	{
		//flying sabers are much more deadly
		//unless you're dead
		if (ent->health <= 0 && g_saberRealisticCombat->integer < 2)
		{
			//so enemies don't keep trying to block it
			return;
		}
		//or unless returning
		if (ent->client->ps.saberEntityState == SES_RETURNING
			&& !(ent->client->ps.saber[0].saberFlags & SFL_RETURN_DAMAGE))
		{
			//special case, since we're returning, chances are if we hit something
			base_damage = 0.1f;
		}
		else
		{
			if (!ent->s.number)
			{
				//cheat for player
				base_damage = 5.0f;
			}
			else
			{
				base_damage = 2.5f;
			}
		}
		//Use old to current since can't predict it
		VectorCopy(ent->client->ps.saber[saber_num].blade[blade_num].muzzlePointOld, mp1);
		VectorCopy(ent->client->ps.saber[saber_num].blade[blade_num].muzzleDirOld, md1);
		VectorCopy(ent->client->ps.saber[saber_num].blade[blade_num].muzzlePoint, mp2);
		VectorCopy(ent->client->ps.saber[saber_num].blade[blade_num].muzzleDir, md2);
	}
	else
	{
		if (ent->client->ps.torsoAnim == BOTH_A7_HILT ||
			ent->client->ps.torsoAnim == BOTH_SLAP_L ||
			ent->client->ps.torsoAnim == BOTH_SLAP_R)
		{
			//no effects, no damage
			return;
		}
		if (ent->client->ps.torsoAnim == BOTH_CIN_70)
		{
			//no effects, no damage
			return;
		}
		if (ent->client->ps.torsoAnim == BOTH_CIN_50)
		{
			//no effects, no damage
			return;
		}
		if (ent->client->ps.torsoAnim == BOTH_MD_CIN_1)
		{
			//no effects, no damage
			return;
		}
		if (G_InCinematicSaberAnim(ent))
		{
			//baseDFlags = DAMAGE_NO_KILL;
			base_damage = 0.1f;
		}
		else if (ent->client->ps.saber_move == LS_READY && !pm_saber_in_special_attack(ent->client->ps.torsoAnim))
		{
			//just do effects
			if (g_saberRealisticCombat->integer < 2 && ent->health >= 0)
			{
				//don't kill with this hit
				//baseDFlags = DAMAGE_NO_KILL;
			}
			if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
				&& ent->client->ps.saber[saber_num].saberFlags2 & SFL2_NO_IDLE_EFFECT
				|| WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
				&& ent->client->ps.saber[saber_num].saberFlags2 & SFL2_NO_IDLE_EFFECT2)
			{
				//do nothing at all when idle
				return;
			}
			base_damage = 0;
		}
		else if (ent->client->ps.saberLockTime > level.time)
		{
			//just do effects
			if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
				&& ent->client->ps.saber[saber_num].saberFlags2 & SFL2_NO_IDLE_EFFECT
				|| WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
				&& ent->client->ps.saber[saber_num].saberFlags2 & SFL2_NO_IDLE_EFFECT2)
			{
				//do nothing at all when idle
				return;
			}
			base_damage = 0;
		}
		else if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
			&& ent->client->ps.saber[saber_num].damageScale <= 0.0f
			&& ent->client->ps.saber[saber_num].knockbackScale <= 0.0f)
		{
			//this blade does no damage and no knockback (only for blocking?)
			base_damage = 0;
		}
		else if (WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
			&& ent->client->ps.saber[saber_num].damageScale2 <= 0.0f
			&& ent->client->ps.saber[saber_num].knockbackScale2 <= 0.0f)
		{
			//this blade does no damage and no knockback (only for blocking?)
			base_damage = 0;
		}
		else if (ent->client->ps.saberBlocked > BLOCKED_NONE
			|| !PM_SaberInAttack(ent->client->ps.saber_move)
			&& !pm_saber_in_special_attack(ent->client->ps.torsoAnim)
			&& !PM_SaberInTransitionAny(ent->client->ps.saber_move))
		{
			//don't do damage if parrying/reflecting/bouncing/deflecting or not actually attacking or in a transition to/from/between attacks
			if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
				&& ent->client->ps.saber[saber_num].saberFlags2 & SFL2_NO_IDLE_EFFECT
				|| WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
				&& ent->client->ps.saber[saber_num].saberFlags2 & SFL2_NO_IDLE_EFFECT2)
			{
				//do nothing at all when idle
				return;
			}
			base_damage = 0;
		}
		else
		{
			//okay, in a saber_move that does damage
			//make sure we're in the right anim
			if (!pm_saber_in_special_attack(ent->client->ps.torsoAnim)
				&& !PM_InAnimForSaberMove(ent->client->ps.torsoAnim, ent->client->ps.saber_move))
			{
				//forced into some other animation somehow, like a pain or death?
				if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
					&& ent->client->ps.saber[saber_num].saberFlags2 & SFL2_NO_IDLE_EFFECT
					|| WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
					&& ent->client->ps.saber[saber_num].saberFlags2 & SFL2_NO_IDLE_EFFECT2)
				{
					//do nothing at all when idle
					return;
				}
				base_damage = 0;
			}
			else if (ent->client->ps.weaponstate == WEAPON_FIRING
				&& ent->client->ps.saberBlocked == BLOCKED_NONE &&
				(PM_SaberInAttack(ent->client->ps.saber_move)
					|| pm_saber_in_special_attack(ent->client->ps.torsoAnim)
					|| PM_SpinningSaberAnim(ent->client->ps.torsoAnim)
					|| ent_power_level > FORCE_LEVEL_2
					|| WP_SaberBladeDoTransitionDamage(&ent->client->ps.saber[saber_num], blade_num)
					&& PM_SaberInTransitionAny(ent->client->ps.saber_move)))
			{
				if (g_saberRealisticCombat->integer > 1)
				{
					switch (ent_power_level)
					{
					default:
					case FORCE_LEVEL_5:
						base_damage = 7.5f;
						break;
					case FORCE_LEVEL_4: //Staff, medium, duals all do same damage
					case FORCE_LEVEL_3:
						base_damage = 5.0f;
						break;
					case FORCE_LEVEL_2:
						base_damage = 2.0f;
						break;
					case FORCE_LEVEL_1: //Fast damage is so low...
					case FORCE_LEVEL_0:
						base_damage = 1.5f;
						break;
					}
				}
				else
				{
					if (g_spskill->integer > 0
						&& ent->s.number < MAX_CLIENTS
						&& (ent->client->ps.torsoAnim == BOTH_ROLL_STAB
							|| ent->client->ps.torsoAnim == BOTH_SPINATTACK6
							|| ent->client->ps.torsoAnim == BOTH_SPINATTACK7
							|| ent->client->ps.torsoAnim == BOTH_LUNGE2_B__T_))
					{
						//*sigh*, these anim do less damage since they're so easy to do
						base_damage = 1.5f;
					}
					else
					{
						switch (ent_power_level)
						{
						default:
						case FORCE_LEVEL_5:
							base_damage = 2.5f * static_cast<float>(ent_power_level);
						case FORCE_LEVEL_4: //Staff, medium, duals all do same damage
						case FORCE_LEVEL_3:
							base_damage = 2.0f * static_cast<float>(ent_power_level);
							break;
						case FORCE_LEVEL_2:
							base_damage = 1.5f * static_cast<float>(ent_power_level);
							break;
						case FORCE_LEVEL_1: // Fast damage is so low...
						case FORCE_LEVEL_0:
							base_damage = 1.0f * static_cast<float>(ent_power_level);
							break;
						}
					}
				}
			}
			else
			{
				//saber is transitioning, defending or idle, don't do as much damage
				//FIXME: strong attacks and returns should do damage and be unblockable
				if (g_timescale->value < 1.0)
				{
					//in slow mo or force speed, we need to do damage during the transitions
					if (g_saberRealisticCombat->integer > 1)
					{
						switch (ent_power_level)
						{
						case FORCE_LEVEL_5:
							base_damage = 7.5f;
							break;
						case FORCE_LEVEL_4:
						case FORCE_LEVEL_3:
							base_damage = 5.0f;
							break;
						case FORCE_LEVEL_2:
							base_damage = 2.0f;
							break;
						default:
						case FORCE_LEVEL_1:
						case FORCE_LEVEL_0:
							base_damage = 1.5f;
							break;
						}
					}
					else
					{
						base_damage = 1.5f * static_cast<float>(ent_power_level);
					}
				}
				else
				{
					//I have to do *some* damage in transitions or else you feel like a total gimp
					base_damage = 0.1f;
				}
			}
		}

		if (ent->client->ps.saberDamageDebounceTime > level.time)
		{
			//really only used when a saber attack start anim starts, not actually for stopping damage
			//we just want to not use the old position to trace the attack from...
			VectorCopy(ent->client->ps.saber[saber_num].blade[blade_num].muzzlePoint,
				ent->client->ps.saber[saber_num].blade[blade_num].muzzlePointOld);
			VectorCopy(ent->client->ps.saber[saber_num].blade[blade_num].muzzleDir,
				ent->client->ps.saber[saber_num].blade[blade_num].muzzleDirOld);
		}
		//do the damage trace from the last position...
		VectorCopy(ent->client->ps.saber[saber_num].blade[blade_num].muzzlePointOld, mp1);
		VectorCopy(ent->client->ps.saber[saber_num].blade[blade_num].muzzleDirOld, md1);
		//...to the current one.
		VectorCopy(ent->client->ps.saber[saber_num].blade[blade_num].muzzlePoint, mp2);
		VectorCopy(ent->client->ps.saber[saber_num].blade[blade_num].muzzleDir, md2);

		//NOTE: this is a test, may not be necc, as I can still swing right through someone without hitting them, somehow...
		//see if anyone is so close that they're within the dist from my origin to the start of the saber
		if (ent->health > 0 && !ent->client->ps.saberLockTime && saber_num == 0 && blade_num == 0
			&& !G_InCinematicSaberAnim(ent))
		{
			//only do once - for first blade
			trace_t trace;
			gi.trace(&trace, ent->currentOrigin, vec3_origin, vec3_origin, mp1, ent->s.number,
				MASK_SHOT & ~(CONTENTS_CORPSE | CONTENTS_ITEM), static_cast<EG2_Collision>(0), 0);

			if (trace.entityNum < ENTITYNUM_WORLD
				&& (trace.entityNum > 0
					|| ent->client->NPC_class == CLASS_DESANN
					|| ent->client->NPC_class == CLASS_VADER
					|| ent->client->NPC_class == CLASS_SITHLORD
					|| ent->client->NPC_class == CLASS_GROGU
					|| ent->client->NPC_class == CLASS_LUKE)) //NPCs don't push player away, unless it's Desann
			{
				//a valid ent
				gentity_t* traceEnt = &g_entities[trace.entityNum];
				if (traceEnt
					&& traceEnt->client
					&& traceEnt->client->NPC_class != CLASS_RANCOR
					&& traceEnt->client->NPC_class != CLASS_ATST
					&& traceEnt->client->NPC_class != CLASS_WAMPA
					&& traceEnt->client->NPC_class != CLASS_SAND_CREATURE
					&& traceEnt->health > 0
					&& traceEnt->client->playerTeam != ent->client->playerTeam
					&& !PM_SuperBreakLoseAnim(traceEnt->client->ps.legsAnim)
					&& !PM_SuperBreakLoseAnim(traceEnt->client->ps.torsoAnim)
					&& !PM_SuperBreakWinAnim(traceEnt->client->ps.legsAnim)
					&& !PM_SuperBreakWinAnim(traceEnt->client->ps.torsoAnim)
					&& !PM_InKnockDown(&traceEnt->client->ps)
					&& !PM_LockedAnim(traceEnt->client->ps.legsAnim)
					&& !PM_LockedAnim(traceEnt->client->ps.torsoAnim)
					&& !G_InCinematicSaberAnim(traceEnt))
				{
					//enemy client, push them away
					if (!traceEnt->client->ps.saberLockTime
						&& !traceEnt->message
						&& !(traceEnt->flags & FL_NO_KNOCKBACK)
						&& (!traceEnt->NPC || traceEnt->NPC->jumpState != JS_JUMPING))
					{
						//don't push people in saberlock or with security keys or who are in BS_JUMP
						vec3_t hit_dir;
						VectorSubtract(trace.endpos, ent->currentOrigin, hit_dir);
						float total_dist = Distance(mp1, ent->currentOrigin);
						float knockback = (total_dist - VectorNormalize(hit_dir)) / total_dist * 200.0f;
						hit_dir[2] = 0;
						VectorMA(traceEnt->client->ps.velocity, knockback, hit_dir, traceEnt->client->ps.velocity);
						traceEnt->client->ps.pm_time = 200;
						traceEnt->client->ps.pm_flags |= PMF_TIME_NOFRICTION;
						if (d_combatinfo->integer || g_DebugSaberCombat->integer)
						{
							gi.Printf("%s pushing away %s at %s\n", ent->NPC_type, traceEnt->NPC_type,
								vtos(traceEnt->client->ps.velocity));
						}
					}
				}
			}
		}
	}

	//the thicker the blade, the more damage... the thinner, the less damage
	base_damage *= ent->client->ps.saber[saber_num].blade[blade_num].radius / SABER_RADIUS_STANDARD; //AMD

	if (g_saberRealisticCombat->integer > 1)
	{
		//always do damage, and lots of it
		if (g_saberRealisticCombat->integer > 2)
		{
			//always do damage, and lots of it
			base_damage = 25.0f;
		}
		else if (base_damage > 0.1f)
		{
			//only do super damage if we would have done damage according to normal rules
			base_damage = 25.0f;
		}
	}
	else if ((!ent->s.number && ent->client->ps.forcePowersActive & 1 << FP_SPEED || ent->client->ps.forcePowersActive &
		1 << FP_RAGE)
		&& g_timescale->value < 1.0f)
	{
		base_damage *= 1.0f - g_timescale->value;
	}
	if (base_damage > 0.1f)
	{
		if (ent->client->ps.forcePowersActive & 1 << FP_RAGE)
		{
			//add some damage if raged
			base_damage += ent->client->ps.forcePowerLevel[FP_RAGE] * 5.0f;
		}
		else if (ent->client->ps.forceRageRecoveryTime)
		{
			//halve it if recovering
			base_damage *= 0.5f;
		}
	}
	// Get the old state of the blade
	VectorCopy(mp1, base_old);
	VectorMA(base_old, ent->client->ps.saber[saber_num].blade[blade_num].length, md1, end_old);
	// Get the future state of the blade
	VectorCopy(mp2, base_new);
	VectorMA(base_new, ent->client->ps.saber[saber_num].blade[blade_num].length, md2, end_new);

	sabersCrossed = -1;

	if (VectorCompare2(base_old, base_new) && VectorCompare2(end_old, end_new))
	{
		hit_wall = WP_SaberDamageForTrace(ent->s.number, mp2, end_new, base_damage * 4, md2,
			qfalse, ent->client->ps.saber[saber_num].type, qfalse, saber_num,
			blade_num);
	}
	else
	{
		float tip_dmg_mod = 1.0f;
		vec3_t base_diff;
		float ave_length, step = 8, stepsize = 8;
		vec3_t ma1;
		vec3_t ma2;
		vec3_t md2_ang{};
		vec3_t cur_base2;
		int xx;
		//do the trace at the base first
		hit_wall = WP_SaberDamageForTrace(ent->s.number, base_old, base_new, base_damage, md2,
			qfalse, ent->client->ps.saber[saber_num].type, qtrue, saber_num,
			blade_num);

		//if hit a saber, shorten rest of traces to match
		if (saberHitFraction < 1.0)
		{
			vec3_t angles;
			vec3_t vec3;
			vectoangles(md1, angles);
			vectoangles(md2, vec3);
			for (xx = 0; xx < 3; xx++)
			{
				md2_ang[xx] = LerpAngle(angles[xx], vec3[xx], saberHitFraction);
			}
			AngleVectors(md2_ang, md2, nullptr, nullptr);
			//shorten the base pos
			VectorSubtract(mp2, mp1, base_diff);
			VectorMA(mp1, saberHitFraction, base_diff, base_new);
			VectorMA(base_new, ent->client->ps.saber[saber_num].blade[blade_num].length, md2, end_new);
		}

		//If the angle diff in the blade is high, need to do it in chunks of 33 to avoid flattening of the arc
		float dir_inc, cur_dir_frac;
		if (PM_SaberInAttack(ent->client->ps.saber_move)
			|| pm_saber_in_special_attack(ent->client->ps.torsoAnim)
			|| PM_SpinningSaberAnim(ent->client->ps.torsoAnim)
			|| PM_InSpecialJump(ent->client->ps.torsoAnim)
			|| g_timescale->value < 1.0f && PM_SaberInTransitionAny(ent->client->ps.saber_move))
		{
			cur_dir_frac = DotProduct(md1, md2);
		}
		else
		{
			cur_dir_frac = 1.0f;
		}
		//NOTE: if saber spun at least 180 degrees since last damage trace, this is not reliable...!
		if (fabs(cur_dir_frac) < 1.0f - MAX_SABER_SWING_INC)
		{
			//the saber blade spun more than 33 degrees since the last damage trace
			cur_dir_frac = dir_inc = 1.0f / ((1.0f - cur_dir_frac) / MAX_SABER_SWING_INC);
		}
		else
		{
			cur_dir_frac = 1.0f;
			dir_inc = 0.0f;
		}
		qboolean hit_saber = qfalse;

		vectoangles(md1, ma1);
		vectoangles(md2, ma2);

		vec3_t cur_md2;
		VectorCopy(md1, cur_md2);
		VectorCopy(base_old, cur_base2);

		while (true)
		{
			vec3_t cur_md1;
			vec3_t cur_base1;
			VectorCopy(cur_md2, cur_md1);
			VectorCopy(cur_base2, cur_base1);
			if (cur_dir_frac >= 1.0f)
			{
				VectorCopy(md2, cur_md2);
				VectorCopy(base_new, cur_base2);
			}
			else
			{
				for (xx = 0; xx < 3; xx++)
				{
					md2_ang[xx] = LerpAngle(ma1[xx], ma2[xx], cur_dir_frac);
				}
				AngleVectors(md2_ang, cur_md2, nullptr, nullptr);
				//VectorMA( md1, curDirFrac, mdDiff, curMD2 );
				VectorSubtract(base_new, base_old, base_diff);
				VectorMA(base_old, cur_dir_frac, base_diff, cur_base2);
			}
			// Move up the blade in intervals of stepsize
			for (step = stepsize; step < ent->client->ps.saber[saber_num].blade[blade_num].length && step < ent->client
				->
				ps.saber[saber_num].blade[blade_num].lengthOld; step += 12)
			{
				vec3_t blade_point_new;
				vec3_t blade_point_old;
				VectorMA(cur_base1, step, cur_md1, blade_point_old);
				VectorMA(cur_base2, step, cur_md2, blade_point_new);
				if (WP_SaberDamageForTrace(ent->s.number, blade_point_old, blade_point_new, base_damage, cur_md2,
					qfalse, ent->client->ps.saber[saber_num].type, qtrue, saber_num,
					blade_num))
				{
					hit_wall = qtrue;
				}

				//if hit a saber, shorten rest of traces to match
				if (saberHitFraction < 1.0)
				{
					//adjust muzzle endpoint
					VectorSubtract(mp2, mp1, base_diff);
					VectorMA(mp1, saberHitFraction, base_diff, base_new);
					VectorMA(base_new, ent->client->ps.saber[saber_num].blade[blade_num].length, cur_md2, end_new);
					//adjust muzzleDir...
					vec3_t curMA1, curMA2;
					vectoangles(cur_md1, curMA1);
					vectoangles(cur_md2, curMA2);
					for (xx = 0; xx < 3; xx++)
					{
						md2_ang[xx] = LerpAngle(curMA1[xx], curMA2[xx], saberHitFraction);
					}
					AngleVectors(md2_ang, cur_md2, nullptr, nullptr);
					hit_saber = qtrue;
				}
				if (hit_wall)
				{
					break;
				}
			}
			if (hit_wall || hit_saber)
			{
				break;
			}
			if (cur_dir_frac >= 1.0f)
			{
				break;
			}
			cur_dir_frac += dir_inc;
			if (cur_dir_frac >= 1.0f)
			{
				cur_dir_frac = 1.0f;
			}
		}

		//do the trace at the end last
		//Special check- adjust for length of blade not being a multiple of 12
		ave_length = (ent->client->ps.saber[saber_num].blade[blade_num].lengthOld + ent->client->ps.saber[saber_num].
			blade[
				blade_num].length) / 2;
		if (step > ave_length)
		{
			//less dmg if the last interval was not stepsize
			tip_dmg_mod = (stepsize - (step - ave_length)) / stepsize;
		}
		//NOTE: since this is the tip, we do not extrapolate the extra 16
		if (WP_SaberDamageForTrace(ent->s.number, end_old, end_new, tip_dmg_mod * base_damage, md2, qfalse,
			ent->client->ps.saber[saber_num].type,
			qfalse, saber_num, blade_num))
		{
			hit_wall = qtrue;
		}
	}

	if ((saberHitFraction < 1.0f || sabersCrossed >= 0 && sabersCrossed <= 32.0f) && (ent->client->ps.weaponstate ==
		WEAPON_FIRING || ent->client->ps.saberInFlight || G_InCinematicSaberAnim(ent)))
	{
		// The saber (in-hand) hit another saber, mano.
		qboolean in_flight_saber_blocked = qfalse;
		qboolean collision_resolved = qfalse;
		qboolean deflected = qfalse;
		gentity_t* hit_ent = &g_entities[saberHitEntity];
		gentity_t* hit_owner = nullptr;
		int hit_owner_power_level = FORCE_LEVEL_0;

		if (hit_ent)
		{
			hit_owner = hit_ent->owner;
		}
		if (hit_owner && hit_owner->client)
		{
			hit_owner_power_level = 2 * hit_owner->client->ps.forcePowerLevel[FP_SABER_DEFENSE] +
				PM_PowerLevelForSaberAnim(
					&hit_owner->client->ps);
		}

		if (ent->client->ps.saberInFlight && saber_num == 0 &&
			ent->client->ps.saber[saber_num].blade[blade_num].active &&
			ent->client->ps.saberEntityNum != ENTITYNUM_NONE &&
			ent->client->ps.saberEntityState != SES_RETURNING)
		{
			//saber was blocked, return it
			in_flight_saber_blocked = qtrue;
		}

		//start of saber behaviour code jacesolaris

		if (hit_owner && hit_owner->health > 0 && ent->health > 0 //both are alive
			&& !in_flight_saber_blocked
			&& hit_owner->client
			&& !hit_owner->client->ps.saberInFlight
			&& !ent->client->ps.saberInFlight //both have sabers in-hand
			&& ent->client->ps.saberBlocked != BLOCKED_PARRY_BROKEN
			&& ent->client->ps.saberLockTime < level.time
			&& hit_owner->client->ps.saberLockTime < level.time)
		{
			//2 in-hand sabers hit
			if (base_damage)
			{
				//there is damage involved, not just effects
				qboolean ent_attacking = qfalse;
				qboolean hit_owner_attacking = qfalse;
				qboolean ent_defending = qfalse;
				qboolean hit_owner_defending = qfalse;
				qboolean force_lock = qfalse;
				qboolean atkfake = ent->client->ps.userInt3 & 1 << FLAG_ATTACKFAKE ? qtrue : qfalse;
				qboolean otherfake = hit_owner->client->ps.userInt3 & 1 << FLAG_ATTACKFAKE ? qtrue : qfalse;

				if (ent->client->NPC_class == CLASS_KYLE && ent->spawnflags & 1 && hit_owner->s.number < MAX_CLIENTS
					|| hit_owner->client->NPC_class == CLASS_KYLE && hit_owner->spawnflags & 1 && ent->s.number <
					MAX_CLIENTS)
				{
					//Player vs. Kyle Boss == lots of saber locks
					if (!Q_irand(0, 2))
					{
						force_lock = qtrue;
					}
				}

				if (PM_SaberInAttack(ent->client->ps.saber_move) ||
					PM_SaberInDamageMove(ent->client->ps.saber_move) ||
					pm_saber_in_special_attack(ent->client->ps.torsoAnim) ||
					PM_SaberDoDamageAnim(ent->client->ps.torsoAnim))
				{
					ent_attacking = qtrue;
				}

				if (PM_SaberInParry(ent->client->ps.saber_move)
					|| ent->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCK
					|| ent->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCKANDATTACK
					|| ent->client->ps.ManualBlockingFlags & 1 << PERFECTBLOCKING
					|| g_saberAutoBlocking->integer && ent->NPC && !G_ControlledByPlayer(ent)
					|| ent->client->ps.ManualBlockingFlags & 1 << MBF_NPCBLOCKING && ent->NPC && !
					G_ControlledByPlayer(ent)
					|| ent->client->ps.saberBlockingTime > level.time
					|| ent->client->ps.saber_move == LS_READY)
				{
					ent_defending = qtrue;
				}

				if (ent->client->ps.torsoAnim == BOTH_A1_SPECIAL
					|| ent->client->ps.torsoAnim == BOTH_A2_SPECIAL
					|| ent->client->ps.torsoAnim == BOTH_A3_SPECIAL
					|| ent->client->ps.torsoAnim == BOTH_A7_SOULCAL
					|| ent->client->ps.torsoAnim == BOTH_A6_SABERPROTECT)
				{
					//parry/block/break-parry bonus for single-style kata moves
					ent_power_level++;
				}
				if (ent_attacking)
				{
					//add twoHanded bonus and breakParryBonus to entPowerLevel here
					if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num))
					{
						ent_power_level += ent->client->ps.saber[saber_num].breakParryBonus;
					}
					else if (WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num))
					{
						ent_power_level += ent->client->ps.saber[saber_num].breakParryBonus2;
					}
				}
				else if (ent_defending)
				{
					//add twoHanded bonus and dualSaber bonus and parryBonus to entPowerLevel here
					ent_power_level += Q_irand(ent->client->ps.saber[saber_num].parryBonus,
						ent->client->ps.forcePowerLevel[FP_SABER_DEFENSE]);
				}

				if (PM_SaberInAttack(hit_owner->client->ps.saber_move) ||
					PM_SaberInDamageMove(hit_owner->client->ps.saber_move) ||
					pm_saber_in_special_attack(hit_owner->client->ps.torsoAnim) ||
					PM_SaberDoDamageAnim(hit_owner->client->ps.torsoAnim))
				{
					hit_owner_attacking = qtrue;
				}

				if (PM_SaberInParry(hit_owner->client->ps.saber_move)
					|| hit_owner->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCK
					|| hit_owner->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCKANDATTACK
					|| hit_owner->client->ps.ManualBlockingFlags & 1 << PERFECTBLOCKING
					|| g_saberAutoBlocking->integer && hit_owner->NPC && !G_ControlledByPlayer(hit_owner)
					|| hit_owner->client->ps.ManualBlockingFlags & 1 << MBF_NPCBLOCKING && hit_owner->NPC && !
					G_ControlledByPlayer(hit_owner)
					|| hit_owner->client->ps.saberBlockingTime > level.time
					|| hit_owner->client->ps.saber_move == LS_READY)
				{
					hit_owner_defending = qtrue;
				}

				if (hit_owner->client->ps.torsoAnim == BOTH_A1_SPECIAL
					|| hit_owner->client->ps.torsoAnim == BOTH_A2_SPECIAL
					|| hit_owner->client->ps.torsoAnim == BOTH_A3_SPECIAL
					|| hit_owner->client->ps.torsoAnim == BOTH_A7_SOULCAL
					|| hit_owner->client->ps.torsoAnim == BOTH_A6_SABERPROTECT)
				{
					//parry/block/break-parry bonus for single-style kata moves
					hit_owner_power_level++;
				}
				if (hit_owner_attacking)
				{
					//add twoHanded bonus and breakParryBonus to entPowerLevel here
					hit_owner_power_level += hit_owner->client->ps.saber[0].breakParryBonus;

					if (hit_owner->client->ps.dualSabers && Q_irand(0, 1))
					{
						hit_owner_power_level += 1 + hit_owner->client->ps.saber[1].breakParryBonus;
					}
				}
				else if (hit_owner_defending)
				{
					//add twoHanded bonus and dualSaber bonus and parryBonus to entPowerLevel here
					hit_owner_power_level += Q_irand(hit_owner->client->ps.saber[saber_num].parryBonus,
						hit_owner->client->ps.forcePowerLevel[FP_SABER_DEFENSE]);

					if (hit_owner->client->ps.dualSabers && Q_irand(0, 1))
					{
						hit_owner_power_level += 1 + Q_irand(hit_owner->client->ps.saber[saber_num].parryBonus,
							hit_owner->client->ps.forcePowerLevel[FP_SABER_DEFENSE]);
					}
				}

				if (PM_SuperBreakLoseAnim(ent->client->ps.torsoAnim)
					|| PM_SuperBreakWinAnim(ent->client->ps.torsoAnim)
					|| PM_SuperBreakLoseAnim(hit_owner->client->ps.torsoAnim)
					|| PM_SuperBreakWinAnim(hit_owner->client->ps.torsoAnim))
				{
					//don't mess with this
					collision_resolved = qtrue;
				}
				else if (ent_attacking && hit_owner_attacking && ent_power_level == hit_owner_power_level
					&& Q_irand(1, 5) <= g_saberLockRandomNess->integer && WP_SabersCheckLock(ent, hit_owner))
				{
					collision_resolved = qtrue;
				}
				else if (hit_owner_attacking && ent_defending && hit_owner_power_level > ent_power_level
					&& Q_irand(1, 5) <= g_saberLockRandomNess->integer && WP_SabersCheckLock(ent, hit_owner))
				{
					collision_resolved = qtrue;
				}
				else if (ent_attacking && hit_owner_defending && ent_power_level > hit_owner_power_level
					&& Q_irand(1, 5) <= g_saberLockRandomNess->integer && WP_SabersCheckLock(ent, hit_owner))
				{
					collision_resolved = qtrue;
				}
				else if (atkfake && !otherfake && Q_irand(1, 5) <= g_saberLockRandomNess->integer && WP_SabersCheckLock(ent, hit_owner))
				{
					collision_resolved = qtrue;
				}
				else if (otherfake && !atkfake && Q_irand(1, 5) <= g_saberLockRandomNess->integer && WP_SabersCheckLock(hit_owner, ent))
				{
					collision_resolved = qtrue;
				}
				else if (otherfake && atkfake && Q_irand(1, 5) <= g_saberLockRandomNess->integer && WP_SabersCheckLock(hit_owner, ent))
				{
					collision_resolved = qtrue;
				}
				else if (force_lock && WP_SabersCheckLock(ent, hit_owner))
				{
					collision_resolved = qtrue;
				}
				else if (force_lock && WP_SabersCheckLock(hit_owner, ent))
				{
					collision_resolved = qtrue;
				}
				else if ((ent_attacking && (ent->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(ent)))
					&& (hit_owner_defending && (hit_owner->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(hit_owner)))
					&& Q_irand(1, 5) <= g_saberLockRandomNess->integer
					&& (g_debugSaberLock->integer || force_lock && WP_SabersCheckLock(ent, hit_owner)))
				{
					collision_resolved = qtrue;
				}
				else if (ent_attacking && hit_owner_defending)
				{
					//I'm attacking hit, they're parrying
					if (saberHitFraction < 1.0f)
					{
						//make me parry	-(Im the blocker)
						sab_beh_block_vs_attack(hit_owner, ent, saber_num, blade_num, saberHitLocation);

						//make me bounce -(Im the attacker)
						sab_beh_attack_vs_block(ent, hit_owner, saber_num, blade_num, saberHitLocation);

						collision_resolved = qtrue;
					}
				}
				else
				{
					//some other kind of in-hand saber collision
				}
			}
		}
		else
		{
			//some kind of in-flight collision
		}

		if (saberHitFraction < 1.0f)
		{
			auto active_defenseentagain = static_cast<qboolean>
				(ent->client->ps.ManualBlockingFlags & 1 << MBF_NPCBLOCKING || ent->client->ps.ManualBlockingFlags & 1
					<< HOLDINGBLOCK);

			if (!collision_resolved && base_damage)
			{
				//some other kind of in-hand saber collision
				//handle my reaction
				if (!ent->client->ps.saberInFlight
					&& ent->client->ps.saberLockTime < level.time)
				{
					//my saber is in hand
					if (ent->client->ps.saberBlocked != BLOCKED_PARRY_BROKEN)
					{
						if (PM_SaberInAttack(ent->client->ps.saber_move)
							|| pm_saber_in_special_attack(ent->client->ps.torsoAnim)
							&& !PM_SaberInIdle(ent->client->ps.saber_move)
							&& !PM_SaberInParry(ent->client->ps.saber_move)
							&& !PM_SaberInReflect(ent->client->ps.saber_move)
							&& !PM_SaberInBounce(ent->client->ps.saber_move)
							&& !PM_SaberInMassiveBounce(ent->client->ps.saber_move))
						{
							//in the middle of attacking
							if (hit_owner->health > 0)
							{
								//don't deflect/bounce in strong attack or when enemy is dead
								WP_GetSaberDeflectionAngle(ent, hit_owner);
								ent->client->ps.saberEventFlags |= SEF_BLOCKED;
								wp_saber_clear_damage_for_ent_num(ent, hit_owner->s.number, saber_num, blade_num);

								if (d_blockinfo->integer || g_DebugSaberCombat->integer)
								{
									gi.Printf(S_COLOR_CYAN"Saber Throw ent Swing blocked\n");
								}
							}
						}
						else
						{
							if (active_defenseentagain)
							{
								if (!PM_SaberInTransitionAny(ent->client->ps.saber_move) && !PM_SaberInBounce(
									ent->client->ps.saber_move))
								{
									WP_SaberParry(ent, hit_owner, saber_num, blade_num);
									wp_saber_clear_damage_for_ent_num(ent, hit_owner->s.number, saber_num, blade_num);
									ent->client->ps.saberEventFlags |= SEF_PARRIED;

									if (d_blockinfo->integer || g_DebugSaberCombat->integer)
									{
										gi.Printf(S_COLOR_CYAN"Saber throw ent manual blocked\n");
									}
								}
							}
						}
					}
					else
					{
						wp_saber_clear_damage_for_ent_num(ent, hit_owner->s.number, saber_num, blade_num);

						if (d_blockinfo->integer || g_DebugSaberCombat->integer)
						{
							gi.Printf(S_COLOR_CYAN"Saber throw ent auto cleared damage?\n");
						}
					}
				}
				else
				{
					//nothing happens to *me* when my inFlight saber hits something
				}

				//handle their reaction
				if (hit_owner
					&& hit_owner->health > 0
					&& hit_owner->client
					&& !hit_owner->client->ps.saberInFlight
					&& hit_owner->client->ps.saberLockTime < level.time)
				{
					//their saber is in hand
					if (PM_SaberInAttack(hit_owner->client->ps.saber_move) || pm_saber_in_special_attack(
						hit_owner->client->ps.torsoAnim)
						&& !PM_SaberInIdle(hit_owner->client->ps.saber_move)
						&& !PM_SaberInParry(hit_owner->client->ps.saber_move)
						&& !PM_SaberInReflect(hit_owner->client->ps.saber_move)
						&& !PM_SaberInBounce(hit_owner->client->ps.saber_move)
						&& !PM_SaberInMassiveBounce(hit_owner->client->ps.saber_move))
					{
						//in the middle of attacking
						if (d_blockinfo->integer || g_DebugSaberCombat->integer)
						{
							gi.Printf(S_COLOR_CYAN"Saber throw Hit owner blank\n");
						}
					}
					else
					{
						//saber collided when not attacking, parry it
						if (!PM_SaberInBrokenParry(hit_owner->client->ps.saber_move))
						{
							if (!WP_SaberParry(hit_owner, ent, saber_num, blade_num))
							{
								if (hit_owner->client->ps.blockPoints < BLOCKPOINTS_FATIGUE)
								{
									//Low points = bad blocks
									SabBeh_SaberShouldBeDisarmedBlocker(hit_owner, saber_num);
									wp_block_points_regenerate_over_ride(hit_owner, BLOCKPOINTS_TEN);
								}
								else
								{
									g_fatigue_bp_knockaway(hit_owner);
									PM_AddBlockFatigue(&hit_owner->client->ps, BLOCKPOINTS_TEN);
								}

								if (d_blockinfo->integer || g_DebugSaberCombat->integer)
								{
									gi.Printf(S_COLOR_CYAN"Saber throw hit owner Did not parry\n");
								}
							}
						}
					}
				}
				else
				{
					//nothing happens to *hitOwner* when their inFlight saber hits something
				}
			}

			//collision must have been handled by now
			//Set the blocked attack bounce value in saberBlocked so we actually play our saberBounceMove anim
			if (ent->client->ps.saberEventFlags & SEF_BLOCKED)
			{
				if (ent->client->ps.saberBlocked != BLOCKED_PARRY_BROKEN)
				{
					ent->client->ps.saberBlocked = BLOCKED_ATK_BOUNCE;
					ent->client->ps.userInt3 |= 1 << FLAG_SLOWBOUNCE;
				}
			}
		}
		// End of saber behaviour code jacesolaris

		/////////////////////////////////////Sound effects //////////////////////////////////////
		if (saberHitFraction < 1.0f || collision_resolved)
		{
			//either actually hit or locked
			if (ent->client->ps.saberLockTime < level.time)
			{
				if (in_flight_saber_blocked)
				{
					//FIXME: never hear this sound
					WP_SaberBounceSound(ent, &g_entities[ent->client->ps.saberEntityNum], 0, 0);
				}
				else
				{
					if (deflected)
					{
						WP_SaberBounceSound(ent, nullptr, saber_num, blade_num);
					}
					else
					{
						if (ent->client->ps.blockPoints > BLOCKPOINTS_HALF || ent->client->ps.userInt3 & 1 << FLAG_PERFECTBLOCK)
						{
							WP_SaberBlockSound(ent, saber_num, blade_num);
						}
						else
						{
							WP_SaberKnockSound(ent, saber_num, blade_num);
						}
					}
				}
				if (!g_saberNoEffects)
				{
					if (ent->client->ps.blockPoints > BLOCKPOINTS_HALF || ent->client->ps.userInt3 & 1 << FLAG_PERFECTBLOCK)
					{
						WP_SaberMBlockEffect(ent, saber_num, blade_num, saberHitLocation, saberHitNormal, qfalse);
					}
					else
					{
						WP_SaberBlockEffect(ent, saber_num, blade_num, saberHitLocation, saberHitNormal, qfalse);
					}
				}
			}
			if (!g_noClashFlare)
			{
				g_saberFlashTime = level.time - 50;
				VectorCopy(saberHitLocation, g_saberFlashPos);
			}
		}

		if (saberHitFraction < 1.0f)
		{
			if (in_flight_saber_blocked)
			{
				//we threw a saber and it was blocked, do any effects, etc.
				int knock_away = 5;
				if (hit_ent
					&& hit_owner
					&& hit_owner->client
					&& (PM_SaberInAttack(hit_owner->client->ps.saber_move)
						|| pm_saber_in_special_attack(hit_owner->client->ps.torsoAnim)
						|| PM_SpinningSaberAnim(hit_owner->client->ps.torsoAnim)))
				{
					//if hit someone who was in an attack or spin anim, more likely to have in-flight saber knocked away
					if (hit_owner_power_level > FORCE_LEVEL_2)
					{
						//strong attacks almost always knock it aside!
						knock_away = 1;
					}
					else
					{
						//33% chance
						knock_away = 2;
					}
					knock_away -= hit_owner->client->ps.SaberDisarmBonus(0);
				}
				if (Q_irand(0, knock_away) <= 0 || //random
					hit_owner
					&& hit_owner->client
					&& hit_owner->NPC
					&& (hit_owner->NPC->aiFlags & NPCAI_BOSS_CHARACTER || hit_owner->NPC->aiFlags &
						NPCAI_BOSS_SERENITYJEDIENGINE))
					//or if blocked by a Boss character FIXME: or base on defense level?
				{
					//knock it aside and turn it off
					if (!g_saberNoEffects)
					{
						if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
							&& ent->client->ps.saber[saber_num].hitOtherEffect)
						{
							G_PlayEffect(ent->client->ps.saber[saber_num].hitOtherEffect, saberHitLocation,
								saberHitNormal);
						}
						else if (WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
							&& ent->client->ps.saber[saber_num].hitOtherEffect2)
						{
							G_PlayEffect(ent->client->ps.saber[saber_num].hitOtherEffect2, saberHitLocation,
								saberHitNormal);
						}
						else
						{
							if (ent->client->ps.blockPoints < BLOCKPOINTS_HALF)
							{
								G_PlayEffect("saber/saber_bodyhit", saberHitLocation, saberHitNormal);
							}
							else
							{
								G_PlayEffect("saber/saber_cut_AMD", saberHitLocation, saberHitNormal);
							}
						}
					}
					if (hit_ent)
					{
						vec3_t new_dir;

						VectorSubtract(g_entities[ent->client->ps.saberEntityNum].currentOrigin, hit_ent->currentOrigin,
							new_dir);
						VectorNormalize(new_dir);
						if (ent->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(ent))
						{
							G_ReflectMissileNPC(ent, &g_entities[ent->client->ps.saberEntityNum], new_dir);
						}
						else
						{
							if (g_SerenityJediEngineMode->integer)
							{
								G_ReflectMissileAuto(ent, &g_entities[ent->client->ps.saberEntityNum], new_dir);
							}
							else
							{
								G_ReflectMissile_JKA(ent, &g_entities[ent->client->ps.saberEntityNum], new_dir);
							}
						}
					}
					jedi_play_deflect_sound(hit_owner);
					WP_SaberDrop(ent, &g_entities[ent->client->ps.saberEntityNum]);
				}
				else
				{
					if (!Q_irand(0, 2) && hit_ent)
					{
						vec3_t new_dir;

						VectorSubtract(g_entities[ent->client->ps.saberEntityNum].currentOrigin, hit_ent->currentOrigin,
							new_dir);
						VectorNormalize(new_dir);
						if (ent->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(ent))
						{
							G_ReflectMissileNPC(ent, &g_entities[ent->client->ps.saberEntityNum], new_dir);
						}
						else
						{
							if (g_SerenityJediEngineMode->integer)
							{
								G_ReflectMissileAuto(ent, &g_entities[ent->client->ps.saberEntityNum], new_dir);
							}
							else
							{
								G_ReflectMissile_JKA(ent, &g_entities[ent->client->ps.saberEntityNum], new_dir);
							}
						}
					}
					WP_SaberDrop(ent, &g_entities[ent->client->ps.saberEntityNum]);
				}
			}
		}
	}

	if (ent->client->ps.saberLockTime > level.time)
	{
		if (ent->s.number < ent->client->ps.saberLockEnemy)
		{
			vec3_t hit_norm = { 0, 0, 1 };

			if (wp_sabers_intersection(ent, &g_entities[ent->client->ps.saberLockEnemy], g_saberFlashPos))
			{
				int index = 1;
				index = Q_irand(1, 9);

				if (!g_saberNoEffects)
				{
					G_PlayEffect("saber/saber_lock.efx", g_saberFlashPos, hit_norm);
				}
				G_Sound(ent, G_SoundIndex(va("sound/weapons/saber/saberlock%d.mp3", index)));
			}
		}
	}
	else
	{
		if (hit_wall
			&& (ent->client->ps.saber[saber_num].saberFlags & SFL_BOUNCE_ON_WALLS || g_SaberBounceOnWalls->integer)
			&& (PM_SaberInAttackPure(ent->client->ps.saber_move) || ent->client->ps.saber_move == LS_A_JUMP_T__B_))
		{
			//bounce off walls
			//do anim
			ent->client->ps.saberBlocked = BLOCKED_ATK_BOUNCE;
			ent->client->ps.saberBounceMove = LS_D1_BR + (saber_moveData[ent->client->ps.saber_move].startQuad - Q_BR);
			//do bounce sound & force feedback
			WP_SaberBounceOnWallSound(ent, saber_num, blade_num);
			//do hit effect
			if (!g_saberNoEffects)
			{
				if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
					&& ent->client->ps.saber[saber_num].hitOtherEffect)
				{
					G_PlayEffect(ent->client->ps.saber[saber_num].hitOtherEffect, saberHitLocation, saberHitNormal);
				}
				else if (WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
					&& ent->client->ps.saber[saber_num].hitOtherEffect2)
				{
					G_PlayEffect(ent->client->ps.saber[saber_num].hitOtherEffect2, saberHitLocation, saberHitNormal);
				}
				else
				{
					G_PlayEffect("saber/saber_bodyhit", saberHitLocation, saberHitNormal);
				}
			}
			//do radius damage/knockback, if any
			if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num))
			{
				WP_SaberRadiusDamage(ent, saberHitLocation, ent->client->ps.saber[saber_num].splashRadius,
					ent->client->ps.saber[saber_num].splashDamage,
					ent->client->ps.saber[saber_num].splashKnockback);
			}
			else
			{
				WP_SaberRadiusDamage(ent, saberHitLocation, ent->client->ps.saber[saber_num].splashRadius2,
					ent->client->ps.saber[saber_num].splashDamage2,
					ent->client->ps.saber[saber_num].splashKnockback2);
			}
		}
		else if (hit_wall &&
			!PM_SaberInAttackPure(ent->client->ps.saber_move) &&
			!PM_CrouchAnim(ent->client->ps.legsAnim) &&
			!PM_WalkingAnim(ent->client->ps.legsAnim) &&
			!PM_RunningAnim(ent->client->ps.legsAnim) &&
			ent->client->buttons & BUTTON_WALKING &&
			ent->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCK &&
			(ent->s.number < MAX_CLIENTS || G_ControlledByPlayer(ent)) &&
			(ent->client->ps.forcePower < BLOCKPOINTS_DANGER || ent->client->ps.blockPoints < BLOCKPOINTS_DANGER))
		{
			//reflect from wall
			ent->client->ps.saberBlocked = BLOCKED_ATK_BOUNCE;
			ent->client->ps.saberBounceMove = LS_D1_BR + (saber_moveData[ent->client->ps.saber_move].startQuad - Q_BR);

			//do hit effect
			if (!g_saberNoEffects)
			{
				if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
					&& ent->client->ps.saber[saber_num].hitOtherEffect)
				{
					G_PlayEffect(ent->client->ps.saber[saber_num].hitOtherEffect, saberHitLocation, saberHitNormal);
				}
				else if (WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
					&& ent->client->ps.saber[saber_num].hitOtherEffect2)
				{
					G_PlayEffect(ent->client->ps.saber[saber_num].hitOtherEffect2, saberHitLocation, saberHitNormal);
				}
				else
				{
					G_PlayEffect("saber/saber_cut", saberHitLocation, saberHitNormal);
				}
			}
			//do radius damage/knockback, if any
			if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num))
			{
				WP_SaberRadiusDamage(ent, saberHitLocation, ent->client->ps.saber[saber_num].splashRadius,
					ent->client->ps.saber[saber_num].splashDamage,
					ent->client->ps.saber[saber_num].splashKnockback);
			}
			else
			{
				WP_SaberRadiusDamage(ent, saberHitLocation, ent->client->ps.saber[saber_num].splashRadius2,
					ent->client->ps.saber[saber_num].splashDamage2,
					ent->client->ps.saber[saber_num].splashKnockback2);
			}
		}
	}

	if (WP_SaberApplyDamageMD(ent, base_damage, base_d_flags, broken_parry, saber_num, blade_num,
		static_cast<qboolean>(saber_num == 0 && ent->client->ps.saberInFlight))) //AMD Mode
	{
		//actually did damage to something
		WP_SaberHitSound(ent, saber_num, blade_num);

		if (!saber_in_special && (d_combatinfo->integer || g_DebugSaberCombat->integer))
		{
			if (g_saberRealisticCombat->integer == 3)
			{
				gi.Printf("AMD Mode Very High Damage. Min damage done was %4.2f\n", base_damage);
			}
			else if (g_saberRealisticCombat->integer == 2)
			{
				gi.Printf("AMD Mode High Damage. Min damage done was %4.2f\n", base_damage);
			}
			else if (g_saberRealisticCombat->integer == 1)
			{
				gi.Printf("AMD Mode Medium Damage. Min damage done was %4.2f\n", base_damage);
			}
			else if (g_saberRealisticCombat->integer == 0)
			{
				gi.Printf("AMD Mode Low Damage. Min damage done was %4.2f\n", base_damage);
			}
		}
	}

	if (hit_wall)
	{
		//just so Jedi knows that he hit a wall
		ent->client->ps.saberEventFlags |= SEF_HITWALL;
		if (ent->s.number == 0)
		{
			AddSoundEvent(ent, ent->currentOrigin, 128, AEL_DISCOVERED, qfalse, qtrue);
			//FIXME: is this impact on ground or not?
			AddSightEvent(ent, ent->currentOrigin, 256, AEL_DISCOVERED, 50);
		}
	}
}

static void WP_SaberDamageTrace_MD(gentity_t* ent, int saber_num, int blade_num)
{
	vec3_t mp1;
	vec3_t mp2;
	vec3_t md1;
	vec3_t md2;
	vec3_t base_old;
	vec3_t base_new;
	vec3_t end_old;
	vec3_t end_new;
	float base_damage;
	int base_d_flags = 0;
	qboolean hit_wall = qfalse;
	qboolean broken_parry = qfalse;
	qboolean saber_in_special = pm_saber_in_special_attack(ent->client->ps.torsoAnim);

	for (int& ven : victimEntityNum)
	{
		ven = ENTITYNUM_NONE;
	}
	memset(totalDmg, 0, sizeof totalDmg);
	memset(dmgDir, 0, sizeof dmgDir);
	memset(dmgNormal, 0, sizeof dmgNormal);
	memset(dmgSpot, 0, sizeof dmgSpot);
	memset(dmgFraction, 0, sizeof dmgFraction);
	memset(hit_loc, HL_NONE, sizeof hit_loc);
	memset(hitDismemberLoc, HL_NONE, sizeof hitDismemberLoc);
	memset(hitDismember, qfalse, sizeof hitDismember);
	numVictims = 0;
	VectorClear(saberHitLocation);
	VectorClear(saberHitNormal);
	saberHitFraction = 1.0; // Closest saber hit.  The saber can do no damage past this point.
	saberHitEntity = ENTITYNUM_NONE;
	sabersCrossed = -1;

	if (!ent->client)
	{
		return;
	}

	if (!ent->s.number)
	{
		//player never uses these
		if (PM_SaberInAttack(ent->client->ps.saber_move))
		{
			//make sure code knows player is attacking and not doing any kind of block
			ent->client->ps.saberEventFlags &= ~SEF_PARRIED;
			ent->client->ps.saberEventFlags &= ~SEF_DEFLECTED;
		}
		ent->client->ps.saberEventFlags &= ~SEF_EVENTS;
	}

	if (ent->client->ps.saber[saber_num].blade[blade_num].length <= 1) //cen get down to 1 when in a wall
	{
		//saber is not on
		return;
	}

	if (VectorCompare(ent->client->renderInfo.muzzlePointOld, vec3_origin) || VectorCompare(
		ent->client->renderInfo.muzzleDirOld, vec3_origin))
	{
		//just started up the saber?
		return;
	}

	int saber_contents = 0;

	if (!(ent->client->ps.saber[saber_num].saberFlags & SFL_ON_IN_WATER))
	{
		//saber can't stay on underwater
		saber_contents = gi.pointcontents(ent->client->renderInfo.muzzlePoint, ent->client->ps.saberEntityNum);
	}
	if (saber_contents & CONTENTS_WATER ||
		saber_contents & CONTENTS_SLIME ||
		saber_contents & CONTENTS_LAVA)
	{
		ent->client->ps.saber[saber_num].blade[blade_num].active = qfalse;
		return;
	}
	if (!g_saberNoEffects && gi.WE_IsOutside(ent->client->renderInfo.muzzlePoint))
	{
		float chance_of_fizz = gi.WE_GetChanceOfSaberFizz();
		if (chance_of_fizz > 0 && Q_flrand(0.0f, 1.0f) < chance_of_fizz)
		{
			vec3_t end;
			VectorMA(ent->client->ps.saber[saber_num].blade[blade_num].muzzlePoint,
				ent->client->ps.saber[saber_num].blade[blade_num].length * Q_flrand(0, 1),
				ent->client->ps.saber[saber_num].blade[blade_num].muzzleDir, end);
			G_PlayEffect("saber/fizz", end);
		}
	}

	int ent_power_level = 0;
	int style_power_modifier = 0;
	int style_power_level = PM_PowerLevelForSaberAnim(&ent->client->ps, saber_num);

	switch (style_power_level) // check what the saber style is and set power modifier accordingly
	{
	case 1:
		style_power_modifier = -2;
		break;
	case 2:
		style_power_modifier = -1;
		break;
	case 3:
		style_power_modifier = 0;
		break;
	case 4:
		style_power_modifier = 1;
		break;
	case 5: //special attacks count as this in bg_panimate
		style_power_modifier = 2;
		break;
	default:;
	}

	if (ent->client->NPC_class == CLASS_SABER_DROID)
	{
		ent_power_level = SaberDroid_PowerLevelForSaberAnim(ent);
	}
	else if (!ent->s.number && ent->client->ps.forcePowersActive & 1 << FP_SPEED)
	{
		ent_power_level += 1 * ent->client->ps.forcePowerLevel[FP_SPEED];
	}
	else
	{
		ent_power_level = PM_PowerLevelForSaberAnim(&ent->client->ps, saber_num);
	}

	if (ent_power_level)
	{
		if (ent->client->ps.forceRageRecoveryTime > level.time)
		{
			ent_power_level -= 2;
		}
		else if (ent->client->ps.forcePowersActive & 1 << FP_RAGE)
		{
			ent_power_level += ent->client->ps.forcePowerLevel[FP_RAGE] + 1;
		}
	}

	if (ent->client->ps.saberInFlight)
	{
		//flying sabers are much more deadly
		//unless you're dead
		if (ent->health <= 0 && g_saberRealisticCombat->integer < 2)
		{
			//so enemies don't keep trying to block it
			return;
		}
		//or unless returning
		if (ent->client->ps.saberEntityState == SES_RETURNING
			&& !(ent->client->ps.saber[0].saberFlags & SFL_RETURN_DAMAGE))
		{
			//special case, since we're returning, chances are if we hit something
			base_damage = 0.1f;
		}
		else
		{
			if (!ent->s.number)
			{
				//cheat for player
				base_damage = 5.0f;
			}
			else
			{
				base_damage = 2.5f;
			}
		}
		//Use old to current since can't predict it
		VectorCopy(ent->client->ps.saber[saber_num].blade[blade_num].muzzlePointOld, mp1);
		VectorCopy(ent->client->ps.saber[saber_num].blade[blade_num].muzzleDirOld, md1);
		VectorCopy(ent->client->ps.saber[saber_num].blade[blade_num].muzzlePoint, mp2);
		VectorCopy(ent->client->ps.saber[saber_num].blade[blade_num].muzzleDir, md2);
	}
	else
	{
		if (ent->client->ps.torsoAnim == BOTH_A7_HILT ||
			ent->client->ps.torsoAnim == BOTH_SLAP_L ||
			ent->client->ps.torsoAnim == BOTH_SLAP_R)
		{
			//no effects, no damage
			return;
		}
		if (ent->client->ps.torsoAnim == BOTH_CIN_70)
		{
			//no effects, no damage
			return;
		}
		if (ent->client->ps.torsoAnim == BOTH_CIN_50)
		{
			//no effects, no damage
			return;
		}
		if (ent->client->ps.torsoAnim == BOTH_MD_CIN_1)
		{
			//no effects, no damage
			return;
		}
		if (G_InCinematicSaberAnim(ent))
		{
			//baseDFlags = DAMAGE_NO_KILL;
			base_damage = 0.1f;
		}
		else if (ent->client->ps.saber_move == LS_READY && !pm_saber_in_special_attack(ent->client->ps.torsoAnim))
		{
			//just do effects
			if (g_saberRealisticCombat->integer < 2 && ent->health >= 0)
			{
				//don't kill with this hit
				//baseDFlags = DAMAGE_NO_KILL;
			}
			if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
				&& ent->client->ps.saber[saber_num].saberFlags2 & SFL2_NO_IDLE_EFFECT
				|| WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
				&& ent->client->ps.saber[saber_num].saberFlags2 & SFL2_NO_IDLE_EFFECT2)
			{
				//do nothing at all when idle
				return;
			}
			base_damage = 0;
		}
		else if (ent->client->ps.saberLockTime > level.time)
		{
			//just do effects
			if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
				&& ent->client->ps.saber[saber_num].saberFlags2 & SFL2_NO_IDLE_EFFECT
				|| WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
				&& ent->client->ps.saber[saber_num].saberFlags2 & SFL2_NO_IDLE_EFFECT2)
			{
				//do nothing at all when idle
				return;
			}
			base_damage = 0;
		}
		else if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
			&& ent->client->ps.saber[saber_num].damageScale <= 0.0f
			&& ent->client->ps.saber[saber_num].knockbackScale <= 0.0f)
		{
			//this blade does no damage and no knockback (only for blocking?)
			base_damage = 0;
		}
		else if (WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
			&& ent->client->ps.saber[saber_num].damageScale2 <= 0.0f
			&& ent->client->ps.saber[saber_num].knockbackScale2 <= 0.0f)
		{
			//this blade does no damage and no knockback (only for blocking?)
			base_damage = 0;
		}
		else if (ent->client->ps.saberBlocked > BLOCKED_NONE
			|| !PM_SaberInAttack(ent->client->ps.saber_move)
			&& !pm_saber_in_special_attack(ent->client->ps.torsoAnim)
			&& !PM_SaberInTransitionAny(ent->client->ps.saber_move))
		{
			//don't do damage if parrying/reflecting/bouncing/deflecting or not actually attacking or in a transition to/from/between attacks
			if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
				&& ent->client->ps.saber[saber_num].saberFlags2 & SFL2_NO_IDLE_EFFECT
				|| WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
				&& ent->client->ps.saber[saber_num].saberFlags2 & SFL2_NO_IDLE_EFFECT2)
			{
				//do nothing at all when idle
				return;
			}
			base_damage = 0;
		}
		else
		{
			//okay, in a saber_move that does damage
			//make sure we're in the right anim
			if (!pm_saber_in_special_attack(ent->client->ps.torsoAnim)
				&& !PM_InAnimForSaberMove(ent->client->ps.torsoAnim, ent->client->ps.saber_move))
			{
				//forced into some other animation somehow, like a pain or death?
				if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
					&& ent->client->ps.saber[saber_num].saberFlags2 & SFL2_NO_IDLE_EFFECT
					|| WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
					&& ent->client->ps.saber[saber_num].saberFlags2 & SFL2_NO_IDLE_EFFECT2)
				{
					//do nothing at all when idle
					return;
				}
				base_damage = 0;
			}
			else if (ent->client->ps.weaponstate == WEAPON_FIRING
				&& ent->client->ps.saberBlocked == BLOCKED_NONE &&
				(PM_SaberInAttack(ent->client->ps.saber_move)
					|| pm_saber_in_special_attack(ent->client->ps.torsoAnim)
					|| PM_SpinningSaberAnim(ent->client->ps.torsoAnim)
					|| ent_power_level > FORCE_LEVEL_2
					|| WP_SaberBladeDoTransitionDamage(&ent->client->ps.saber[saber_num], blade_num)
					&& PM_SaberInTransitionAny(ent->client->ps.saber_move)))
			{
				if (g_saberRealisticCombat->integer)
				{
					switch (ent_power_level)
					{
					default:
					case FORCE_LEVEL_5:
						base_damage = 7.5f;
						break;
					case FORCE_LEVEL_4: //Staff, medium, duals all do same damage
					case FORCE_LEVEL_3:
						base_damage = 5.0f;
						break;
					case FORCE_LEVEL_2:
						base_damage = 2.0f;
						break;
					case FORCE_LEVEL_1: //Fast damage is so low...
					case FORCE_LEVEL_0:
						base_damage = 1.5f;
						break;
					}
				}
				else
				{
					if (g_spskill->integer > 0
						&& ent->s.number < MAX_CLIENTS
						&& (ent->client->ps.torsoAnim == BOTH_ROLL_STAB
							|| ent->client->ps.torsoAnim == BOTH_SPINATTACK6
							|| ent->client->ps.torsoAnim == BOTH_SPINATTACK7
							|| ent->client->ps.torsoAnim == BOTH_LUNGE2_B__T_))
					{
						//*sigh*, these anim do less damage since they're so easy to do
						base_damage = 1.5f;
					}
					else
					{
						switch (ent_power_level)
						{
						default:
						case FORCE_LEVEL_5:
							base_damage = 2.5f * static_cast<float>(ent_power_level);
						case FORCE_LEVEL_4: //Staff, medium, duals all do same damage
						case FORCE_LEVEL_3:
							base_damage = 2.0f * static_cast<float>(ent_power_level);
							break;
						case FORCE_LEVEL_2:
							base_damage = 1.5f * static_cast<float>(ent_power_level);
							break;
						case FORCE_LEVEL_1: // Fast damage is so low...
						case FORCE_LEVEL_0:
							base_damage = 1.0f * static_cast<float>(ent_power_level);
							break;
						}
					}
				}
			}
			else
			{
				//saber is transitioning, defending or idle, don't do as much damage
				//FIXME: strong attacks and returns should do damage and be unblockable
				if (g_timescale->value < 1.0)
				{
					//in slow mo or force speed, we need to do damage during the transitions
					if (g_saberRealisticCombat->integer > 1)
					{
						switch (ent_power_level)
						{
						case FORCE_LEVEL_5:
							base_damage = 7.5f;
							break;
						case FORCE_LEVEL_4:
						case FORCE_LEVEL_3:
							base_damage = 5.0f;
							break;
						case FORCE_LEVEL_2:
							base_damage = 2.0f;
							break;
						default:
						case FORCE_LEVEL_1:
						case FORCE_LEVEL_0:
							base_damage = 1.5f;
							break;
						}
					}
					else
					{
						base_damage = 1.5f * static_cast<float>(ent_power_level);
					}
				}
				else
				{
					//I have to do *some* damage in transitions or else you feel like a total gimp
					base_damage = 0.1f;
				}
			}
		}

		if (ent->client->ps.saberDamageDebounceTime > level.time)
		{
			//really only used when a saber attack start anim starts, not actually for stopping damage
			//we just want to not use the old position to trace the attack from...
			VectorCopy(ent->client->ps.saber[saber_num].blade[blade_num].muzzlePoint,
				ent->client->ps.saber[saber_num].blade[blade_num].muzzlePointOld);
			VectorCopy(ent->client->ps.saber[saber_num].blade[blade_num].muzzleDir,
				ent->client->ps.saber[saber_num].blade[blade_num].muzzleDirOld);
		}
		//do the damage trace from the last position...
		VectorCopy(ent->client->ps.saber[saber_num].blade[blade_num].muzzlePointOld, mp1);
		VectorCopy(ent->client->ps.saber[saber_num].blade[blade_num].muzzleDirOld, md1);
		//...to the current one.
		VectorCopy(ent->client->ps.saber[saber_num].blade[blade_num].muzzlePoint, mp2);
		VectorCopy(ent->client->ps.saber[saber_num].blade[blade_num].muzzleDir, md2);

		//NOTE: this is a test, may not be necc, as I can still swing right through someone without hitting them, somehow...
		//see if anyone is so close that they're within the dist from my origin to the start of the saber
		if (ent->health > 0 && !ent->client->ps.saberLockTime && saber_num == 0 && blade_num == 0
			&& !G_InCinematicSaberAnim(ent))
		{
			//only do once - for first blade
			trace_t trace;
			gi.trace(&trace, ent->currentOrigin, vec3_origin, vec3_origin, mp1, ent->s.number,
				MASK_SHOT & ~(CONTENTS_CORPSE | CONTENTS_ITEM), static_cast<EG2_Collision>(0), 0);

			if (trace.entityNum < ENTITYNUM_WORLD
				&& (trace.entityNum > 0
					|| ent->client->NPC_class == CLASS_DESANN
					|| ent->client->NPC_class == CLASS_VADER
					|| ent->client->NPC_class == CLASS_SITHLORD
					|| ent->client->NPC_class == CLASS_GROGU
					|| ent->client->NPC_class == CLASS_LUKE)) //NPCs don't push player away, unless it's Desann
			{
				//a valid ent
				gentity_t* traceEnt = &g_entities[trace.entityNum];
				if (traceEnt
					&& traceEnt->client
					&& traceEnt->client->NPC_class != CLASS_RANCOR
					&& traceEnt->client->NPC_class != CLASS_ATST
					&& traceEnt->client->NPC_class != CLASS_WAMPA
					&& traceEnt->client->NPC_class != CLASS_SAND_CREATURE
					&& traceEnt->health > 0
					&& traceEnt->client->playerTeam != ent->client->playerTeam
					&& !PM_SuperBreakLoseAnim(traceEnt->client->ps.legsAnim)
					&& !PM_SuperBreakLoseAnim(traceEnt->client->ps.torsoAnim)
					&& !PM_SuperBreakWinAnim(traceEnt->client->ps.legsAnim)
					&& !PM_SuperBreakWinAnim(traceEnt->client->ps.torsoAnim)
					&& !PM_InKnockDown(&traceEnt->client->ps)
					&& !PM_LockedAnim(traceEnt->client->ps.legsAnim)
					&& !PM_LockedAnim(traceEnt->client->ps.torsoAnim)
					&& !G_InCinematicSaberAnim(traceEnt))
				{
					//enemy client, push them away
					if (!traceEnt->client->ps.saberLockTime
						&& !traceEnt->message
						&& !(traceEnt->flags & FL_NO_KNOCKBACK)
						&& (!traceEnt->NPC || traceEnt->NPC->jumpState != JS_JUMPING))
					{
						//don't push people in saberlock or with security keys or who are in BS_JUMP
						vec3_t hit_dir;
						VectorSubtract(trace.endpos, ent->currentOrigin, hit_dir);
						float total_dist = Distance(mp1, ent->currentOrigin);
						float knockback = (total_dist - VectorNormalize(hit_dir)) / total_dist * 200.0f;
						hit_dir[2] = 0;
						VectorMA(traceEnt->client->ps.velocity, knockback, hit_dir, traceEnt->client->ps.velocity);
						traceEnt->client->ps.pm_time = 200;
						traceEnt->client->ps.pm_flags |= PMF_TIME_NOFRICTION;
						if (d_combatinfo->integer || g_DebugSaberCombat->integer)
						{
							gi.Printf("%s pushing away %s at %s\n", ent->NPC_type, traceEnt->NPC_type,
								vtos(traceEnt->client->ps.velocity));
						}
					}
				}
			}
		}
	}

	//the thicker the blade, the more damage... the thinner, the less damage
	base_damage *= ent->client->ps.saber[saber_num].blade[blade_num].radius / SABER_RADIUS_STANDARD; //MD

	if (g_saberRealisticCombat->integer > 1)
	{
		//always do damage, and lots of it
		if (g_saberRealisticCombat->integer > 2)
		{
			//always do damage, and lots of it
			base_damage = 25.0f;
		}
		else if (base_damage > 0.1f)
		{
			//only do super damage if we would have done damage according to normal rules
			base_damage = 25.0f;
		}
	}
	else if ((!ent->s.number && ent->client->ps.forcePowersActive & 1 << FP_SPEED || ent->client->ps.forcePowersActive &
		1 << FP_RAGE)
		&& g_timescale->value < 1.0f)
	{
		base_damage *= 1.0f - g_timescale->value;
	}
	if (base_damage > 0.1f)
	{
		if (ent->client->ps.forcePowersActive & 1 << FP_RAGE)
		{
			//add some damage if raged
			base_damage += ent->client->ps.forcePowerLevel[FP_RAGE] * 5.0f;
		}
		else if (ent->client->ps.forceRageRecoveryTime)
		{
			//halve it if recovering
			base_damage *= 0.5f;
		}
	}
	// Get the old state of the blade
	VectorCopy(mp1, base_old);
	VectorMA(base_old, ent->client->ps.saber[saber_num].blade[blade_num].length, md1, end_old);
	// Get the future state of the blade
	VectorCopy(mp2, base_new);
	VectorMA(base_new, ent->client->ps.saber[saber_num].blade[blade_num].length, md2, end_new);

	sabersCrossed = -1;

	if (VectorCompare2(base_old, base_new) && VectorCompare2(end_old, end_new))
	{
		hit_wall = WP_SaberDamageForTrace(ent->s.number, mp2, end_new, base_damage * 4, md2,
			qfalse, ent->client->ps.saber[saber_num].type, qfalse, saber_num,
			blade_num);
	}
	else
	{
		float tip_dmg_mod = 1.0f;
		vec3_t base_diff;
		float ave_length, step = 8, stepsize = 8;
		vec3_t ma1, ma2, md2_ang{}, cur_base2;
		int xx;
		//do the trace at the base first
		hit_wall = WP_SaberDamageForTrace(ent->s.number, base_old, base_new, base_damage, md2,
			qfalse, ent->client->ps.saber[saber_num].type, qtrue, saber_num,
			blade_num);

		//if hit a saber, shorten rest of traces to match
		if (saberHitFraction < 1.0)
		{
			vec3_t angles;
			vec3_t vec3;
			vectoangles(md1, angles);
			vectoangles(md2, vec3);
			for (xx = 0; xx < 3; xx++)
			{
				md2_ang[xx] = LerpAngle(angles[xx], vec3[xx], saberHitFraction);
			}
			AngleVectors(md2_ang, md2, nullptr, nullptr);
			//shorten the base pos
			VectorSubtract(mp2, mp1, base_diff);
			VectorMA(mp1, saberHitFraction, base_diff, base_new);
			VectorMA(base_new, ent->client->ps.saber[saber_num].blade[blade_num].length, md2, end_new);
		}

		//If the angle diff in the blade is high, need to do it in chunks of 33 to avoid flattening of the arc
		float dir_inc, cur_dir_frac;
		if (PM_SaberInAttack(ent->client->ps.saber_move)
			|| pm_saber_in_special_attack(ent->client->ps.torsoAnim)
			|| PM_SpinningSaberAnim(ent->client->ps.torsoAnim)
			|| PM_InSpecialJump(ent->client->ps.torsoAnim)
			|| g_timescale->value < 1.0f && PM_SaberInTransitionAny(ent->client->ps.saber_move))
		{
			cur_dir_frac = DotProduct(md1, md2);
		}
		else
		{
			cur_dir_frac = 1.0f;
		}
		//NOTE: if saber spun at least 180 degrees since last damage trace, this is not reliable...!
		if (fabs(cur_dir_frac) < 1.0f - MAX_SABER_SWING_INC)
		{
			//the saber blade spun more than 33 degrees since the last damage trace
			cur_dir_frac = dir_inc = 1.0f / ((1.0f - cur_dir_frac) / MAX_SABER_SWING_INC);
		}
		else
		{
			cur_dir_frac = 1.0f;
			dir_inc = 0.0f;
		}
		qboolean hit_saber = qfalse;

		vectoangles(md1, ma1);
		vectoangles(md2, ma2);

		vec3_t cur_md2;
		VectorCopy(md1, cur_md2);
		VectorCopy(base_old, cur_base2);

		while (true)
		{
			vec3_t curMD1;
			vec3_t curBase1;
			VectorCopy(cur_md2, curMD1);
			VectorCopy(cur_base2, curBase1);
			if (cur_dir_frac >= 1.0f)
			{
				VectorCopy(md2, cur_md2);
				VectorCopy(base_new, cur_base2);
			}
			else
			{
				for (xx = 0; xx < 3; xx++)
				{
					md2_ang[xx] = LerpAngle(ma1[xx], ma2[xx], cur_dir_frac);
				}
				AngleVectors(md2_ang, cur_md2, nullptr, nullptr);
				//VectorMA( md1, curDirFrac, mdDiff, curMD2 );
				VectorSubtract(base_new, base_old, base_diff);
				VectorMA(base_old, cur_dir_frac, base_diff, cur_base2);
			}
			// Move up the blade in intervals of stepsize
			for (step = stepsize; step < ent->client->ps.saber[saber_num].blade[blade_num].length && step < ent->client
				->
				ps.saber[saber_num].blade[blade_num].lengthOld; step += 12)
			{
				vec3_t blade_point_new;
				vec3_t blade_point_old;
				VectorMA(curBase1, step, curMD1, blade_point_old);
				VectorMA(cur_base2, step, cur_md2, blade_point_new);
				if (WP_SaberDamageForTrace(ent->s.number, blade_point_old, blade_point_new, base_damage, cur_md2,
					qfalse, ent->client->ps.saber[saber_num].type, qtrue, saber_num,
					blade_num))
				{
					hit_wall = qtrue;
				}

				//if hit a saber, shorten rest of traces to match
				if (saberHitFraction < 1.0)
				{
					//adjust muzzle endpoint
					VectorSubtract(mp2, mp1, base_diff);
					VectorMA(mp1, saberHitFraction, base_diff, base_new);
					VectorMA(base_new, ent->client->ps.saber[saber_num].blade[blade_num].length, cur_md2, end_new);
					//adjust muzzleDir...
					vec3_t cur_ma1, cur_ma2;
					vectoangles(curMD1, cur_ma1);
					vectoangles(cur_md2, cur_ma2);
					for (xx = 0; xx < 3; xx++)
					{
						md2_ang[xx] = LerpAngle(cur_ma1[xx], cur_ma2[xx], saberHitFraction);
					}
					AngleVectors(md2_ang, cur_md2, nullptr, nullptr);
					hit_saber = qtrue;
				}
				if (hit_wall)
				{
					break;
				}
			}
			if (hit_wall || hit_saber)
			{
				break;
			}
			if (cur_dir_frac >= 1.0f)
			{
				break;
			}
			cur_dir_frac += dir_inc;
			if (cur_dir_frac >= 1.0f)
			{
				cur_dir_frac = 1.0f;
			}
		}

		//do the trace at the end last
		//Special check- adjust for length of blade not being a multiple of 12
		ave_length = (ent->client->ps.saber[saber_num].blade[blade_num].lengthOld + ent->client->ps.saber[saber_num].
			blade[
				blade_num].length) / 2;
		if (step > ave_length)
		{
			//less dmg if the last interval was not stepsize
			tip_dmg_mod = (stepsize - (step - ave_length)) / stepsize;
		}
		//NOTE: since this is the tip, we do not extrapolate the extra 16
		if (WP_SaberDamageForTrace(ent->s.number, end_old, end_new, tip_dmg_mod * base_damage, md2,
			qfalse, ent->client->ps.saber[saber_num].type, qfalse, saber_num,
			blade_num))
		{
			hit_wall = qtrue;
		}
	}

	if ((saberHitFraction < 1.0f || sabersCrossed >= 0 && sabersCrossed <= 32.0f) && (ent->client->ps.weaponstate ==
		WEAPON_FIRING || ent->client->ps.saberInFlight || G_InCinematicSaberAnim(ent)))
	{
		// The saber (in-hand) hit another saber, mano.
		qboolean in_flight_saber_blocked = qfalse;
		qboolean collision_resolved = qfalse;
		qboolean deflected = qfalse;
		gentity_t* hit_ent = &g_entities[saberHitEntity];
		gentity_t* hit_owner = nullptr;
		int hit_owner_power_level = FORCE_LEVEL_0;

		if (hit_ent)
		{
			hit_owner = hit_ent->owner;
		}
		if (hit_owner && hit_owner->client)
		{
			hit_owner_power_level = 2 * hit_owner->client->ps.forcePowerLevel[FP_SABER_DEFENSE] +
				PM_PowerLevelForSaberAnim(
					&hit_owner->client->ps);
		}

		if (ent->client->ps.saberInFlight && saber_num == 0 &&
			ent->client->ps.saber[saber_num].blade[blade_num].active &&
			ent->client->ps.saberEntityNum != ENTITYNUM_NONE &&
			ent->client->ps.saberEntityState != SES_RETURNING)
		{
			//saber was blocked, return it
			in_flight_saber_blocked = qtrue;
		}

		//start of saber behaviour code jacesolaris

		if (hit_owner && hit_owner->health > 0 && ent->health > 0 //both are alive
			&& !in_flight_saber_blocked
			&& hit_owner->client
			&& !hit_owner->client->ps.saberInFlight
			&& !ent->client->ps.saberInFlight //both have sabers in-hand
			&& ent->client->ps.saberBlocked != BLOCKED_PARRY_BROKEN
			&& ent->client->ps.saberLockTime < level.time
			&& hit_owner->client->ps.saberLockTime < level.time)
		{
			//2 in-hand sabers hit
			if (base_damage)
			{
				//there is damage involved, not just effects
				qboolean ent_attacking = qfalse;
				qboolean hit_owner_attacking = qfalse;
				qboolean ent_defending = qfalse;
				qboolean hit_owner_defending = qfalse;
				qboolean force_lock = qfalse;
				qboolean atkfake = ent->client->ps.userInt3 & 1 << FLAG_ATTACKFAKE ? qtrue : qfalse;
				qboolean otherfake = hit_owner->client->ps.userInt3 & 1 << FLAG_ATTACKFAKE ? qtrue : qfalse;

				if (ent->client->NPC_class == CLASS_KYLE && ent->spawnflags & 1 && hit_owner->s.number < MAX_CLIENTS
					|| hit_owner->client->NPC_class == CLASS_KYLE && hit_owner->spawnflags & 1 && ent->s.number <
					MAX_CLIENTS)
				{
					//Player vs. Kyle Boss == lots of saberlocks
					if (!Q_irand(0, 2))
					{
						force_lock = qtrue;
					}
				}

				if (PM_SaberInAttack(ent->client->ps.saber_move) ||
					PM_SaberInDamageMove(ent->client->ps.saber_move) ||
					pm_saber_in_special_attack(ent->client->ps.torsoAnim) ||
					PM_SaberDoDamageAnim(ent->client->ps.torsoAnim))
				{
					ent_attacking = qtrue;
				}

				if (PM_SaberInParry(ent->client->ps.saber_move)
					|| ent->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCK
					|| ent->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCKANDATTACK
					|| ent->client->ps.ManualBlockingFlags & 1 << PERFECTBLOCKING
					|| g_saberAutoBlocking->integer && ent->NPC && !G_ControlledByPlayer(ent)
					|| ent->client->ps.ManualBlockingFlags & 1 << MBF_NPCBLOCKING && ent->NPC && !
					G_ControlledByPlayer(ent)
					|| ent->client->ps.saberBlockingTime > level.time
					|| ent->client->ps.saber_move == LS_READY)
				{
					ent_defending = qtrue;
				}

				if (ent->client->ps.torsoAnim == BOTH_A1_SPECIAL
					|| ent->client->ps.torsoAnim == BOTH_A2_SPECIAL
					|| ent->client->ps.torsoAnim == BOTH_A3_SPECIAL
					|| ent->client->ps.torsoAnim == BOTH_A7_SOULCAL
					|| ent->client->ps.torsoAnim == BOTH_A6_SABERPROTECT)
				{
					//parry/block/break-parry bonus for single-style kata moves
					ent_power_level++;
				}
				if (ent_attacking)
				{
					//add twoHanded bonus and breakParryBonus to entPowerLevel here
					if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num))
					{
						ent_power_level += ent->client->ps.saber[saber_num].breakParryBonus;
					}
					else if (WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num))
					{
						ent_power_level += ent->client->ps.saber[saber_num].breakParryBonus2;
					}
				}
				else if (ent_defending)
				{
					//add twoHanded bonus and dualSaber bonus and parryBonus to entPowerLevel here
					ent_power_level += Q_irand(ent->client->ps.saber[saber_num].parryBonus,
						ent->client->ps.forcePowerLevel[FP_SABER_DEFENSE]);
				}

				if (PM_SaberInAttack(hit_owner->client->ps.saber_move) ||
					PM_SaberInDamageMove(hit_owner->client->ps.saber_move) ||
					pm_saber_in_special_attack(hit_owner->client->ps.torsoAnim) ||
					PM_SaberDoDamageAnim(hit_owner->client->ps.torsoAnim))
				{
					hit_owner_attacking = qtrue;
				}

				if (PM_SaberInParry(hit_owner->client->ps.saber_move)
					|| hit_owner->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCK
					|| hit_owner->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCKANDATTACK
					|| hit_owner->client->ps.ManualBlockingFlags & 1 << PERFECTBLOCKING
					|| g_saberAutoBlocking->integer && hit_owner->NPC && !G_ControlledByPlayer(hit_owner)
					|| hit_owner->client->ps.ManualBlockingFlags & 1 << MBF_NPCBLOCKING && hit_owner->NPC && !
					G_ControlledByPlayer(hit_owner)
					|| hit_owner->client->ps.saberBlockingTime > level.time
					|| hit_owner->client->ps.saber_move == LS_READY)
				{
					hit_owner_defending = qtrue;
				}

				if (hit_owner->client->ps.torsoAnim == BOTH_A1_SPECIAL
					|| hit_owner->client->ps.torsoAnim == BOTH_A2_SPECIAL
					|| hit_owner->client->ps.torsoAnim == BOTH_A3_SPECIAL
					|| hit_owner->client->ps.torsoAnim == BOTH_A7_SOULCAL
					|| hit_owner->client->ps.torsoAnim == BOTH_A6_SABERPROTECT)
				{
					//parry/block/break-parry bonus for single-style kata moves
					hit_owner_power_level++;
				}
				if (hit_owner_attacking)
				{
					//add twoHanded bonus and breakParryBonus to entPowerLevel here
					hit_owner_power_level += hit_owner->client->ps.saber[0].breakParryBonus;

					if (hit_owner->client->ps.dualSabers && Q_irand(0, 1))
					{
						hit_owner_power_level += 1 + hit_owner->client->ps.saber[1].breakParryBonus;
					}
				}
				else if (hit_owner_defending)
				{
					//add twoHanded bonus and dualSaber bonus and parryBonus to entPowerLevel here
					hit_owner_power_level += Q_irand(hit_owner->client->ps.saber[saber_num].parryBonus,
						hit_owner->client->ps.forcePowerLevel[FP_SABER_DEFENSE]);

					if (hit_owner->client->ps.dualSabers && Q_irand(0, 1))
					{
						hit_owner_power_level += 1 + Q_irand(hit_owner->client->ps.saber[saber_num].parryBonus,
							hit_owner->client->ps.forcePowerLevel[FP_SABER_DEFENSE]);
					}
				}

				if (PM_SuperBreakLoseAnim(ent->client->ps.torsoAnim)
					|| PM_SuperBreakWinAnim(ent->client->ps.torsoAnim)
					|| PM_SuperBreakLoseAnim(hit_owner->client->ps.torsoAnim)
					|| PM_SuperBreakWinAnim(hit_owner->client->ps.torsoAnim))
				{
					//don't mess with this
					collision_resolved = qtrue;
				}
				else if (ent_attacking && hit_owner_attacking && ent_power_level == hit_owner_power_level
					&& g_saberLockRandomNess->integer > 1 && Q_irand(1, 5) <= g_saberLockRandomNess->integer && WP_SabersCheckLock(ent, hit_owner))
				{
					collision_resolved = qtrue;
				}
				else if (hit_owner_attacking && ent_defending && hit_owner_power_level > ent_power_level
					&& Q_irand(1, 5) <= g_saberLockRandomNess->integer && WP_SabersCheckLock(ent, hit_owner))
				{
					collision_resolved = qtrue;
				}
				else if (ent_attacking && hit_owner_defending && ent_power_level > hit_owner_power_level
					&& Q_irand(1, 5) <= g_saberLockRandomNess->integer && WP_SabersCheckLock(ent, hit_owner))
				{
					collision_resolved = qtrue;
				}
				else if (atkfake && !otherfake && Q_irand(1, 5) <= g_saberLockRandomNess->integer && WP_SabersCheckLock(ent, hit_owner))
				{
					collision_resolved = qtrue;
				}
				else if (otherfake && !atkfake && Q_irand(1, 5) <= g_saberLockRandomNess->integer && WP_SabersCheckLock(hit_owner, ent))
				{
					collision_resolved = qtrue;
				}
				else if (otherfake && atkfake && Q_irand(1, 5) <= g_saberLockRandomNess->integer && WP_SabersCheckLock(hit_owner, ent))
				{
					collision_resolved = qtrue;
				}
				else if (force_lock && WP_SabersCheckLock(ent, hit_owner))
				{
					collision_resolved = qtrue;
				}
				else if (force_lock && WP_SabersCheckLock(hit_owner, ent))
				{
					collision_resolved = qtrue;
				}
				else if ((ent_attacking && (ent->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(ent)))
					&& (hit_owner_defending && (hit_owner->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(hit_owner)))
					&& Q_irand(1, 5) <= g_saberLockRandomNess->integer
					&& (g_debugSaberLock->integer || force_lock && WP_SabersCheckLock(ent, hit_owner)))
				{
					collision_resolved = qtrue;
				}
				else if (ent_attacking && hit_owner_defending)
				{
					//I'm attacking hit, they're parrying
					if (saberHitFraction < 1.0f)
					{
						//make me parry	-(Im the blocker)
						sab_beh_block_vs_attack(hit_owner, ent, saber_num, blade_num, saberHitLocation);

						//make me bounce -(Im the attacker)
						sab_beh_attack_vs_block(ent, hit_owner, saber_num, blade_num, saberHitLocation);

						collision_resolved = qtrue;
					}
				}
				else
				{
					//some other kind of in-hand saber collision
				}
			}
		}
		else
		{
			//some kind of in-flight collision
		}

		if (saberHitFraction < 1.0f)
		{
			auto active_defenseentagain = static_cast<qboolean>
				(ent->client->ps.ManualBlockingFlags & 1 << MBF_NPCBLOCKING || ent->client->ps.ManualBlockingFlags & 1
					<< HOLDINGBLOCK);

			if (!collision_resolved && base_damage)
			{
				//some other kind of in-hand saber collision
				//handle my reaction
				if (!ent->client->ps.saberInFlight
					&& ent->client->ps.saberLockTime < level.time)
				{
					//my saber is in hand
					if (ent->client->ps.saberBlocked != BLOCKED_PARRY_BROKEN)
					{
						if (PM_SaberInAttack(ent->client->ps.saber_move)
							|| pm_saber_in_special_attack(ent->client->ps.torsoAnim)
							&& !PM_SaberInIdle(ent->client->ps.saber_move)
							&& !PM_SaberInParry(ent->client->ps.saber_move)
							&& !PM_SaberInReflect(ent->client->ps.saber_move)
							&& !PM_SaberInBounce(ent->client->ps.saber_move)
							&& !PM_SaberInMassiveBounce(ent->client->ps.saber_move))
						{
							//in the middle of attacking
							if (hit_owner->health > 0)
							{
								//don't deflect/bounce in strong attack or when enemy is dead
								WP_GetSaberDeflectionAngle(ent, hit_owner);
								ent->client->ps.saberEventFlags |= SEF_BLOCKED;
								wp_saber_clear_damage_for_ent_num(ent, hit_owner->s.number, saber_num, blade_num);

								if (d_blockinfo->integer || g_DebugSaberCombat->integer)
								{
									gi.Printf(S_COLOR_CYAN"Saber Throw ent Swing blocked\n");
								}
							}
						}
						else
						{
							if (active_defenseentagain)
							{
								if (!PM_SaberInTransitionAny(ent->client->ps.saber_move) && !PM_SaberInBounce(
									ent->client->ps.saber_move))
								{
									WP_SaberParry(ent, hit_owner, saber_num, blade_num);
									wp_saber_clear_damage_for_ent_num(ent, hit_owner->s.number, saber_num, blade_num);
									ent->client->ps.saberEventFlags |= SEF_PARRIED;

									if (d_blockinfo->integer || g_DebugSaberCombat->integer)
									{
										gi.Printf(S_COLOR_CYAN"Saber throw ent manual blocked\n");
									}
								}
							}
						}
					}
					else
					{
						wp_saber_clear_damage_for_ent_num(ent, hit_owner->s.number, saber_num, blade_num);

						if (d_blockinfo->integer || g_DebugSaberCombat->integer)
						{
							gi.Printf(S_COLOR_CYAN"Saber throw ent auto cleared damage?\n");
						}
					}
				}
				else
				{
					//nothing happens to *me* when my inFlight saber hits something
				}

				//handle their reaction
				if (hit_owner
					&& hit_owner->health > 0
					&& hit_owner->client
					&& !hit_owner->client->ps.saberInFlight
					&& hit_owner->client->ps.saberLockTime < level.time)
				{
					//their saber is in hand
					if (PM_SaberInAttack(hit_owner->client->ps.saber_move) || pm_saber_in_special_attack(
						hit_owner->client->ps.torsoAnim)
						&& !PM_SaberInIdle(hit_owner->client->ps.saber_move)
						&& !PM_SaberInParry(hit_owner->client->ps.saber_move)
						&& !PM_SaberInReflect(hit_owner->client->ps.saber_move)
						&& !PM_SaberInBounce(hit_owner->client->ps.saber_move)
						&& !PM_SaberInMassiveBounce(hit_owner->client->ps.saber_move))
					{
						//in the middle of attacking
						if (d_blockinfo->integer || g_DebugSaberCombat->integer)
						{
							gi.Printf(S_COLOR_CYAN"Saber throw Hit owner blank\n");
						}
					}
					else
					{
						//saber collided when not attacking, parry it
						if (!PM_SaberInBrokenParry(hit_owner->client->ps.saber_move))
						{
							if (!WP_SaberParry(hit_owner, ent, saber_num, blade_num))
							{
								if (hit_owner->client->ps.forcePower < BLOCKPOINTS_FATIGUE)
								{
									//Low points = bad blocks
									SabBeh_SaberShouldBeDisarmedBlocker(hit_owner, saber_num);
									wp_block_points_regenerate_over_ride(hit_owner, BLOCKPOINTS_TEN);
								}
								else
								{
									g_fatigue_bp_knockaway(hit_owner);
									PM_AddBlockFatigue(&hit_owner->client->ps, BLOCKPOINTS_TEN);
								}

								if (d_blockinfo->integer || g_DebugSaberCombat->integer)
								{
									gi.Printf(S_COLOR_CYAN"Saber throw hit owner Did not parry\n");
								}
							}
						}
					}
				}
				else
				{
					//nothing happens to *hitOwner* when their inFlight saber hits something
				}
			}

			//collision must have been handled by now
			//Set the blocked attack bounce value in saberBlocked so we actually play our saberBounceMove anim
			if (ent->client->ps.saberEventFlags & SEF_BLOCKED)
			{
				if (ent->client->ps.saberBlocked != BLOCKED_PARRY_BROKEN)
				{
					ent->client->ps.saberBlocked = BLOCKED_ATK_BOUNCE;
					ent->client->ps.userInt3 |= 1 << FLAG_SLOWBOUNCE;
				}
			}
		}
		// End of saber behaviour code jacesolaris

		/////////////////////////////////////Sound effects //////////////////////////////////////
		if (saberHitFraction < 1.0f || collision_resolved)
		{
			//either actually hit or locked
			if (ent->client->ps.saberLockTime < level.time)
			{
				if (in_flight_saber_blocked)
				{
					//FIXME: never hear this sound
					WP_SaberBounceSound(ent, &g_entities[ent->client->ps.saberEntityNum], 0, 0);
				}
				else
				{
					if (deflected)
					{
						WP_SaberBounceSound(ent, nullptr, saber_num, blade_num);
					}
					else
					{
						if (ent->client->ps.forcePower > BLOCKPOINTS_HALF || ent->client->ps.userInt3 & 1 << FLAG_PERFECTBLOCK)
						{
							WP_SaberBlockSound(ent, saber_num, blade_num);
						}
						else
						{
							WP_SaberKnockSound(ent, saber_num, blade_num);
						}
					}
				}
				if (!g_saberNoEffects)
				{
					if (ent->client->ps.forcePower > BLOCKPOINTS_HALF || ent->client->ps.userInt3 & 1 << FLAG_PERFECTBLOCK)
					{
						WP_SaberMBlockEffect(ent, saber_num, blade_num, saberHitLocation, saberHitNormal, qfalse);
					}
					else
					{
						WP_SaberBlockEffect(ent, saber_num, blade_num, saberHitLocation, saberHitNormal, qfalse);
					}
				}
			}
			if (!g_noClashFlare)
			{
				g_saberFlashTime = level.time - 50;
				VectorCopy(saberHitLocation, g_saberFlashPos);
			}
		}

		if (saberHitFraction < 1.0f)
		{
			if (in_flight_saber_blocked)
			{
				//we threw a saber and it was blocked, do any effects, etc.
				int knock_away = 5;
				if (hit_ent
					&& hit_owner
					&& hit_owner->client
					&& (PM_SaberInAttack(hit_owner->client->ps.saber_move)
						|| pm_saber_in_special_attack(hit_owner->client->ps.torsoAnim)
						|| PM_SpinningSaberAnim(hit_owner->client->ps.torsoAnim)))
				{
					//if hit someone who was in an attack or spin anim, more likely to have in-flight saber knocked away
					if (hit_owner_power_level > FORCE_LEVEL_2)
					{
						//strong attacks almost always knock it aside!
						knock_away = 1;
					}
					else
					{
						//33% chance
						knock_away = 2;
					}
					knock_away -= hit_owner->client->ps.SaberDisarmBonus(0);
				}
				if (Q_irand(0, knock_away) <= 0 || //random
					hit_owner
					&& hit_owner->client
					&& hit_owner->NPC
					&& (hit_owner->NPC->aiFlags & NPCAI_BOSS_CHARACTER || hit_owner->NPC->aiFlags &
						NPCAI_BOSS_SERENITYJEDIENGINE))
					//or if blocked by a Boss character FIXME: or base on defense level?
				{
					//knock it aside and turn it off
					if (!g_saberNoEffects)
					{
						if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
							&& ent->client->ps.saber[saber_num].hitOtherEffect)
						{
							G_PlayEffect(ent->client->ps.saber[saber_num].hitOtherEffect, saberHitLocation,
								saberHitNormal);
						}
						else if (WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
							&& ent->client->ps.saber[saber_num].hitOtherEffect2)
						{
							G_PlayEffect(ent->client->ps.saber[saber_num].hitOtherEffect2, saberHitLocation,
								saberHitNormal);
						}
						else
						{
							if (ent->client->ps.forcePower < BLOCKPOINTS_HALF)
							{
								G_PlayEffect("saber/saber_bodyhit", saberHitLocation, saberHitNormal);
							}
							else
							{
								G_PlayEffect("saber/saber_cut_MD", saberHitLocation, saberHitNormal);
							}
						}
					}
					if (hit_ent)
					{
						vec3_t new_dir;

						VectorSubtract(g_entities[ent->client->ps.saberEntityNum].currentOrigin, hit_ent->currentOrigin,
							new_dir);
						VectorNormalize(new_dir);
						if (ent->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(ent))
						{
							G_ReflectMissileNPC(ent, &g_entities[ent->client->ps.saberEntityNum], new_dir);
						}
						else
						{
							if (g_SerenityJediEngineMode->integer)
							{
								G_ReflectMissileAuto(ent, &g_entities[ent->client->ps.saberEntityNum], new_dir);
							}
							else
							{
								G_ReflectMissile_JKA(ent, &g_entities[ent->client->ps.saberEntityNum], new_dir);
							}
						}
					}
					jedi_play_deflect_sound(hit_owner);
					WP_SaberDrop(ent, &g_entities[ent->client->ps.saberEntityNum]);
				}
				else
				{
					if (!Q_irand(0, 2) && hit_ent)
					{
						vec3_t new_dir;

						VectorSubtract(g_entities[ent->client->ps.saberEntityNum].currentOrigin, hit_ent->currentOrigin,
							new_dir);
						VectorNormalize(new_dir);
						if (ent->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(ent))
						{
							G_ReflectMissileNPC(ent, &g_entities[ent->client->ps.saberEntityNum], new_dir);
						}
						else
						{
							if (g_SerenityJediEngineMode->integer)
							{
								G_ReflectMissileAuto(ent, &g_entities[ent->client->ps.saberEntityNum], new_dir);
							}
							else
							{
								G_ReflectMissile_JKA(ent, &g_entities[ent->client->ps.saberEntityNum], new_dir);
							}
						}
					}
					WP_SaberDrop(ent, &g_entities[ent->client->ps.saberEntityNum]);
				}
			}
		}
	}

	if (ent->client->ps.saberLockTime > level.time)
	{
		if (ent->s.number < ent->client->ps.saberLockEnemy)
		{
			vec3_t hit_norm = { 0, 0, 1 };

			if (wp_sabers_intersection(ent, &g_entities[ent->client->ps.saberLockEnemy], g_saberFlashPos))
			{
				int index = 1;
				index = Q_irand(1, 9);

				if (!g_saberNoEffects)
				{
					G_PlayEffect("saber/saber_lock.efx", g_saberFlashPos, hit_norm);
				}
				G_Sound(ent, G_SoundIndex(va("sound/weapons/saber/saberlock%d.mp3", index)));
			}
		}
	}
	else
	{
		if (hit_wall
			&& (ent->client->ps.saber[saber_num].saberFlags & SFL_BOUNCE_ON_WALLS || g_SaberBounceOnWalls->integer)
			&& (PM_SaberInAttackPure(ent->client->ps.saber_move) || ent->client->ps.saber_move == LS_A_JUMP_T__B_))
		{
			//bounce off walls
			//do anim
			ent->client->ps.saberBlocked = BLOCKED_ATK_BOUNCE;
			ent->client->ps.saberBounceMove = LS_D1_BR + (saber_moveData[ent->client->ps.saber_move].startQuad - Q_BR);
			//do bounce sound & force feedback
			WP_SaberBounceOnWallSound(ent, saber_num, blade_num);
			//do hit effect
			if (!g_saberNoEffects)
			{
				if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
					&& ent->client->ps.saber[saber_num].hitOtherEffect)
				{
					G_PlayEffect(ent->client->ps.saber[saber_num].hitOtherEffect, saberHitLocation, saberHitNormal);
				}
				else if (WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
					&& ent->client->ps.saber[saber_num].hitOtherEffect2)
				{
					G_PlayEffect(ent->client->ps.saber[saber_num].hitOtherEffect2, saberHitLocation, saberHitNormal);
				}
				else
				{
					G_PlayEffect("saber/saber_bodyhit", saberHitLocation, saberHitNormal);
				}
			}
			//do radius damage/knockback, if any
			if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num))
			{
				WP_SaberRadiusDamage(ent, saberHitLocation, ent->client->ps.saber[saber_num].splashRadius,
					ent->client->ps.saber[saber_num].splashDamage,
					ent->client->ps.saber[saber_num].splashKnockback);
			}
			else
			{
				WP_SaberRadiusDamage(ent, saberHitLocation, ent->client->ps.saber[saber_num].splashRadius2,
					ent->client->ps.saber[saber_num].splashDamage2,
					ent->client->ps.saber[saber_num].splashKnockback2);
			}
		}
		else if (hit_wall &&
			!PM_SaberInAttackPure(ent->client->ps.saber_move) &&
			!PM_CrouchAnim(ent->client->ps.legsAnim) &&
			!PM_WalkingAnim(ent->client->ps.legsAnim) &&
			!PM_RunningAnim(ent->client->ps.legsAnim) &&
			ent->client->buttons & BUTTON_WALKING &&
			ent->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCK &&
			(ent->s.number < MAX_CLIENTS || G_ControlledByPlayer(ent)) &&
			(ent->client->ps.forcePower < BLOCKPOINTS_DANGER || ent->client->ps.blockPoints < BLOCKPOINTS_DANGER))
		{
			//reflect from wall
			ent->client->ps.saberBlocked = BLOCKED_ATK_BOUNCE;
			ent->client->ps.saberBounceMove = LS_D1_BR + (saber_moveData[ent->client->ps.saber_move].startQuad - Q_BR);

			//do hit effect
			if (!g_saberNoEffects)
			{
				if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
					&& ent->client->ps.saber[saber_num].hitOtherEffect)
				{
					G_PlayEffect(ent->client->ps.saber[saber_num].hitOtherEffect, saberHitLocation, saberHitNormal);
				}
				else if (WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num)
					&& ent->client->ps.saber[saber_num].hitOtherEffect2)
				{
					G_PlayEffect(ent->client->ps.saber[saber_num].hitOtherEffect2, saberHitLocation, saberHitNormal);
				}
				else
				{
					G_PlayEffect("saber/saber_cut", saberHitLocation, saberHitNormal);
				}
			}
			//do radius damage/knockback, if any
			if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[saber_num], blade_num))
			{
				WP_SaberRadiusDamage(ent, saberHitLocation, ent->client->ps.saber[saber_num].splashRadius,
					ent->client->ps.saber[saber_num].splashDamage,
					ent->client->ps.saber[saber_num].splashKnockback);
			}
			else
			{
				WP_SaberRadiusDamage(ent, saberHitLocation, ent->client->ps.saber[saber_num].splashRadius2,
					ent->client->ps.saber[saber_num].splashDamage2,
					ent->client->ps.saber[saber_num].splashKnockback2);
			}
		}
	}

	if (WP_SaberApplyDamageMD(ent, base_damage, base_d_flags, broken_parry, saber_num, blade_num,
		static_cast<qboolean>(saber_num == 0 && ent->client->ps.saberInFlight))) //MD Mode
	{
		//actually did damage to something
		WP_SaberHitSound(ent, saber_num, blade_num);

		if (!saber_in_special && (d_combatinfo->integer || g_DebugSaberCombat->integer))
		{
			if (g_saberRealisticCombat->integer == 3)
			{
				gi.Printf("MD Mode Very High Damage. Min damage done was %4.2f\n", base_damage);
			}
			else if (g_saberRealisticCombat->integer == 2)
			{
				gi.Printf("MD Mode High Damage. Min damage done was %4.2f\n", base_damage);
			}
			else if (g_saberRealisticCombat->integer == 1)
			{
				gi.Printf("MD Mode Medium Damage. Min damage done was %4.2f\n", base_damage);
			}
			else if (g_saberRealisticCombat->integer == 0)
			{
				gi.Printf("MD Mode Low Damage. Min damage done was %4.2f\n", base_damage);
			}
		}
	}

	if (hit_wall)
	{
		//just so Jedi knows that he hit a wall
		ent->client->ps.saberEventFlags |= SEF_HITWALL;
		if (ent->s.number == 0)
		{
			AddSoundEvent(ent, ent->currentOrigin, 128, AEL_DISCOVERED, qfalse, qtrue);
			//FIXME: is this impact on ground or not?
			AddSightEvent(ent, ent->currentOrigin, 256, AEL_DISCOVERED, 50);
		}
	}
}

void WP_SabersDamageTrace(gentity_t* ent, const qboolean no_effects)
{
	if (!ent->client)
	{
		return;
	}
	if (PM_SuperBreakLoseAnim(ent->client->ps.torsoAnim))
	{
		return;
	}
	// Saber 1.
	g_saberNoEffects = no_effects;
	for (int i = 0; i < ent->client->ps.saber[0].numBlades; i++)
	{
		// If the Blade is not active and the length is 0, don't trace it, try the next blade...
		if (!ent->client->ps.saber[0].blade[i].active && ent->client->ps.saber[0].blade[i].length == 0)
			continue;

		if (i != 0)
		{
			//not first blade
			if (ent->client->ps.saber[0].type == SABER_BROAD ||
				ent->client->ps.saber[0].type == SABER_SAI ||
				ent->client->ps.saber[0].type == SABER_CLAW)
			{
				g_saberNoEffects = qtrue;
			}
		}
		g_noClashFlare = qfalse;
		if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[0], i) && ent->client->ps.saber[0].saberFlags2 &
			SFL2_NO_CLASH_FLARE
			|| WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[0], i) && ent->client->ps.saber[0].saberFlags2 &
			SFL2_NO_CLASH_FLARE2)
		{
			g_noClashFlare = qtrue;
		}

		if (g_SerenityJediEngineMode->integer && !in_camera)
		{
			if (g_SerenityJediEngineMode->integer == 2)
			{
				wp_saber_damage_trace_amd(ent, 0, i);
			}
			else
			{
				WP_SaberDamageTrace_MD(ent, 0, i);
			}
		}
		else
		{
			WP_SaberDamageTrace(ent, 0, i);
		}
	}
	// Saber 2.
	g_saberNoEffects = no_effects;
	if (ent->client->ps.dualSabers)
	{
		for (int i = 0; i < ent->client->ps.saber[1].numBlades; i++)
		{
			// If the Blade is not active and the length is 0, don't trace it, try the next blade...
			if (!ent->client->ps.saber[1].blade[i].active && ent->client->ps.saber[1].blade[i].length == 0)
				continue;

			if (i != 0)
			{
				//not first blade
				if (ent->client->ps.saber[1].type == SABER_BROAD ||
					ent->client->ps.saber[1].type == SABER_SAI ||
					ent->client->ps.saber[1].type == SABER_CLAW)
				{
					g_saberNoEffects = qtrue;
				}
			}
			g_noClashFlare = qfalse;
			if (!WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[1], i) && ent->client->ps.saber[1].saberFlags2
				& SFL2_NO_CLASH_FLARE
				|| WP_SaberBladeUseSecondBladeStyle(&ent->client->ps.saber[1], i) && ent->client->ps.saber[1].
				saberFlags2 & SFL2_NO_CLASH_FLARE2)
			{
				g_noClashFlare = qtrue;
			}

			if (g_SerenityJediEngineMode->integer && !in_camera)
			{
				if (g_SerenityJediEngineMode->integer == 2)
				{
					wp_saber_damage_trace_amd(ent, 1, i);
				}
				else
				{
					WP_SaberDamageTrace_MD(ent, 1, i);
				}
			}
			else
			{
				WP_SaberDamageTrace(ent, 1, i);
			}
		}
	}
	g_saberNoEffects = qfalse;
	g_noClashFlare = qfalse;
}

//SABER THROWING============================================================================
//SABER THROWING============================================================================
//SABER THROWING============================================================================
//SABER THROWING============================================================================
//SABER THROWING============================================================================
//SABER THROWING============================================================================

/*
================
WP_SaberImpact

================
*/
static void WP_SaberImpact(gentity_t* owner, gentity_t* saber, trace_t* trace)
{
	gentity_t* other = &g_entities[trace->entityNum];

	if (other->takedamage && other->svFlags & SVF_BBRUSH)
	{
		//a breakable brush?  break it!
		if (other->spawnflags & 1 //INVINCIBLE
			|| other->flags & FL_DMG_BY_HEAVY_WEAP_ONLY) //HEAVY weapon damage only
		{
			//can't actually break it
			//no hit effect (besides regular client-side one)
		}
		else if (other->NPC_targetname &&
			(!owner || !owner->targetname || Q_stricmp(owner->targetname, other->NPC_targetname)))
		{
			//only breakable by an entity who is not the attacker
			//no hit effect (besides regular client-side one)
		}
		else
		{
			vec3_t dir;
			VectorCopy(saber->s.pos.trDelta, dir);
			VectorNormalize(dir);

			int dmg = other->health * 2;
			if (other->health > 50 && dmg > 20 && !(other->svFlags & SVF_GLASS_BRUSH))
			{
				dmg = 20;
			}
			G_Damage(other, saber, owner, dir, trace->endpos, dmg, 0, MOD_SABER);
			if (owner
				&& owner->client
				&& owner->client->ps.saber[0].hitOtherEffect)
			{
				G_PlayEffect(owner->client->ps.saber[0].hitOtherEffect, trace->endpos, dir);
			}
			else
			{
				if (g_SerenityJediEngineMode->integer)
				{
					if (g_SerenityJediEngineMode->integer == 2)
					{
						G_PlayEffect("saber/saber_cut_AMD", trace->endpos, dir);
					}
					else
					{
						G_PlayEffect("saber/saber_cut_MD", trace->endpos, dir);
					}
				}
				else
				{
					G_PlayEffect("saber/saber_cut", trace->endpos, dir);
				}
			}
			if (owner->s.number == 0)
			{
				AddSoundEvent(owner, trace->endpos, 256, AEL_DISCOVERED);
				AddSightEvent(owner, trace->endpos, 512, AEL_DISCOVERED, 50);
			}
			return;
		}
	}

	if (saber->s.pos.trType == TR_LINEAR)
	{
		if (g_SerenityJediEngineMode->integer && g_SaberMustReturn->integer < 1 && (owner->s.number < MAX_CLIENTS || G_ControlledByPlayer(owner)))
		{
			//hit a wall?
			WP_SaberDrop(saber->owner, saber);
		}
		else
		{
			//hit a wall? send it back
			WP_SaberReturn(saber->owner, saber);
		}
	}

	if (other && !other->client && other->contents & CONTENTS_LIGHTSABER)
	{
		//2 in-flight sabers collided!
		WP_SaberBlockSound(saber->owner, 0, 0);
		WP_SaberBlockEffect(saber->owner, 0, 0, trace->endpos, nullptr, qfalse);
		qboolean no_flare = qfalse;
		if (saber->owner
			&& saber->owner->client
			&& saber->owner->client->ps.saber[0].saberFlags2 & SFL2_NO_CLASH_FLARE)
		{
			no_flare = qtrue;
		}
		if (!no_flare)
		{
			g_saberFlashTime = level.time - 50;
			VectorCopy(trace->endpos, g_saberFlashPos);
		}
	}

	if (owner && owner->s.number == 0 && owner->client)
	{
		//Add the event
		if (owner->client->ps.SaberLength() > 0)
		{
			//saber is on, very suspicious
			if (!owner->client->ps.saberInFlight && owner->client->ps.groundEntityNum == ENTITYNUM_WORLD
				//holding saber and on ground
				|| saber->s.pos.trType == TR_STATIONARY) //saber out there somewhere and on ground
			{
				//an on-ground alert
				AddSoundEvent(owner, saber->currentOrigin, 128, AEL_DISCOVERED, qfalse, qtrue);
			}
			else
			{
				//an in-air alert
				AddSoundEvent(owner, saber->currentOrigin, 128, AEL_DISCOVERED);
			}
			AddSightEvent(owner, saber->currentOrigin, 256, AEL_DISCOVERED, 50);
		}
		else
		{
			//saber is off, not as suspicious
			AddSoundEvent(owner, saber->currentOrigin, 128, AEL_SUSPICIOUS);
			AddSightEvent(owner, saber->currentOrigin, 256, AEL_SUSPICIOUS);
		}
	}

	// check for bounce
	if (!other->takedamage && saber->s.eFlags & (EF_BOUNCE | EF_BOUNCE_HALF))
	{
		// Check to see if there is a bounce count
		if (saber->bounceCount)
		{
			// decrement number of bounces and then see if it should be done bouncing
			if (--saber->bounceCount <= 0)
			{
				// He (or she) will bounce no more (after this current bounce, that is).
				saber->s.eFlags &= ~(EF_BOUNCE | EF_BOUNCE_HALF);
				if (saber->s.pos.trType == TR_LINEAR && owner && owner->client && owner->client->ps.saberEntityState ==
					SES_RETURNING)
				{
					WP_SaberDrop(saber->owner, saber);
				}
				return;
			}
			//bounced and still have bounces left
			if (saber->s.pos.trType == TR_LINEAR && owner && owner->client && owner->client->ps.saberEntityState ==
				SES_RETURNING)
			{
				//under telekinetic control
				if (!gi.inPVS(saber->currentOrigin, owner->client->renderInfo.handRPoint))
				{
					//not in the PVS of my master
					saber->bounceCount -= 25;
				}
			}
		}

		if (saber->s.pos.trType == TR_LINEAR && owner && owner->client && owner->client->ps.saberEntityState ==
			SES_RETURNING)
		{
			//don't home for a few frames so we can get around this thing
			trace_t bounce_tr;
			vec3_t end;
			const float owner_dist = Distance(owner->client->renderInfo.handRPoint, saber->currentOrigin);

			VectorMA(saber->currentOrigin, 10, trace->plane.normal, end);
			gi.trace(&bounce_tr, saber->currentOrigin, saber->mins, saber->maxs, end, owner->s.number, saber->clipmask,
				static_cast<EG2_Collision>(0), 0);
			VectorCopy(bounce_tr.endpos, saber->currentOrigin);
			if (owner_dist > 0)
			{
				if (owner_dist > 50)
				{
					owner->client->ps.saberEntityDist = owner_dist - 50;
				}
				else
				{
					owner->client->ps.saberEntityDist = 0;
				}
			}
			return;
		}

		G_BounceMissile(saber, trace);

		if (saber->s.pos.trType == TR_GRAVITY)
		{
			//bounced
			//play a bounce sound
			WP_SaberFallSound(owner, saber);
			//change rotation
			VectorCopy(saber->currentAngles, saber->s.apos.trBase);
			saber->s.apos.trType = TR_LINEAR;
			saber->s.apos.trTime = level.time;
			VectorSet(saber->s.apos.trDelta, Q_irand(-300, 300), Q_irand(-300, 300), Q_irand(-300, 300));
		}
		//see if we stopped
		else if (saber->s.pos.trType == TR_STATIONARY)
		{
			//stopped
			//play a bounce sound
			WP_SaberFallSound(owner, saber);
			//stop rotation
			VectorClear(saber->s.apos.trDelta);
			pitch_roll_for_slope(saber, trace->plane.normal, saber->currentAngles);
			saber->currentAngles[0] += SABER_PITCH_HACK;
			VectorCopy(saber->currentAngles, saber->s.apos.trBase);
			//remember when it fell so it can return automatically
			saber->aimDebounceTime = level.time;
		}
	}
	else if (other->client && other->health > 0
		&& (other->NPC && (other->NPC->aiFlags & NPCAI_BOSS_CHARACTER || other->NPC->aiFlags &
			NPCAI_BOSS_SERENITYJEDIENGINE)
			//|| other->client->NPC_class == CLASS_ALORA
			|| other->client->NPC_class == CLASS_BOBAFETT /*|| other->client->NPC_class == CLASS_MANDALORIAN*/ || other
			->client->NPC_class == CLASS_JANGO || other->client->NPC_class == CLASS_JANGODUAL
			|| other->client->ps.powerups[PW_GALAK_SHIELD] > 0))
	{
		//Luke, Desann and Tavion slap thrown sabers aside
		WP_SaberDrop(owner, saber);

		if (owner && owner->client->ps.blockPoints < BLOCKPOINTS_HALF || owner->client->ps.forcePower <
			BLOCKPOINTS_HALF)
		{
			WP_SaberKnockSound(owner, 0, 0);
		}
		else
		{
			WP_SaberBlockSound(owner, 0, 0);
		}
		WP_SaberBlockEffect(owner, 0, 0, trace->endpos, nullptr, qfalse);
		qboolean no_flare = qfalse;
		if (owner
			&& owner->client
			&& owner->client->ps.saber[0].saberFlags2 & SFL2_NO_CLASH_FLARE)
		{
			no_flare = qtrue;
		}
		if (!no_flare)
		{
			g_saberFlashTime = level.time - 50;
			VectorCopy(trace->endpos, g_saberFlashPos);
		}
		//FIXME: make Luke/Desann/Tavion play an attack anim or some other special anim when this happens
		jedi_play_deflect_sound(other);
	}
}

extern float G_PointDistFromLineSegment(const vec3_t start, const vec3_t end, const vec3_t from);

void WP_SaberInFlightReflectCheck(gentity_t* self)
{
	gentity_t* entity_list[MAX_GENTITIES];
	gentity_t* missile_list[MAX_GENTITIES]{};
	vec3_t mins{}, maxs{};
	int ent_count = 0;
	vec3_t center;
	vec3_t up = { 0, 0, 1 };

	if (self->NPC && self->NPC->scriptFlags & SCF_IGNORE_ALERTS)
	{
		//don't react to things flying at me...
		return;
	}
	//sanity checks: make sure we actually have a saberent
	if (self->client->ps.weapon != WP_SABER)
	{
		return;
	}
	if (!self->client->ps.saberInFlight)
	{
		return;
	}
	if (!self->client->ps.SaberLength())
	{
		return;
	}
	if (self->client->ps.saberEntityNum == ENTITYNUM_NONE)
	{
		return;
	}
	gentity_t* saberent = &g_entities[self->client->ps.saberEntityNum];
	if (!saberent)
	{
		return;
	}
	//okay, enough damn sanity checks

	VectorCopy(saberent->currentOrigin, center);

	for (int i = 0; i < 3; i++)
	{
		constexpr int radius = 180;
		mins[i] = center[i] - radius;
		maxs[i] = center[i] + radius;
	}

	const int num_listed_entities = gi.EntitiesInBox(mins, maxs, entity_list, MAX_GENTITIES);

	//FIXME: check visibility?
	for (int e = 0; e < num_listed_entities; e++)
	{
		gentity_t* ent = entity_list[e];

		if (ent == self)
			continue;
		if (ent->owner == self)
			continue;
		if (!ent->inuse)
			continue;
		if (ent->s.eType != ET_MISSILE)
		{
			if (ent->client || ent->s.weapon != WP_SABER)
			{
				//FIXME: wake up bad guys?
				continue;
			}
			if (ent->s.eFlags & EF_NODRAW)
			{
				continue;
			}
			if (Q_stricmp("lightsaber", ent->classname) != 0)
			{
				//not a lightsaber
				continue;
			}
		}
		else
		{
			//FIXME: make exploding missiles explode?
			if (ent->s.pos.trType == TR_STATIONARY)
			{
				//nothing you can do with a stationary missile
				continue;
			}
			if (ent->splashDamage || ent->splashRadius)
			{
				//can't deflect exploding missiles
				if (DistanceSquared(ent->currentOrigin, center) < 256) //16 squared
				{
					G_MissileImpacted(ent, saberent, ent->currentOrigin, up);
				}
				continue;
			}
		}

		//don't deflect it if it's not within 16 units of the blade
		//do this for all blades
		qboolean will_hit = qfalse;
		int num_sabers = 1;
		if (self->client->ps.dualSabers)
		{
			num_sabers = 2;
		}
		for (int saber_num = 0; saber_num < num_sabers; saber_num++)
		{
			for (int blade_num = 0; blade_num < self->client->ps.saber[saber_num].numBlades; blade_num++)
			{
				vec3_t tip;
				VectorMA(self->client->ps.saber[saber_num].blade[blade_num].muzzlePoint,
					self->client->ps.saber[saber_num].blade[blade_num].length,
					self->client->ps.saber[saber_num].blade[blade_num].muzzleDir, tip);

				if (G_PointDistFromLineSegment(self->client->ps.saber[saber_num].blade[blade_num].muzzlePoint, tip,
					ent->currentOrigin) <= 32)
				{
					will_hit = qtrue;
					break;
				}
			}
			if (will_hit)
			{
				break;
			}
		}
		if (!will_hit)
		{
			continue;
		}
		// ok, we are within the radius, add us to the incoming list
		missile_list[ent_count] = ent;
		ent_count++;
	}

	if (ent_count)
	{
		// we are done, do we have any to deflect?
		if (ent_count)
		{
			for (int x = 0; x < ent_count; x++)
			{
				vec3_t fx_dir;
				if (missile_list[x]->s.weapon == WP_SABER)
				{
					//just send it back
					if (missile_list[x]->owner && missile_list[x]->owner->client && missile_list[x]->owner->client->ps.
						saber[0].Active() && missile_list[x]->s.pos.trType == TR_LINEAR && missile_list[x]->owner->
						client->ps.saberEntityState != SES_RETURNING)
					{
						//it's on and being controlled
						if (g_SerenityJediEngineMode->integer && g_SaberMustReturn->integer < 1 && (G_ControlledByPlayer(missile_list[x]->owner)))
						{
							WP_SaberDrop(missile_list[x]->owner, missile_list[x]);
						}
						else
						{
							if (missile_list[x]->owner->NPC && !G_ControlledByPlayer(missile_list[x]->owner))
							{
								WP_SaberDrop(missile_list[x]->owner, missile_list[x]);
							}
							else
							{
								WP_SaberReturn(missile_list[x]->owner, missile_list[x]);
							}
						}
						VectorNormalize2(missile_list[x]->s.pos.trDelta, fx_dir);
						WP_SaberBlockEffect(self, 0, 0, missile_list[x]->currentOrigin, fx_dir, qfalse);

						if (missile_list[x]->owner->client->ps.saberInFlight && self->client->ps.saberInFlight)
						{
							if (self->client->ps.blockPoints < BLOCKPOINTS_HALF || self->client->ps.forcePower <
								BLOCKPOINTS_HALF)
							{
								WP_SaberKnockSound(self, 0, 0);
							}
							else
							{
								WP_SaberBlockSound(self, 0, 0);
							}

							qboolean no_flare = qfalse;
							if (missile_list[x]->owner->client->ps.saber[0].saberFlags2 & SFL2_NO_CLASH_FLARE
								&& self->client->ps.saber[0].saberFlags2 & SFL2_NO_CLASH_FLARE)
							{
								no_flare = qtrue;
							}
							if (!no_flare)
							{
								g_saberFlashTime = level.time - 50;
								const gentity_t* saber = &g_entities[self->client->ps.saberEntityNum];
								vec3_t org;
								VectorSubtract(missile_list[x]->currentOrigin, saber->currentOrigin, org);
								VectorMA(saber->currentOrigin, 0.5, org, org);
								VectorCopy(org, g_saberFlashPos);
							}
						}
					}
				}
				else
				{
					//bounce it
					vec3_t reflect_angle, forward;
					if (self->client && !self->s.number)
					{
						self->client->sess.missionStats.saberBlocksCnt++;
					}
					VectorCopy(saberent->s.apos.trBase, reflect_angle);
					reflect_angle[PITCH] = Q_flrand(-90, 90);
					AngleVectors(reflect_angle, forward, nullptr, nullptr);

					if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self))
					{
						G_ReflectMissileNPC(self, missile_list[x], forward);
					}
					else
					{
						if (g_SerenityJediEngineMode->integer)
						{
							G_ReflectMissileAuto(self, missile_list[x], forward);
						}
						else
						{
							G_ReflectMissile_JKA(self, missile_list[x], forward);
						}
					}
					//do an effect
					VectorNormalize2(missile_list[x]->s.pos.trDelta, fx_dir);
					G_PlayEffect("blaster/deflect", missile_list[x]->currentOrigin, fx_dir);
				}
			}
		}
	}
}

static qboolean WP_SaberValidateEnemy(gentity_t* self, gentity_t* enemy)
{
	if (!enemy)
	{
		return qfalse;
	}

	if (!enemy || enemy == self || !enemy->inuse || !enemy->client)
	{
		//not valid
		return qfalse;
	}

	if (enemy->health <= 0)
	{
		//corpse
		return qfalse;
	}

	if (enemy->s.number >= MAX_CLIENTS)
	{
		//NPCs can cheat and use the homing saber throw 3 on the player
		if (enemy->client->ps.forcePowersKnown)
		{
			//not other jedi?
			return qfalse;
		}
	}

	if (DistanceSquared(self->client->renderInfo.handRPoint, enemy->currentOrigin) > saberThrowDistSquared[self->client
		->ps.forcePowerLevel[FP_SABERTHROW]])
	{
		//too far
		return qfalse;
	}

	if ((!InFront(enemy->currentOrigin, self->currentOrigin, self->client->ps.viewangles, 0.0f) || !G_ClearLOS(
		self, self->client->renderInfo.eyePoint, enemy))
		&& (DistanceHorizontalSquared(enemy->currentOrigin, self->currentOrigin) > 65536 || fabs(
			enemy->currentOrigin[2] - self->currentOrigin[2]) > 384))
	{
		//(not in front or not clear LOS) & greater than 256 away
		return qfalse;
	}

	if (enemy->client->playerTeam == self->client->playerTeam && (enemy->client->playerTeam != TEAM_SOLO && self->client
		->playerTeam != TEAM_SOLO))
	{
		//on same team
		return qfalse;
	}

	return qtrue;
}

static float WP_SaberRateEnemy(const gentity_t* enemy, vec3_t center, vec3_t forward, const float radius)
{
	vec3_t dir;

	VectorSubtract(enemy->currentOrigin, center, dir);
	float rating = 1.0f - VectorNormalize(dir) / radius;
	rating *= DotProduct(forward, dir);
	return rating;
}

static gentity_t* WP_SaberFindEnemy(gentity_t* self, const gentity_t* saber)
{
	//FIXME: should be a more intelligent way of doing this, like auto aim?
	//closest, most in front... did damage to... took damage from?  How do we know who the player is focusing on?
	gentity_t* best_ent = nullptr;
	gentity_t* entity_list[MAX_GENTITIES];
	vec3_t center, mins{}, maxs{}, fwdangles{}, forward;
	constexpr float radius = 400;
	float best_rating = 0.0f;

	//FIXME: no need to do this in 1st person?
	fwdangles[1] = self->client->ps.viewangles[1];
	AngleVectors(fwdangles, forward, nullptr, nullptr);

	VectorCopy(saber->currentOrigin, center);

	for (int i = 0; i < 3; i++)
	{
		mins[i] = center[i] - radius;
		maxs[i] = center[i] + radius;
	}

	//if the saber has an enemy from the last time it looked, init to that one
	if (WP_SaberValidateEnemy(self, saber->enemy))
	{
		if (gi.inPVS(self->currentOrigin, saber->enemy->currentOrigin))
		{
			//potentially visible
			if (G_ClearLOS(self, self->client->renderInfo.eyePoint, saber->enemy))
			{
				//can see him
				best_ent = saber->enemy;
				best_rating = WP_SaberRateEnemy(best_ent, center, forward, radius);
			}
		}
	}

	//If I have an enemy, see if that's even better
	if (WP_SaberValidateEnemy(self, self->enemy))
	{
		const float my_enemy_rating = WP_SaberRateEnemy(self->enemy, center, forward, radius);
		if (my_enemy_rating > best_rating)
		{
			if (gi.inPVS(self->currentOrigin, self->enemy->currentOrigin))
			{
				//potentially visible
				if (G_ClearLOS(self, self->client->renderInfo.eyePoint, self->enemy))
				{
					//can see him
					best_ent = self->enemy;
					best_rating = my_enemy_rating;
				}
			}
		}
	}

	const int num_listed_entities = gi.EntitiesInBox(mins, maxs, entity_list, MAX_GENTITIES);

	if (!num_listed_entities)
	{
		//should we clear the enemy?
		return best_ent;
	}

	for (int e = 0; e < num_listed_entities; e++)
	{
		gentity_t* ent = entity_list[e];

		if (ent == self || ent == saber || ent == best_ent)
		{
			continue;
		}
		if (!WP_SaberValidateEnemy(self, ent))
		{
			//doesn't meet criteria of valid look enemy (don't check current since we would have done that before this func's call
			continue;
		}
		if (!gi.inPVS(self->currentOrigin, ent->currentOrigin))
		{
			//not even potentially visible
			continue;
		}
		if (!G_ClearLOS(self, self->client->renderInfo.eyePoint, ent))
		{
			//can't see him
			continue;
		}
		//rate him based on how close & how in front he is
		const float rating = WP_SaberRateEnemy(ent, center, forward, radius);
		if (rating > best_rating)
		{
			best_ent = ent;
			best_rating = rating;
		}
	}
	return best_ent;
}

static void WP_RunSaber(gentity_t* self, gentity_t* saber)
{
	vec3_t origin, old_org;
	trace_t tr;

	VectorCopy(saber->currentOrigin, old_org);
	// get current position
	EvaluateTrajectory(&saber->s.pos, level.time, origin);
	// get current angles
	EvaluateTrajectory(&saber->s.apos, level.time, saber->currentAngles);

	// trace a line from the previous position to the current position,
	// ignoring interactions with the missile owner
	int clipmask = saber->clipmask;
	if (!self || !self->client || self->client->ps.SaberLength() <= 0)
	{
		//don't keep hitting other sabers when turned off
		clipmask &= ~CONTENTS_LIGHTSABER;
	}
	gi.trace(&tr, saber->currentOrigin, saber->mins, saber->maxs, origin,
		saber->owner ? saber->owner->s.number : ENTITYNUM_NONE, clipmask, static_cast<EG2_Collision>(0), 0);

	VectorCopy(tr.endpos, saber->currentOrigin);

	if (self->client->ps.SaberActive())
	{
		if (self->client->ps.saberInFlight || self->client->ps.weaponTime && !Q_irand(0, 100))
		{
			//make enemies run from a lit saber in flight or from me when I'm attacking
			if (!Q_irand(0, 10))
			{
				//not so often...
				AddSightEvent(self, saber->currentOrigin, self->client->ps.SaberLength() * 3, AEL_DANGER, 100);
			}
		}
	}

	if (tr.startsolid)
	{
		tr.fraction = 0;
	}

	gi.linkentity(saber);

	//touch push triggers?

	if (tr.fraction != 1)
	{
		WP_SaberImpact(self, saber, &tr);
	}

	if (saber->s.pos.trType == TR_LINEAR)
	{
		vec3_t fwdangles = { 0 };

		VectorCopy(self->client->ps.viewangles, fwdangles);
		if (self->s.number)
		{
			fwdangles[0] -= 8;
		}
		else if (cg.renderingThirdPerson)
		{
			fwdangles[0] -= 5;
		}

		if (self->client->ps.forcePowerLevel[FP_SABERTHROW] > FORCE_LEVEL_1
			|| self->client->ps.saberEntityState == SES_RETURNING
			|| VectorCompare(saber->s.pos.trDelta, vec3_origin))
		{
			vec3_t saber_dest;
			vec3_t forward;
			vec3_t saber_home;
			//control if it's returning or just starting
			float saber_speed = 500; //FIXME: based on force level?
			gentity_t* enemy = nullptr;

			AngleVectors(fwdangles, forward, nullptr, nullptr);

			if (self->client->ps.saberEntityDist < 100)
			{
				//make the saber head to my hand- the bolt it was attached to
				VectorCopy(self->client->renderInfo.handRPoint, saber_home);
			}
			else
			{
				//aim saber from eyes
				VectorCopy(self->client->renderInfo.eyePoint, saber_home);
			}
			VectorMA(saber_home, self->client->ps.saberEntityDist, forward, saber_dest);

			if (self->client->ps.forcePowerLevel[FP_SABERTHROW] > FORCE_LEVEL_2
				&& self->client->ps.saberEntityState == SES_LEAVING)
			{
				//max level
				if (self->enemy &&
					!WP_SaberValidateEnemy(self, self->enemy))
				{
					//if my enemy isn't valid to auto-aim at, don't autoaim
				}
				else
				{
					//pick an enemy
					enemy = WP_SaberFindEnemy(self, saber);
					if (enemy)
					{
						//home in on enemy
						const float enemy_dist = Distance(self->client->renderInfo.handRPoint, enemy->currentOrigin);
						VectorCopy(enemy->currentOrigin, saber_dest);
						saber_dest[2] += enemy->maxs[2] / 2.0f;
						//FIXME: when in a knockdown anim, the saber float above them... do we care?
						self->client->ps.saberEntityDist = enemy_dist;
						//once you pick an enemy, stay with it!
						saber->enemy = enemy;
						//FIXME: lock onto that enemy for a minimum amount of time (unless they become invalid?)
					}
				}
			}

			//Make the saber head there
			VectorSubtract(saber_dest, saber->currentOrigin, saber->s.pos.trDelta);
			const float dist = VectorNormalize(saber->s.pos.trDelta);
			if (self->client->ps.forcePowerLevel[FP_SABERTHROW] > FORCE_LEVEL_2 && self->client->ps.saberEntityState ==
				SES_LEAVING && !enemy)
			{
				if (dist < 200)
				{
					saber_speed = 400 - dist * 2;
				}
			}
			else if (self->client->ps.saberEntityState == SES_LEAVING && dist < 50)
			{
				saber_speed = dist * 2 + 30;
				if (enemy && dist > enemy->maxs[0] || !enemy && dist > 24)
				{
					//auto-tracking an enemy and we can't hit him
					if (saber_speed < 120)
					{
						//clamp to a minimum speed
						saber_speed = 120;
					}
				}
			}

			VectorScale(saber->s.pos.trDelta, saber_speed, saber->s.pos.trDelta);
			//SnapVector( saber->s.pos.trDelta );	// save net bandwidth
			VectorCopy(saber->currentOrigin, saber->s.pos.trBase);
			saber->s.pos.trTime = level.time;
			saber->s.pos.trType = TR_LINEAR;
		}
		else
		{
			VectorCopy(saber->currentOrigin, saber->s.pos.trBase);
			saber->s.pos.trTime = level.time;
			saber->s.pos.trType = TR_LINEAR;
		}

		//if it's heading back, point it's base at us
		if (self->client->ps.saberEntityState == SES_RETURNING
			&& !(self->client->ps.saber[0].saberFlags & SFL_RETURN_DAMAGE))
		{
			fwdangles[0] += SABER_PITCH_HACK;
			VectorCopy(fwdangles, saber->s.apos.trBase);
			saber->s.apos.trTime = level.time;
			saber->s.apos.trType = TR_INTERPOLATE;
			VectorClear(saber->s.apos.trDelta);
		}
	}
}

static qboolean WP_SaberLaunch(gentity_t* self, gentity_t* saber, const qboolean thrown, const qboolean no_fail = qfalse)
{
	//FIXME: probably need a debounce time
	constexpr vec3_t saber_mins = { -3.0f, -3.0f, -3.0f };
	constexpr vec3_t saber_maxs = { 3.0f, 3.0f, 3.0f };
	trace_t trace;

	if (self->client->NPC_class == CLASS_SABER_DROID)
	{
		//saber droids can't drop their saber
		return qfalse;
	}
	if (!no_fail)
	{
		if (thrown)
		{
			//this is a regular throw, so see if it's legal
			if (self->client->ps.forcePowerLevel[FP_SABERTHROW] > FORCE_LEVEL_2)
			{
				if (!WP_ForcePowerUsable(self, FP_SABERTHROW, 20))
				{
					return qfalse;
				}
			}
			else
			{
				if (!WP_ForcePowerUsable(self, FP_SABERTHROW, 0))
				{
					return qfalse;
				}
			}
		}
		if (!self->s.number && (cg.zoomMode || in_camera))
		{
			//can't saber throw when zoomed in or in cinematic
			return qfalse;
		}
		//make sure it won't start in solid
		gi.trace(&trace, self->client->renderInfo.handRPoint, saber_mins, saber_maxs,
			self->client->renderInfo.handRPoint,
			saber->s.number, MASK_SOLID, static_cast<EG2_Collision>(0), 0);
		if (trace.startsolid || trace.allsolid)
		{
			return qfalse;
		}
		//make sure I'm not throwing it on the other side of a door or wall or whatever
		gi.trace(&trace, self->currentOrigin, vec3_origin, vec3_origin, self->client->renderInfo.handRPoint,
			self->s.number, MASK_SOLID, static_cast<EG2_Collision>(0), 0);
		if (trace.startsolid || trace.allsolid || trace.fraction < 1.0f)
		{
			return qfalse;
		}

		if (thrown)
		{
			//this is a regular throw, so take force power
			if (self->client->ps.forcePowerLevel[FP_SABERTHROW] > FORCE_LEVEL_2)
			{
				//at max skill, the cost increases as keep it out
				WP_ForcePowerStart(self, FP_SABERTHROW, 10);
			}
			else
			{
				WP_ForcePowerStart(self, FP_SABERTHROW, 0);
			}
		}
	}
	//clear the enemy
	saber->enemy = nullptr;

	//===FIXME!!!==============================================================================================
	//We should copy the right-hand saber's g2 instance to the thrown saber
	//Then back again when you catch it!!!
	//===FIXME!!!==============================================================================================

	//draw it
	saber->s.eFlags &= ~EF_NODRAW;
	saber->svFlags |= SVF_BROADCAST;
	saber->svFlags &= ~SVF_NOCLIENT;

	//place it
	VectorCopy(self->client->renderInfo.handRPoint, saber->currentOrigin); //muzzlePoint
	VectorCopy(saber->currentOrigin, saber->s.pos.trBase);
	saber->s.pos.trTime = level.time;
	saber->s.pos.trType = TR_LINEAR;
	VectorClear(saber->s.pos.trDelta);
	gi.linkentity(saber);

	//spin it
	VectorClear(saber->s.apos.trBase);
	saber->s.apos.trTime = level.time;
	saber->s.apos.trType = TR_LINEAR;
	if (self->health > 0 && thrown)
	{
		//throwing it
		saber->s.apos.trBase[1] = self->client->ps.viewangles[1];
		saber->s.apos.trBase[0] = SABER_PITCH_HACK;
	}
	else
	{
		//dropping it
		vectoangles(self->client->renderInfo.muzzleDir, saber->s.apos.trBase);
	}

	VectorClear(saber->s.apos.trDelta);

	if (g_SerenityJediEngineMode->integer == 2)
	{
		if (self->client->ps.saber_anim_level == SS_STAFF)
		{
			saber->s.apos.trDelta[1] = 800;
		}
		else
		{
			if (g_overpoweredsaberthrow->integer == 1)
			{
				saber->s.apos.trDelta[1] = 800;
			}
			else
			{
				saber->s.apos.trDelta[0] = 600;
			}
		}
	}
	else
	{
		switch (self->client->ps.forcePowerLevel[FP_SABERTHROW])
		{
		default:
		case FORCE_LEVEL_1:
			saber->s.apos.trDelta[1] = 600;
			break;
		case FORCE_LEVEL_2:
			saber->s.apos.trDelta[1] = 800;
			break;
		case FORCE_LEVEL_3:
			saber->s.apos.trDelta[1] = 1200;
			break;
		}
	}

	//Take it out of my hand
	self->client->ps.saberInFlight = qtrue;
	self->client->ps.saberEntityState = SES_LEAVING;
	self->client->ps.saberEntityDist = saberThrowDist[self->client->ps.forcePowerLevel[FP_SABERTHROW]];
	self->client->ps.saberThrowTime = level.time;
	//if ( self->client->ps.forcePowerLevel[FP_SABERTHROW] > FORCE_LEVEL_2 )
	{
		self->client->ps.forcePowerDebounce[FP_SABERTHROW] = level.time + 1000;
		//so we can keep it out for a minimum amount of time
	}

	if (thrown)
	{
		//this is a regular throw, so turn the saber on
		//turn saber on
		if (self->client->ps.saber[0].saberFlags & SFL_SINGLE_BLADE_THROWABLE)
		{
			//only first blade can be on
			if (!self->client->ps.saber[0].blade[0].active)
			{
				//turn on first one
				self->client->ps.SaberBladeActivate(0, 0);
			}
			for (int i = 1; i < self->client->ps.saber[0].numBlades; i++)
			{
				//turn off all others
				if (self->client->ps.saber[0].blade[i].active)
				{
					self->client->ps.SaberBladeActivate(0, i, qfalse);
				}
			}
		}
		else
		{
			//turn the sabers, all blades...?
			self->client->ps.saber[0].Activate();
			//self->client->ps.SaberActivate();
		}
		//turn on the saber trail
		self->client->ps.saber[0].ActivateTrail(150);
	}

	//reset the mins
	VectorCopy(saber_mins, saber->mins);
	VectorCopy(saber_maxs, saber->maxs);
	saber->contents = 0; //CONTENTS_LIGHTSABER;
	saber->clipmask = MASK_SOLID | CONTENTS_LIGHTSABER;

	// remove the ghoul2 right-hand saber model on the player
	if (self->weaponModel[0] > 0)
	{
		gi.G2API_RemoveGhoul2Model(self->ghoul2, self->weaponModel[0]);
		self->weaponModel[0] = -1;
	}

	return qtrue;
}

qboolean WP_SaberLose(gentity_t* self, vec3_t throw_dir)
{
	if (!self || !self->client || self->client->ps.saberEntityNum <= 0)
	{
		//WTF?!!  We lost it already?
		return qfalse;
	}
	if (self->client->NPC_class == CLASS_SABER_DROID)
	{
		//saber droids can't drop their saber
		return qfalse;
	}
	gentity_t* dropped = &g_entities[self->client->ps.saberEntityNum];

	if (!self->client->ps.saberInFlight)
	{
		//not already in air
		//throw it
		if (!WP_SaberLaunch(self, dropped, qfalse))
		{
			//couldn't throw it
			return qfalse;
		}
	}
	if (self->client->ps.saber[0].Active())
	{
		//on
		//drop it instantly
		WP_SaberDrop(self, dropped);
	}
	//optionally give it some thrown velocity
	if (throw_dir && !VectorCompare(throw_dir, vec3_origin))
	{
		VectorCopy(throw_dir, dropped->s.pos.trDelta);
	}
	//don't pull it back on the next frame
	if (self->NPC)
	{
		self->NPC->last_ucmd.buttons &= ~BUTTON_ATTACK;
	}
	return qtrue;
}

static void WP_SaberKnockedOutOfHand(const gentity_t* self, gentity_t* saber)
{
	//clear the enemy
	saber->enemy = nullptr;
	saber->s.eFlags &= ~EF_BOUNCE;
	saber->bounceCount = 0;
	//make it fall
	saber->s.pos.trType = TR_GRAVITY;
	//make it bounce some
	saber->s.eFlags |= EF_BOUNCE_HALF;
	//make it spin
	VectorCopy(saber->currentAngles, saber->s.apos.trBase);
	saber->s.apos.trType = TR_LINEAR;
	saber->s.apos.trTime = level.time;

	VectorSet(saber->s.apos.trDelta, Q_irand(-300, 300), saber->s.apos.trDelta[1], Q_irand(-300, 300));

	if (!saber->s.apos.trDelta[1])
	{
		saber->s.apos.trDelta[1] = Q_irand(-300, 300);
	}
	//force it to be ready to return
	self->client->ps.saberEntityDist = 0;
	self->client->ps.saberEntityState = SES_LEAVING;
	//turn it off
	self->client->ps.saber[0].Deactivate();
	//turn off the saber trail
	self->client->ps.saber[0].DeactivateTrail(75);
	//play the saber turning off sound
	G_SoundIndexOnEnt(saber, CHAN_AUTO, self->client->ps.saber[0].soundOff);

	if (self->health <= 0)
	{
		//owner is dead!
		saber->s.time = level.time; //will make us free ourselves after a time
	}
}

qboolean WP_SaberDisarmed(gentity_t* self, vec3_t throw_dir)
{
	if (!self || !self->client || self->client->ps.saberEntityNum <= 0)
	{
		//WTF?!!  We lost it already?
		return qfalse;
	}

	if (self->client->NPC_class == CLASS_SABER_DROID)
	{
		//saber droids can't drop their saber
		return qfalse;
	}

	gentity_t* dropped = &g_entities[self->client->ps.saberEntityNum];

	if (!self->client->ps.saberInFlight)
	{
		//not already in air
		//throw it
		if (!WP_SaberLaunch(self, dropped, qfalse))
		{
			//couldn't throw it
			return qfalse;
		}
	}

	if (self->client->ps.saber[0].Active())
	{
		//on
		//drop it instantly
		WP_SaberKnockedOutOfHand(self, dropped);
	}
	//optionally give it some thrown velocity
	if (throw_dir && !VectorCompare(throw_dir, vec3_origin))
	{
		VectorCopy(throw_dir, dropped->s.pos.trDelta);
	}
	//don't pull it back on the next frame
	/*if (self->NPC)
	{
		self->NPC->last_ucmd.buttons &= ~BUTTON_ATTACK;
	}*/
	ucmd.buttons &= ~BUTTON_ATTACK;
	return qtrue;
}

void WP_SetSaberOrigin(gentity_t* self, vec3_t new_org)
{
	if (!self || !self->client)
	{
		return;
	}
	if (self->client->ps.saberEntityNum <= 0 || self->client->ps.saberEntityNum >= ENTITYNUM_WORLD)
	{
		//no saber ent to reposition
		return;
	}
	if (self->client->NPC_class == CLASS_SABER_DROID)
	{
		//saber droids can't drop their saber
		return;
	}
	gentity_t* dropped = &g_entities[self->client->ps.saberEntityNum];
	if (!self->client->ps.saberInFlight)
	{
		//not already in air
		qboolean no_force_throw = qfalse;
		//make it so we can throw it
		self->client->ps.forcePowersKnown |= 1 << FP_SABERTHROW;
		if (self->client->ps.forcePowerLevel[FP_SABERTHROW] < FORCE_LEVEL_1)
		{
			no_force_throw = qtrue;
			self->client->ps.forcePowerLevel[FP_SABERTHROW] = FORCE_LEVEL_1;
		}
		//throw it
		if (!WP_SaberLaunch(self, dropped, qfalse, qtrue))
		{
			//couldn't throw it
			return;
		}
		if (no_force_throw)
		{
			self->client->ps.forcePowerLevel[FP_SABERTHROW] = FORCE_LEVEL_0;
		}
	}
	VectorCopy(new_org, dropped->s.origin);
	VectorCopy(new_org, dropped->currentOrigin);
	VectorCopy(new_org, dropped->s.pos.trBase);
	//drop it instantly
	WP_SaberDrop(self, dropped);
	//don't pull it back on the next frame
	if (self->NPC)
	{
		self->NPC->last_ucmd.buttons &= ~BUTTON_ATTACK;
	}
}

void WP_SaberCatch(gentity_t* self, gentity_t* saber, const qboolean switch_to_saber)
{
	if (self->flags & FL_NO_SABER_RETURN && (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self)))
	{
		return;
	}
	if (self->health > 0 && !PM_SaberInBrokenParry(self->client->ps.saber_move) && self->client->ps.saberBlocked !=
		BLOCKED_PARRY_BROKEN)
	{
		//clear the enemy
		saber->enemy = nullptr;
		//===FIXME!!!==============================================================================================
		//We should copy the thrown saber's g2 instance to the right-hand saber
		//When you catch it, and vice-versa when you throw it!!!
		//===FIXME!!!==============================================================================================
		//don't draw it
		saber->s.eFlags |= EF_NODRAW;
		saber->svFlags &= SVF_BROADCAST;
		saber->svFlags |= SVF_NOCLIENT;

		//take off any gravity stuff if we'd dropped it
		saber->s.pos.trType = TR_LINEAR;
		saber->s.eFlags &= ~EF_BOUNCE_HALF;

		//Put it in my hand
		self->client->ps.saberInFlight = qfalse;
		self->client->ps.saberEntityState = SES_LEAVING;

		//turn off the saber trail
		self->client->ps.saber[0].DeactivateTrail(75);

		//reset its contents/clipmask
		saber->contents = CONTENTS_LIGHTSABER; // | CONTENTS_SHOTCLIP;
		saber->clipmask = MASK_SHOT | CONTENTS_LIGHTSABER;

		//play catch sound
		G_Sound(saber, G_SoundIndex("sound/weapons/saber/saber_catch.mp3"));
		if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self)) //NPC only
		{
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_STAND1TO2, SETANIM_AFLAG_PACE);
		}
		//FIXME: if an NPC, don't turn it back on if no enemy or enemy is dead...
		//if it's not our current weapon, make it our current weapon
		if (self->client->ps.weapon == WP_SABER)
		{
			//only do the first saber since we only throw the first one
			WP_SaberAddG2SaberModels(self, qfalse);

			if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self)) //NPC only
			{
				if (self->client->ps.saberFatigueChainCount >= MISHAPLEVEL_TEN)
				{
					self->client->ps.saberFatigueChainCount = MISHAPLEVEL_LIGHT;
				}
				if (g_SerenityJediEngineMode->integer)
				{
					if (g_SerenityJediEngineMode->integer == 2)
					{
						WP_BlockPointsRegenerate(self, BLOCKPOINTS_TWENTYFIVE);
					}
					else
					{
						WP_ForcePowerRegenerate(self, BLOCKPOINTS_TWENTYFIVE);
					}
				}
			}
		}

		if (switch_to_saber)
		{
			if (self->client->ps.weapon != WP_SABER)
			{
				CG_ChangeWeapon(WP_SABER);
			}
			else
			{
				//if it's not active, turn it on
				if (self->client->ps.saber[0].saberFlags & SFL_SINGLE_BLADE_THROWABLE)
				{
					//only first blade can be on
					if (!self->client->ps.saber[0].blade[0].active)
					{
						//only turn it on if first blade is off, otherwise, leave as-is
						self->client->ps.saber[0].Activate();
					}
				}
				else
				{
					//turn all blades on
					self->client->ps.saber[0].Activate();
				}
			}
		}
	}
}

void WP_SaberReturn(const gentity_t* self, gentity_t* saber)
{
	const qboolean active_blocking = self->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCKANDATTACK ? qtrue : qfalse;
	const qboolean is_holding_block_button = self->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCK ? qtrue : qfalse;
	//Normal Blocking

	if (self->flags & FL_NO_SABER_RETURN && (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self)))
	{
		return;
	}
	if (PM_SaberInBrokenParry(self->client->ps.saber_move) || self->client->ps.saberBlocked == BLOCKED_PARRY_BROKEN)
	{
		return;
	}
	if (g_SerenityJediEngineMode->integer && self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self))
	{
		if (self->client->ps.forcePower < BLOCKPOINTS_FIVE
			|| self->client->ps.blockPoints < BLOCKPOINTS_TWELVE
			|| is_holding_block_button || active_blocking)
		{
			return;
		}
	}
	if (self && self->client)
	{
		//still alive and stuff
		self->client->ps.saberEntityState = SES_RETURNING;
		//turn down the saber trail
		if (!(self->client->ps.saber[0].saberFlags & SFL_RETURN_DAMAGE))
		{
			self->client->ps.saber[0].DeactivateTrail(75);
		}
	}
	if (!(saber->s.eFlags & EF_BOUNCE))
	{
		saber->s.eFlags |= EF_BOUNCE;
		saber->bounceCount = 300;
	}
}

void WP_SaberDrop(const gentity_t* self, gentity_t* saber)
{
	//clear the enemy
	saber->enemy = nullptr;
	saber->s.eFlags &= ~EF_BOUNCE;
	saber->bounceCount = 0;
	//make it fall
	saber->s.pos.trType = TR_GRAVITY;
	//make it bounce some
	saber->s.eFlags |= EF_BOUNCE_HALF;
	//make it spin
	VectorCopy(saber->currentAngles, saber->s.apos.trBase);
	saber->s.apos.trType = TR_LINEAR;
	saber->s.apos.trTime = level.time;
	VectorSet(saber->s.apos.trDelta, Q_irand(-300, 300), saber->s.apos.trDelta[1], Q_irand(-300, 300));
	if (!saber->s.apos.trDelta[1])
	{
		saber->s.apos.trDelta[1] = Q_irand(-300, 300);
	}
	//force it to be ready to return
	self->client->ps.saberEntityDist = 0;
	self->client->ps.saberEntityState = SES_RETURNING;
	//turn it off
	self->client->ps.saber[0].Deactivate();
	//turn off the saber trail
	self->client->ps.saber[0].DeactivateTrail(75);
	//play the saber turning off sound
	G_SoundIndexOnEnt(saber, CHAN_AUTO, self->client->ps.saber[0].soundOff);

	if (self->health <= 0)
	{
		//owner is dead!
		saber->s.time = level.time; //will make us free ourselves after a time
	}
}

static void WP_SaberPull(const gentity_t* self, gentity_t* saber)
{
	const qboolean active_blocking = self->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCKANDATTACK ? qtrue : qfalse;
	const qboolean is_holding_block_button = self->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCK ? qtrue : qfalse;
	//Normal Blocking

	if (self->flags & FL_NO_SABER_RETURN && (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self)))
	{
		return;
	}
	if (PM_SaberInBrokenParry(self->client->ps.saber_move) || self->client->ps.saberBlocked == BLOCKED_PARRY_BROKEN)
	{
		return;
	}
	if (self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self))
	{
		if (self->client->ps.forcePower < BLOCKPOINTS_FIVE || self->client->ps.blockPoints < BLOCKPOINTS_TWELVE ||
			is_holding_block_button || active_blocking)
		{
			return;
		}
	}
	if (self->health > 0)
	{
		//take off gravity
		saber->s.pos.trType = TR_LINEAR;
		//take off bounce
		saber->s.eFlags &= EF_BOUNCE_HALF;
		//play sound
		G_Sound(self, G_SoundIndex("sound/weapons/force/pull.wav"));
	}
}

static void WP_SaberGrab(const gentity_t* self, gentity_t* saber)
{
	if (self->flags & FL_NO_SABER_RETURN && (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self)))
	{
		return;
	}
	if (PM_SaberInBrokenParry(self->client->ps.saber_move) || self->client->ps.saberBlocked == BLOCKED_PARRY_BROKEN)
	{
		return;
	}
	if (self->health > 0)
	{
		//take off gravity
		saber->s.pos.trType = TR_LINEAR;
		//take off bounce
		saber->s.eFlags &= EF_BOUNCE_HALF;
		//play sound
		G_Sound(self, G_SoundIndex("sound/weapons/force/pull.wav"));
	}
}

const char* saberColorStringForColor[SABER_PURPLE + 1] =
{
	"red", //SABER_RED
	"orange", //SABER_ORANGE
	"yellow", //SABER_YELLOW
	"green", //SABER_GREEN
	"blue", //SABER_BLUE
	"purple", //SABER_PURPLE
};

// Check if we are throwing it, launch it if needed, update position if needed.
static void WP_SaberThrow(gentity_t* self, const usercmd_t* ucmd)
{
	vec3_t saber_diff;
	trace_t tr;

	if (self->client->ps.saberEntityNum <= 0 || self->client->ps.saberEntityNum >= ENTITYNUM_WORLD)
	{
		//WTF?!!  We lost it?
		return;
	}

	if (self->client->ps.torsoAnim == BOTH_LOSE_SABER)
	{
		//can't catch it while it's being yanked from your hand!
		return;
	}

	if (!g_saberNewControlScheme->integer)
	{
		if (PM_SaberInKata(static_cast<saber_moveName_t>(self->client->ps.saber_move)))
		{
			//don't throw saber when in special attack (alt+attack)
			return;
		}
		if (ucmd->buttons & BUTTON_ATTACK
			&& ucmd->buttons & BUTTON_ALT_ATTACK
			&& !self->client->ps.saberInFlight)
		{
			//trying to do special attack, don't throw it
			return;
		}
		if (self->client->ps.torsoAnim == BOTH_A1_SPECIAL
			|| self->client->ps.torsoAnim == BOTH_A2_SPECIAL
			|| self->client->ps.torsoAnim == BOTH_A3_SPECIAL)
		{
			//don't throw in these anims!
			return;
		}
	}
	gentity_t* saberent = &g_entities[self->client->ps.saberEntityNum];

	VectorSubtract(self->client->renderInfo.handRPoint, saberent->currentOrigin, saber_diff);

	//is our saber in flight?
	if (!self->client->ps.saberInFlight)
	{
		//saber is not in flight right now
		if (self->client->ps.weapon != WP_SABER)
		{
			//don't even have it out
			return;
		}
		if (ucmd->buttons & BUTTON_ALT_ATTACK && !(self->client->ps.pm_flags & PMF_ALT_ATTACK_HELD))
		{
			//still holding it, not still holding attack from a previous throw, so throw it.
			if (!(self->client->ps.saberEventFlags & SEF_INWATER) && WP_SaberLaunch(self, saberent, qtrue))
			{
				if (self->client && !self->s.number)
				{
					self->client->sess.missionStats.saberThrownCnt++;
				}
				//need to recalc this because we just moved it
				VectorSubtract(self->client->renderInfo.handRPoint, saberent->currentOrigin, saber_diff);
			}
			else
			{
				//couldn't throw it
				return;
			}
		}
		else
		{
			//holding it, don't want to throw it, go away.
			return;
		}
	}
	else
	{
		//inflight
		//is our saber currently on it's way back to us?
		if (self->client->ps.saberEntityState == SES_RETURNING)
		{
			//see if we're close enough to pick it up
			if (VectorLengthSquared(saber_diff) <= 256)
				//16 squared//G_BoundsOverlap( self->absmin, self->absmax, saberent->absmin, saberent->absmax ) )//
			{
				//caught it
				vec3_t axis_point;
				trace_t trace;
				VectorCopy(self->currentOrigin, axis_point);
				axis_point[2] = self->client->renderInfo.handRPoint[2];
				gi.trace(&trace, axis_point, vec3_origin, vec3_origin, self->client->renderInfo.handRPoint,
					self->s.number, MASK_SOLID, static_cast<EG2_Collision>(0), 0);
				if (!trace.startsolid && trace.fraction >= 1.0f)
				{
					//our hand isn't through a wall
					WP_SaberCatch(self, saberent, qtrue);
				}
				return;
			}
		}

		if (saberent->s.pos.trType != TR_STATIONARY)
		{
			//saber is in flight, lerp it
			if (self->health <= 0) //&& level.time > saberent->s.time + 5000 )
			{
				//make us free ourselves after a time
				if (g_saberPickuppableDroppedSabers->integer
					&& G_DropSaberItem(self->client->ps.saber[0].name, self->client->ps.saber[0].blade[0].color,
						saberent->currentOrigin, saberent->s.pos.trDelta,
						saberent->currentAngles) != nullptr)
				{
					//dropped it
					//free it
					G_FreeEntity(saberent);
					//forget it
					self->client->ps.saberEntityNum = ENTITYNUM_NONE;
					return;
				}
			}
			WP_RunSaber(self, saberent);
		}
		else
		{
			//it fell on the ground
			if (self->health <= 0)
			{
				//make us free ourselves after a time
				if (g_saberPickuppableDroppedSabers->integer)
				{
					//spawn an item
					G_DropSaberItem(self->client->ps.saber[0].name, self->client->ps.saber[0].blade[0].color,
						saberent->currentOrigin, saberent->s.pos.trDelta, saberent->currentAngles);
				}
				//free it
				G_FreeEntity(saberent);
				//forget it
				self->client->ps.saberEntityNum = ENTITYNUM_NONE;
				return;
			}
			if (!self->s.number && level.time - saberent->aimDebounceTime > 15000
				|| self->s.number && level.time - saberent->aimDebounceTime > 5000)
			{
				//(only for player) been missing for 15 seconds, automatically return
				WP_SaberCatch(self, saberent, qfalse);
				return;
			}
		}
	}

	//are we still trying to use the saber?
	if (self->client->ps.weapon != WP_SABER)
	{
		//switched away
		if (!self->client->ps.saberInFlight)
		{
			//wasn't throwing saber
			return;
		}
		if (saberent->s.pos.trType == TR_LINEAR)
		{
			//switched away while controlling it, just drop the saber
			WP_SaberDrop(self, saberent);
			return;
		}
		//it's on the ground, see if it's inside us (touching)
		if (G_PointInBounds(saberent->currentOrigin, self->absmin, self->absmax))
		{
			//it's in us, pick it up automatically
			if (self->NPC && !G_ControlledByPlayer(self))
			{
				if (level.time - self->client->ps.saberThrowTime >= MAX_LEAVE_TIME &&
					!PM_SaberInBrokenParry(self->client->ps.saber_move) && self->client->ps.saberBlocked !=
					BLOCKED_PARRY_BROKEN)
				{
					WP_SaberPull(self, saberent);
				}
			}
			else
			{
				if (level.time - self->client->ps.saberThrowTime >= MAX_RETURN_TIME &&
					!PM_SaberInBrokenParry(self->client->ps.saber_move) && self->client->ps.saberBlocked !=
					BLOCKED_PARRY_BROKEN)
				{
					WP_SaberGrab(self, saberent);
					if (self->client->ps.blockPoints < BLOCKPOINTS_TWELVE)
					{
						WP_BlockPointsRegenerate(self, BLOCKPOINTS_FATIGUE);
					}
				}
			}
		}
	}
	else if (saberent->s.pos.trType != TR_LINEAR)
	{
		//weapon is saber and not flying
		if (self->client->ps.saberInFlight)
		{
			//we dropped it
			if (ucmd->buttons & BUTTON_ATTACK)
			{
				//we actively want to pick it up or we just switched to it, so pull it back
				gi.trace(&tr, saberent->currentOrigin, saberent->mins, saberent->maxs,
					self->client->renderInfo.handRPoint, self->s.number, MASK_SOLID, static_cast<EG2_Collision>(0),
					0);

				if (tr.allsolid || tr.startsolid || tr.fraction < 1.0f)
				{
					//can't pick it up yet, no LOS
					return;
				}
				//clear LOS, pick it up
				if (self->NPC && !G_ControlledByPlayer(self))
				{
					if (level.time - self->client->ps.saberThrowTime >= MAX_LEAVE_TIME &&
						!PM_SaberInBrokenParry(self->client->ps.saber_move) && self->client->ps.saberBlocked !=
						BLOCKED_PARRY_BROKEN)
					{
						WP_SaberPull(self, saberent);
					}
				}
				else
				{
					if (level.time - self->client->ps.saberThrowTime >= MAX_RETURN_TIME &&
						!PM_SaberInBrokenParry(self->client->ps.saber_move) && self->client->ps.saberBlocked !=
						BLOCKED_PARRY_BROKEN)
					{
						WP_SaberPull(self, saberent);
					}
				}
			}
			else
			{
				//see if it's inside us (touching)
				if (G_PointInBounds(saberent->currentOrigin, self->absmin, self->absmax))
				{
					//it's in us, pick it up automatically
					if (self->NPC && !G_ControlledByPlayer(self))
					{
						if (level.time - self->client->ps.saberThrowTime >= MAX_LEAVE_TIME &&
							!PM_SaberInBrokenParry(self->client->ps.saber_move) && self->client->ps.saberBlocked !=
							BLOCKED_PARRY_BROKEN)
						{
							WP_SaberPull(self, saberent);
						}
					}
					else
					{
						if (level.time - self->client->ps.saberThrowTime >= MAX_RETURN_TIME &&
							!PM_SaberInBrokenParry(self->client->ps.saber_move) && self->client->ps.saberBlocked !=
							BLOCKED_PARRY_BROKEN)
						{
							WP_SaberGrab(self, saberent);
							if (self->client->ps.blockPoints < BLOCKPOINTS_TWELVE)
							{
								WP_BlockPointsRegenerate(self, BLOCKPOINTS_FATIGUE);
							}
						}
					}
				}
			}
		}
	}
	else if (self->health <= 0 && self->client->ps.saberInFlight)
	{
		//we died, drop it
		WP_SaberDrop(self, saberent);
		return;
	}
	else if (!self->client->ps.saber[0].Active() && self->client->ps.saberEntityState != SES_RETURNING)
	{
		//we turned it off, drop it
		WP_SaberDrop(self, saberent);
		return;
	}

	if (saberent->s.pos.trType != TR_LINEAR)
	{
		//don't home
		return;
	}

	const float saber_dist = VectorLength(saber_diff);

	if (self->client->ps.saberEntityState == SES_LEAVING)
	{
		//saber still flying forward
		if (self->client->ps.forcePowerLevel[FP_SABERTHROW] > FORCE_LEVEL_2)
		{
			//still holding it out
			if (!(ucmd->buttons & BUTTON_ALT_ATTACK) && self->client->ps.forcePowerDebounce[FP_SABERTHROW] < level.time)
			{
				//done throwing, return to me
				if (self->client->ps.saber[0].Active())
				{
					//still on
					WP_SaberReturn(self, saberent);
				}
			}
			else if (level.time - self->client->ps.saberThrowTime >= 100)
			{
				if (WP_ForcePowerAvailable(self, FP_SABERTHROW, 10))
				{
					WP_ForcePowerDrain(self, FP_SABERTHROW, 1);
					self->client->ps.saberThrowTime = level.time;
				}
				else
				{
					//out of force power, return to me
					if (g_SerenityJediEngineMode->integer && g_SaberMustReturn->integer < 1 && (self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self)))
					{
						if (g_SerenityJediEngineMode->integer == 2)
						{
							WP_SaberDrop(self, saberent);
						}
						else
						{
							WP_SaberReturn(self, saberent);
						}
					}
					else
					{
						WP_SaberReturn(self, saberent);
					}
				}
			}
		}
		else
		{
			if (!(ucmd->buttons & BUTTON_ALT_ATTACK) && self->client->ps.forcePowerDebounce[FP_SABERTHROW] < level.time)
			{
				//not holding button and has been out at least 1 second, return to me
				if (self->client->ps.saber[0].Active())
				{
					//still on
					if (g_SerenityJediEngineMode->integer && g_SaberMustReturn->integer < 1 && (self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self)))
					{
						if (g_SerenityJediEngineMode->integer == 2)
						{
							WP_SaberDrop(self, saberent);
						}
						else
						{
							WP_SaberReturn(self, saberent);
						}
					}
					else
					{
						WP_SaberReturn(self, saberent);
					}
				}
			}
			else if (level.time - self->client->ps.saberThrowTime > 3000
				|| self->client->ps.forcePowerLevel[FP_SABERTHROW] == FORCE_LEVEL_1 && saber_dist >= self->client->ps.
				saberEntityDist)
			{
				//been out too long, or saber throw 1 went too far, return to me
				if (self->client->ps.saber[0].Active())
				{
					//still on
					if (g_SerenityJediEngineMode->integer && g_SaberMustReturn->integer < 1 && (self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self)))
					{
						if (g_SerenityJediEngineMode->integer == 2)
						{
							WP_SaberDrop(self, saberent);
						}
						else
						{
							WP_SaberReturn(self, saberent);
						}
					}
					else
					{
						WP_SaberReturn(self, saberent);
					}
				}
			}
		}
	}
	if (self->client->ps.saberEntityState == SES_RETURNING)
	{
		if (self->client->ps.saberEntityDist > 0)
		{
			self->client->ps.saberEntityDist -= 25;
		}
		if (self->client->ps.saberEntityDist < 0)
		{
			self->client->ps.saberEntityDist = 0;
		}
		else if (saber_dist < self->client->ps.saberEntityDist)
		{
			//if it's coming back to me, never push it away
			self->client->ps.saberEntityDist = saber_dist;
		}
	}
}

//SABER BLOCKING============================================================================
//SABER BLOCKING============================================================================
//SABER BLOCKING============================================================================
//SABER BLOCKING============================================================================
//SABER BLOCKING============================================================================

static qboolean Manual_Hand_Block_Lightning(const gentity_t* defender)
{
	if (defender->health <= 1
		|| defender->client->ps.forcePower <= BLOCKPOINTS_FATIGUE
		|| defender->client->ps.blockPoints <= BLOCKPOINTS_FATIGUE
		|| PM_InKnockDown(&defender->client->ps)
		|| PM_InRoll(&defender->client->ps)
		|| PM_InSpecialJump(defender->client->ps.torsoAnim)
		|| !WalkCheck(defender)
		|| defender->client->ps.groundEntityNum == ENTITYNUM_NONE
		|| defender->client->ps.forcePowerLevel[FP_ABSORB] < FORCE_LEVEL_1
		|| in_camera)
	{
		return qfalse;
	}

	if (!(defender->client->buttons & BUTTON_BLOCK))
	{
		if (defender->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(defender))
		{
			return qtrue;
		}
		return qfalse;
	}
	return qtrue;
}

static qboolean Manual_Hand_Block_Lightning_NPC(const gentity_t* attacker, const gentity_t* defender, int attackPower)
{
	int Ability_difference;		//the difference in skill between the defender's defend power and the attacker's attack power.

	if (defender->health <= 1
		|| defender->client->ps.forcePower <= BLOCKPOINTS_FATIGUE
		|| defender->client->ps.blockPoints <= BLOCKPOINTS_FATIGUE
		|| PM_InKnockDown(&defender->client->ps)
		|| PM_InRoll(&defender->client->ps)
		|| PM_InSpecialJump(defender->client->ps.torsoAnim)
		|| !WalkCheck(defender)
		|| defender->client->ps.groundEntityNum == ENTITYNUM_NONE
		|| defender->client->ps.forcePowerLevel[FP_ABSORB] < FORCE_LEVEL_1
		|| in_camera)
	{
		return qfalse;
	}

	Ability_difference = attacker->client->ps.forcePowerLevel[attackPower] - defender->client->ps.forcePowerLevel[attackPower];

	if (Ability_difference > attacker->client->ps.forcePowerLevel[attackPower] - defender->client->ps.forcePowerLevel[FP_ABSORB])
	{//defender's absorb ability is stronger than their attackPower ability, use that instead.
		Ability_difference = attacker->client->ps.forcePowerLevel[attackPower] - defender->client->ps.forcePowerLevel[FP_ABSORB];
	}

	if (Ability_difference >= 2)
	{//defender is largely weaker than the attacker (2 levels)
		if (!WalkCheck(defender) || defender->client->ps.groundEntityNum == ENTITYNUM_NONE)
		{//can't block much stronger Force power while running or in mid-air
			return qfalse;
		}
	}
	else if (Ability_difference >= 1)
	{//defender is slightly weaker than their attacker
		if (defender->client->ps.groundEntityNum == ENTITYNUM_NONE)
		{
			return qfalse;
		}
	}

	return qtrue;
}

static qboolean Manual_Forceblocking(const gentity_t* defender) //Is this dude blocking or not?
{
	if (defender->health <= 1)
	{
		return qfalse;
	}

	if (defender->client->ps.forcePower <= BLOCKPOINTS_FATIGUE || defender->client->ps.blockPoints <=
		BLOCKPOINTS_FATIGUE)
	{
		return qfalse;
	}

	if (!(defender->client->ps.forcePowersKnown & 1 << FP_ABSORB))
	{
		//doesn't have absorb
		return qfalse;
	}

	if (defender->client->NPC_class == CLASS_GUARD)
	{
		return qfalse;
	}

	if (jedi_jedi_master_low(defender))
	{
		return qfalse;
	}

	if (defender->health <= 1
		|| PM_InKnockDown(&defender->client->ps)
		|| PM_InRoll(&defender->client->ps)
		|| PM_SuperBreakLoseAnim(defender->client->ps.torsoAnim)
		|| PM_SuperBreakWinAnim(defender->client->ps.torsoAnim)
		|| pm_saber_in_special_attack(defender->client->ps.torsoAnim)
		|| PM_InSpecialJump(defender->client->ps.torsoAnim)
		|| defender->client->ps.groundEntityNum == ENTITYNUM_NONE
		|| !WalkCheck(defender)
		|| in_camera)
	{
		return qfalse;
	}

	if (!(defender->client->buttons & BUTTON_BLOCK))
	{
		if (defender->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(defender))
		{
			return qtrue;
		}
		return qfalse;
	}
	return qtrue;
}

qboolean Block_Button_Held(const gentity_t* defender)
{
	if (defender->client->ps.pm_flags & PMF_BLOCK_HELD)
	{
		return qtrue;
	}
	if (defender->client->buttons & BUTTON_USE)
	{
		return qfalse;
	}
	return qfalse;
}

qboolean manual_saberblocking(const gentity_t* defender) //Is this guy blocking or not?
{
	if (!g_SerenityJediEngineMode->integer)
	{
		return qfalse;
	}

	if (PM_RestAnim(defender->client->ps.legsAnim))
	{
		return qfalse;
	}

	if (defender->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(defender) && defender->client->ps.weapon != WP_SABER) //npc
	{
		return qfalse;
	}

	if (defender->s.eFlags & EF_FORCE_DRAINED
		|| defender->s.eFlags & EF_FORCE_GRIPPED
		|| defender->s.eFlags & EF_FORCE_GRASPED)
	{
		return qfalse;
	}

	if (defender->client->ps.forcePowerLevel[FP_SABER_DEFENSE] < FORCE_LEVEL_1)
	{
		//doesn't have saber defense
		return qfalse;
	}

	if (defender->client->ps.weapon != WP_SABER
		|| defender->client->ps.weapon == WP_NONE
		|| defender->client->ps.weapon == WP_MELEE) //saber not here
	{
		return qfalse;
	}

	if (defender->client->ps.weapon == WP_SABER && defender->client->ps.saberInFlight)
	{
		//saber not currently in use or available, attempt to use our hands instead.
		return qfalse;
	}

	if (defender->health <= 1
		|| BG_InKnockDown(defender->client->ps.legsAnim)
		|| BG_InKnockDown(defender->client->ps.torsoAnim)
		|| PM_InRoll(&defender->client->ps)
		|| PM_SuperBreakLoseAnim(defender->client->ps.torsoAnim)
		|| PM_SuperBreakWinAnim(defender->client->ps.torsoAnim)
		|| pm_saber_in_special_attack(defender->client->ps.torsoAnim)
		|| PM_InSpecialJump(defender->client->ps.torsoAnim)
		|| PM_SaberInBounce(defender->client->ps.saber_move)
		|| PM_SaberInKnockaway(defender->client->ps.saber_move)
		|| PM_SaberInBrokenParry(defender->client->ps.saber_move)
		|| defender->client->ps.groundEntityNum == ENTITYNUM_NONE
		|| g_SerenityJediEngineMode->integer == 2 && defender->client->ps.blockPoints < BLOCKPOINTS_FIVE
		|| defender->client->ps.forcePower < BLOCKPOINTS_FIVE)
	{
		return qfalse;
	}

	if (defender->client->buttons & BUTTON_ALT_ATTACK ||
		defender->client->buttons & BUTTON_FORCE_LIGHTNING ||
		defender->client->buttons & BUTTON_LIGHTNING_STRIKE ||
		defender->client->buttons & BUTTON_PROJECTION ||
		defender->client->buttons & BUTTON_USE_FORCE ||
		defender->client->buttons & BUTTON_FORCE_DRAIN ||
		defender->client->buttons & BUTTON_FORCEGRIP ||
		defender->client->buttons & BUTTON_DASH)
	{
		return qfalse;
	}

	if (SaberAttacking(defender))
	{
		if (defender->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(defender) && defender->client->ps.weapon == WP_SABER)
		{
			//bots just randomly parry to make up for them not intelligently parrying.
			return qtrue;
		}
		return qfalse;
	}

	if (!(defender->client->buttons & BUTTON_BLOCK))
	{
		if (defender->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(defender) && defender->client->ps.weapon == WP_SABER)
		{
			//bots just randomly parry to make up for them not intelligently parrying.
			return qtrue;
		}
		return qfalse;
	}
	return qtrue;
}

qboolean manual_running_and_saberblocking(const gentity_t* defender) //Is this guy blocking or not?
{
	if (!g_SerenityJediEngineMode->integer)
	{
		return qfalse;
	}

	if (!PM_RunningAnim(defender->client->ps.legsAnim))
	{
		return qfalse;
	}

	if (defender->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(defender))
	{
		return qfalse;
	}

	if (defender->client->buttons & BUTTON_ATTACK)
	{
		return qfalse;
	}

	if (defender->client->buttons & BUTTON_WALKING)
	{
		return qfalse;
	}

	if (PM_RestAnim(defender->client->ps.legsAnim))
	{
		return qfalse;
	}

	if (defender->s.eFlags & EF_FORCE_DRAINED
		|| defender->s.eFlags & EF_FORCE_GRIPPED
		|| defender->s.eFlags & EF_FORCE_GRASPED)
	{
		return qfalse;
	}

	if (!(defender->client->ps.forcePowersKnown & 1 << FP_SABER_DEFENSE))
	{
		//doesn't have saber defense
		return qfalse;
	}

	if (defender->health <= 1
		|| BG_InKnockDown(defender->client->ps.legsAnim)
		|| BG_InKnockDown(defender->client->ps.torsoAnim)
		|| PM_InRoll(&defender->client->ps)
		|| PM_SuperBreakLoseAnim(defender->client->ps.torsoAnim)
		|| PM_SuperBreakWinAnim(defender->client->ps.torsoAnim)
		|| pm_saber_in_special_attack(defender->client->ps.torsoAnim)
		|| PM_InSpecialJump(defender->client->ps.torsoAnim)
		|| PM_SaberInBounce(defender->client->ps.saber_move)
		|| PM_SaberInKnockaway(defender->client->ps.saber_move)
		|| PM_SaberInBrokenParry(defender->client->ps.saber_move)
		|| defender->client->ps.groundEntityNum == ENTITYNUM_NONE
		|| g_SerenityJediEngineMode->integer == 2 && defender->client->ps.blockPoints < BLOCKPOINTS_FIVE
		|| defender->client->ps.forcePower < BLOCKPOINTS_FIVE)
	{
		return qfalse;
	}

	if (defender->client->ps.weapon != WP_SABER
		|| defender->client->ps.weapon == WP_NONE
		|| defender->client->ps.weapon == WP_MELEE) //saber not here
	{
		return qfalse;
	}

	if (defender->client->ps.weapon == WP_SABER && defender->client->ps.saberInFlight)
	{
		//saber not currently in use or available, attempt to use our hands instead.
		return qfalse;
	}

	if (defender->client->buttons & BUTTON_ALT_ATTACK ||
		defender->client->buttons & BUTTON_FORCE_LIGHTNING ||
		defender->client->buttons & BUTTON_LIGHTNING_STRIKE ||
		defender->client->buttons & BUTTON_PROJECTION ||
		defender->client->buttons & BUTTON_USE_FORCE ||
		defender->client->buttons & BUTTON_FORCE_DRAIN ||
		defender->client->buttons & BUTTON_FORCEGRIP)
	{
		return qfalse;
	}

	if (!(defender->client->buttons & BUTTON_BLOCK))
	{
		return qfalse;
	}
	return qtrue;
}

qboolean manual_melee_dodging(const gentity_t* defender) //Is this guy dodgeing or not?
{
	if (defender->client->NPC_class == CLASS_BOBAFETT || defender->client->NPC_class == CLASS_MANDALORIAN || defender->client->NPC_class == CLASS_JANGO)
	{
		return qfalse;
	}
	if (!PM_WalkingOrRunningAnim(defender->client->ps.legsAnim)
		&& defender->client->buttons & BUTTON_USE
		&& !(defender->client->buttons & BUTTON_WALKING)
		&& !(defender->client->buttons & BUTTON_BLOCK)
		&& !PM_KickMove(defender->client->ps.saber_move)
		&& !PM_KickingAnim(defender->client->ps.torsoAnim)
		&& !PM_KickingAnim(defender->client->ps.legsAnim)
		&& !PM_InRoll(&defender->client->ps)
		&& !PM_InKnockDown(&defender->client->ps)
		&& !(defender->client->ps.pm_flags & PMF_DUCKED))
	{
		return qtrue;
	}
	return qfalse;
}

qboolean Manual_NPCSaberblocking(const gentity_t* defender) //Is this guy blocking or not?
{
	if (defender->s.number < MAX_CLIENTS || G_ControlledByPlayer(defender))
	{
		return qfalse;
	}

	if (defender->NPC && !G_ControlledByPlayer(defender) && defender->client->ps.weapon != WP_SABER)
	{
		return qfalse;
	}

	if (BG_IsAlreadyinTauntAnim(defender->client->ps.torsoAnim))
	{
		return qfalse;
	}

	if (defender->s.eFlags & EF_FORCE_DRAINED
		|| defender->s.eFlags & EF_FORCE_GRIPPED
		|| defender->s.eFlags & EF_FORCE_GRASPED)
	{
		return qfalse;
	}

	if (PM_SaberInKata(static_cast<saber_moveName_t>(defender->client->ps.saber_move)))
	{
		return qfalse;
	}

	if (defender->client->NPC_class == CLASS_GUARD)
	{
		return qfalse;
	}

	if (defender->health <= 1
		|| BG_InKnockDown(defender->client->ps.legsAnim)
		|| BG_InKnockDown(defender->client->ps.torsoAnim)
		|| PM_InRoll(&defender->client->ps)
		|| PM_SuperBreakLoseAnim(defender->client->ps.torsoAnim)
		|| PM_SuperBreakWinAnim(defender->client->ps.torsoAnim)
		|| pm_saber_in_special_attack(defender->client->ps.torsoAnim)
		|| PM_SaberInMassiveBounce(defender->client->ps.torsoAnim)
		|| PM_SaberInBashedAnim(defender->client->ps.torsoAnim)
		|| PM_InSpecialJump(defender->client->ps.torsoAnim)
		|| defender->client->ps.groundEntityNum == ENTITYNUM_NONE)
	{
		return qfalse;
	}

	if (defender->client->ps.weapon != WP_SABER
		|| defender->client->ps.weapon == WP_NONE
		|| defender->client->ps.weapon == WP_MELEE) //saber not here
	{
		return qfalse;
	}

	if (defender->client->ps.weapon == WP_SABER && !defender->client->ps.SaberActive())
	{
		//saber not currently in use or available, attempt to use our hands instead.
		return qfalse;
	}

	if (defender->client->ps.weapon == WP_SABER && defender->client->ps.saberInFlight)
	{
		//saber not currently in use or available, attempt to use our hands instead.
		return qfalse;
	}

	if (PM_SaberInMassiveBounce(defender->client->ps.torsoAnim) || PM_SaberInBashedAnim(defender->client->ps.torsoAnim))
	{
		return qfalse;
	}

	if (SaberAttacking(defender) && defender->client->ps.saberFatigueChainCount < MISHAPLEVEL_HUDFLASH)
	{
		//bots just randomly parry to make up for them not intelligently parrying.
		return qtrue;
	}

	return qtrue;
}

qboolean NPC_Can_Do_Blocking_stances_In_SJE_Mode(const gentity_t* defender)
{
	if (g_SerenityJediEngineMode->integer <= 2)
	{
		return qfalse;
	}

	if (!g_RealisticBlockingMode->integer)
	{
		return qfalse;
	}

	if (in_camera)
	{
		return qfalse;
	}

	if (defender->s.number < MAX_CLIENTS || G_ControlledByPlayer(defender))
	{
		return qfalse;
	}

	if (defender->NPC && !G_ControlledByPlayer(defender) && defender->client->ps.weapon != WP_SABER)
	{
		return qfalse;
	}

	if (BG_IsAlreadyinTauntAnim(defender->client->ps.torsoAnim))
	{
		return qfalse;
	}

	if (defender->s.eFlags & EF_FORCE_DRAINED
		|| defender->s.eFlags & EF_FORCE_GRIPPED
		|| defender->s.eFlags & EF_FORCE_GRASPED)
	{
		return qfalse;
	}

	if (pm_saber_innonblockable_attack(defender->client->ps.torsoAnim))
	{
		return qfalse;
	}

	if (defender->client->NPC_class == CLASS_GUARD)
	{
		return qfalse;
	}

	if (defender->health <= 1
		|| BG_InKnockDown(defender->client->ps.legsAnim)
		|| BG_InKnockDown(defender->client->ps.torsoAnim)
		|| PM_InRoll(&defender->client->ps)
		|| PM_SuperBreakLoseAnim(defender->client->ps.torsoAnim)
		|| PM_SuperBreakWinAnim(defender->client->ps.torsoAnim)
		|| pm_saber_in_special_attack(defender->client->ps.torsoAnim)
		|| PM_SaberInMassiveBounce(defender->client->ps.torsoAnim)
		|| PM_SaberInBashedAnim(defender->client->ps.torsoAnim)
		|| PM_Saberinstab(defender->client->ps.saber_move)
		|| PM_InSpecialJump(defender->client->ps.torsoAnim)
		|| defender->client->ps.groundEntityNum == ENTITYNUM_NONE)
	{
		return qfalse;
	}

	if (defender->client->ps.weapon != WP_SABER
		|| defender->client->ps.weapon == WP_NONE
		|| defender->client->ps.weapon == WP_MELEE) //saber not here
	{
		return qfalse;
	}

	if (defender->client->ps.weapon == WP_SABER && !defender->client->ps.SaberActive())
	{
		//saber not currently in use or available, attempt to use our hands instead.
		return qfalse;
	}

	if (defender->client->ps.weapon == WP_SABER && defender->client->ps.saberInFlight)
	{
		//saber not currently in use or available, attempt to use our hands instead.
		return qfalse;
	}

	return qtrue;
}

extern qboolean BG_InFlipBack(int anim);

int PlayerCanAbsorbKick(const gentity_t* defender, const vec3_t push_dir) //Can the player absorb a kick
{
	vec3_t p_l_angles, p_l_fwd;

	const qboolean is_holding_block_button = defender->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCK ? qtrue : qfalse;
	//Normal Blocking

	if (!defender || !defender->client)
	{
		//non-humanoids can't absorb kicks.
		return qfalse;
	}

	if (g_SerenityJediEngineMode->integer) // (MD Mode and AMD mode)
	{
		if (!is_holding_block_button) // Must be holding Block button
		{
			// Not doing any blocking can't absorb kicks.
			return qfalse;
		}
	}

	if (in_camera)
	{
		return qfalse;
	}

	if (G_InScriptedCinematicSaberAnim(defender))
	{
		return qfalse;
	}

	if (!WalkCheck(defender))
	{
		// runners cant absorb kick
		return qfalse;
	}

	// Cant absorb kick if
	if (defender->health <= 1 // low health (so dead people dont do it)
		|| BG_InKnockDown(defender->client->ps.legsAnim) // In a Knockdown (legs)
		|| BG_InKnockDown(defender->client->ps.torsoAnim) // In a Knockdown (torso)
		|| PM_InRoll(&defender->client->ps) // In a roll
		|| BG_InFlipBack(defender->client->ps.torsoAnim) // Flipping back
		|| PM_SuperBreakLoseAnim(defender->client->ps.torsoAnim) // lost a saber lock
		|| PM_SuperBreakWinAnim(defender->client->ps.torsoAnim) // won a saber lock
		|| pm_saber_in_special_attack(defender->client->ps.torsoAnim) // A special saber attack
		|| PM_InSpecialJump(defender->client->ps.torsoAnim) // A Force jump
		|| PM_SaberInBounce(defender->client->ps.saber_move) // Saber is bouncing
		|| PM_SaberInKnockaway(defender->client->ps.saber_move) // Saber is being knocked away
		|| PM_SaberInBrokenParry(defender->client->ps.saber_move) // Your parry got smashed open
		|| PM_KickMove(defender->client->ps.saber_move) // If you are doing a kick / melee / slap
		|| SaberAttacking(defender) // you are saber attacking
		|| BG_InGrappleMove(defender->client->ps.torsoAnim) // Trying to grab
		|| defender->client->ps.forcePowerLevel[FP_SABER_DEFENSE] < FORCE_LEVEL_1
		// No force saber deference (Gunners cant do it at all)
		|| defender->client->moveType == MT_FLYSWIM // Bobafett flying cant do it
		|| defender->client->ps.groundEntityNum == ENTITYNUM_NONE // Your in the air (jumping).
		|| defender->client->ps.blockPoints < FATIGUE_DODGEING // Less than 35 Block points
		|| defender->client->ps.forcePower < FATIGUE_DODGEING // Less than 35 Force points
		|| defender->client->ps.saberFatigueChainCount >= MISHAPLEVEL_TEN) // Your saber fatigued
	{
		return qfalse;
	}

	VectorSet(p_l_angles, 0, defender->client->ps.viewangles[YAW], 0);
	AngleVectors(p_l_angles, p_l_fwd, nullptr, nullptr);

	if (DotProduct(p_l_fwd, push_dir) > 0.2f)
	{
		//not hit in the front, can't absorb kick.
		return qfalse;
	}

	return qtrue; // If all that stuff above is clear then you can convert a knockdown in to a stagger
}

int BotCanAbsorbKick(const gentity_t* defender, const vec3_t push_dir) //Can the player absorb a kick
{
	vec3_t p_l_angles, p_l_fwd;

	const qboolean npc_blocking = defender->client->ps.ManualBlockingFlags & 1 << MBF_NPCKICKBLOCK ? qtrue : qfalse;	//NPC Blocking

	if (!defender || !defender->client)
	{
		//non-humanoids can't absorb kicks.
		return qfalse;
	}

	if (!WalkCheck(defender))
	{
		// runners cant absorb kick
		return qfalse;
	}

	if (in_camera)
	{
		return qfalse;
	}

	if (G_InScriptedCinematicSaberAnim(defender))
	{
		return qfalse;
	}

	// Cant absorb kick if
	if (defender->health <= 1 // low health (so dead people dont do it)
		|| BG_InKnockDown(defender->client->ps.legsAnim) // In a Knockdown (legs)
		|| BG_InKnockDown(defender->client->ps.torsoAnim) // In a Knockdown (torso)
		|| PM_InRoll(&defender->client->ps) // In a roll
		|| BG_InFlipBack(defender->client->ps.torsoAnim) // Flipping back
		|| PM_SuperBreakLoseAnim(defender->client->ps.torsoAnim) // lost a saber lock
		|| PM_SuperBreakWinAnim(defender->client->ps.torsoAnim) // won a saber lock
		|| pm_saber_in_special_attack(defender->client->ps.torsoAnim) // A special saber attack
		|| PM_InSpecialJump(defender->client->ps.torsoAnim) // A Force jump
		|| PM_SaberInBounce(defender->client->ps.saber_move) // Saber is bouncing
		|| PM_SaberInKnockaway(defender->client->ps.saber_move) // Saber is being knocked away
		|| PM_SaberInBrokenParry(defender->client->ps.saber_move) // Your parry got smashed open
		|| PM_KickMove(defender->client->ps.saber_move) // If you are doing a kick / melee / slap
		|| SaberAttacking(defender) // you are saber attacking
		|| BG_InGrappleMove(defender->client->ps.torsoAnim) // Trying to grab
		|| defender->client->ps.forcePowerLevel[FP_SABER_DEFENSE] < FORCE_LEVEL_1
		// No force saber defense (Gunners cant do it at all)
		|| defender->client->moveType == MT_FLYSWIM // Bobafett flying cant do it
		|| defender->client->ps.groundEntityNum == ENTITYNUM_NONE // Your in the air (jumping).
		|| defender->client->ps.blockPoints < FATIGUE_DODGEING // Less than 35 Block points
		|| defender->client->ps.forcePower < FATIGUE_DODGEING // Less than 35 Force points
		|| defender->client->ps.saberFatigueChainCount >= MISHAPLEVEL_TEN
		&& !npc_blocking) // Your saber fatigued
	{
		return qfalse;
	}

	VectorSet(p_l_angles, 0, defender->client->ps.viewangles[YAW], 0);
	AngleVectors(p_l_angles, p_l_fwd, nullptr, nullptr);

	if (DotProduct(p_l_fwd, push_dir) > 0.2f)
	{
		//not hit in the front, can't absorb kick.
		return qfalse;
	}

	return qtrue; // If all that stuff above is clear then you can convert a knockdown in to a stagger
}

qboolean Manual_NPCKickAbsorbing(const gentity_t* defender) //Is this guy blocking or not?
{
	if (defender->s.number < MAX_CLIENTS || G_ControlledByPlayer(defender))
	{
		return qfalse;
	}

	if (defender->client->ps.saberFatigueChainCount > MISHAPLEVEL_TEN
		&& (g_SerenityJediEngineMode->integer == 1 && defender->client->ps.forcePower <= BLOCKPOINTS_HALF
			|| g_SerenityJediEngineMode->integer == 2 && defender->client->ps.blockPoints <= BLOCKPOINTS_HALF))
	{
		return qfalse;
	}

	if (defender->s.eFlags & EF_FORCE_DRAINED
		|| defender->s.eFlags & EF_FORCE_GRIPPED
		|| defender->s.eFlags & EF_FORCE_GRASPED)
	{
		return qfalse;
	}

	if (defender->health <= 1
		|| BG_InKnockDown(defender->client->ps.legsAnim)
		|| BG_InKnockDown(defender->client->ps.torsoAnim)
		|| PM_InRoll(&defender->client->ps)
		|| PM_SuperBreakLoseAnim(defender->client->ps.torsoAnim)
		|| PM_SuperBreakWinAnim(defender->client->ps.torsoAnim)
		|| pm_saber_in_special_attack(defender->client->ps.torsoAnim)
		|| PM_InSpecialJump(defender->client->ps.torsoAnim)
		|| PM_SaberInBounce(defender->client->ps.saber_move)
		|| PM_SaberInReturn(defender->client->ps.saber_move)
		|| PM_SaberInKnockaway(defender->client->ps.saber_move)
		|| PM_SaberInBrokenParry(defender->client->ps.saber_move)
		|| PM_SaberInMassiveBounce(defender->client->ps.saber_move)
		|| PM_SaberInBashedAnim(defender->client->ps.saber_move)
		|| defender->client->ps.groundEntityNum == ENTITYNUM_NONE
		|| defender->client->ps.blockPoints < BLOCKPOINTS_THIRTY
		|| defender->client->ps.forcePower < BLOCKPOINTS_THIRTY
		|| defender->client->ps.userInt3 & 1 << FLAG_FATIGUED)
	{
		return qfalse;
	}

	if (defender->client->ps.weapon != WP_SABER
		|| defender->client->ps.weapon == WP_NONE
		|| defender->client->ps.weapon == WP_MELEE) //saber not here
	{
		return qfalse;
	}

	if (defender->client->ps.weapon == WP_SABER
		&& defender->client->ps.saberInFlight)
	{
		//saber not currently in use or available, attempt to use our hands instead.
		return qfalse;
	}

	if (defender->client->ps.weapon == WP_SABER
		&& !defender->client->ps.SaberActive())
	{
		//saber not currently in use or available, attempt to use our hands instead.
		return qfalse;
	}

	if (g_SerenityJediEngineMode->integer && !WalkCheck(defender))
	{
		//can't block while running.
		return qfalse;
	}

	if (g_SerenityJediEngineMode->integer == 1 && defender->client->ps.forcePower <= BLOCKPOINTS_TEN
		|| g_SerenityJediEngineMode->integer == 2 && defender->client->ps.blockPoints <= BLOCKPOINTS_TEN)
	{
		return qfalse;
	}

	return qtrue;
}

qboolean Manual_JKAMode_NPCSaberblocking(const gentity_t* defender) //Is this guy blocking or not?
{
	if (g_SerenityJediEngineMode->integer > 0)
	{
		return qfalse;
	}

	if (defender->s.number < MAX_CLIENTS || G_ControlledByPlayer(defender))
	{
		return qfalse;
	}

	if (defender->NPC && !G_ControlledByPlayer(defender) && defender->client->ps.weapon != WP_SABER)
	{
		return qfalse;
	}

	if (defender->s.eFlags & EF_FORCE_DRAINED
		|| defender->s.eFlags & EF_FORCE_GRIPPED
		|| defender->s.eFlags & EF_FORCE_GRASPED)
	{
		return qfalse;
	}

	if (defender->client->NPC_class == CLASS_GUARD)
	{
		return qfalse;
	}

	if (defender->health <= 1
		|| BG_InKnockDown(defender->client->ps.legsAnim)
		|| BG_InKnockDown(defender->client->ps.torsoAnim)
		|| PM_InRoll(&defender->client->ps)
		|| PM_SuperBreakLoseAnim(defender->client->ps.torsoAnim)
		|| PM_SuperBreakWinAnim(defender->client->ps.torsoAnim)
		|| pm_saber_in_special_attack(defender->client->ps.torsoAnim)
		|| PM_InSpecialJump(defender->client->ps.torsoAnim)
		|| defender->client->ps.groundEntityNum == ENTITYNUM_NONE)
	{
		return qfalse;
	}

	if (defender->client->ps.weapon != WP_SABER
		|| defender->client->ps.weapon == WP_NONE
		|| defender->client->ps.weapon == WP_MELEE) //saber not here
	{
		return qfalse;
	}

	if (defender->client->ps.weapon == WP_SABER && !defender->client->ps.SaberActive())
	{
		//saber not currently in use or available, attempt to use our hands instead.
		return qfalse;
	}

	if (defender->client->ps.weapon == WP_SABER && defender->client->ps.saberInFlight)
	{
		//saber not currently in use or available, attempt to use our hands instead.
		return qfalse;
	}

	return qtrue;
}

int WP_MissileBlockForBlock(const int saber_block)
{
	switch (saber_block)
	{
	case BLOCKED_UPPER_RIGHT:
		return BLOCKED_UPPER_RIGHT_PROJ;
	case BLOCKED_UPPER_LEFT:
		return BLOCKED_UPPER_LEFT_PROJ;
	case BLOCKED_LOWER_RIGHT:
		return BLOCKED_LOWER_RIGHT_PROJ;
	case BLOCKED_LOWER_LEFT:
		return BLOCKED_LOWER_LEFT_PROJ;
	case BLOCKED_TOP:
		return BLOCKED_TOP_PROJ;
	case BLOCKED_BACK:
		return BLOCKED_BACK;
	default:;
	}
	return saber_block;
}

extern qboolean BG_FullBodyEmoteAnim(int anim);
extern qboolean BG_FullBodyCowerstartAnim(int anim);
extern qboolean BG_FullBodyRespectAnim(int anim);
extern qboolean BG_AnimRequiresResponce(int anim);

qboolean IsSurrendering(const gentity_t* self)
{
	if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self))
	{
		return qfalse;
	}

	if (self->client->ps.weapon != WP_SABER)
	{
		return qfalse;
	}

	if (!BG_FullBodyEmoteAnim(self->client->ps.torsoAnim))
	{
		// Ignore players surrendering
		return qfalse;
	}

	return qtrue;
}

qboolean IsCowering(const gentity_t* self)
{
	if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self))
	{
		return qfalse;
	}

	if (!BG_FullBodyCowerstartAnim(self->client->ps.torsoAnim))
	{
		// Ignore players surrendering
		return qfalse;
	}

	return qtrue;
}

qboolean IsRESPECTING(const gentity_t* self)
{
	if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self))
	{
		return qfalse;
	}

	if (!BG_FullBodyRespectAnim(self->client->ps.torsoAnim))
	{
		// Ignore players surrendering
		return qfalse;
	}

	return qtrue;
}

qboolean is_anim_requires_responce(const gentity_t* self)
{
	if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self))
	{
		return qfalse;
	}

	if (!BG_AnimRequiresResponce(self->client->ps.torsoAnim))
	{
		// Ignore players surrendering
		return qfalse;
	}

	return qtrue;
}

int IsPressingKickButton(const gentity_t* self)
{
	if (!(self->client->buttons & BUTTON_DASH)
		&& self->client->NPC_class != CLASS_DROIDEKA
		&& (self->client->buttons & BUTTON_KICK && self->client->ps.pm_flags & PMF_KICK_HELD))
	{
		return qtrue;
	}
	return qfalse;
}

extern qboolean BG_AnimIsSurrenderingandRequiresResponce(int anim);

qboolean IsSurrenderingAnimRequiresResponce(const gentity_t* self)
{
	if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self))
	{
		return qfalse;
	}

	if (!BG_AnimIsSurrenderingandRequiresResponce(self->client->ps.torsoAnim))
	{
		// Ignore players surrendering
		return qfalse;
	}

	return qtrue;
}

float VectorBlockDistance(vec3_t v1, vec3_t v2)
{
	//returns the distance between the two points.
	vec3_t dir;

	VectorSubtract(v2, v1, dir);
	return VectorLength(dir);
}

int BasicWeaponBlockCosts[NUM_MODS] =
{
	-1, //MOD_UNKNOWN,
	20, //MOD_SABER,
	20, //MOD_BRYAR,
	10, //MOD_BRYAR_ALT,
	20, //MOD_BLASTER,
	20, //MOD_BLASTER_ALT,
	20, //MOD_CLONERIFLE,
	20, //MOD_CLONERIFLE_ALT,
	20, //MOD_REBELBLASTER,
	20, //MOD_REBELBLASTER_ALT,
	20, //MOD_CLONECOMMANDO,
	20, //MOD_CLONECOMMANDO_ALT,
	20, //MOD_Z6_ROTARY_CANNON,
	20, //MOD_REBELRIFLE,
	20, //MOD_REBELRIFLE_ALT,
	20, //MOD_REY,
	20, //MOD_REY_ALT,
	20, //MOD_CLONEPISTOL,
	20, //MOD_CLONEPISTOL_ALT,
	20, //MOD_JANGO,
	20, //MOD_JANGO_ALT,
	20, //MOD_BOBA,
	20, //MOD_BOBA_ALT,
	20, //MOD_DISRUPTOR,
	20, //MOD_SNIPER,
	20, //MOD_BOWCASTER,
	20, //MOD_BOWCASTER_ALT,
	20, //MOD_REPEATER,
	20, //MOD_REPEATER_ALT,
	20, //MOD_DEMP2,
	20, //MOD_DEMP2_ALT,
	20, //MOD_FLECHETTE,
	20, //MOD_FLECHETTE_ALT,
	20, //MOD_ROCKET,
	20, //MOD_ROCKET_ALT,
	20, //MOD_CONC,
	20, //MOD_CONC_ALT,
	20, //MOD_THERMAL,
	20, //MOD_THERMAL_ALT,
	20, //MOD_DETPACK,
	20, //MOD_LASERTRIP,
	20, //MOD_LASERTRIP_ALT,
	-1, //MOD_MELEE,
	20, //MOD_SEEKER,
	-1, //MOD_FORCE_GRIP,
	20, //MOD_FORCE_LIGHTNING,
	-1, //MOD_FORCE_DRAIN,
	20, //MOD_EMPLACED,
	20, //MOD_ELECTROCUTE,
	20, //MOD_EXPLOSIVE,
	20, //MOD_EXPLOSIVE_SPLASH,
	-1, //MOD_KNOCKOUT,
	-1, //MOD_ENERGY,
	-1, //MOD_ENERGY_SPLASH,
	-1, //MOD_WATER,
	-1, //MOD_SLIME,
	-1, //MOD_LAVA,
	-1, //MOD_CRUSH,
	-1, //MOD_IMPACT,
	-1, //MOD_FALLING,
	-1, //MOD_SUICIDE,
	-1, //MOD_TRIGGER_HURT,
	-1, //MOD_GAS,
	-1, //MOD_DESTRUCTION,
	20, //MOD_HEADSHOT,
	20, //MOD_BODYSHOT,
	20, //MOD_LIGHTNING_STRIKE,
	0, //MOD_PROJECTION_END,

	//NUM_MODS,
};

static int BasicSaberBlockCost(const int attacker_style)
{
	//returns the basic saber block cost of blocking an attack from the given saber style.
	switch (attacker_style)
	{
	case SS_DUAL:
		return 13;
	case SS_STAFF:
		return 13;
	case SS_TAVION:
		return 14;
	case SS_FAST:
		return 12;
	case SS_MEDIUM:
		return 15;
	case SS_DESANN:
		return 16;
	case SS_STRONG:
		return 17;
	default:
		return 0;
	}
}

static qboolean IsMoving(const gentity_t* ent)
{
	if (!ent || !ent->client)
		return qfalse;

	if (ent->client->pers.cmd.upmove == 0
		&& ent->client->pers.cmd.forwardmove == 0
		&& ent->client->pers.cmd.rightmove == 0)
		return qfalse;

	return qtrue;
}

int WP_SaberBlockCost(gentity_t* defender, const gentity_t* attacker, vec3_t hit_locs)
{
	//returns the cost to block this attack for this attacker/defender combo.
	float saber_block_cost;
	//===========================
	// Determine Base Block Cost
	//===========================

	if (!attacker //don't have attacker
		|| !attacker->client //attacker isn't a NPC/player
		|| attacker->client->ps.weapon != WP_SABER) //or the player that is attacking isn't using a saber
	{
		//standard bolt block!
		saber_block_cost = DODGE_BOLTBLOCK;

		if (attacker && attacker->client && attacker->activator && attacker->activator->s.weapon == WP_BRYAR_PISTOL)
		{
			saber_block_cost = 4;
		}

		if (attacker && attacker->client && attacker->activator && attacker->activator->s.weapon == WP_SBD_BLASTER)
		{
			saber_block_cost = 4;
		}

		if (attacker && attacker->client && attacker->activator && attacker->activator->s.weapon == WP_JAWA)
		{
			saber_block_cost = 4;
		}

		if (attacker->client && attacker->client->ps.weapon != WP_FLECHETTE)
		{
			saber_block_cost += 2;
		}

		if (defender->client && defender->client->ps.weapon == WP_SABER)
		{
			if (defender->client->ps.forcePowersActive & 1 << FP_SPEED)
			{
				saber_block_cost += 10; //Using force speed
			}
			if (PM_RunningAnim(defender->client->ps.legsAnim))
			{
				saber_block_cost += 5; //Running
			}
			if (defender->client->ps.groundEntityNum == ENTITYNUM_NONE)
			{
				saber_block_cost += 10;
			}
			if (WalkCheck(defender) && IsMoving(defender))
			{
				saber_block_cost++; //Walking
			}
		}

		if (attacker->activator && attacker->activator->s.weapon == WP_BRYAR_PISTOL
			|| attacker->activator && attacker->activator->s.weapon == WP_BLASTER_PISTOL
			|| attacker->activator && attacker->activator->s.weapon == WP_DUAL_PISTOL
			|| attacker->activator && attacker->activator->s.weapon == WP_DUAL_CLONEPISTOL
			|| attacker->activator && attacker->activator->s.weapon == WP_DROIDEKA
			|| attacker->activator && attacker->activator->s.weapon == WP_SBD_BLASTER
			|| attacker->activator && attacker->activator->s.weapon == WP_REPEATER
			|| attacker->activator && attacker->activator->s.weapon == WP_BOWCASTER
			|| attacker->activator && attacker->activator->s.weapon == WP_DISRUPTOR
			|| attacker->activator && attacker->activator->s.weapon == WP_EMPLACED_GUN
			|| attacker->activator && attacker->activator->s.weapon == WP_FLECHETTE
			|| attacker->activator && attacker->activator->s.weapon == WP_JAWA)
		{
			if (attacker->activator->s.weapon == WP_FLECHETTE)
			{
				const float distance = VectorBlockDistance(attacker->activator->currentOrigin, defender->currentOrigin);

				if (WalkCheck(defender))
				{
					saber_block_cost = 2;
				}
				else
				{
					saber_block_cost = 4;
				}

				if (defender->client->ps.forcePowerLevel[FP_SABER_OFFENSE] >= FORCE_LEVEL_3 && defender->client->ps.
					saber_anim_level != SS_MEDIUM)
				{
					saber_block_cost++;
				}

				if (distance >= 200.0f)
				{
					saber_block_cost += 1.5;
				}
				saber_block_cost += 1;
			}
			else if (attacker->activator->s.weapon != WP_BOWCASTER)
			{
				const float distance = VectorBlockDistance(attacker->activator->currentOrigin, defender->currentOrigin);

				if (distance <= 125.0f)
				{
					saber_block_cost = DODGE_BOLTBLOCK * 3;
				}
				else if (distance <= 300.0f)
				{
					saber_block_cost = DODGE_BOLTBLOCK * 2;
				}
				else
				{
					saber_block_cost = DODGE_BOLTBLOCK;
				}

				if (attacker->activator->s.weapon == WP_REPEATER)
				{
					saber_block_cost = DODGE_REPEATERBLOCK;
				}
			}
			else if (attacker->activator->s.weapon == WP_DISRUPTOR)
			{
				saber_block_cost = 10;
			}
			else if (attacker->activator->s.weapon == WP_DEMP2)
			{
				saber_block_cost = DODGE_TUSKENBLOCK * 3;
			}
			else if (attacker->activator->s.weapon == WP_TUSKEN_RIFLE)
			{
				saber_block_cost = DODGE_TUSKENBLOCK * 3;
			}
			else
			{
				saber_block_cost = 5;
			}

			if (PM_SaberInAttack(defender->client->ps.saber_move) || PM_SaberInStart(defender->client->ps.saber_move))
			{
				if (attacker->activator->s.weapon == WP_FLECHETTE)
				{
					saber_block_cost = saber_block_cost * 1.5;
				}
				else
				{
					saber_block_cost = saber_block_cost * 2;
				}
			}

			if (attacker->activator->s.weapon == WP_BOWCASTER)
			{
				saber_block_cost = 3;
			}

			if (defender->client->ps.saber_anim_level == SS_FAST)
			{
				saber_block_cost--;
			}
		}
		else if (attacker->activator && attacker->activator->s.weapon == WP_BLASTER)
		{
			saber_block_cost = 2;
		}
		else
		{
			saber_block_cost = DODGE_BOLTBLOCK;
		}
	}
	else if (attacker->client->ps.saber_move == LS_A_LUNGE
		|| attacker->client->ps.saber_move == LS_SPINATTACK
		|| attacker->client->ps.saber_move == LS_SPINATTACK_DUAL)
	{
		//lunge attacks
		saber_block_cost = .75 * BasicSaberBlockCost(attacker->client->ps.saber_anim_level);
	}
	else if (attacker->client->ps.saber_move == LS_ROLL_STAB)
	{
		//roll stab
		saber_block_cost = 2 * BasicSaberBlockCost(attacker->client->ps.saber_anim_level);
	}
	else if (attacker->client->ps.saber_move == LS_A_JUMP_T__B_)
	{
		//DFA moves
		saber_block_cost = 4 * BasicSaberBlockCost(attacker->client->ps.saber_anim_level);
	}
	else if (attacker->client->ps.saber_move == LS_A_FLIP_STAB
		|| attacker->client->ps.saber_move == LS_A_FLIP_SLASH)
	{
		//flip stabs do more DP
		saber_block_cost = 2 * BasicSaberBlockCost(attacker->client->ps.saber_anim_level);
	}
	else
	{
		//"normal" swing moves
		if (attacker->client->ps.userInt3 & 1 << FLAG_ATTACKFAKE)
		{
			//attacker is in an attack fake
			if (attacker->client->ps.saber_anim_level == SS_STRONG && !g_accurate_blocking(defender, attacker, hit_locs))
			{
				//Red does additional DP damage with attack fakes if they aren't parried.
				saber_block_cost = BasicSaberBlockCost(attacker->client->ps.saber_anim_level) * 1.35;
			}
			else
			{
				saber_block_cost = BasicSaberBlockCost(attacker->client->ps.saber_anim_level) * 1.25;
			}
		}
		else
		{
			//normal saber block
			saber_block_cost = BasicSaberBlockCost(attacker->client->ps.saber_anim_level);
		}

		//add running damage bonus to normal swings but don't apply if the defender is slow bouncing
		if (!WalkCheck(attacker)
			&& !(defender->client->ps.userInt3 & 1 << FLAG_SLOWBOUNCE)
			&& !(defender->client->ps.userInt3 & 1 << FLAG_OLDSLOWBOUNCE))
		{
			if (attacker->client->ps.saber_anim_level == SS_DUAL)
			{
				saber_block_cost *= 3.0;
			}
			else
			{
				saber_block_cost *= 1.5;
			}
		}
	}

	//======================
	// Block Cost Modifiers
	//======================

	if (attacker && attacker->client)
	{
		//attacker is a player so he must have just hit you with a saber blow.
		if (g_accurate_blocking(defender, attacker, hit_locs))
		{
			//parried this attack, cost is less
			if (defender->client->ps.saber_anim_level == SS_FAST)
			{
				//blue parries cheaper
				saber_block_cost = saber_block_cost / 3.25;
			}
			else
			{
				saber_block_cost = saber_block_cost / 3;
			}
		}

		if (!InFront(attacker->client->ps.origin, defender->client->ps.origin, defender->client->ps.viewangles, -0.7f))
		{
			//player is behind us, costs more to block
			//staffs back block at normal cost.
			if (defender->client->ps.saber_anim_level == SS_STAFF && defender->client->ps.forcePowerLevel[
				FP_SABER_DEFENSE] == FORCE_LEVEL_3)
			{
				// Having both staff and defense 3 allow no extra back hit damage
				saber_block_cost *= 1;
			}
			else if (defender->client->ps.saber_anim_level == SS_STAFF && defender->client->ps.forcePowerLevel[
				FP_SABER_DEFENSE] == FORCE_LEVEL_2)
			{
				//level 2 defense lowers back damage more
				saber_block_cost *= 1.50;
			}
			else if (defender->client->ps.saber_anim_level == SS_STAFF && defender->client->ps.forcePowerLevel[
				FP_SABER_DEFENSE] == FORCE_LEVEL_1)
			{
				//level 1 defense lowers back damage a bit
				saber_block_cost *= 1.75;
			}
			else
			{
				saber_block_cost *= 2;
			}
		}

		//clamp to body dodge cost since it wouldn't be fair to cost more than that.
		if (saber_block_cost > BasicWeaponBlockCosts[MOD_SABER])
		{
			saber_block_cost = BasicWeaponBlockCosts[MOD_SABER];
		}
	}
	if (PM_SaberInBrokenParry(defender->client->ps.saber_move))
	{
		//we're stunned/stumbling, increase DP cost
		saber_block_cost *= 1.5;
	}

	if (PM_KickingAnim(defender->client->ps.legsAnim))
	{
		//kicking
		saber_block_cost *= 1.5;
	}

	if (!WalkCheck(defender))
	{
		if (defender->NPC)
		{
			saber_block_cost *= 1.0;
		}
		else
		{
			saber_block_cost *= 2.5;
		}
	}
	if (defender->client->ps.groundEntityNum == ENTITYNUM_NONE)
	{
		//in mid-air
		if (defender->client->ps.saber_anim_level == SS_DUAL) //Ataru's other perk much less cost for air hit
		{
			saber_block_cost *= .5;
		}
		else
		{
			saber_block_cost *= 2;
		}
	}
	if (defender->client->ps.saberBlockingTime > level.time)
	{
		//attempting to block something too soon after a saber bolt block
		saber_block_cost *= 2;
	}
	return static_cast<int>(saber_block_cost);
}

int WP_SaberBoltBlockCost(gentity_t* defender, const gentity_t* attacker)
{
	//returns the cost to block this attack for this attacker/defender combo.
	float saber_block_cost;
	//===========================
	// Determine Base Block Cost
	//===========================

	if (!attacker //don't have attacker
		|| !attacker->client //attacker isn't a NPC/player
		|| attacker->client->ps.weapon != WP_SABER) //or the player that is attacking isn't using a saber
	{
		//standard bolt block!
		saber_block_cost = DODGE_BOLTBLOCK;

		if (attacker && attacker->client && attacker->activator && attacker->activator->s.weapon == WP_BRYAR_PISTOL)
		{
			saber_block_cost = 4;
		}

		if (attacker && attacker->client && attacker->activator && attacker->activator->s.weapon == WP_SBD_BLASTER)
		{
			saber_block_cost = 4;
		}

		if (attacker && attacker->client && attacker->activator && attacker->activator->s.weapon == WP_JAWA)
		{
			saber_block_cost = 4;
		}
		if (attacker->client && attacker->client->ps.weapon != WP_FLECHETTE)
		{
			saber_block_cost += 2;
		}

		if (defender->client->ps.weapon == WP_SABER)
		{
			if (defender->client->ps.forcePowersActive & 1 << FP_SPEED)
			{
				saber_block_cost += 10; //Using force speed
			}
			else if (PM_RunningAnim(defender->client->ps.legsAnim))
			{
				saber_block_cost += 5; //Running
			}
			else if (WalkCheck(defender) && IsMoving(defender))
			{
				saber_block_cost++; //Walking
			}
			if (defender->client->ps.groundEntityNum == ENTITYNUM_NONE)
			{
				saber_block_cost += 10;
			}
		}

		if (attacker->activator && attacker->activator->s.weapon == WP_BRYAR_PISTOL
			|| attacker->activator && attacker->activator->s.weapon == WP_BLASTER_PISTOL
			|| attacker->activator && attacker->activator->s.weapon == WP_DUAL_PISTOL
			|| attacker->activator && attacker->activator->s.weapon == WP_DUAL_CLONEPISTOL
			|| attacker->activator && attacker->activator->s.weapon == WP_DROIDEKA
			|| attacker->activator && attacker->activator->s.weapon == WP_SBD_BLASTER
			|| attacker->activator && attacker->activator->s.weapon == WP_REPEATER
			|| attacker->activator && attacker->activator->s.weapon == WP_BOWCASTER
			|| attacker->activator && attacker->activator->s.weapon == WP_DISRUPTOR
			|| attacker->activator && attacker->activator->s.weapon == WP_EMPLACED_GUN
			|| attacker->activator && attacker->activator->s.weapon == WP_FLECHETTE
			|| attacker->activator && attacker->activator->s.weapon == WP_JAWA)
		{
			if (attacker->activator->s.weapon == WP_FLECHETTE)
			{
				const float distance = VectorBlockDistance(attacker->activator->currentOrigin, defender->currentOrigin);

				if (WalkCheck(defender))
				{
					saber_block_cost = 2;
				}
				else
				{
					saber_block_cost = 4;
				}

				if (defender->client->ps.forcePowerLevel[FP_SABER_OFFENSE] >= FORCE_LEVEL_3 && defender->client->ps.
					saber_anim_level != SS_MEDIUM)
				{
					saber_block_cost++;
				}

				if (distance >= 200.0f)
				{
					saber_block_cost += 1.5;
				}
				saber_block_cost += 1;
			}
			else if (attacker->activator->s.weapon != WP_BOWCASTER)
			{
				const float distance = VectorBlockDistance(attacker->activator->currentOrigin, defender->currentOrigin);

				if (distance <= 125.0f)
				{
					saber_block_cost = DODGE_BOLTBLOCK * 3;
				}
				else if (distance <= 300.0f)
				{
					saber_block_cost = DODGE_BOLTBLOCK * 2;
				}
				else
				{
					saber_block_cost = DODGE_BOLTBLOCK;
				}

				if (attacker->activator->s.weapon == WP_REPEATER)
				{
					saber_block_cost = DODGE_REPEATERBLOCK;
				}
			}
			else if (attacker->activator->s.weapon == WP_DISRUPTOR)
			{
				saber_block_cost = 10;
			}
			else if (attacker->activator->s.weapon == WP_DEMP2)
			{
				saber_block_cost = DODGE_TUSKENBLOCK * 3;
			}
			else if (attacker->activator->s.weapon == WP_TUSKEN_RIFLE)
			{
				saber_block_cost = DODGE_TUSKENBLOCK * 3;
			}
			else
			{
				saber_block_cost = 5;
			}

			if (PM_SaberInAttack(defender->client->ps.saber_move) || PM_SaberInStart(defender->client->ps.saber_move))
			{
				if (attacker->activator->s.weapon == WP_FLECHETTE)
				{
					saber_block_cost = saber_block_cost * 1.5;
				}
				else
				{
					saber_block_cost = saber_block_cost * 2;
				}
			}

			if (attacker->activator->s.weapon == WP_BOWCASTER)
			{
				saber_block_cost = 3;
			}

			if (defender->client->ps.saber_anim_level == SS_FAST)
			{
				saber_block_cost--;
			}
		}
		else if (attacker->activator && attacker->activator->s.weapon == WP_BLASTER)
		{
			saber_block_cost = 2;
		}
		else
		{
			saber_block_cost = DODGE_BOLTBLOCK;
		}
	}
	else if (attacker->client->ps.saber_move == LS_A_LUNGE
		|| attacker->client->ps.saber_move == LS_SPINATTACK
		|| attacker->client->ps.saber_move == LS_SPINATTACK_DUAL)
	{
		//lunge attacks
		saber_block_cost = .75 * BasicSaberBlockCost(attacker->client->ps.saber_anim_level);
	}
	else if (attacker->client->ps.saber_move == LS_ROLL_STAB)
	{
		//roll stab
		saber_block_cost = 2 * BasicSaberBlockCost(attacker->client->ps.saber_anim_level);
	}
	else if (attacker->client->ps.saber_move == LS_A_JUMP_T__B_)
	{
		//DFA moves
		saber_block_cost = 4 * BasicSaberBlockCost(attacker->client->ps.saber_anim_level);
	}
	else if (attacker->client->ps.saber_move == LS_A_FLIP_STAB
		|| attacker->client->ps.saber_move == LS_A_FLIP_SLASH)
	{
		//flip stabs do more DP
		saber_block_cost = 2 * BasicSaberBlockCost(attacker->client->ps.saber_anim_level);
	}
	else
	{
		//"normal" swing moves
		if (attacker->client->ps.userInt3 & 1 << FLAG_ATTACKFAKE)
		{
			//attacker is in an attack fake
			if (attacker->client->ps.saber_anim_level == SS_STRONG)
			{
				//Red does additional DP damage with attack fakes if they aren't parried.
				saber_block_cost = BasicSaberBlockCost(attacker->client->ps.saber_anim_level) * 1.35;
			}
			else
			{
				saber_block_cost = BasicSaberBlockCost(attacker->client->ps.saber_anim_level) * 1.25;
			}
		}
		else
		{
			//normal saber block
			saber_block_cost = BasicSaberBlockCost(attacker->client->ps.saber_anim_level);
		}

		//add running damage bonus to normal swings but don't apply if the defender is slowbouncing
		if (!WalkCheck(attacker)
			&& !(defender->client->ps.userInt3 & 1 << FLAG_SLOWBOUNCE)
			&& !(defender->client->ps.userInt3 & 1 << FLAG_OLDSLOWBOUNCE))
		{
			if (attacker->client->ps.saber_anim_level == SS_DUAL)
			{
				saber_block_cost *= 3.0;
			}
			else
			{
				saber_block_cost *= 1.5;
			}
		}
	}

	//======================
	// Block Cost Modifiers
	//======================

	if (attacker && attacker->client)
	{
		//attacker is a player so he must have just hit you with a saber blow.
		if (!InFront(attacker->client->ps.origin, defender->client->ps.origin, defender->client->ps.viewangles, -0.7f))
		{
			//player is behind us, costs more to block
			//staffs back block at normal cost.
			if (defender->client->ps.saber_anim_level == SS_STAFF && defender->client->ps.forcePowerLevel[
				FP_SABER_DEFENSE] == FORCE_LEVEL_3)
			{
				// Having both staff and defense 3 allow no extra back hit damage
				saber_block_cost *= 1;
			}
			else if (defender->client->ps.saber_anim_level == SS_STAFF && defender->client->ps.forcePowerLevel[
				FP_SABER_DEFENSE] == FORCE_LEVEL_2)
			{
				//level 2 defense lowers back damage more
				saber_block_cost *= 1.50;
			}
			else if (defender->client->ps.saber_anim_level == SS_STAFF && defender->client->ps.forcePowerLevel[
				FP_SABER_DEFENSE] == FORCE_LEVEL_1)
			{
				//level 1 defense lowers back damage a bit
				saber_block_cost *= 1.75;
			}
			else
			{
				saber_block_cost *= 2;
			}
		}

		//clamp to body dodge cost since it wouldn't be fair to cost more than that.
		if (saber_block_cost > BasicWeaponBlockCosts[MOD_SABER])
		{
			saber_block_cost = BasicWeaponBlockCosts[MOD_SABER];
		}
	}
	if (PM_SaberInBrokenParry(defender->client->ps.saber_move))
	{
		//we're stunned/stumbling, increase DP cost
		saber_block_cost *= 1.5;
	}

	if (PM_KickingAnim(defender->client->ps.legsAnim))
	{
		//kicking
		saber_block_cost *= 1.5;
	}

	if (!WalkCheck(defender))
	{
		if (defender->NPC)
		{
			saber_block_cost *= 1.0;
		}
		else
		{
			saber_block_cost *= 2.5;
		}
	}
	if (defender->client->ps.groundEntityNum == ENTITYNUM_NONE)
	{
		//in mid-air
		if (defender->client->ps.saber_anim_level == SS_DUAL) //Ataru's other perk much less cost for air hit
		{
			saber_block_cost *= .5;
		}
		else
		{
			saber_block_cost *= 2;
		}
	}
	if (defender->client->ps.saberBlockingTime > level.time)
	{
		//attempting to block something too soon after a saber bolt block
		saber_block_cost *= 2;
	}
	return static_cast<int>(saber_block_cost);
}

extern qboolean G_ControlledByNPC(const gentity_t* self);

int WP_SaberMustBoltBlock(gentity_t* self, const gentity_t* atk, const qboolean check_b_box_block, vec3_t point, const int rSaberNum, const int rBladeNum)
{
	if (!self || !self->client || !atk)
	{
		return 0;
	}

	if (g_SerenityJediEngineMode->integer < 1)
	{
		return 0;
	}

	if (atk && atk->s.eType == ET_MISSILE
		&& (atk->s.weapon == WP_ROCKET_LAUNCHER ||
			atk->s.weapon == WP_THERMAL ||
			atk->s.weapon == WP_TRIP_MINE ||
			atk->s.weapon == WP_DET_PACK ||
			atk->methodOfDeath == MOD_CONC ||
			atk->methodOfDeath == MOD_CONC_ALT ||
			atk->methodOfDeath == MOD_REPEATER_ALT ||
			atk->methodOfDeath == MOD_FLECHETTE_ALT))
	{
		//can't block this stuff with a saber
		return 0;
	}

	if (!(self->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCK))
	{
		if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self))
		{
			//bots just randomly parry to make up for them not intelligently parrying.
			if (self->client->ps.weapon == WP_SABER && self->client->ps.SaberActive() && !self->client->ps.
				saberInFlight)
			{
				return 1;
			}
			return 0;
		}
		return 0;
	}

	if (PM_SaberInBrokenParry(self->client->ps.saber_move))
	{
		//you've been stunned from a broken parry
		return 0;
	}

	if (BG_InGrappleMove(self->client->ps.torsoAnim))
	{
		//you can't block while doing a melee move.
		return 0;
	}

	if (PM_KickMove(self->client->ps.saber_move))
	{
		return 0;
	}

	if (self->client->ps.weapon != WP_SABER
		|| self->client->ps.weapon == WP_NONE
		|| self->client->ps.weapon == WP_MELEE) //saber not here
	{
		return 0;
	}

	if (self->client->ps.weapon == WP_SABER && self->client->ps.saberInFlight)
	{
		//saber not currently in use or available, attempt to use our hands instead.
		return 0;
	}

	if (self->client->ps.weaponstate == WEAPON_RAISING)
	{
		if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self))
		{
			//bots just randomly parry to make up for them not intelligently parrying.
			if (self->client->ps.weapon == WP_SABER && self->client->ps.SaberActive() && !self->client->ps.
				saberInFlight)
			{
				return 1;
			}
			return 0;
		}
		return 0;
	}

	if (!WalkCheck(self) && self->client->ps.forcePowersActive & 1 << FP_SPEED)
	{
		//can't block while running in force speed.
		return 0;
	}

	if (PM_InKnockDown(&self->client->ps))
	{
		//can't block while knocked down or getting up from knockdown.
		return 0;
	}

	if (atk && atk->client && atk->client->ps.weapon == WP_SABER)
	{
		//player is attacking with saber
		if ((atk->client->ps.saber_move == LS_A_LUNGE
			|| atk->client->ps.saber_move == LS_SPINATTACK
			|| atk->client->ps.saber_move == LS_SPINATTACK_DUAL)
			&& (self->client->ps.userInt3 & 1 << FLAG_FATIGUED || self->client->ps.userInt3 & 1 << FLAG_BLOCKDRAINED))
		{
			//saber attacker, we can't block lunge attacks while fatigued.
			return 0;
		}

		if (g_SerenityJediEngineMode->integer == 2)
		{
			if (PM_SuperBreakWinAnim(atk->client->ps.torsoAnim) && self->client->ps.blockPoints < BLOCKPOINTS_THIRTY)
			{
				//can't block super breaks when in critical fp.
				return 0;
			}
		}
		else
		{
			if (PM_SuperBreakWinAnim(atk->client->ps.torsoAnim) && self->client->ps.forcePower < BLOCKPOINTS_THIRTY)
			{
				//can't block super breaks when in critical fp.
				return 0;
			}
		}

		if (!WalkCheck(self)
			&& (!InFront(atk->client->ps.origin, self->client->ps.origin, self->client->ps.viewangles, -0.7f)
				|| PM_SaberInAttack(self->client->ps.saber_move)
				|| PM_SaberInStart(self->client->ps.saber_move)))
		{
			//can't block saber swings while running and hit from behind or in swing.
			if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self))
			{
				//bots just randomly parry to make up for them not intelligently parrying.
				if (self->client->ps.weapon == WP_SABER && self->client->ps.SaberActive() && !self->client->ps.
					saberInFlight)
				{
					return 1;
				}
				return 0;
			}
			return 0;
		}
	}

	if (g_SerenityJediEngineMode->integer == 2)
	{
		//check to see if we have the force to do this.
		if (self->client->ps.blockPoints < WP_SaberBlockCost(self, atk, point))
		{
			return 0;
		}
	}
	else
	{
		if (self->client->ps.forcePower < WP_SaberBlockCost(self, atk, point))
		{
			return 0;
		}
	}

	// allow for blocking behind our backs
	if (!InFront(point, self->client->ps.origin, self->client->ps.viewangles, -0.7f))
	{
		return 1;
	}

	if (!check_b_box_block)
	{
		//don't do the additional checkBBoxBlock checks.  As such, we're safe to saber block.
		return 1;
	}

	if (atk && atk->client && atk->client->ps.weapon == WP_SABER && PM_SuperBreakWinAnim(atk->client->ps.torsoAnim))
	{
		//never box block saberlock super break wins, it looks weird.
		return 0;
	}

	if (VectorCompare(point, vec3_origin))
	{
		//no hit position given, can't do blade movement check.
		return 0;
	}

	if (atk && atk->client && rSaberNum != -1 && rBladeNum != -1)
	{
		vec3_t saber_move_dir;
		vec3_t dir_to_body;
		vec3_t closest_body_point;
		vec3_t body_max;
		vec3_t body_min;
		//player attacker, if they are here they're using their saber to attack.
		//Check to make sure that we only block the blade if it is moving towards the player

		//create a line seqment thru the center of the player.
		VectorCopy(self->client->ps.origin, body_min);
		VectorCopy(self->client->ps.origin, body_max);

		body_max[2] += self->maxs[2];
		body_min[2] -= self->mins[2];

		//find dirToBody
		G_FindClosestPointOnLineSegment(body_min, body_max, point, closest_body_point);

		VectorSubtract(closest_body_point, point, dir_to_body);

		//find current saber movement direction of the attacker
		VectorSubtract(atk->client->ps.saber[rSaberNum].blade[rBladeNum].muzzlePoint,
			atk->client->ps.saber[rSaberNum].blade[rBladeNum].muzzlePointOld, saber_move_dir);

		if (DotProduct(dir_to_body, saber_move_dir) < 0)
		{
			//saber is moving away from defender
			return 0;
		}
	}

	return 1;
}

int WP_SaberMustDisruptorBlock(gentity_t* self, const gentity_t* atk, const qboolean check_b_box_block, vec3_t point, const int rSaberNum, const int rBladeNum)
{
	if (!self || !self->client || !atk)
	{
		return 0;
	}

	if (g_SerenityJediEngineMode->integer < 1)
	{
		return 0;
	}

	if (atk && atk->s.eType == ET_MISSILE
		&& (atk->s.weapon == WP_ROCKET_LAUNCHER ||
			atk->s.weapon == WP_THERMAL ||
			atk->s.weapon == WP_TRIP_MINE ||
			atk->s.weapon == WP_DET_PACK ||
			atk->methodOfDeath == MOD_CONC ||
			atk->methodOfDeath == MOD_CONC_ALT ||
			atk->methodOfDeath == MOD_REPEATER_ALT ||
			atk->methodOfDeath == MOD_FLECHETTE_ALT))
	{
		//can't block this stuff with a saber
		return 0;
	}

	if (!(self->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCK))
	{
		if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self))
		{
			//bots just randomly parry to make up for them not intelligently parrying.
			if (self->client->ps.weapon == WP_SABER && self->client->ps.SaberActive() && !self->client->ps.
				saberInFlight)
			{
				return 1;
			}
			return 0;
		}
		return 0;
	}

	if (PM_SaberInBrokenParry(self->client->ps.saber_move))
	{
		//you've been stunned from a broken parry
		return 0;
	}

	if (BG_InGrappleMove(self->client->ps.torsoAnim))
	{
		//you can't block while doing a melee move.
		return 0;
	}

	if (PM_KickMove(self->client->ps.saber_move))
	{
		return 0;
	}

	if (self->client->ps.weapon != WP_SABER
		|| self->client->ps.weapon == WP_NONE
		|| self->client->ps.weapon == WP_MELEE) //saber not here
	{
		return 0;
	}

	if (self->client->ps.weapon == WP_SABER && self->client->ps.saberInFlight)
	{
		//saber not currently in use or available, attempt to use our hands instead.
		return 0;
	}

	if (PM_InKnockDown(&self->client->ps))
	{
		//can't block while knocked down or getting up from knockdown.
		return 0;
	}

	if (atk && atk->client && atk->client->ps.weapon == WP_SABER)
	{
		//player is attacking with saber
		if ((atk->client->ps.saber_move == LS_A_LUNGE
			|| atk->client->ps.saber_move == LS_SPINATTACK
			|| atk->client->ps.saber_move == LS_SPINATTACK_DUAL)
			&& (self->client->ps.userInt3 & 1 << FLAG_FATIGUED || self->client->ps.userInt3 & 1 << FLAG_BLOCKDRAINED))
		{
			//saber attacker, we can't block lunge attacks while fatigued.
			return 0;
		}

		if (g_SerenityJediEngineMode->integer == 2)
		{
			if (PM_SuperBreakWinAnim(atk->client->ps.torsoAnim) && self->client->ps.blockPoints < BLOCKPOINTS_THIRTY)
			{
				//can't block super breaks when in critical fp.
				return 0;
			}
		}
		else
		{
			if (PM_SuperBreakWinAnim(atk->client->ps.torsoAnim) && self->client->ps.forcePower < BLOCKPOINTS_THIRTY)
			{
				//can't block super breaks when in critical fp.
				return 0;
			}
		}

		if (!WalkCheck(self)
			&& (!InFront(atk->client->ps.origin, self->client->ps.origin, self->client->ps.viewangles, -0.7f)
				|| PM_SaberInAttack(self->client->ps.saber_move)
				|| PM_SaberInStart(self->client->ps.saber_move)))
		{
			//can't block bolts while running and hit from behind or in swing.
			if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self))
			{
				//bots just randomly parry to make up for them not intelligently parrying.
				if (self->client->ps.weapon == WP_SABER && self->client->ps.SaberActive() && !self->client->ps.
					saberInFlight)
				{
					return 1;
				}
				return 0;
			}
			return 0;
		}
	}

	if (g_SerenityJediEngineMode->integer == 2)
	{
		//check to see if we have the force to do this.
		if (self->client->ps.blockPoints < WP_SaberBlockCost(self, atk, point))
		{
			if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self))
			{
				//bots just randomly parry to make up for them not intelligently parrying.
				if (self->client->ps.weapon == WP_SABER && self->client->ps.SaberActive() && !self->client->ps.
					saberInFlight)
				{
					return 1;
				}
				return 0;
			}
			return 0;
		}
	}
	else
	{
		if (self->client->ps.forcePower < WP_SaberBlockCost(self, atk, point))
		{
			if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self))
			{
				//bots just randomly parry to make up for them not intelligently parrying.
				if (self->client->ps.weapon == WP_SABER && self->client->ps.SaberActive() && !self->client->ps.
					saberInFlight)
				{
					return 1;
				}
				return 0;
			}
			return 0;
		}
	}

	// allow for blocking behind our backs
	if (!InFront(point, self->client->ps.origin, self->client->ps.viewangles, -0.7f))
	{
		return 1;
	}

	if (!check_b_box_block)
	{
		//don't do the additional checkBBoxBlock checks.  As such, we're safe to saber block.
		return 1;
	}

	if (atk && atk->client && atk->client->ps.weapon == WP_SABER && PM_SuperBreakWinAnim(atk->client->ps.torsoAnim))
	{
		//never box block saberlock super break wins, it looks weird.
		return 0;
	}

	if (VectorCompare(point, vec3_origin))
	{
		//no hit position given, can't do blade movement check.
		return 0;
	}

	if (atk && atk->client && rSaberNum != -1 && rBladeNum != -1)
	{
		vec3_t saber_move_dir;
		vec3_t dir_to_body;
		vec3_t closest_body_point;
		vec3_t body_max;
		vec3_t body_min;
		//player attacker, if they are here they're using their saber to attack.
		//Check to make sure that we only block the blade if it is moving towards the player

		//create a line seqment thru the center of the player.
		VectorCopy(self->client->ps.origin, body_min);
		VectorCopy(self->client->ps.origin, body_max);

		body_max[2] += self->maxs[2];
		body_min[2] -= self->mins[2];

		//find dirToBody
		G_FindClosestPointOnLineSegment(body_min, body_max, point, closest_body_point);

		VectorSubtract(closest_body_point, point, dir_to_body);

		//find current saber movement direction of the attacker
		VectorSubtract(atk->client->ps.saber[rSaberNum].blade[rBladeNum].muzzlePoint,
			atk->client->ps.saber[rSaberNum].blade[rBladeNum].muzzlePointOld, saber_move_dir);

		if (DotProduct(dir_to_body, saber_move_dir) < 0)
		{
			//saber is moving away from defender
			return 0;
		}
	}

	return 1;
}

int WP_SaberMustBoltBlockJKAMode(gentity_t* self, const gentity_t* atk, const qboolean check_b_box_block, vec3_t point, const int rSaberNum, const int rBladeNum)
{
	if (!self || !self->client || !atk)
	{
		return 0;
	}

	if (!g_saberAutoBlocking->integer)
	{
		return 0;
	}

	if (atk && atk->s.eType == ET_MISSILE
		&& (atk->s.weapon == WP_ROCKET_LAUNCHER ||
			atk->s.weapon == WP_THERMAL ||
			atk->s.weapon == WP_TRIP_MINE ||
			atk->s.weapon == WP_DET_PACK ||
			atk->methodOfDeath == MOD_CONC ||
			atk->methodOfDeath == MOD_CONC_ALT ||
			atk->methodOfDeath == MOD_REPEATER_ALT ||
			atk->methodOfDeath == MOD_FLECHETTE_ALT))
	{
		//can't block this stuff with a saber
		return 0;
	}

	if (PM_SaberInBrokenParry(self->client->ps.saber_move))
	{
		//you've been stunned from a broken parry
		return 0;
	}

	if (BG_InGrappleMove(self->client->ps.torsoAnim))
	{
		//you can't block while doing a melee move.
		return 0;
	}

	if (PM_KickMove(self->client->ps.saber_move))
	{
		return 0;
	}

	if (self->client->ps.weapon != WP_SABER
		|| self->client->ps.weapon == WP_NONE
		|| self->client->ps.weapon == WP_MELEE) //saber not here
	{
		return 0;
	}

	if (self->client->ps.weapon == WP_SABER && self->client->ps.saberInFlight)
	{
		//saber not currently in use or available, attempt to use our hands instead.
		return 0;
	}

	if (self->client->ps.weapon == WP_SABER && !self->client->ps.SaberActive())
	{
		//saber not currently in use or available, attempt to use our hands instead.
		return 0;
	}

	if (SaberAttacking(self))
	{
		if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self))
		{
			//bots just randomly parry to make up for them not intelligently parrying.
			if (self->client->ps.weapon == WP_SABER && self->client->ps.SaberActive() && !self->client->ps.
				saberInFlight)
			{
				return 1;
			}
			return 0;
		}
		return 0;
	}

	if ((self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self)) && !Q_irand(0, 3))
	{
		//bots just randomly parry to make up for them not intelligently parrying.
		if (self->client->ps.weapon == WP_SABER && self->client->ps.SaberActive() && !self->client->ps.saberInFlight)
		{
			return 1;
		}
		return 0;
	}

	if (self->client->ps.weaponstate == WEAPON_RAISING)
	{
		if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self))
		{
			//bots just randomly parry to make up for them not intelligently parrying.
			if (self->client->ps.weapon == WP_SABER && self->client->ps.SaberActive() && !self->client->ps.
				saberInFlight)
			{
				return 1;
			}
			return 0;
		}
		return 0;
	}

	if (!WalkCheck(self))
	{
		//can't block while running.
		return 0;
	}

	if (PM_InKnockDown(&self->client->ps))
	{
		//can't block while knocked down or getting up from knockdown.
		return 0;
	}

	if (atk && atk->client && atk->client->ps.weapon == WP_SABER)
	{
		//player is attacking with saber
		if ((atk->client->ps.saber_move == LS_A_LUNGE
			|| atk->client->ps.saber_move == LS_SPINATTACK
			|| atk->client->ps.saber_move == LS_SPINATTACK_DUAL)
			&& (self->client->ps.userInt3 & 1 << FLAG_FATIGUED || self->client->ps.userInt3 & 1 << FLAG_BLOCKDRAINED))
		{
			//saber attacker, we can't block lunge attacks while fatigued.
			return 0;
		}

		if (PM_SuperBreakWinAnim(atk->client->ps.torsoAnim) && self->client->ps.forcePower < BLOCKPOINTS_THIRTY)
		{
			//can't block super breaks when in critical fp.
			return 0;
		}

		if (!InFront(atk->client->ps.origin, self->client->ps.origin, self->client->ps.viewangles, -0.7f)
			|| PM_SaberInAttack(self->client->ps.saber_move)
			|| PM_SaberInStart(self->client->ps.saber_move))
		{
			//can't block saber swings while running and hit from behind or in swing.
			if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self))
			{
				//bots just randomly parry to make up for them not intelligently parrying.
				if (self->client->ps.weapon == WP_SABER && self->client->ps.SaberActive() && !self->client->ps.
					saberInFlight)
				{
					return 1;
				}
				return 0;
			}
			return 0;
		}
	}

	if (self->client->ps.forcePower < WP_SaberBlockCost(self, atk, point))
	{
		return 0;
	}

	// allow for blocking behind our backs
	if (!InFront(point, self->client->ps.origin, self->client->ps.viewangles, -0.7f))
	{
		return 1;
	}

	if (!check_b_box_block)
	{
		//don't do the additional checkBBoxBlock checks.  As such, we're safe to saber block.
		return 1;
	}

	if (atk && atk->client && atk->client->ps.weapon == WP_SABER && PM_SuperBreakWinAnim(atk->client->ps.torsoAnim))
	{
		//never box block saberlock super break wins, it looks weird.
		return 0;
	}

	if (VectorCompare(point, vec3_origin))
	{
		//no hit position given, can't do blade movement check.
		return 0;
	}

	if (atk && atk->client && rSaberNum != -1 && rBladeNum != -1)
	{
		vec3_t saber_move_dir;
		vec3_t dir_to_body;
		vec3_t closest_body_point;
		vec3_t body_max;
		vec3_t body_min;
		//player attacker, if they are here they're using their saber to attack.
		//Check to make sure that we only block the blade if it is moving towards the player

		//create a line seqment thru the center of the player.
		VectorCopy(self->client->ps.origin, body_min);
		VectorCopy(self->client->ps.origin, body_max);

		body_max[2] += self->maxs[2];
		body_min[2] -= self->mins[2];

		//find dirToBody
		G_FindClosestPointOnLineSegment(body_min, body_max, point, closest_body_point);

		VectorSubtract(closest_body_point, point, dir_to_body);

		//find current saber movement direction of the attacker
		VectorSubtract(atk->client->ps.saber[rSaberNum].blade[rBladeNum].muzzlePoint,
			atk->client->ps.saber[rSaberNum].blade[rBladeNum].muzzlePointOld, saber_move_dir);

		if (DotProduct(dir_to_body, saber_move_dir) < 0)
		{
			//saber is moving away from defender
			return 0;
		}
	}

	return 1;
}

qboolean wp_saber_block_check_random(gentity_t* self, vec3_t hitloc)
{
	vec3_t diff, fwdangles = { 0, 0, 0 }, right;
	const qboolean in_front = InFront(hitloc, self->client->ps.origin, self->client->ps.viewangles, -0.7f);

	VectorSubtract(hitloc, self->client->renderInfo.eyePoint, diff);
	diff[2] = 0;
	VectorNormalize(diff);
	fwdangles[1] = self->client->ps.viewangles[1];
	// Ultimately we might care if the shot was ahead or behind, but for now, just quadrant is fine.
	AngleVectors(fwdangles, nullptr, right, nullptr);
	const float rightdot = DotProduct(right, diff);
	const float zdiff = hitloc[2] - self->client->renderInfo.eyePoint[2];

	if (self->client->ps.weaponstate == WEAPON_DROPPING ||
		self->client->ps.weaponstate == WEAPON_RAISING)
	{
		//don't block while changing weapons
		return qfalse;
	}
	if (PM_SuperBreakLoseAnim(self->client->ps.torsoAnim)
		|| PM_SuperBreakWinAnim(self->client->ps.torsoAnim))
	{
		return qfalse;
	}

	if (PM_SaberInMassiveBounce(self->client->ps.torsoAnim) || PM_SaberInBashedAnim(self->client->ps.torsoAnim)
		|| PM_InKnockDown(&self->client->ps))
	{
		return qfalse;
	}

	if (!in_front && self->client->ps.forcePowerLevel[FP_SABER_DEFENSE] >= FORCE_LEVEL_1)
	{
		switch (self->client->ps.saber_anim_level)
		{
		case SS_STAFF:
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_P7_S1_B_, SETANIM_AFLAG_BLOCKPACE);
			break;
		case SS_DUAL:
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_P6_S1_B_, SETANIM_AFLAG_BLOCKPACE);
			break;
		default:
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_P1_S1_B_, SETANIM_AFLAG_BLOCKPACE);
			break;
		}
		self->client->ps.weaponTime = Q_irand(300, 600);
	}
	else if (zdiff > -5) //0 )//40 )
	{
		if (rightdot > 0.3)
		{
			self->client->ps.saberBlocked = BLOCKED_UPPER_RIGHT;
		}
		else if (rightdot < -0.3)
		{
			self->client->ps.saberBlocked = BLOCKED_UPPER_LEFT;
		}
		else
		{
			self->client->ps.saberBlocked = BLOCKED_TOP;
		}
	}
	else if (zdiff > -22)
	{
		if (zdiff < -10)
		{
			//NPC should duck, but NPC should never get here
		}
		if (rightdot > 0.1)
		{
			self->client->ps.saberBlocked = BLOCKED_UPPER_RIGHT;
		}
		else if (rightdot < -0.1)
		{
			self->client->ps.saberBlocked = BLOCKED_UPPER_LEFT;
		}
		else
		{
			self->client->ps.saberBlocked = BLOCKED_TOP;
		}
	}
	else
	{
		if (rightdot >= 0)
		{
			self->client->ps.saberBlocked = BLOCKED_LOWER_RIGHT;
		}
		else
		{
			self->client->ps.saberBlocked = BLOCKED_LOWER_LEFT;
		}
	}

	if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self) && self->client->ps.saberBlocked != BLOCKED_NONE)
	{
		const int parry_re_calc_time = jedi_re_calc_parry_time(self, EVASION_PARRY);
		if (self->client->ps.forcePowerDebounce[FP_SABER_DEFENSE] < level.time + parry_re_calc_time)
		{
			self->client->ps.forcePowerDebounce[FP_SABER_DEFENSE] = level.time + parry_re_calc_time;
		}
	}

	self->client->ps.userInt3 &= ~(1 << FLAG_PREBLOCK);
	return qtrue;
}

qboolean WP_SaberBlockNonRandom(gentity_t* self, vec3_t hitloc, const qboolean missileBlock)
{
	vec3_t diff, fwdangles = { 0, 0, 0 }, right;
	const qboolean in_front = InFront(hitloc, self->client->ps.origin, self->client->ps.viewangles, -0.7f);

	VectorSubtract(hitloc, self->client->renderInfo.eyePoint, diff);
	diff[2] = 0;
	VectorNormalize(diff);
	fwdangles[1] = self->client->ps.viewangles[1];
	// Ultimately we might care if the shot was ahead or behind, but for now, just quadrant is fine.
	AngleVectors(fwdangles, nullptr, right, nullptr);
	const float rightdot = DotProduct(right, diff);
	const float zdiff = hitloc[2] - self->client->renderInfo.eyePoint[2];

	if (self->client->ps.weaponstate == WEAPON_DROPPING ||
		self->client->ps.weaponstate == WEAPON_RAISING)
	{
		//don't block
		if (self->health > 0
			&& self->NPC
			&& self->client->ps.weapon == WP_SABER)
		{
			return qtrue;
		}
		return qfalse;
	}

	if (PM_SaberInAttack(self->client->ps.saber_move) ||
		PM_SuperBreakLoseAnim(self->client->ps.torsoAnim) ||
		PM_SuperBreakWinAnim(self->client->ps.torsoAnim) ||
		PM_SaberInBrokenParry(self->client->ps.saber_move) ||
		PM_SaberInKnockaway(self->client->ps.saber_move) ||
		PM_InRoll(&self->client->ps) ||
		BG_InKnockDown(self->client->ps.legsAnim) ||
		BG_InKnockDown(self->client->ps.torsoAnim) ||
		PM_InKnockDown(&self->client->ps))
	{
		return qfalse;
	}

	if (PM_SaberInMassiveBounce(self->client->ps.torsoAnim) || PM_SaberInBashedAnim(self->client->ps.torsoAnim))
	{
		return qfalse;
	}

	if (g_SerenityJediEngineMode->integer == 1 && self->client->ps.forcePower <= BLOCKPOINTS_DANGER
		|| g_SerenityJediEngineMode->integer == 2 && self->client->ps.blockPoints <= BLOCKPOINTS_FAIL)
	{
		return qfalse;
	}

	if (!in_front && self->client->ps.forcePowerLevel[FP_SABER_DEFENSE] >= FORCE_LEVEL_1)
	{
		switch (self->client->ps.saber_anim_level)
		{
		case SS_STAFF:
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_P7_S1_B_, SETANIM_AFLAG_BLOCKPACE);
			break;
		case SS_DUAL:
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_P6_S1_B_, SETANIM_AFLAG_BLOCKPACE);
			break;
		default:
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_P1_S1_B_, SETANIM_AFLAG_BLOCKPACE);
			break;
		}
		self->client->ps.weaponTime = Q_irand(300, 600);
	}
	else if (zdiff > -5)
	{
		if (rightdot > 0.3)
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P7_S7_TR, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P6_S6_TR, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P1_S1_TR, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			if (self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self))
			{
				self->client->ps.weaponTime = Q_irand(400, 800);
			}
			else
			{
				self->client->ps.weaponTime = self->client->ps.torsoAnimTimer + Q_irand(500, 1000);
			}
		}
		else if (rightdot < -0.3)
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P7_S7_TL, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P6_S6_TL, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P1_S1_TL, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			if (self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self))
			{
				self->client->ps.weaponTime = Q_irand(400, 800);
			}
			else
			{
				self->client->ps.weaponTime = self->client->ps.torsoAnimTimer + Q_irand(500, 1000);
			}
		}
		else
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P7_S7_T_, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P6_S6_T_, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P1_S1_T_, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			if (self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self))
			{
				self->client->ps.weaponTime = Q_irand(400, 800);
			}
			else
			{
				self->client->ps.weaponTime = self->client->ps.torsoAnimTimer + Q_irand(500, 1000);
			}
		}
	}
	else if (zdiff > -20)
	{
		if (zdiff < -10)
		{
			//hmm, pretty low, but not low enough to use the low block, so we need to duck
		}
		if (rightdot > 0.1)
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P7_S7_TR, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P6_S6_TR, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P1_S1_TR, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			if (self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self))
			{
				self->client->ps.weaponTime = Q_irand(400, 800);
			}
			else
			{
				self->client->ps.weaponTime = self->client->ps.torsoAnimTimer + Q_irand(500, 1000);
			}
		}
		else if (rightdot < -0.1)
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P7_S7_TL, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P6_S6_TL, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P1_S1_TL, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			if (self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self))
			{
				self->client->ps.weaponTime = Q_irand(400, 800);
			}
			else
			{
				self->client->ps.weaponTime = self->client->ps.torsoAnimTimer + Q_irand(500, 1000);
			}
		}
		else
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P7_S7_T_, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P6_S6_T_, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P1_S1_T_, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			if (self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self))
			{
				self->client->ps.weaponTime = Q_irand(400, 800);
			}
			else
			{
				self->client->ps.weaponTime = self->client->ps.torsoAnimTimer + Q_irand(500, 1000);
			}
		}
	}
	else
	{
		if (rightdot >= 0)
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P7_S7_BR, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P6_S6_BR, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P1_S1_BR, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			if (self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self))
			{
				self->client->ps.weaponTime = Q_irand(400, 800);
			}
			else
			{
				self->client->ps.weaponTime = self->client->ps.torsoAnimTimer + Q_irand(500, 1000);
			}
		}
		else
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P7_S7_BL, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P6_S6_BL, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P1_S1_BL, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			if (self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self))
			{
				self->client->ps.weaponTime = Q_irand(400, 800);
			}
			else
			{
				self->client->ps.weaponTime = self->client->ps.torsoAnimTimer + Q_irand(500, 1000);
			}
		}
	}

#ifndef FINAL_BUILD
	if (d_saberCombat->integer || d_combatinfo->integer || g_DebugSaberCombat->integer)
	{
		if (!self->s.number)
		{
			gi.Printf("EyeZ: %4.2f  HitZ: %4.2f  zdiff: %4.2f  rdot: %4.2f\n", self->client->renderInfo.eyePoint[2], hitloc[2], zdiff, rightdot);
			switch (self->client->ps.saberBlocked)
			{
			case BLOCKED_TOP:
			case BLOCKED_TOP_MD:
				gi.Printf("BLOCKED_TOP\n");
				break;
			case BLOCKED_UPPER_RIGHT:
				gi.Printf("BLOCKED_UPPER_RIGHT\n");
				break;
			case BLOCKED_UPPER_LEFT:
				gi.Printf("BLOCKED_UPPER_LEFT\n");
				break;
			case BLOCKED_LOWER_RIGHT:
				gi.Printf("BLOCKED_LOWER_RIGHT\n");
				break;
			case BLOCKED_LOWER_LEFT:
				gi.Printf("BLOCKED_LOWER_LEFT\n");
				break;
			case BLOCKED_BACK:
				gi.Printf("BLOCKED_BACK\n");
				break;
			default:
				break;
			}
		}
	}
#endif

	if (missileBlock)
	{
		self->client->ps.saberBlocked = WP_MissileBlockForBlock(self->client->ps.saberBlocked);
		self->client->ps.weaponTime = Q_irand(300, 600);
	}

	if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self) && self->client->ps.saberBlocked != BLOCKED_NONE)
	{
		const int parry_re_calc_time = jedi_re_calc_parry_time(self, EVASION_PARRY);
		if (self->client->ps.forcePowerDebounce[FP_SABER_DEFENSE] < level.time + parry_re_calc_time)
		{
			self->client->ps.forcePowerDebounce[FP_SABER_DEFENSE] = level.time + parry_re_calc_time;
		}
	}

	self->client->ps.userInt3 &= ~(1 << FLAG_PREBLOCK);
	return qtrue;
}

qboolean WP_SaberMBlockDirection(gentity_t* self, vec3_t hitloc, const qboolean missileBlock)
{
	vec3_t diff, fwdangles = { 0, 0, 0 }, right;
	const qboolean in_front = InFront(hitloc, self->client->ps.origin, self->client->ps.viewangles, -0.7f);

	VectorSubtract(hitloc, self->client->renderInfo.eyePoint, diff);
	diff[2] = 0;
	VectorNormalize(diff);
	fwdangles[1] = self->client->ps.viewangles[1];
	// Ultimately we might care if the shot was ahead or behind, but for now, just quadrant is fine.
	AngleVectors(fwdangles, nullptr, right, nullptr);
	const float rightdot = DotProduct(right, diff);
	const float zdiff = hitloc[2] - self->client->renderInfo.eyePoint[2];

	if (self->client->ps.weaponstate == WEAPON_DROPPING ||
		self->client->ps.weaponstate == WEAPON_RAISING)
	{
		//don't block
		if (self->health > 0
			&& self->NPC
			&& self->client->ps.weapon == WP_SABER)
		{
			return qtrue;
		}
		return qfalse;
	}

	if (PM_SaberInAttack(self->client->ps.saber_move) ||
		PM_SuperBreakLoseAnim(self->client->ps.torsoAnim) ||
		PM_SuperBreakWinAnim(self->client->ps.torsoAnim) ||
		PM_SaberInBrokenParry(self->client->ps.saber_move) ||
		PM_SaberInKnockaway(self->client->ps.saber_move) ||
		PM_InRoll(&self->client->ps) ||
		BG_InKnockDown(self->client->ps.legsAnim) ||
		BG_InKnockDown(self->client->ps.torsoAnim) ||
		PM_InKnockDown(&self->client->ps))
	{
		return qfalse;
	}

	if (PM_SaberInMassiveBounce(self->client->ps.torsoAnim) || PM_SaberInBashedAnim(self->client->ps.torsoAnim))
	{
		return qfalse;
	}

	if (g_SerenityJediEngineMode->integer == 1 && self->client->ps.forcePower <= BLOCKPOINTS_DANGER
		|| g_SerenityJediEngineMode->integer == 2 && self->client->ps.blockPoints <= BLOCKPOINTS_FAIL)
	{
		return qfalse;
	}

	if (!in_front && self->client->ps.forcePowerLevel[FP_SABER_DEFENSE] >= FORCE_LEVEL_1)
	{
		switch (self->client->ps.saber_anim_level)
		{
			//BACK
		case SS_STAFF:
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_P7_S1_B_, SETANIM_AFLAG_BLOCKPACE);
			break;
		case SS_DUAL:
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_P6_S1_B_, SETANIM_AFLAG_BLOCKPACE);
			break;
		default:
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_P1_S1_B_, SETANIM_AFLAG_BLOCKPACE);
			break;
		}
		self->client->ps.weaponTime = Q_irand(300, 600);
	}
	else if (zdiff > -5)
	{
		if (rightdot > 0.3)
		{
			//RIGHT
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_B7_TR___, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_B6_TR___, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_K1_S1_TR_MD, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
		else if (rightdot < -0.3)
		{
			//LEFT
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_B7_TL___, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_B6_TL___, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_K1_S1_TL_MD, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
		else
		{
			switch (self->client->ps.saber_anim_level)
			{
				//TOP
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_B7_T____, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_B6_T____, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_B1_T____, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
	}
	else if (zdiff > -22)
	{
		if (zdiff < -10)
		{
			//hmm, pretty low, but not low enough to use the low block
		}
		if (rightdot > 0.1)
		{
			//RIGHT
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_B7_TR___, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_B6_TR___, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_K1_S1_TR_MD, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
		else if (rightdot < -0.1)
		{
			//LEFT
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_B7_TL___, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_B6_TL___, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_K1_S1_TL_MD, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
		else
		{
			switch (self->client->ps.saber_anim_level)
			{
				//TOP
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_B7_T____, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_B6_T____, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_B1_T____, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
	}
	else
	{
		if (rightdot >= 0)
		{
			switch (self->client->ps.saber_anim_level)
			{
				//BOTTOM RIGHT
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_B7_BR___, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_B6_BR___, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_B1_BR___, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
		else
		{
			switch (self->client->ps.saber_anim_level)
			{
				//BOTTOM LEFT
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_B7_BL___, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_B6_BL___, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_B1_BL___, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
	}

	if (missileBlock)
	{
		self->client->ps.saberBlocked = WP_MissileBlockForBlock(self->client->ps.saberBlocked);
		self->client->ps.weaponTime = Q_irand(300, 600);
	}

	if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self) && self->client->ps.saberBlocked != BLOCKED_NONE)
	{
		const int parry_re_calc_time = jedi_re_calc_parry_time(self, EVASION_PARRY);
		if (self->client->ps.forcePowerDebounce[FP_SABER_DEFENSE] < level.time + parry_re_calc_time)
		{
			self->client->ps.forcePowerDebounce[FP_SABER_DEFENSE] = level.time + parry_re_calc_time;
		}
	}

	self->client->ps.userInt3 &= ~(1 << FLAG_PREBLOCK);
	return qtrue;
}

qboolean WP_SaberMBlockDirectionNPC(gentity_t* self, vec3_t hitloc, const qboolean missileBlock)
{
	vec3_t diff, fwdangles = { 0, 0, 0 }, right;
	const qboolean in_front = InFront(hitloc, self->client->ps.origin, self->client->ps.viewangles, -0.7f);

	VectorSubtract(hitloc, self->client->renderInfo.eyePoint, diff);
	diff[2] = 0;
	VectorNormalize(diff);
	fwdangles[1] = self->client->ps.viewangles[1];
	// Ultimately we might care if the shot was ahead or behind, but for now, just quadrant is fine.
	AngleVectors(fwdangles, nullptr, right, nullptr);
	const float rightdot = DotProduct(right, diff);
	const float zdiff = hitloc[2] - self->client->renderInfo.eyePoint[2];

	if (self->client->ps.weaponstate == WEAPON_DROPPING ||
		self->client->ps.weaponstate == WEAPON_RAISING)
	{
		//don't block
		if (self->health > 0
			&& self->NPC
			&& self->client->ps.weapon == WP_SABER)
		{
			return qtrue;
		}
		return qfalse;
	}

	if (PM_SaberInAttack(self->client->ps.saber_move) ||
		PM_SuperBreakLoseAnim(self->client->ps.torsoAnim) ||
		PM_SuperBreakWinAnim(self->client->ps.torsoAnim) ||
		PM_SaberInBrokenParry(self->client->ps.saber_move) ||
		PM_SaberInKnockaway(self->client->ps.saber_move) ||
		PM_InRoll(&self->client->ps) ||
		BG_InKnockDown(self->client->ps.legsAnim) ||
		BG_InKnockDown(self->client->ps.torsoAnim) ||
		PM_InKnockDown(&self->client->ps))
	{
		return qfalse;
	}

	if (PM_SaberInMassiveBounce(self->client->ps.torsoAnim) || PM_SaberInBashedAnim(self->client->ps.torsoAnim))
	{
		return qfalse;
	}

	if (g_SerenityJediEngineMode->integer == 1 && self->client->ps.forcePower <= BLOCKPOINTS_DANGER
		|| g_SerenityJediEngineMode->integer == 2 && self->client->ps.blockPoints <= BLOCKPOINTS_FAIL)
	{
		return qfalse;
	}

	if (!in_front && self->client->ps.forcePowerLevel[FP_SABER_DEFENSE] >= FORCE_LEVEL_1)
	{
		switch (self->client->ps.saber_anim_level)
		{
			//BACK
		case SS_STAFF:
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_P7_S1_B_, SETANIM_AFLAG_BLOCKPACE);
			break;
		case SS_DUAL:
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_P6_S1_B_, SETANIM_AFLAG_BLOCKPACE);
			break;
		default:
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_P1_S1_B_, SETANIM_AFLAG_BLOCKPACE);
			break;
		}
		self->client->ps.weaponTime = Q_irand(300, 600);
	}
	else if (zdiff > -5)
	{
		if (rightdot > 0.3)
		{
			//RIGHT
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_B7_TR___, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_B6_TR___, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_K1_S1_TR_MD, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
		else if (rightdot < -0.3)
		{
			//LEFT
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_B7_TL___, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_B6_TL___, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_K1_S1_TL_MD, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
		else
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P7_S7_T__MD, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P6_S6_T__MD, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P1_S1_T__MD, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
	}
	else if (zdiff > -22)
	{
		if (zdiff < -10)
		{
			//hmm, pretty low, but not low enough to use the low block
		}
		if (rightdot > 0.1)
		{
			//RIGHT
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_B7_TR___, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_B6_TR___, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_K1_S1_TR_MD, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
		else if (rightdot < -0.1)
		{
			//LEFT
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_B7_TL___, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_B6_TL___, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_K1_S1_TL_MD, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
		else
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P7_S7_T__MD, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P6_S6_T__MD, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P1_S1_T__MD, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
	}
	else
	{
		if (rightdot >= 0)
		{
			switch (self->client->ps.saber_anim_level)
			{
				//BOTTOM RIGHT
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_B7_BR___, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_B6_BR___, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_B1_BR___, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
		else
		{
			switch (self->client->ps.saber_anim_level)
			{
				//BOTTOM LEFT
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_B7_BL___, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_B6_BL___, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_B1_BL___, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
	}

	if (missileBlock)
	{
		self->client->ps.saberBlocked = WP_MissileBlockForBlock(self->client->ps.saberBlocked);
		self->client->ps.weaponTime = Q_irand(300, 600);
	}

	if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self) && self->client->ps.saberBlocked != BLOCKED_NONE)
	{
		const int parry_re_calc_time = jedi_re_calc_parry_time(self, EVASION_PARRY);
		if (self->client->ps.forcePowerDebounce[FP_SABER_DEFENSE] < level.time + parry_re_calc_time)
		{
			self->client->ps.forcePowerDebounce[FP_SABER_DEFENSE] = level.time + parry_re_calc_time;
		}
	}

	self->client->ps.userInt3 &= ~(1 << FLAG_PREBLOCK);
	return qtrue;
}

qboolean WP_SaberFatigueDirection(gentity_t* self, vec3_t hitloc, const qboolean missileBlock)
{
	vec3_t diff, fwdangles = { 0, 0, 0 }, right;
	const qboolean in_front = InFront(hitloc, self->client->ps.origin, self->client->ps.viewangles, -0.7f);

	VectorSubtract(hitloc, self->client->renderInfo.eyePoint, diff);
	diff[2] = 0;
	VectorNormalize(diff);
	fwdangles[1] = self->client->ps.viewangles[1];
	// Ultimately we might care if the shot was ahead or behind, but for now, just quadrant is fine.
	AngleVectors(fwdangles, nullptr, right, nullptr);
	const float rightdot = DotProduct(right, diff);
	const float zdiff = hitloc[2] - self->client->renderInfo.eyePoint[2];

	if (self->client->ps.weaponstate == WEAPON_DROPPING ||
		self->client->ps.weaponstate == WEAPON_RAISING)
	{
		//don't block
		if (self->health > 0
			&& self->NPC
			&& self->client->ps.weapon == WP_SABER)
		{
			return qtrue;
		}
		return qfalse;
	}

	if (PM_SaberInAttack(self->client->ps.saber_move) ||
		PM_SuperBreakLoseAnim(self->client->ps.torsoAnim) ||
		PM_SuperBreakWinAnim(self->client->ps.torsoAnim) ||
		PM_SaberInBrokenParry(self->client->ps.saber_move) ||
		PM_SaberInKnockaway(self->client->ps.saber_move) ||
		PM_InRoll(&self->client->ps) ||
		BG_InKnockDown(self->client->ps.legsAnim) ||
		BG_InKnockDown(self->client->ps.torsoAnim) ||
		PM_InKnockDown(&self->client->ps))
	{
		return qfalse;
	}

	if (PM_SaberInMassiveBounce(self->client->ps.torsoAnim) || PM_SaberInBashedAnim(self->client->ps.torsoAnim))
	{
		return qfalse;
	}

	if (g_SerenityJediEngineMode->integer == 1 && self->client->ps.forcePower <= BLOCKPOINTS_DANGER
		|| g_SerenityJediEngineMode->integer == 2 && self->client->ps.blockPoints <= BLOCKPOINTS_FAIL)
	{
		return qfalse;
	}

	if (!in_front && self->client->ps.forcePowerLevel[FP_SABER_DEFENSE] >= FORCE_LEVEL_1)
	{
		switch (self->client->ps.saber_anim_level)
		{
		case SS_STAFF:
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_P7_S1_B_, SETANIM_AFLAG_BLOCKPACE);
			break;
		case SS_DUAL:
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_P6_S1_B_, SETANIM_AFLAG_BLOCKPACE);
			break;
		default:
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_P1_S1_B_, SETANIM_AFLAG_BLOCKPACE);
			break;
		}
		self->client->ps.weaponTime = Q_irand(300, 600);
	}
	else if (zdiff > -5)
	{
		if (rightdot > 0.3)
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_K7_S7_TR, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_K6_S6_TR, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_K1_S1_TR, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
		else if (rightdot < -0.3)
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_K7_S7_TL, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_K6_S6_TL, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_K1_S1_TL, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
		else
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_K7_S7_T_, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_K6_S6_T_, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_K1_S1_T_, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
	}
	else if (zdiff > -22)
	{
		if (zdiff < -10)
		{
			//hmm, pretty low, but not low enough to use the low block
		}
		if (rightdot > 0.1)
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_K7_S7_TR, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_K6_S6_TR, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_K1_S1_TR, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
		else if (rightdot < -0.1)
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_K7_S7_TL, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_K6_S6_TL, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_K1_S1_TL, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
		else
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_K7_S7_T_, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_K6_S6_T_, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_K1_S1_T_, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
	}
	else
	{
		if (rightdot >= 0)
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_K7_S7_BR, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_K6_S6_BR, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_K1_S1_BR, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
		else
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_K7_S7_BL, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_K6_S6_BL, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_K1_S1_BL, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
	}

	if (missileBlock)
	{
		self->client->ps.saberBlocked = WP_MissileBlockForBlock(self->client->ps.saberBlocked);
		self->client->ps.weaponTime = Q_irand(300, 600);
	}

	if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self) && self->client->ps.saberBlocked != BLOCKED_NONE)
	{
		const int parry_re_calc_time = jedi_re_calc_parry_time(self, EVASION_PARRY);
		if (self->client->ps.forcePowerDebounce[FP_SABER_DEFENSE] < level.time + parry_re_calc_time)
		{
			self->client->ps.forcePowerDebounce[FP_SABER_DEFENSE] = level.time + parry_re_calc_time;
		}
	}

	self->client->ps.userInt3 &= ~(1 << FLAG_PREBLOCK);
	return qtrue;
}

qboolean WP_SaberBounceDirection(gentity_t* self, vec3_t hitloc, const qboolean missileBlock)
{
	vec3_t diff, fwdangles = { 0, 0, 0 }, right;
	const qboolean in_front = InFront(hitloc, self->client->ps.origin, self->client->ps.viewangles, -0.7f);

	VectorSubtract(hitloc, self->client->renderInfo.eyePoint, diff);
	diff[2] = 0;
	VectorNormalize(diff);
	fwdangles[1] = self->client->ps.viewangles[1];
	// Ultimately we might care if the shot was ahead or behind, but for now, just quadrant is fine.
	AngleVectors(fwdangles, nullptr, right, nullptr);
	const float rightdot = DotProduct(right, diff);
	const float zdiff = hitloc[2] - self->client->renderInfo.eyePoint[2];

	if (self->client->ps.weaponstate == WEAPON_DROPPING ||
		self->client->ps.weaponstate == WEAPON_RAISING)
	{
		//don't block
		if (self->health > 0
			&& self->NPC
			&& self->client->ps.weapon == WP_SABER)
		{
			return qtrue;
		}
		return qfalse;
	}

	if (PM_SaberInAttack(self->client->ps.saber_move) ||
		PM_SuperBreakLoseAnim(self->client->ps.torsoAnim) ||
		PM_SuperBreakWinAnim(self->client->ps.torsoAnim) ||
		PM_SaberInBrokenParry(self->client->ps.saber_move) ||
		PM_SaberInKnockaway(self->client->ps.saber_move) ||
		PM_InRoll(&self->client->ps) ||
		BG_InKnockDown(self->client->ps.legsAnim) ||
		BG_InKnockDown(self->client->ps.torsoAnim) ||
		PM_InKnockDown(&self->client->ps))
	{
		return qfalse;
	}

	if (PM_SaberInMassiveBounce(self->client->ps.torsoAnim) || PM_SaberInBashedAnim(self->client->ps.torsoAnim))
	{
		return qfalse;
	}

	if (g_SerenityJediEngineMode->integer == 1 && self->client->ps.forcePower <= BLOCKPOINTS_DANGER
		|| g_SerenityJediEngineMode->integer == 2 && self->client->ps.blockPoints <= BLOCKPOINTS_FAIL)
	{
		return qfalse;
	}

	if (!in_front && self->client->ps.forcePowerLevel[FP_SABER_DEFENSE] >= FORCE_LEVEL_1)
	{
		switch (self->client->ps.saber_anim_level)
		{
		case SS_STAFF:
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_P7_S1_B_, SETANIM_AFLAG_BLOCKPACE);
			break;
		case SS_DUAL:
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_P6_S1_B_, SETANIM_AFLAG_BLOCKPACE);
			break;
		default:
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_P1_S1_B_, SETANIM_AFLAG_BLOCKPACE);
			break;
		}
		self->client->ps.weaponTime = Q_irand(300, 600);
	}
	else if (zdiff > -5)
	{
		if (rightdot > 0.3)
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V7_TR_S7, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V6_TR_S6, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V1_TR_S1, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
		else if (rightdot < -0.3)
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V1_TL_S1, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V1_TL_S1, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V1_TL_S1, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
		else
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V7_T__S7, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V6_T__S6, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V1_T__S1, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
	}
	else if (zdiff > -22)
	{
		if (zdiff < -10)
		{
			//hmm, pretty low, but not low enough to use the low block
		}
		if (rightdot > 0.1)
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V7_TR_S7, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V6_TR_S6, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V1_TR_S1, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
		else if (rightdot < -0.1)
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V1_TL_S1, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V1_TL_S1, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V1_TL_S1, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
		else
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V7_T__S7, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V6_T__S6, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V1_T__S1, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
	}
	else
	{
		if (rightdot >= 0)
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V7_BR_S7, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V6_BR_S6, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V1_BR_S1, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
		else
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V7_BL_S7, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V6_BL_S6, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V1_BL_S1, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
	}

	if (missileBlock)
	{
		self->client->ps.saberBlocked = WP_MissileBlockForBlock(self->client->ps.saberBlocked);
		self->client->ps.weaponTime = Q_irand(300, 600);
	}

	if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self) && self->client->ps.saberBlocked != BLOCKED_NONE)
	{
		const int parryReCalcTime = jedi_re_calc_parry_time(self, EVASION_PARRY);
		if (self->client->ps.forcePowerDebounce[FP_SABER_DEFENSE] < level.time + parryReCalcTime)
		{
			self->client->ps.forcePowerDebounce[FP_SABER_DEFENSE] = level.time + parryReCalcTime;
		}
	}

	self->client->ps.userInt3 &= ~(1 << FLAG_PREBLOCK);
	return qtrue;
}

qboolean WP_SaberBlockNonRandom_MD(gentity_t* self, vec3_t hitloc, const qboolean missileBlock)
{
	vec3_t diff, fwdangles = { 0, 0, 0 }, right;
	const qboolean in_front = InFront(hitloc, self->client->ps.origin, self->client->ps.viewangles, -0.7f);

	VectorSubtract(hitloc, self->client->renderInfo.eyePoint, diff);
	diff[2] = 0;
	VectorNormalize(diff);
	fwdangles[1] = self->client->ps.viewangles[1];
	// Ultimately we might care if the shot was ahead or behind, but for now, just quadrant is fine.
	AngleVectors(fwdangles, nullptr, right, nullptr);
	const float rightdot = DotProduct(right, diff);
	const float zdiff = hitloc[2] - self->client->renderInfo.eyePoint[2];

	if (self->client->ps.weaponstate == WEAPON_DROPPING ||
		self->client->ps.weaponstate == WEAPON_RAISING)
	{
		//don't block
		if (self->health > 0
			&& self->NPC
			&& self->client->ps.weapon == WP_SABER)
		{
			return qtrue;
		}
		return qfalse;
	}

	if (PM_SaberInAttack(self->client->ps.saber_move) ||
		PM_SuperBreakLoseAnim(self->client->ps.torsoAnim) ||
		PM_SuperBreakWinAnim(self->client->ps.torsoAnim) ||
		PM_SaberInBrokenParry(self->client->ps.saber_move) ||
		PM_SaberInKnockaway(self->client->ps.saber_move) ||
		PM_InRoll(&self->client->ps) ||
		BG_InKnockDown(self->client->ps.legsAnim) ||
		BG_InKnockDown(self->client->ps.torsoAnim) ||
		PM_InKnockDown(&self->client->ps))
	{
		return qfalse;
	}

	if (PM_SaberInMassiveBounce(self->client->ps.torsoAnim) || PM_SaberInBashedAnim(self->client->ps.torsoAnim))
	{
		return qfalse;
	}

	if (g_SerenityJediEngineMode->integer == 1 && self->client->ps.forcePower <= BLOCKPOINTS_DANGER
		|| g_SerenityJediEngineMode->integer == 2 && self->client->ps.blockPoints <= BLOCKPOINTS_FAIL)
	{
		return qfalse;
	}

	if (self->client->ps.weapon != WP_SABER)
	{
		return qfalse;
	}

	if (!in_front && self->client->ps.forcePowerLevel[FP_SABER_DEFENSE] >= FORCE_LEVEL_1)
	{
		switch (self->client->ps.saber_anim_level)
		{
		case SS_STAFF:
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_P7_S1_B_, SETANIM_AFLAG_BLOCKPACE);
			break;
		case SS_DUAL:
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_P6_S1_B_, SETANIM_AFLAG_BLOCKPACE);
			break;
		default:
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_P1_S1_B_, SETANIM_AFLAG_BLOCKPACE);
			break;
		}
		self->client->ps.weaponTime = Q_irand(300, 600);
	}
	else if (zdiff > -5)
	{
		if (rightdot > 0.3)
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P7_S7_TR_MD, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P6_S6_TR_MD, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				if (self->client && NPC_IsOversized(self))
				{
					NPC_SetAnim(self, SETANIM_TORSO, BOTH_K1_S1_TR_MD, SETANIM_AFLAG_BLOCKPACE);
				}
				else
				{
					NPC_SetAnim(self, SETANIM_TORSO, BOTH_P1_S1_TR_MD, SETANIM_AFLAG_BLOCKPACE);
				}
				break;
			}
			if (self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self))
			{
				self->client->ps.weaponTime = Q_irand(400, 800);
			}
			else
			{
				self->client->ps.weaponTime = self->client->ps.torsoAnimTimer + Q_irand(500, 900);
			}
		}
		else if (rightdot < -0.3)
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P7_S7_TL_MD, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P6_S6_TL_MD, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				if (self->client && NPC_IsOversized(self))
				{
					NPC_SetAnim(self, SETANIM_TORSO, BOTH_K1_S1_TL_MD, SETANIM_AFLAG_BLOCKPACE);
				}
				else
				{
					NPC_SetAnim(self, SETANIM_TORSO, BOTH_P1_S1_TL_MD, SETANIM_AFLAG_BLOCKPACE);
				}
				break;
			}
			if (self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self))
			{
				self->client->ps.weaponTime = Q_irand(400, 800);
			}
			else
			{
				self->client->ps.weaponTime = self->client->ps.torsoAnimTimer + Q_irand(500, 900);
			}
		}
		else
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P7_S7_T__MD, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P6_S6_T__MD, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				if (self->client && NPC_IsOversized(self))
				{
					NPC_SetAnim(self, SETANIM_TORSO, BOTH_STAND_BLOCKING_ON, SETANIM_AFLAG_BLOCKPACE);
				}
				else
				{
					NPC_SetAnim(self, SETANIM_TORSO, BOTH_P1_S1_T__MD, SETANIM_AFLAG_BLOCKPACE);
				}
				break;
			}
			if (self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self))
			{
				self->client->ps.weaponTime = Q_irand(400, 800);
			}
			else
			{
				self->client->ps.weaponTime = self->client->ps.torsoAnimTimer + Q_irand(500, 900);
			}
		}
	}
	else if (zdiff > -22)
	{
		if (zdiff < -10)
		{
			//hmm, pretty low, but not low enough to use the low block, so we need to duck
		}
		if (rightdot > 0.1)
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P7_S7_TR_MD, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P6_S6_TR_MD, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P1_S1_TR_MD, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			if (self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self))
			{
				self->client->ps.weaponTime = Q_irand(400, 800);
			}
			else
			{
				self->client->ps.weaponTime = self->client->ps.torsoAnimTimer + Q_irand(500, 900);
			}
		}
		else if (rightdot < -0.1)
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P7_S7_TL_MD, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P6_S6_TL_MD, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P1_S1_TL_MD, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			if (self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self))
			{
				self->client->ps.weaponTime = Q_irand(400, 800);
			}
			else
			{
				self->client->ps.weaponTime = self->client->ps.torsoAnimTimer + Q_irand(500, 900);
			}
		}
		else
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P7_S7_T__MD, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P6_S6_T__MD, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P1_S1_T__MD, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			if (self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self))
			{
				self->client->ps.weaponTime = Q_irand(400, 800);
			}
			else
			{
				self->client->ps.weaponTime = self->client->ps.torsoAnimTimer + Q_irand(500, 900);
			}
		}
	}
	else
	{
		if (rightdot >= 0)
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P7_S7_BR_MD, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P6_S6_BR_MD, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P1_S1_BR_MD, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			if (self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self))
			{
				self->client->ps.weaponTime = Q_irand(400, 800);
			}
			else
			{
				self->client->ps.weaponTime = self->client->ps.torsoAnimTimer + Q_irand(500, 900);
			}
		}
		else
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P7_S7_BL_MD, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P6_S6_BL_MD, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P1_S1_BL_MD, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			if (self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self))
			{
				self->client->ps.weaponTime = Q_irand(400, 800);
			}
			else
			{
				self->client->ps.weaponTime = self->client->ps.torsoAnimTimer + Q_irand(500, 900);
			}
		}
	}

	if (missileBlock)
	{
		self->client->ps.saberBlocked = WP_MissileBlockForBlock(self->client->ps.saberBlocked);
		self->client->ps.weaponTime = Q_irand(300, 600);
	}

	if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self) && self->client->ps.saberBlocked != BLOCKED_NONE)
	{
		const int parry_re_calc_time = jedi_re_calc_parry_time(self, EVASION_PARRY);
		if (self->client->ps.forcePowerDebounce[FP_SABER_DEFENSE] < level.time + parry_re_calc_time)
		{
			self->client->ps.forcePowerDebounce[FP_SABER_DEFENSE] = level.time + parry_re_calc_time;
		}
	}

	self->client->ps.userInt3 &= ~(1 << FLAG_PREBLOCK);
	return qtrue;
}

qboolean WP_SaberBlockBolt_MD(gentity_t* self, vec3_t hitloc, const qboolean missileBlock)
{
	vec3_t diff, fwdangles = { 0, 0, 0 }, right;
	const qboolean in_front = InFront(hitloc, self->client->ps.origin, self->client->ps.viewangles, -0.7f);

	VectorSubtract(hitloc, self->client->renderInfo.eyePoint, diff);
	diff[2] = 0;
	VectorNormalize(diff);
	fwdangles[1] = self->client->ps.viewangles[1];
	// Ultimately we might care if the shot was ahead or behind, but for now, just quadrant is fine.
	AngleVectors(fwdangles, nullptr, right, nullptr);
	const float rightdot = DotProduct(right, diff);
	const float zdiff = hitloc[2] - self->client->renderInfo.eyePoint[2];

	if (self->client->ps.weaponstate == WEAPON_DROPPING ||
		self->client->ps.weaponstate == WEAPON_RAISING)
	{
		//don't block
		if (self->health > 0
			&& self->NPC
			&& self->client->ps.weapon == WP_SABER)
		{
			return qtrue;
		}
		return qfalse;
	}

	if (PM_SaberInAttack(self->client->ps.saber_move) ||
		PM_SuperBreakLoseAnim(self->client->ps.torsoAnim) ||
		PM_SuperBreakWinAnim(self->client->ps.torsoAnim) ||
		PM_SaberInBrokenParry(self->client->ps.saber_move) ||
		PM_SaberInKnockaway(self->client->ps.saber_move) ||
		PM_InRoll(&self->client->ps) ||
		BG_InKnockDown(self->client->ps.legsAnim) ||
		BG_InKnockDown(self->client->ps.torsoAnim) ||
		PM_InKnockDown(&self->client->ps))
	{
		return qfalse;
	}

	if (PM_SaberInMassiveBounce(self->client->ps.torsoAnim) || PM_SaberInBashedAnim(self->client->ps.torsoAnim))
	{
		return qfalse;
	}

	if (g_SerenityJediEngineMode->integer == 1 && self->client->ps.forcePower <= BLOCKPOINTS_DANGER
		|| g_SerenityJediEngineMode->integer == 2 && self->client->ps.blockPoints <= BLOCKPOINTS_FAIL)
	{
		return qfalse;
	}

	if (!in_front && self->client->ps.forcePowerLevel[FP_SABER_DEFENSE] >= FORCE_LEVEL_1)
	{
		switch (self->client->ps.saber_anim_level)
		{
		case SS_STAFF:
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_P7_S1_B_, SETANIM_AFLAG_BLOCKPACE);
			break;
		case SS_DUAL:
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_P6_S1_B_, SETANIM_AFLAG_BLOCKPACE);
			break;
		default:
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_P1_S1_B_, SETANIM_AFLAG_BLOCKPACE);
			break;
		}
		self->client->ps.weaponTime = Q_irand(300, 600);
	}
	else if (zdiff > -5)
	{
		if (rightdot > 0.3)
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_R7_TR_S7, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_R6_TR_S6, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_R1_TR_S1, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
		else if (rightdot < -0.3)
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_R7_TL_S7, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_R6_TL_S6, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_R1_TL_S1, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
		else
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_K7_S7_T_, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_K6_S6_T_, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_R2_TL_S1, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
	}
	else if (zdiff > -22)
	{
		if (zdiff < -10)
		{
			//hmm, pretty low, but not low enough to use the low block
		}
		if (rightdot > 0.1)
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_R7_TR_S7, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_R6_TR_S6, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_R1_TR_S1, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
		else if (rightdot < -0.1)
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_R7_TL_S7, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_R6_TL_S6, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_R1_TL_S1, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
		else
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_K7_S7_T_, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_K6_S6_T_, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_R2_TL_S1, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
	}
	else
	{
		if (rightdot >= 0)
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P7_S7_BR_MD, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P6_S6_BR_MD, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P1_S1_BR_MD, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
		else
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P7_S7_BL_MD, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P6_S6_BL_MD, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_P1_S1_BL_MD, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
	}

	if (missileBlock)
	{
		self->client->ps.saberBlocked = WP_MissileBlockForBlock(self->client->ps.saberBlocked);
		self->client->ps.weaponTime = Q_irand(300, 600);
	}

	if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self) && self->client->ps.saberBlocked != BLOCKED_NONE)
	{
		const int parry_re_calc_time = jedi_re_calc_parry_time(self, EVASION_PARRY);
		if (self->client->ps.forcePowerDebounce[FP_SABER_DEFENSE] < level.time + parry_re_calc_time)
		{
			self->client->ps.forcePowerDebounce[FP_SABER_DEFENSE] = level.time + parry_re_calc_time;
		}
	}

	self->client->ps.userInt3 &= ~(1 << FLAG_PREBLOCK);
	return qtrue;
}

qboolean WP_SaberFatiguedParryDirection(gentity_t* self, vec3_t hitloc, const qboolean missileBlock)
{
	vec3_t diff, fwdangles = { 0, 0, 0 }, right;
	const qboolean in_front = InFront(hitloc, self->client->ps.origin, self->client->ps.viewangles, -0.7f);

	VectorSubtract(hitloc, self->client->renderInfo.eyePoint, diff);
	diff[2] = 0;
	VectorNormalize(diff);
	fwdangles[1] = self->client->ps.viewangles[1];
	// Ultimately we might care if the shot was ahead or behind, but for now, just quadrant is fine.
	AngleVectors(fwdangles, nullptr, right, nullptr);
	const float rightdot = DotProduct(right, diff);
	const float zdiff = hitloc[2] - self->client->renderInfo.eyePoint[2];

	if (self->client->ps.weaponstate == WEAPON_DROPPING ||
		self->client->ps.weaponstate == WEAPON_RAISING)
	{
		//don't block
		if (self->health > 0
			&& self->NPC
			&& self->client->ps.weapon == WP_SABER)
		{
			return qtrue;
		}
		return qfalse;
	}

	if (PM_SaberInAttack(self->client->ps.saber_move) ||
		PM_SuperBreakLoseAnim(self->client->ps.torsoAnim) ||
		PM_SuperBreakWinAnim(self->client->ps.torsoAnim) ||
		PM_SaberInBrokenParry(self->client->ps.saber_move) ||
		PM_SaberInKnockaway(self->client->ps.saber_move) ||
		PM_InRoll(&self->client->ps) ||
		BG_InKnockDown(self->client->ps.legsAnim) ||
		BG_InKnockDown(self->client->ps.torsoAnim) ||
		PM_InKnockDown(&self->client->ps))
	{
		return qfalse;
	}

	if (PM_SaberInMassiveBounce(self->client->ps.torsoAnim) || PM_SaberInBashedAnim(self->client->ps.torsoAnim))
	{
		return qfalse;
	}

	if (g_SerenityJediEngineMode->integer == 1 && self->client->ps.forcePower <= BLOCKPOINTS_DANGER
		|| g_SerenityJediEngineMode->integer == 2 && self->client->ps.blockPoints <= BLOCKPOINTS_FAIL)
	{
		return qfalse;
	}

	if (!in_front && self->client->ps.forcePowerLevel[FP_SABER_DEFENSE] >= FORCE_LEVEL_1)
	{
		switch (self->client->ps.saber_anim_level)
		{
		case SS_STAFF:
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_P7_S1_B_, SETANIM_AFLAG_BLOCKPACE);
			break;
		case SS_DUAL:
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_P6_S1_B_, SETANIM_AFLAG_BLOCKPACE);
			break;
		default:
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_P1_S1_B_, SETANIM_AFLAG_BLOCKPACE);
			break;
		}
		self->client->ps.weaponTime = Q_irand(300, 600);
	}
	else if (zdiff > -5)
	{
		if (rightdot > 0.3)
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V7_TR_S7, SETANIM_AFLAG_BLOCKPACE); //TOP RIGHT
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V6_TR_S6, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V1_TR_S1, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
		else if (rightdot < -0.3)
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V7_TL_S7, SETANIM_AFLAG_BLOCKPACE); //TOP LEFT
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V6_TL_S6, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V1_TL_S1, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
		else
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V7_T__S7, SETANIM_AFLAG_BLOCKPACE); //TOP TOP
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V6_T__S6, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V1_T__S1, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
	}
	else if (zdiff > -22)
	{
		if (zdiff < -10)
		{
			//hmm, pretty low, but not low enough to use the low block
		}
		if (rightdot > 0.1)
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V7__R_S7, SETANIM_AFLAG_BLOCKPACE); //TOP RIGHT
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V6__R_S6, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V1__R_S1, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
		else if (rightdot < -0.1)
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V7__L_S7, SETANIM_AFLAG_BLOCKPACE); //TOP LEFT
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V6__L_S6, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V1_TL_S1, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
		else
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V7_T__S7, SETANIM_AFLAG_BLOCKPACE); //TOP TOP
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V6_T__S6, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V1_T__S1, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
	}
	else
	{
		if (rightdot >= 0)
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V7_BR_S7, SETANIM_AFLAG_BLOCKPACE); //BOTTOM RIGHT
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V6_BR_S6, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V1_BR_S1, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
		else
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V7_BL_S7, SETANIM_AFLAG_BLOCKPACE); //BOTTOM LEFT
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V6_BL_S6, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_V1_BL_S1, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
	}

	if (missileBlock)
	{
		self->client->ps.saberBlocked = WP_MissileBlockForBlock(self->client->ps.saberBlocked);
		self->client->ps.weaponTime = Q_irand(300, 600);
	}

	if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self) && self->client->ps.saberBlocked != BLOCKED_NONE)
	{
		const int parry_re_calc_time = jedi_re_calc_parry_time(self, EVASION_PARRY);
		if (self->client->ps.forcePowerDebounce[FP_SABER_DEFENSE] < level.time + parry_re_calc_time)
		{
			self->client->ps.forcePowerDebounce[FP_SABER_DEFENSE] = level.time + parry_re_calc_time;
		}
	}

	self->client->ps.userInt3 &= ~(1 << FLAG_PREBLOCK);
	return qtrue;
}

qboolean WP_SaberBlockBolt_AMD(gentity_t* self, vec3_t hitloc, const qboolean missileBlock)
{
	vec3_t diff, fwdangles = { 0, 0, 0 }, right;
	const qboolean in_front = InFront(hitloc, self->client->ps.origin, self->client->ps.viewangles, -0.7f);

	VectorSubtract(hitloc, self->client->renderInfo.eyePoint, diff);
	diff[2] = 0;
	VectorNormalize(diff);
	fwdangles[1] = self->client->ps.viewangles[1];
	// Ultimately we might care if the shot was ahead or behind, but for now, just quadrant is fine.
	AngleVectors(fwdangles, nullptr, right, nullptr);
	const float rightdot = DotProduct(right, diff);
	const float zdiff = hitloc[2] - self->client->renderInfo.eyePoint[2];

	if (self->client->ps.weaponstate == WEAPON_DROPPING ||
		self->client->ps.weaponstate == WEAPON_RAISING)
	{
		//don't block
		if (self->health > 0
			&& self->NPC
			&& self->client->ps.weapon == WP_SABER)
		{
			return qtrue;
		}
		return qfalse;
	}

	if (PM_SaberInAttack(self->client->ps.saber_move) ||
		PM_SuperBreakLoseAnim(self->client->ps.torsoAnim) ||
		PM_SuperBreakWinAnim(self->client->ps.torsoAnim) ||
		PM_SaberInBrokenParry(self->client->ps.saber_move) ||
		PM_SaberInKnockaway(self->client->ps.saber_move) ||
		PM_InRoll(&self->client->ps) ||
		BG_InKnockDown(self->client->ps.legsAnim) ||
		BG_InKnockDown(self->client->ps.torsoAnim) ||
		PM_InKnockDown(&self->client->ps))
	{
		return qfalse;
	}

	if (PM_SaberInMassiveBounce(self->client->ps.torsoAnim) || PM_SaberInBashedAnim(self->client->ps.torsoAnim))
	{
		return qfalse;
	}

	if (g_SerenityJediEngineMode->integer == 1 && self->client->ps.forcePower <= BLOCKPOINTS_DANGER
		|| g_SerenityJediEngineMode->integer == 2 && self->client->ps.blockPoints <= BLOCKPOINTS_FAIL)
	{
		return qfalse;
	}

	if (!in_front && self->client->ps.forcePowerLevel[FP_SABER_DEFENSE] >= FORCE_LEVEL_1)
	{
		switch (self->client->ps.saber_anim_level)
		{
		case SS_STAFF:
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_P7_S1_B_, SETANIM_AFLAG_BLOCKPACE);
			break;
		case SS_DUAL:
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_P6_S1_B_, SETANIM_AFLAG_BLOCKPACE);
			break;
		default:
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_P1_S1_B_, SETANIM_AFLAG_BLOCKPACE);
			break;
		}
		self->client->ps.weaponTime = Q_irand(300, 600);
	}
	else if (zdiff > -5)
	{
		if (rightdot > 0.3)
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				if (self->client->NPC_class == CLASS_GALEN)
				{
					NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_BACKHAND_TOP_RIGHT, SETANIM_AFLAG_BLOCKPACE);
				}
				else
				{
					NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_STAFF_TOP_RIGHT, SETANIM_AFLAG_BLOCKPACE);
				}
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_DUAL_TOP_RIGHT, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_FAST:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_TWO_HAND_TOP_RIGHT, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_MEDIUM:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_TWO_HAND_TOP_RIGHT, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_STRONG:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_TWO_HAND_TOP_RIGHT, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DESANN:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_SINGLE_HAND_TOP_RIGHT, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_TAVION:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_SINGLE_HAND_TOP_RIGHT, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_SINGLE_HAND_TOP_RIGHT, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
		else if (rightdot < -0.3)
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				if (self->client->NPC_class == CLASS_GALEN)
				{
					NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_BACKHAND_TOP_LEFT, SETANIM_AFLAG_BLOCKPACE);
				}
				else
				{
					NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_STAFF_TOP_LEFT, SETANIM_AFLAG_BLOCKPACE);
				}
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_DUAL_TOP_LEFT, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_FAST:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_TWO_HAND_TOP_LEFT, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_MEDIUM:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_TWO_HAND_TOP_LEFT, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_STRONG:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_TWO_HAND_TOP_LEFT, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DESANN:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_SINGLE_HAND_TOP_LEFT, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_TAVION:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_SINGLE_HAND_TOP_LEFT, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_SINGLE_HAND_TOP_LEFT, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
		else
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				if (self->client->NPC_class == CLASS_GALEN)
				{
					NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_BACKHAND_TOP_MIDDLE, SETANIM_AFLAG_BLOCKPACE);
				}
				else
				{
					NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_STAFF_TOP_MIDDLE, SETANIM_AFLAG_BLOCKPACE);
				}
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_DUAL_TOP_MIDDLE, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_FAST:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_TWO_HAND_TOP_MIDDLE, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_MEDIUM:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_TWO_HAND_TOP_MIDDLE, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_STRONG:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_TWO_HAND_TOP_MIDDLE, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DESANN:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_SINGLE_HAND_TOP_MIDDLE, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_TAVION:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_SINGLE_HAND_TOP_MIDDLE, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_SINGLE_HAND_TOP_MIDDLE, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
	}
	else if (zdiff > -22)
	{
		if (zdiff < -10)
		{
			//hmm, pretty low, but not low enough to use the low block
		}
		if (rightdot > 0.1)
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				if (self->client->NPC_class == CLASS_GALEN)
				{
					NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_BACKHAND_MIDDLE_RIGHT, SETANIM_AFLAG_BLOCKPACE);
				}
				else
				{
					NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_STAFF_MIDDLE_RIGHT, SETANIM_AFLAG_BLOCKPACE);
				}
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_DUAL_MIDDLE_RIGHT, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_FAST:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_TWO_HAND_MIDDLE_RIGHT, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_MEDIUM:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_TWO_HAND_MIDDLE_RIGHT, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_STRONG:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_TWO_HAND_MIDDLE_RIGHT, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DESANN:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_SINGLE_HAND_MIDDLE_RIGHT, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_TAVION:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_SINGLE_HAND_MIDDLE_RIGHT, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_SINGLE_HAND_MIDDLE_RIGHT, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
		else if (rightdot < -0.1)
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				if (self->client->NPC_class == CLASS_GALEN)
				{
					NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_BACKHAND_MIDDLE_LEFT, SETANIM_AFLAG_BLOCKPACE);
				}
				else
				{
					NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_STAFF_MIDDLE_LEFT, SETANIM_AFLAG_BLOCKPACE);
				}
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_DUAL_MIDDLE_LEFT, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_FAST:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_TWO_HAND_MIDDLE_LEFT, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_MEDIUM:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_TWO_HAND_MIDDLE_LEFT, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_STRONG:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_TWO_HAND_MIDDLE_LEFT, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DESANN:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_SINGLE_HAND_MIDDLE_LEFT, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_TAVION:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_SINGLE_HAND_MIDDLE_LEFT, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_SINGLE_HAND_MIDDLE_LEFT, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
		else
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				if (self->client->NPC_class == CLASS_GALEN)
				{
					NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_BACKHAND_TOP_MIDDLE, SETANIM_AFLAG_BLOCKPACE);
				}
				else
				{
					NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_STAFF_TOP_MIDDLE, SETANIM_AFLAG_BLOCKPACE);
				}
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_DUAL_TOP_MIDDLE, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_FAST:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_TWO_HAND_TOP_MIDDLE, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_MEDIUM:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_TWO_HAND_TOP_MIDDLE, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_STRONG:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_TWO_HAND_TOP_MIDDLE, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DESANN:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_SINGLE_HAND_TOP_MIDDLE, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_TAVION:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_SINGLE_HAND_TOP_MIDDLE, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_SINGLE_HAND_TOP_MIDDLE, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
	}
	else
	{
		if (rightdot >= 0)
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				if (self->client->NPC_class == CLASS_GALEN)
				{
					NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_BACKHAND_BOTTOM_RIGHT, SETANIM_AFLAG_BLOCKPACE);
				}
				else
				{
					NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_STAFF_BOTTOM_RIGHT, SETANIM_AFLAG_BLOCKPACE);
				}
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_DUAL_BOTTOM_RIGHT, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_FAST:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_TWO_HAND_BOTTOM_RIGHT, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_MEDIUM:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_TWO_HAND_BOTTOM_RIGHT, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_STRONG:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_TWO_HAND_BOTTOM_RIGHT, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DESANN:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_SINGLE_HAND_BOTTOM_RIGHT, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_TAVION:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_SINGLE_HAND_BOTTOM_RIGHT, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_SINGLE_HAND_BOTTOM_RIGHT, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
		else
		{
			switch (self->client->ps.saber_anim_level)
			{
			case SS_STAFF:
				if (self->client->NPC_class == CLASS_GALEN)
				{
					NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_BACKHAND_BOTTOM_LEFT, SETANIM_AFLAG_BLOCKPACE);
				}
				else
				{
					NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_STAFF_BOTTOM_LEFT, SETANIM_AFLAG_BLOCKPACE);
				}
				break;
			case SS_DUAL:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_DUAL_BOTTOM_LEFT, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_FAST:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_TWO_HAND_BOTTOM_LEFT, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_MEDIUM:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_TWO_HAND_BOTTOM_LEFT, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_STRONG:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_TWO_HAND_BOTTOM_LEFT, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_DESANN:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_SINGLE_HAND_BOTTOM_LEFT, SETANIM_AFLAG_BLOCKPACE);
				break;
			case SS_TAVION:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_SINGLE_HAND_BOTTOM_LEFT, SETANIM_AFLAG_BLOCKPACE);
				break;
			default:
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_BOLT_BLOCK_SINGLE_HAND_BOTTOM_LEFT, SETANIM_AFLAG_BLOCKPACE);
				break;
			}
			self->client->ps.weaponTime = Q_irand(300, 600);
		}
	}

	if (missileBlock)
	{
		self->client->ps.saberBlocked = WP_MissileBlockForBlock(self->client->ps.saberBlocked);
		self->client->ps.weaponTime = Q_irand(300, 600);
	}

	if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self) && self->client->ps.saberBlocked != BLOCKED_NONE)
	{
		const int parry_re_calc_time = jedi_re_calc_parry_time(self, EVASION_PARRY);
		if (self->client->ps.forcePowerDebounce[FP_SABER_DEFENSE] < level.time + parry_re_calc_time)
		{
			self->client->ps.forcePowerDebounce[FP_SABER_DEFENSE] = level.time + parry_re_calc_time;
		}
	}

	self->client->ps.userInt3 &= ~(1 << FLAG_PREBLOCK);
	return qtrue;
}

void wp_saber_start_missile_block_check(gentity_t* self, const usercmd_t* ucmd)
{
	gentity_t* incoming = nullptr;
	gentity_t* entity_list[MAX_GENTITIES];
	vec3_t mins{}, maxs{};
	constexpr float radius = 256;
	vec3_t forward;
	vec3_t fwdangles = { 0 };
	trace_t trace;
	vec3_t trace_to, entDir;
	qboolean dodge_only_sabers = qfalse;

	if (self->NPC && self->NPC->scriptFlags & SCF_IGNORE_ALERTS)
	{
		//don't react to things flying at me...
		return;
	}
	if (self->health <= 0)
	{
		//dead don't try to block (NOTE: actual deflection happens in missile code)
		return;
	}

	if (PM_InKnockDown(&self->client->ps))
	{
		//can't block when knocked down
		return;
	}

	if (PM_SuperBreakLoseAnim(self->client->ps.torsoAnim)
		|| PM_SuperBreakWinAnim(self->client->ps.torsoAnim))
	{
		//can't block while in break anim
		return;
	}

	if (rosh_being_healed(self))
	{
		return;
	}

	if (self->client->NPC_class == CLASS_ROCKETTROOPER)
	{
		//rockettrooper
		if (self->client->ps.groundEntityNum != ENTITYNUM_NONE)
		{
			//must be in air
			return;
		}
		if (Q_irand(0, 4 - g_spskill->integer * 2))
		{
			//easier level guys do this less
			return;
		}
		if (Q_irand(0, 3))
		{
			//base level: 25% chance of looking for something to dodge
			if (Q_irand(0, 1))
			{
				//dodge sabers twice as frequently as other projectiles
				dodge_only_sabers = qtrue;
			}
			else
			{
				return;
			}
		}
	}

	if (self->client->NPC_class == CLASS_BOBAFETT || self->client->NPC_class == CLASS_MANDALORIAN || self->client->
		NPC_class == CLASS_JANGO || self->client->NPC_class == CLASS_JANGODUAL)
	{
		//Boba doesn't dodge quite as much
		if (Q_irand(0, 2 - g_spskill->integer))
		{
			//easier level guys do this less
			return;
		}
	}

	if (self->client->NPC_class != CLASS_BOBAFETT && self->client->NPC_class != CLASS_MANDALORIAN && self->client->
		NPC_class != CLASS_JANGO && self->client->NPC_class != CLASS_JANGODUAL
		&& (self->client->NPC_class != CLASS_REBORN || self->s.weapon == WP_SABER)
		&& (self->client->NPC_class != CLASS_ROCKETTROOPER || !self->NPC || self->NPC->rank < RANK_LT))
	{
		if (ucmd->buttons & BUTTON_USE && !(ucmd->buttons & BUTTON_WALKING)
			&& cg.renderingThirdPerson
			&& G_OkayToLean(&self->client->ps, ucmd, qfalse)
			&& self->client->ps.forcePowersActive & 1 << FP_SPEED)
		{
		}
		else
		{
			if (self->client->ps.weapon != WP_SABER)
			{
				return;
			}

			if (self->client->ps.saberInFlight)
			{
				return;
			}

			if (self->s.number < MAX_CLIENTS)
			{
				if (!self->client->ps.SaberLength())
				{
					//player doesn't auto-activate
					return;
				}

				if (!g_saberAutoBlocking->integer && self->client->ps.saberBlockingTime < level.time)
				{
					return;
				}
			}

			if (self->client->ps.saber[0].saberFlags & SFL_NOT_ACTIVE_BLOCKING)
			{
				//can't actively block with this saber type
				return;
			}
		}

		if (!self->s.number)
		{
			//don't do this if already attacking!
			if (ucmd->buttons & BUTTON_ATTACK
				|| PM_SaberInAttack(self->client->ps.saber_move)
				|| pm_saber_in_special_attack(self->client->ps.torsoAnim)
				|| PM_SaberInTransitionAny(self->client->ps.saber_move))
			{
				return;
			}
		}

		if (self->client->ps.forcePowerLevel[FP_SABER_DEFENSE] < FORCE_LEVEL_1)
		{
			//you have not the SKILLZ
			return;
		}

		if (self->client->ps.forcePowerDebounce[FP_SABER_DEFENSE] > level.time)
		{
			//can't block while already blocking
			return;
		}

		if (self->client->ps.forcePowersActive & 1 << FP_LIGHTNING)
		{
			//can't block while zapping
			return;
		}

		if (self->client->ps.forcePowersActive & 1 << FP_LIGHTNING_STRIKE)
		{
			//can't block while zapping
			return;
		}

		if (self->client->ps.forcePowersActive & 1 << FP_DRAIN)
		{
			//can't block while draining
			return;
		}

		if (self->client->ps.forcePowersActive & 1 << FP_PUSH)
		{
			//can't block while shoving
			return;
		}

		if (self->client->ps.forcePowersActive & 1 << FP_GRIP)
		{
			//can't block while gripping (FIXME: or should it break the grip?  Pain should break the grip, I think...)
			return;
		}

		if (self->client->ps.forcePowersActive & 1 << FP_GRASP)
		{
			//can't block while gripping (FIXME: or should it break the grip?  Pain should break the grip, I think...)
			return;
		}
	}

	fwdangles[1] = self->client->ps.viewangles[1];
	AngleVectors(fwdangles, forward, nullptr, nullptr);

	for (int i = 0; i < 3; i++)
	{
		mins[i] = self->currentOrigin[i] - radius;
		maxs[i] = self->currentOrigin[i] + radius;
	}

	const int num_listed_entities = gi.EntitiesInBox(mins, maxs, entity_list, MAX_GENTITIES);

	float closest_dist = radius;

	for (int e = 0; e < num_listed_entities; e++)
	{
		vec3_t missile_dir;
		vec3_t dir;
		gentity_t* ent = entity_list[e];

		if (ent == self)
			continue;
		if (ent->owner == self)
			continue;
		if (!ent->inuse)
			continue;
		if (dodge_only_sabers)
		{
			//only care about thrown sabers
			if (ent->client
				|| ent->s.weapon != WP_SABER
				|| !ent->classname
				|| !ent->classname[0]
				|| Q_stricmp("lightsaber", ent->classname))
			{
				//not a lightsaber, ignore it
				continue;
			}
		}
		if (ent->s.eType != ET_MISSILE && !(ent->s.eFlags & EF_MISSILE_STICK))
		{
			//not a normal projectile
			if (ent->client || ent->s.weapon != WP_SABER)
			{
				//FIXME: wake up bad guys?
				continue;
			}
			if (ent->s.eFlags & EF_NODRAW)
			{
				continue;
			}
			if (Q_stricmp("lightsaber", ent->classname) != 0)
			{
				//not a lightsaber
				//FIXME: what about general objects that are small in size- like rocks, etc...
				continue;
			}
			//a lightsaber.. make sure it's on and inFlight
			if (!ent->owner || !ent->owner->client)
			{
				continue;
			}
			if (!ent->owner->client->ps.saberInFlight)
			{
				//not in flight
				continue;
			}
			if (ent->owner->client->ps.SaberLength() <= 0)
			{
				//not on
				continue;
			}
			if (ent->owner->health <= 0 && g_saberRealisticCombat->integer < 2)
			{
				//it's not doing damage, so ignore it
				continue;
			}
		}
		else
		{
			if (ent->s.pos.trType == TR_STATIONARY && !self->s.number)
			{
				//nothing you can do with a stationary missile if you're the player
				continue;
			}
		}

		float dot1, dot2;
		//see if they're in front of me
		VectorSubtract(ent->currentOrigin, self->currentOrigin, dir);
		const float dist = VectorNormalize(dir);
		//FIXME: handle detpacks, proximity mines and tripmines
		if (ent->s.weapon == WP_THERMAL)
		{
			//thermal detonator!
			if (self->NPC && dist < ent->splashRadius)
			{
				if (dist < ent->splashRadius &&
					ent->nextthink < level.time + 600 &&
					ent->count &&
					self->client->ps.groundEntityNum != ENTITYNUM_NONE &&
					(ent->s.pos.trType == TR_STATIONARY ||
						ent->s.pos.trType == TR_INTERPOLATE ||
						(dot1 = DotProduct(dir, forward)) < SABER_REFLECT_MISSILE_CONE ||
						!WP_ForcePowerUsable(self, FP_PUSH, 0)))
				{
					//TD is close enough to hurt me, I'm on the ground and the thing is at rest or behind me and about to blow up, or I don't have force-push so force-jump!
					//FIXME: sometimes this might make me just jump into it...?
					self->client->ps.forceJumpCharge = 480;
				}
				else if (self->client->NPC_class != CLASS_BOBAFETT && self->client->NPC_class != CLASS_MANDALORIAN &&
					self->client->NPC_class != CLASS_JANGO && self->client->NPC_class != CLASS_JANGODUAL
					&& (self->client->NPC_class != CLASS_REBORN || self->s.weapon == WP_SABER)
					&& self->client->NPC_class != CLASS_ROCKETTROOPER && self->client->NPC_class != CLASS_GUARD)
				{
					if (!ent->owner || !OnSameTeam(self, ent->owner))
					{
						ForceThrow_JKA(self, qfalse);
					}
				}
			}
			continue;
		}
		if (ent->splashDamage && ent->splashRadius && !(ent->s.powerups & 1 << PW_FORCE_PROJECTILE))
		{
			//exploding missile
			//FIXME: handle tripmines and detpacks somehow...
			//			maybe do a force-gesture that makes them explode?
			//			But what if we're within it's splashradius?
			if (!self->s.number)
			{
				//players don't auto-handle these at all
				continue;
			}
			if (self->client->NPC_class == CLASS_BOBAFETT || self->client->NPC_class == CLASS_MANDALORIAN || self->
				client->NPC_class == CLASS_JANGO || self->client->NPC_class == CLASS_JANGODUAL
				|| self->client->NPC_class == CLASS_ROCKETTROOPER)
			{
				/*
					if ( ent->s.pos.trType == TR_STATIONARY && (ent->s.eFlags&EF_MISSILE_STICK) )
					{//sorry, you're scrooged here
						//FIXME: maybe jump or go up if on ground?
						continue;
					}
					//else it's a rocket, try to evade it
					*/
					//HMM... let's see what happens if these guys try to avoid tripmines and detpacks, too...?
			}
			else
			{
				//normal Jedi
				if (ent->s.pos.trType == TR_STATIONARY && ent->s.eFlags & EF_MISSILE_STICK
					&& (self->client->NPC_class != CLASS_REBORN || self->s.weapon == WP_SABER))
				{
					//a placed explosive like a tripmine or detpack
					if (InFOV(ent->currentOrigin, self->client->renderInfo.eyePoint, self->client->ps.viewangles, 90,
						90))
					{
						//in front of me
						if (G_ClearLOS(self, ent))
						{
							//can see it
							vec3_t throw_dir;
							//make the gesture
							ForceThrow_JKA(self, qfalse);
							//take it off the wall and toss it
							ent->s.pos.trType = TR_GRAVITY;
							ent->s.eType = ET_MISSILE;
							ent->s.eFlags &= ~EF_MISSILE_STICK;
							ent->s.eFlags |= EF_BOUNCE_HALF;
							AngleVectors(ent->currentAngles, throw_dir, nullptr, nullptr);
							VectorMA(ent->currentOrigin, ent->maxs[0] + 4, throw_dir, ent->currentOrigin);
							VectorCopy(ent->currentOrigin, ent->s.pos.trBase);
							VectorScale(throw_dir, 300, ent->s.pos.trDelta);
							ent->s.pos.trDelta[2] += 150;
							VectorMA(ent->s.pos.trDelta, 800, dir, ent->s.pos.trDelta);
							ent->s.pos.trTime = level.time; // move a bit on the very first frame
							VectorCopy(ent->currentOrigin, ent->s.pos.trBase);
							ent->owner = self;
							// make it explode, but with less damage
							ent->splashDamage /= 3;
							ent->splashRadius /= 3;
							ent->e_ThinkFunc = thinkF_WP_Explode;
							ent->nextthink = level.time + Q_irand(500, 3000);
						}
					}
				}
				else if (dist < ent->splashRadius && self->client->NPC_class != CLASS_GUARD
					&& self->client->ps.groundEntityNum != ENTITYNUM_NONE
					&& (DotProduct(dir, forward) < SABER_REFLECT_MISSILE_CONE
						|| !WP_ForcePowerUsable(self, FP_PUSH, 0)))
				{
					//NPCs try to evade it
					self->client->ps.forceJumpCharge = 480;
				}
				else if ((self->client->NPC_class != CLASS_REBORN || self->s.weapon == WP_SABER) && self->client->NPC_class != CLASS_GUARD)
				{
					//else, try to force-throw it away
					if (!ent->owner || !OnSameTeam(self, ent->owner))
					{
						ForceThrow_JKA(self, qfalse);
					}
				}
				//otherwise, can't block it, so we're screwed
				continue;
			}
		}

		if (ent->s.weapon != WP_SABER)
		{
			//only block shots coming from behind
			if ((dot1 = DotProduct(dir, forward)) < SABER_REFLECT_MISSILE_CONE)
				continue;
		}
		else if (!self->s.number)
		{
			//player never auto-blocks thrown sabers
			continue;
		} //NPCs always try to block sabers coming from behind!

		//see if they're heading towards me
		VectorCopy(ent->s.pos.trDelta, missile_dir);
		VectorNormalize(missile_dir);
		if ((dot2 = DotProduct(dir, missile_dir)) > 0)
			continue;

		//FIXME: must have a clear trace to me, too...
		if (dist < closest_dist)
		{
			VectorCopy(self->currentOrigin, trace_to);
			trace_to[2] = self->absmax[2] - 4;
			gi.trace(&trace, ent->currentOrigin, ent->mins, ent->maxs, trace_to, ent->s.number, ent->clipmask,
				static_cast<EG2_Collision>(0), 0);
			if (trace.allsolid || trace.startsolid || trace.fraction < 1.0f && trace.entityNum != self->s.number &&
				trace.entityNum != self->client->ps.saberEntityNum)
			{
				//okay, try one more check
				VectorNormalize2(ent->s.pos.trDelta, entDir);
				VectorMA(ent->currentOrigin, radius, entDir, trace_to);
				gi.trace(&trace, ent->currentOrigin, ent->mins, ent->maxs, trace_to, ent->s.number, ent->clipmask,
					static_cast<EG2_Collision>(0), 0);
				if (trace.allsolid || trace.startsolid || trace.fraction < 1.0f && trace.entityNum != self->s.number &&
					trace.entityNum != self->client->ps.saberEntityNum)
				{
					//can't hit me, ignore it
					continue;
				}
			}
			if (self->s.number != 0)
			{
				//An NPC
				if (self->NPC && !self->enemy && ent->owner)
				{
					if (ent->owner->health >= 0 && (!ent->owner->client || ent->owner->client->playerTeam != self->
						client->playerTeam))
					{
						G_SetEnemy(self, ent->owner);
					}
				}
			}
			//FIXME: if NPC, predict the intersection between my current velocity/path and the missile's, see if it intersects my bounding box (+/-saberLength?), don't try to deflect unless it does?
			closest_dist = dist;
			incoming = ent;
		}
	}

	if (incoming)
	{
		if (self->NPC && !G_ControlledByPlayer(self))
		{
			if (jedi_waiting_ambush(self))
			{
				jedi_ambush(self);
			}
			if ((self->client->NPC_class == CLASS_BOBAFETT || self->client->NPC_class == CLASS_MANDALORIAN || self->
				client->NPC_class == CLASS_JANGO || self->client->NPC_class == CLASS_JANGODUAL || self->client->
				NPC_class == CLASS_ROCKETTROOPER)
				&& self->client->moveType == MT_FLYSWIM
				&& incoming->methodOfDeath != MOD_ROCKET_ALT)
			{
				//a hovering Boba Fett, not a tracking rocket
				if (!Q_irand(0, 1))
				{
					//strafe
					self->NPC->standTime = 0;
					self->client->ps.forcePowerDebounce[FP_SABER_DEFENSE] = level.time + Q_irand(1000, 2000);
				}
				if (!Q_irand(0, 1))
				{
					//go up/down
					TIMER_Set(self, "heightChange", Q_irand(1000, 3000));
					self->client->ps.forcePowerDebounce[FP_SABER_DEFENSE] = level.time + Q_irand(1000, 2000);
				}
			}
			else if (self->client->NPC_class != CLASS_ROCKETTROOPER
				&& jedi_saber_block_go(self, &self->NPC->last_ucmd, nullptr, nullptr, incoming) != EVASION_NONE)
			{
				//make sure to turn on your saber if it's not on
				if (self->client->NPC_class != CLASS_BOBAFETT
					&& self->client->NPC_class != CLASS_MANDALORIAN
					&& self->client->NPC_class != CLASS_JANGO
					&& self->client->NPC_class != CLASS_JANGODUAL
					&& (self->client->NPC_class != CLASS_REBORN || self->s.weapon == WP_SABER)
					&& (self->client->NPC_class != CLASS_GROGU || self->s.weapon == WP_SABER))
				{
					self->client->ps.SaberActivate();
				}
			}
		}
		else //player
		{
			if (!(ucmd->buttons & BUTTON_USE))
			{
				WP_SaberBlockNonRandom(self, incoming->currentOrigin, qtrue);
			}
			else
			{
				vec3_t diff, start, end;
				VectorSubtract(incoming->currentOrigin, self->currentOrigin, diff);
				const float dist = VectorLength(diff);
				VectorNormalize2(incoming->s.pos.trDelta, entDir);
				VectorMA(incoming->currentOrigin, dist, entDir, start);
				VectorCopy(self->currentOrigin, end);
				end[2] += self->maxs[2] * 0.75f;
				gi.trace(&trace, start, incoming->mins, incoming->maxs, end, incoming->s.number, MASK_SHOT, G2_COLLIDE,
					10);

				jedi_dodge_evasion(self, incoming->owner, &trace, HL_NONE);
			}
			if (incoming->owner && incoming->owner->client && (!self->enemy || self->enemy->s.weapon != WP_SABER))
			{
				self->enemy = incoming->owner;
				NPC_SetLookTarget(self, incoming->owner->s.number, level.time + 1000);
			}
		}
	}
}

extern int BlockedforQuad(int quad);
extern int InvertQuad(int quad);

void wp_saber_start_missile_block_check_md(gentity_t* self, const usercmd_t* ucmd)
{
	qboolean closest_swing_block = qfalse; //default setting makes the compiler happy.
	int swing_block_quad = Q_T;
	int closestSwingQuad = Q_T;
	gentity_t* incoming = nullptr;
	gentity_t* entity_list[MAX_GENTITIES];
	vec3_t mins{}, maxs{};
	constexpr float radius = 256;
	vec3_t forward;
	vec3_t fwdangles = { 0 };
	trace_t trace;
	vec3_t trace_to, ent_dir;
	qboolean dodge_only_sabers = qfalse;
	qboolean do_full_routine = qtrue;

	if (self->client->ps.weapon != WP_SABER) //saber not here
	{
		//saber not currently in use or available, attempt to use our hands instead.
		do_full_routine = qfalse;
	}

	if (self->client->ps.weapon == WP_SABER && !self->client->ps.SaberActive())
	{
		//saber not currently in use or available, attempt to use our hands instead.
		do_full_routine = qfalse;
	}

	if (self->client->ps.weapon == WP_SABER && self->client->ps.saberInFlight)
	{
		//saber not currently in use or available, attempt to use our hands instead.
		do_full_routine = qfalse;
	}

	if (g_SerenityJediEngineMode->integer)
	{
		if ((self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self)) && !(self->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCK))
		{
			return;
		}
	}

	if (self->client->ps.SaberLength() <= 0)
	{
		//not on
		return;
	}

	if (!WalkCheck(self)
		&& (PM_SaberInAttack(self->client->ps.saber_move)
			|| PM_SaberInStart(self->client->ps.saber_move)))
	{
		//this was put in to help bolts stop swings a bit. I dont know why it helps but it does :p
		do_full_routine = qfalse;
	}

	if (self->client->ps.weaponTime > 0 && !PM_SaberInParry(self->client->ps.saber_move))
	{
		//don't autoblock while busy with stuff
		return;
	}

	if (self->NPC && self->NPC->scriptFlags & SCF_IGNORE_ALERTS)
	{
		//don't react to things flying at me...
		return;
	}
	if (self->health <= 0)
	{
		//dead don't try to block (NOTE: actual deflection happens in missile code)
		return;
	}

	if (PM_InKnockDown(&self->client->ps))
	{
		//can't block when knocked down
		return;
	}

	if (PM_SuperBreakLoseAnim(self->client->ps.torsoAnim)
		|| PM_SuperBreakWinAnim(self->client->ps.torsoAnim))
	{
		//can't block while in break anim
		return;
	}

	if (rosh_being_healed(self))
	{
		return;
	}

	if (self->client->NPC_class == CLASS_ROCKETTROOPER)
	{
		//rockettrooper
		if (self->client->ps.groundEntityNum != ENTITYNUM_NONE)
		{
			//must be in air
			return;
		}
		if (Q_irand(0, 4 - g_spskill->integer * 2))
		{
			//easier level guys do this less
			return;
		}
		if (Q_irand(0, 3))
		{
			//base level: 25% chance of looking for something to dodge
			if (Q_irand(0, 1))
			{
				//dodge sabers twice as frequently as other projectiles
				dodge_only_sabers = qtrue;
			}
			else
			{
				return;
			}
		}
	}

	if (self->client->NPC_class == CLASS_BOBAFETT || self->client->NPC_class == CLASS_MANDALORIAN)
	{
		//Boba doesn't dodge quite as much
		if (Q_irand(0, 2 - g_spskill->integer))
		{
			//easier level guys do this less
			return;
		}
	}

	if (self->client->NPC_class != CLASS_BOBAFETT && self->client->NPC_class != CLASS_MANDALORIAN && self->client->
		NPC_class != CLASS_JANGO && self->client->NPC_class != CLASS_JANGODUAL
		&& (self->client->NPC_class != CLASS_REBORN || self->s.weapon == WP_SABER)
		&& (self->client->NPC_class != CLASS_ROCKETTROOPER || !self->NPC || self->NPC->rank < RANK_LT))
	{
		if (ucmd->buttons & BUTTON_USE && !(ucmd->buttons & BUTTON_WALKING)
			&& cg.renderingThirdPerson
			&& G_OkayToLean(&self->client->ps, ucmd, qfalse)
			&& self->client->ps.forcePowersActive & 1 << FP_SPEED)
		{
		}
		else
		{
			if (self->client->ps.weapon != WP_SABER)
			{
				return;
			}

			if (self->client->ps.saberInFlight)
			{
				return;
			}

			if (self->s.number < MAX_CLIENTS)
			{
				if (!self->client->ps.SaberLength())
				{
					//player doesn't auto-activate
					return;
				}
			}

			if (self->client->ps.saber[0].saberFlags & SFL_NOT_ACTIVE_BLOCKING)
			{
				//can't actively block with this saber type
				return;
			}
		}

		if (!self->s.number)
		{
			//don't do this if already attacking!
			if (ucmd->buttons & BUTTON_ATTACK
				|| PM_SaberInAttack(self->client->ps.saber_move)
				|| pm_saber_in_special_attack(self->client->ps.torsoAnim)
				|| PM_SaberInTransitionAny(self->client->ps.saber_move))
			{
				return;
			}
		}

		if (self->client->ps.forcePowerLevel[FP_SABER_DEFENSE] < FORCE_LEVEL_1)
		{
			//you have not the SKILLZ
			return;
		}

		if (self->client->ps.forcePowerDebounce[FP_SABER_DEFENSE] > level.time)
		{
			//can't block while already blocking
			do_full_routine = qfalse;
		}

		if (self->client->ps.forcePowersActive & 1 << FP_LIGHTNING)
		{
			//can't block while zapping
			do_full_routine = qfalse;
		}

		if (self->client->ps.forcePowersActive & 1 << FP_LIGHTNING_STRIKE)
		{
			//can't block while zapping
			do_full_routine = qfalse;
		}

		if (self->client->ps.forcePowersActive & 1 << FP_DRAIN)
		{
			//can't block while draining
			do_full_routine = qfalse;
		}

		if (self->client->ps.forcePowersActive & 1 << FP_PUSH)
		{
			//can't block while shoving
			do_full_routine = qfalse;
		}

		if (self->client->ps.forcePowersActive & 1 << FP_GRIP)
		{
			//can't block while gripping (FIXME: or should it break the grip?  Pain should break the grip, I think...)
			do_full_routine = qfalse;
		}

		if (self->client->ps.forcePowersActive & 1 << FP_GRASP)
		{
			//can't block while gripping (FIXME: or should it break the grip?  Pain should break the grip, I think...)
			do_full_routine = qfalse;
		}

		if (self->client->ps.weaponTime > 0 && !PM_SaberInParry(self->client->ps.saber_move))
		{
			//don't autoblock while busy with stuff
			return;
		}

		if (self->client->ps.SaberLength() <= 0)
		{
			//not on
			return;
		}
	}

	fwdangles[1] = self->client->ps.viewangles[1];
	AngleVectors(fwdangles, forward, nullptr, nullptr);

	for (int i = 0; i < 3; i++)
	{
		mins[i] = self->currentOrigin[i] - radius;
		maxs[i] = self->currentOrigin[i] + radius;
	}

	const int num_listed_entities = gi.EntitiesInBox(mins, maxs, entity_list, MAX_GENTITIES);

	float closest_dist = radius;

	for (int e = 0; e < num_listed_entities; e++)
	{
		vec3_t dir;
		gentity_t* ent = entity_list[e];
		qboolean swing_block = qfalse;

		if (ent == self)
			continue;
		if (ent->owner == self)
			continue;
		if (!ent->inuse)
			continue;
		if (dodge_only_sabers)
		{
			//only care about thrown sabers
			if (ent->client
				|| ent->s.weapon != WP_SABER
				|| !ent->classname
				|| !ent->classname[0]
				|| Q_stricmp("lightsaber", ent->classname))
			{
				//not a lightsaber, ignore it
				continue;
			}
		}
		if (ent->s.eType != ET_MISSILE && !(ent->s.eFlags & EF_MISSILE_STICK))
		{
			//not a normal projectile
			if (ent->client || ent->s.weapon != WP_SABER)
			{
				//FIXME: wake up bad guys?
				continue;
			}
			if (ent->s.eFlags & EF_NODRAW)
			{
				continue;
			}
			if (Q_stricmp("lightsaber", ent->classname) != 0)
			{
				//not a lightsaber
				//FIXME: what about general objects that are small in size- like rocks, etc...
				continue;
			}
			//a lightsaber.. make sure it's on and inFlight
			if (!ent->owner || !ent->owner->client)
			{
				continue;
			}
			if (ent->owner->client->ps.SaberLength() <= 0)
			{
				//not on
				continue;
			}
			if (ent->owner->health <= 0 && g_saberRealisticCombat->integer < 2)
			{
				//it's not doing damage, so ignore it
				continue;
			}

			if (!ent->owner->client->ps.saberInFlight)
			{
				//active saber blade, treat differently.//allow the blocking of normal saber swings
				swing_block = qtrue;
				if (BG_SaberInNonIdleDamageMove(&self->client->ps))
				{
					//attacking
					swing_block_quad = InvertQuad(saber_moveData[self->client->ps.saber_move].startQuad);
				}
				else if (PM_SaberInStart(self->client->ps.saber_move) ||
					PM_SaberInTransition(self->client->ps.saber_move))
				{
					//preparing to attack
					swing_block_quad = InvertQuad(saber_moveData[self->client->ps.saber_move].endQuad);
				}
				else
				{
					//not attacking
					continue;
				}
			}
		}
		else
		{
			if (ent->s.pos.trType == TR_STATIONARY && !self->s.number)
			{
				//nothing you can do with a stationary missile if you're the player
				continue;
			}
		}

		float dot1;
		//see if they're in front of me
		VectorSubtract(ent->currentOrigin, self->currentOrigin, dir);
		const float dist = VectorNormalize(dir);

		if (dist > 150 && swing_block)
		{
			//don't block swings that are too far away.
			continue;
		}

		//handle detpacks, proximity mines and tripmines
		if (ent->s.weapon == WP_THERMAL)
		{
			//thermal detonator!
			if (self->NPC && dist < ent->splashRadius)
			{
				if (dist < ent->splashRadius &&
					ent->nextthink < level.time + 600 &&
					ent->count &&
					self->client->ps.groundEntityNum != ENTITYNUM_NONE &&
					(ent->s.pos.trType == TR_STATIONARY ||
						ent->s.pos.trType == TR_INTERPOLATE ||
						(dot1 = DotProduct(dir, forward)) < SABER_REFLECT_MISSILE_CONE))
				{
					//TD is close enough to hurt me, I'm on the ground and the thing is at rest or behind me and about to blow up, or I don't have force-push so force-jump!
					if (self->client->NPC_class == CLASS_BOBAFETT
						|| self->client->NPC_class == CLASS_MANDALORIAN
						|| self->client->NPC_class == CLASS_ROCKETTROOPER)
					{
						//jump out of the way
						self->client->ps.forceJumpCharge = 480;
						PM_AddFatigue(&self->client->ps, FORCE_LONGJUMP_POWER);
					}
				}
				else if (self->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCK
					&& self->client->NPC_class != CLASS_BOBAFETT
					&& self->client->NPC_class != CLASS_MANDALORIAN
					&& self->client->NPC_class != CLASS_ROCKETTROOPER && self->client->NPC_class != CLASS_GUARD)
				{
					if (!ent->owner || !OnSameTeam(self, ent->owner))
					{
						if (g_SerenityJediEngineMode->integer)
						{
							if (self->client->NPC_class == CLASS_GALEN
								&& (self->s.weapon == WP_MELEE || self->s.weapon == WP_NONE || self->s.weapon ==
									WP_SABER && !self->client->ps.SaberActive())
								&& self->client->ps.groundEntityNum == ENTITYNUM_NONE)
							{
								ForceRepulse(self, qfalse);
							}
							else
							{
								ForceThrow_MD(self, qfalse);
							}
						}
						else
						{
							ForceThrow_JKA(self, qfalse);
						}
						PM_AddFatigue(&self->client->ps, FORCE_DEFLECT_PUSH);
					}
				}
			}
			continue;
		}
		if (ent->splashDamage && ent->splashRadius && !(ent->s.powerups & 1 << PW_FORCE_PROJECTILE))
		{
			//exploding missile
			if (ent->s.pos.trType == TR_STATIONARY && ent->s.eFlags & EF_MISSILE_STICK)
			{
				//a placed explosive like a tripmine or detpack
				if (InFOV(ent->currentOrigin, self->client->renderInfo.eyePoint, self->client->ps.viewangles, 90, 90))
				{
					//in front of me
					if (G_ClearLOS(self, ent))
					{
						//can see it
						vec3_t throw_dir;
						//make the gesture
						if (self->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCK
							&& self->client->NPC_class != CLASS_BOBAFETT
							&& self->client->NPC_class != CLASS_MANDALORIAN
							&& self->client->NPC_class != CLASS_ROCKETTROOPER)
						{
							if (g_SerenityJediEngineMode->integer)
							{
								if (self->client->NPC_class == CLASS_GALEN
									&& (self->s.weapon == WP_MELEE || self->s.weapon == WP_NONE || self->s.weapon ==
										WP_SABER && !self->client->ps.SaberActive())
									&& self->client->ps.groundEntityNum == ENTITYNUM_NONE)
								{
									ForceRepulse(self, qfalse);
								}
								else
								{
									ForceThrow_MD(self, qfalse);
								}
							}
							else
							{
								ForceThrow_JKA(self, qfalse);
							}
							PM_AddFatigue(&self->client->ps, FORCE_DEFLECT_PUSH);
						}
						//take it off the wall and toss it
						ent->s.pos.trType = TR_GRAVITY;
						ent->s.eType = ET_MISSILE;
						ent->s.eFlags &= ~EF_MISSILE_STICK;
						ent->s.eFlags |= EF_BOUNCE_HALF;
						AngleVectors(ent->currentAngles, throw_dir, nullptr, nullptr);
						VectorMA(ent->currentOrigin, ent->maxs[0] + 4, throw_dir, ent->currentOrigin);
						VectorCopy(ent->currentOrigin, ent->s.pos.trBase);
						VectorScale(throw_dir, 300, ent->s.pos.trDelta);
						ent->s.pos.trDelta[2] += 150;
						VectorMA(ent->s.pos.trDelta, 800, dir, ent->s.pos.trDelta);
						ent->s.pos.trTime = level.time; // move a bit on the very first frame
						VectorCopy(ent->currentOrigin, ent->s.pos.trBase);
						ent->owner = self;
						// make it explode, but with less damage
						ent->splashDamage /= 3;
						ent->splashRadius /= 3;
						ent->e_ThinkFunc = thinkF_WP_Explode;
						ent->nextthink = level.time + Q_irand(500, 3000);
					}
				}
			}
			else if (self->s.number
				&& dist < ent->splashRadius
				&& self->client->ps.groundEntityNum != ENTITYNUM_NONE
				&& DotProduct(dir, forward) < SABER_REFLECT_MISSILE_CONE)
			{
				//try to evade it
				if (self->client->NPC_class == CLASS_BOBAFETT
					|| self->client->NPC_class == CLASS_MANDALORIAN
					|| self->client->NPC_class == CLASS_ROCKETTROOPER)
				{
					//jump out of the way
					self->client->ps.forceJumpCharge = 480;
					PM_AddFatigue(&self->client->ps, FORCE_LONGJUMP_POWER);
				}
			}
			else if (self->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCK
				&& self->client->NPC_class != CLASS_BOBAFETT
				&& self->client->NPC_class != CLASS_MANDALORIAN
				&& self->client->NPC_class != CLASS_ROCKETTROOPER)
			{
				if (!ent->owner || !OnSameTeam(self, ent->owner))
				{
					if (!self->s.number && self->client->ps.forcePowerLevel[FP_PUSH] == 1 && dist >= 192)
					{
						//player with push 1 has to wait until it's closer otherwise the push misses
					}
					else
					{
						if (g_SerenityJediEngineMode->integer)
						{
							if (self->client->NPC_class == CLASS_GALEN
								&& (self->s.weapon == WP_MELEE || self->s.weapon == WP_NONE || self->s.weapon ==
									WP_SABER && !self->client->ps.SaberActive())
								&& self->client->ps.groundEntityNum == ENTITYNUM_NONE)
							{
								ForceRepulse(self, qfalse);
							}
							else
							{
								ForceThrow_MD(self, qfalse);
							}
						}
						else
						{
							ForceThrow_JKA(self, qfalse);
						}

						if (g_SerenityJediEngineMode->integer == 2)
						{
							PM_AddFatigue(&self->client->ps, FORCE_DEFLECT_PUSH);
						}
						else
						{
							PM_AddFatigue(&self->client->ps, FORCE_DEFLECT_PUSH);
						}
					}
				}
			}
			//otherwise, can't block it, so we're screwed
			continue;
		}

		if (!do_full_routine)
		{
			//don't care about the rest then
			continue;
		}

		if (ent->s.weapon != WP_SABER)
		{
			//only block shots coming from behind
			if ((dot1 = DotProduct(dir, forward)) < SABER_REFLECT_MISSILE_CONE)
				continue;
		}

		//see if they're heading towards me
		if (!swing_block)
		{
			float dot2;
			vec3_t missile_dir;
			VectorCopy(ent->s.pos.trDelta, missile_dir);
			VectorNormalize(missile_dir);
			if ((dot2 = DotProduct(dir, missile_dir)) > 0)
				continue;
		}

		//FIXME: must have a clear trace to me, too...
		if (dist < closest_dist)
		{
			VectorCopy(self->currentOrigin, trace_to);
			trace_to[2] = self->absmax[2] - 4;
			gi.trace(&trace, ent->currentOrigin, ent->mins, ent->maxs, trace_to, ent->s.number, ent->clipmask,
				static_cast<EG2_Collision>(0), 0);
			if (trace.allsolid || trace.startsolid || trace.fraction < 1.0f && trace.entityNum != self->s.number &&
				trace.entityNum != self->client->ps.saberEntityNum)
			{
				//okay, try one more check
				VectorNormalize2(ent->s.pos.trDelta, ent_dir);
				VectorMA(ent->currentOrigin, radius, ent_dir, trace_to);
				gi.trace(&trace, ent->currentOrigin, ent->mins, ent->maxs, trace_to, ent->s.number, ent->clipmask,
					static_cast<EG2_Collision>(0), 0);
				if (trace.allsolid || trace.startsolid || trace.fraction < 1.0f && trace.entityNum != self->s.number &&
					trace.entityNum != self->client->ps.saberEntityNum)
				{
					//can't hit me, ignore it
					continue;
				}
			}
			if (self->s.number != 0)
			{
				//An NPC
				if (self->NPC && !self->enemy && ent->owner)
				{
					if (ent->owner->health >= 0 && (!ent->owner->client || ent->owner->client->playerTeam != self->
						client->playerTeam))
					{
						G_SetEnemy(self, ent->owner);
					}
				}
			}
			//FIXME: if NPC, predict the intersection between my current velocity/path and the missile's, see if it intersects my bounding box (+/-saberLength?), don't try to deflect unless it does?
			closest_dist = dist;
			incoming = ent;
			closest_swing_block = swing_block;
			closestSwingQuad = swing_block_quad;
		}
	}

	if (!do_full_routine)
	{
		//then we're done now
		return;
	}

	if (incoming)
	{
		if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self))
		{
			if (jedi_waiting_ambush(self))
			{
				jedi_ambush(self);
			}
			if ((self->client->NPC_class == CLASS_BOBAFETT ||
				self->client->NPC_class == CLASS_MANDALORIAN || self->client->NPC_class == CLASS_ROCKETTROOPER)
				&& self->client->moveType == MT_FLYSWIM
				&& incoming->methodOfDeath != MOD_ROCKET_ALT)
			{
				//a hovering Boba Fett, not a tracking rocket
				if (!Q_irand(0, 1))
				{
					//strafe
					self->NPC->standTime = 0;
					self->client->ps.forcePowerDebounce[FP_SABER_DEFENSE] = level.time + Q_irand(1000, 2000);
				}
				if (!Q_irand(0, 1))
				{
					//go up/down
					TIMER_Set(self, "heightChange", Q_irand(1000, 3000));
					self->client->ps.forcePowerDebounce[FP_SABER_DEFENSE] = level.time + Q_irand(1000, 2000);
				}
			}
			else if (jedi_saber_block_go(self, &self->NPC->last_ucmd, nullptr, nullptr, incoming) != EVASION_NONE)
			{
				//make sure to turn on your saber if it's not on
				if (self->client->NPC_class != CLASS_BOBAFETT
					&& self->client->NPC_class != CLASS_ROCKETTROOPER
					&& self->client->NPC_class != CLASS_MANDALORIAN
					&& self->client->NPC_class != CLASS_JANGO
					&& self->client->NPC_class != CLASS_JANGODUAL
					&& (self->client->NPC_class != CLASS_REBORN)
					&& (self->client->NPC_class != CLASS_GROGU))
				{
					//make sure to turn on your saber if it's not on
					if (self->s.weapon == WP_SABER)
					{
						self->client->ps.SaberActivate();
					}
				}
			}
		}
		else //player
		{
			gentity_t* blocker = &g_entities[incoming->ownerNum];

			if (self->client && !self->client->ps.SaberActive())
			{
				self->client->ps.SaberActivate();
			}
			if (closest_swing_block && blocker->health > 0)
			{
				blocker->client->ps.saberBlocked = BlockedforQuad(closestSwingQuad);
				blocker->client->ps.userInt3 |= 1 << FLAG_PREBLOCK;
			}
			else if (blocker->health > 0 && (blocker->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCK || blocker->client->ps.ManualBlockingFlags & 1 << MBF_NPCBLOCKING))
			{
				WP_SaberBlockNonRandom(blocker, incoming->currentOrigin, qtrue);
			}
			else
			{
				vec3_t diff, start, end;
				VectorSubtract(incoming->currentOrigin, self->currentOrigin, diff);
				const float dist = VectorLength(diff);
				VectorNormalize2(incoming->s.pos.trDelta, ent_dir);
				VectorMA(incoming->currentOrigin, dist, ent_dir, start);
				VectorCopy(self->currentOrigin, end);
				end[2] += self->maxs[2] * 0.75f;
				gi.trace(&trace, start, incoming->mins, incoming->maxs, end, incoming->s.number, MASK_SHOT, G2_COLLIDE, 10);

				jedi_dodge_evasion(self, incoming->owner, &trace, HL_NONE);
			}
			if (incoming->owner && incoming->owner->client && (!self->enemy || self->enemy->s.weapon != WP_SABER))
			{
				self->enemy = incoming->owner;
				NPC_SetLookTarget(self, incoming->owner->s.number, level.time + 1000);
			}
		}
	}
}

//GENERAL SABER============================================================================
//GENERAL SABER============================================================================
//GENERAL SABER============================================================================
//GENERAL SABER============================================================================
//GENERAL SABER============================================================================

static void WP_SetSaberMove(const gentity_t* self, const short blocked)
{
	self->client->ps.saberBlocked = blocked;
}

extern void CG_CubeOutline(vec3_t mins, vec3_t maxs, int time, unsigned int color);

void WP_SaberUpdateJKA(gentity_t* self, const usercmd_t* ucmd)
{
	float minsize = 16;

	const qboolean npc_blocking = self->client->ps.ManualBlockingFlags & 1 << MBF_NPCBLOCKING ? qtrue : qfalse;
	const qboolean holding_block_and_attack = self->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCKANDATTACK
		? qtrue
		: qfalse;
	const qboolean is_holding_block_button = self->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCK ? qtrue : qfalse;

	if (!self->client)
	{
		return;
	}

	if (self->client->ps.saberEntityNum < 0 || self->client->ps.saberEntityNum >= ENTITYNUM_WORLD)
	{
		//never got one
		return;
	}

	// Check if we are throwing it, launch it if needed, update position if needed.
	WP_SaberThrow(self, ucmd);

	if (self->client->ps.saberEntityNum <= 0)
	{
		//WTF?!!  We lost it?
		return;
	}

	gentity_t* saberent = &g_entities[self->client->ps.saberEntityNum];

	if (self->client->ps.saberBlocked != BLOCKED_NONE)
	{
		//we're blocking, increase min size
		minsize = 32;
	}

	if (G_InCinematicSaberAnim(self))
	{
		//fake some blocking
		self->client->ps.saberBlocking = BLK_TIGHT;
		if (self->client->ps.saber[0].Active())
		{
			self->client->ps.saber[0].ActivateTrail(150);
		}
		if (self->client->ps.saber[1].Active())
		{
			self->client->ps.saber[1].ActivateTrail(150);
		}
	}

	//is our saber in flight?
	if (!self->client->ps.saberInFlight)
	{
		// It isn't, which means we can update its position as we will.
		qboolean always_block[MAX_SABERS][MAX_BLADES]{};
		qboolean force_block = qfalse;
		qboolean no_blocking = qfalse;

		//clear out last frame's numbers
		VectorClear(saberent->mins);
		VectorClear(saberent->maxs);

		const Vehicle_t* p_veh = G_IsRidingVehicle(self);
		if (!self->client->ps.SaberActive()
			|| !self->client->ps.saberBlocking
			|| PM_InKnockDown(&self->client->ps)
			|| PM_SuperBreakLoseAnim(self->client->ps.torsoAnim)
			|| p_veh && p_veh->m_pVehicleInfo && p_veh->m_pVehicleInfo->type != VH_ANIMAL
			&& p_veh->m_pVehicleInfo->type != VH_FLIER) //riding a vehicle that you cannot block shots on
		{
			//can't block if saber isn't on
			int j;
			for (int i = 0; i < MAX_SABERS; i++)
			{
				//initialize to not blocking
				for (j = 0; j < MAX_BLADES; j++)
				{
					always_block[i][j] = qfalse;
				}
				if (i > 0 && !self->client->ps.dualSabers)
				{
					//not using a second saber, leave it not blocking
				}
				else
				{
					if (self->client->ps.saber[i].saberFlags2 & SFL2_ALWAYS_BLOCK)
					{
						for (j = 0; j < self->client->ps.saber[i].numBlades; j++)
						{
							always_block[i][j] = qtrue;
							force_block = qtrue;
						}
					}
					if (self->client->ps.saber[i].bladeStyle2Start > 0)
					{
						for (j = self->client->ps.saber[i].bladeStyle2Start; j < self->client->ps.saber[i].numBlades; j
							++)
						{
							if (self->client->ps.saber[i].saberFlags2 & SFL2_ALWAYS_BLOCK2)
							{
								always_block[i][j] = qtrue;
								force_block = qtrue;
							}
							else
							{
								always_block[i][j] = qfalse;
							}
						}
					}
				}
			}
			if (!force_block)
			{
				no_blocking = qtrue;
			}
			else if (!self->client->ps.saberBlocking)
			{
				//turn blocking on!
				self->client->ps.saberBlocking = BLK_TIGHT;
			}
		}
		if (no_blocking)
		{
			G_SetOrigin(saberent, self->currentOrigin);
		}
		else if (self->client->ps.saberBlocking == BLK_TIGHT || self->client->ps.saberBlocking == BLK_WIDE)
		{
			vec3_t saber_org;

			if (!force_block
				&& (self->s.number && !jedi_saber_busy(self) && !g_saberRealisticCombat->integer
					|| npc_blocking && self->NPC && !G_ControlledByPlayer(self)
					|| (is_holding_block_button && self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self))
					|| (holding_block_and_attack && self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self))
					|| self->s.number == 0 && self->client->ps.saberBlocking == BLK_WIDE && (g_saberAutoBlocking->
						integer || self->client->ps.saberBlockingTime > level.time))
				&& self->client->ps.weaponTime <= 0
				&& !G_InCinematicSaberAnim(self))
			{
				//full-size blocking for non-attacking player with g_saberAutoBlocking on
				vec3_t fwd;
				vec3_t saberang = { 0, 0, 0 };
				constexpr vec3_t sabermaxs = { 8, 8, 8 };
				constexpr vec3_t sabermins = { -8, -8, -8 };

				saberang[YAW] = self->client->ps.viewangles[YAW];
				AngleVectors(saberang, fwd, nullptr, nullptr);

				VectorMA(self->currentOrigin, 12, fwd, saber_org);

				VectorAdd(self->mins, sabermins, saberent->mins);
				VectorAdd(self->maxs, sabermaxs, saberent->maxs);

				saberent->contents = CONTENTS_LIGHTSABER;

				G_SetOrigin(saberent, saber_org);
			}
			else if (!force_block
				&& (self->s.number && NPC_IsOversized(self)
					|| npc_blocking && self->NPC && !G_ControlledByPlayer(self)
					|| (is_holding_block_button && self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self))
					|| (holding_block_and_attack && self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self))
					|| self->s.number == 0 && self->client->ps.saberBlocking == BLK_WIDE && (g_saberAutoBlocking->
						integer || self->client->ps.saberBlockingTime > level.time))
				&& self->client->ps.weaponTime <= 0
				&& !G_InCinematicSaberAnim(self))
			{
				//full-size blocking for non-attacking player with g_saberAutoBlocking on
				vec3_t fwd;
				vec3_t saberang = { 0, 0, 0 };
				constexpr vec3_t sabermaxs = { 8, 8, 8 };
				constexpr vec3_t sabermins = { -8, -8, -8 };

				saberang[YAW] = self->client->ps.viewangles[YAW];
				AngleVectors(saberang, fwd, nullptr, nullptr);

				VectorMA(self->currentOrigin, 12, fwd, saber_org);

				VectorAdd(self->mins, sabermins, saberent->mins);
				VectorAdd(self->maxs, sabermaxs, saberent->maxs);

				saberent->contents = CONTENTS_LIGHTSABER;

				G_SetOrigin(saberent, saber_org);
			}
			else
			{
				int num_sabers = 1;
				if (self->client->ps.dualSabers)
				{
					num_sabers = 2;
				}
				for (int saber_num = 0; saber_num < num_sabers; saber_num++)
				{
					for (int blade_num = 0; blade_num < self->client->ps.saber[saber_num].numBlades; blade_num++)
					{
						vec3_t saber_tip;
						vec3_t saber_base;
						if (self->client->ps.saber[saber_num].blade[blade_num].length <= 0.0f)
						{
							//don't include blades that are not on...
							continue;
						}
						if (force_block)
						{
							//doing blade-specific bbox-sizing only, see if this blade should be counted
							if (!always_block[saber_num][blade_num])
							{
								//this blade doesn't count right now
								continue;
							}
						}
						VectorCopy(self->client->ps.saber[saber_num].blade[blade_num].muzzlePoint, saber_base);
						VectorMA(saber_base, self->client->ps.saber[saber_num].blade[blade_num].length,
							self->client->ps.saber[saber_num].blade[blade_num].muzzleDir, saber_tip);
						VectorMA(saber_base, self->client->ps.saber[saber_num].blade[blade_num].length * 0.5,
							self->client->ps.saber[saber_num].blade[blade_num].muzzleDir, saber_org);
						for (int i = 0; i < 3; i++)
						{
							float new_size_tip = saber_tip[i] - saber_org[i];
							new_size_tip += new_size_tip >= 0 ? 8 : -8;
							float new_size_base = saber_base[i] - saber_org[i];
							new_size_base += new_size_base >= 0 ? 8 : -8;
							if (new_size_tip > saberent->maxs[i])
							{
								saberent->maxs[i] = new_size_tip;
							}
							if (new_size_base > saberent->maxs[i])
							{
								saberent->maxs[i] = new_size_base;
							}
							if (new_size_tip < saberent->mins[i])
							{
								saberent->mins[i] = new_size_tip;
							}
							if (new_size_base < saberent->mins[i])
							{
								saberent->mins[i] = new_size_base;
							}
						}
					}
				}
				if (!force_block)
				{
					//not doing special "alwaysBlock" bbox
					if (self->client->ps.weaponTime > 0
						|| self->s.number
						|| g_saberAutoBlocking->integer
						|| self->client->ps.saberBlockingTime > level.time)
					{
						//if attacking or blocking (or an NPC), inflate to a minimum size
						for (int i = 0; i < 3; i++)
						{
							if (saberent->maxs[i] < minsize)
							{
								saberent->maxs[i] = minsize;
							}
							if (saberent->mins[i] > -minsize)
							{
								saberent->mins[i] = -minsize;
							}
						}
					}
				}
				saberent->contents = CONTENTS_LIGHTSABER;
				G_SetOrigin(saberent, saber_org);
			}
		}
		else
		{
			G_SetOrigin(saberent, self->currentOrigin);
		}
		saberent->clipmask = MASK_SHOT | CONTENTS_LIGHTSABER;
		gi.linkentity(saberent);
	}
	else
	{
		WP_SaberInFlightReflectCheck(self);
	}

#ifndef FINAL_BUILD
	if (d_saberCombat->integer > 2)
	{
		CG_CubeOutline(saberent->absmin, saberent->absmax, 50, WPDEBUG_SaberColor(self->client->ps.saber[0].blade[0].color), 1);
	}
#endif

	if (d_saberinfo->integer || g_DebugSaberCombat->integer)
	{
		CG_CubeOutline(saberent->absmin, saberent->absmax, 10,
			WPDEBUG_SaberColor(self->client->ps.saber[0].blade[0].color));
	}
}

void WP_SaberUpdateMD(gentity_t* self, const usercmd_t* ucmd)
{
	float minsize = 16;

	const qboolean holding_block_and_attack = self->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCKANDATTACK
		? qtrue
		: qfalse;
	const qboolean is_holding_block_button = self->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCK ? qtrue : qfalse;

	if (!self->client)
	{
		return;
	}

	if (self->client->ps.saberEntityNum < 0 || self->client->ps.saberEntityNum >= ENTITYNUM_WORLD)
	{
		//never got one
		return;
	}

	// Check if we are throwing it, launch it if needed, update position if needed.
	WP_SaberThrow(self, ucmd);

	if (self->client->ps.saberEntityNum <= 0)
	{
		//WTF?!!  We lost it?
		return;
	}

	gentity_t* saberent = &g_entities[self->client->ps.saberEntityNum];

	if (self->client->ps.saberBlocked != BLOCKED_NONE)
	{
		//we're blocking, increase min size
		minsize = 32;
	}

	if (G_InCinematicSaberAnim(self))
	{
		//fake some blocking
		self->client->ps.saberBlocking = BLK_TIGHT;
		if (self->client->ps.saber[0].Active())
		{
			self->client->ps.saber[0].ActivateTrail(150);
		}
		if (self->client->ps.saber[1].Active())
		{
			self->client->ps.saber[1].ActivateTrail(150);
		}
	}

	//is our saber in flight?
	if (!self->client->ps.saberInFlight)
	{
		// It isn't, which means we can update its position as we will.
		qboolean always_block[MAX_SABERS][MAX_BLADES]{};
		qboolean force_block = qfalse;
		qboolean no_blocking = qfalse;

		//clear out last frame's numbers
		VectorClear(saberent->mins);
		VectorClear(saberent->maxs);

		const Vehicle_t* p_veh = G_IsRidingVehicle(self);

		if (!self->client->ps.SaberActive()
			|| !self->client->ps.saberBlocking
			|| PM_InKnockDown(&self->client->ps)
			|| PM_SuperBreakLoseAnim(self->client->ps.torsoAnim)
			|| p_veh && p_veh->m_pVehicleInfo && p_veh->m_pVehicleInfo->type != VH_ANIMAL && p_veh->m_pVehicleInfo->type
			!= VH_FLIER) //riding a vehicle that you cannot block shots on
		{
			//can't block if saber isn't on
			int j;
			for (int i = 0; i < MAX_SABERS; i++)
			{
				//initialize to not blocking
				for (j = 0; j < MAX_BLADES; j++)
				{
					always_block[i][j] = qfalse;
				}
				if (i > 0 && !self->client->ps.dualSabers)
				{
					//not using a second saber, leave it not blocking
				}
				else
				{
					if (self->client->ps.saber[i].saberFlags2 & SFL2_ALWAYS_BLOCK)
					{
						for (j = 0; j < self->client->ps.saber[i].numBlades; j++)
						{
							always_block[i][j] = qtrue;
							force_block = qtrue;
						}
					}
					if (self->client->ps.saber[i].bladeStyle2Start > 0)
					{
						for (j = self->client->ps.saber[i].bladeStyle2Start; j < self->client->ps.saber[i].numBlades; j
							++)
						{
							if (self->client->ps.saber[i].saberFlags2 & SFL2_ALWAYS_BLOCK2)
							{
								always_block[i][j] = qtrue;
								force_block = qtrue;
							}
							else
							{
								always_block[i][j] = qfalse;
							}
						}
					}
				}
			}
			if (!force_block)
			{
				no_blocking = qtrue;
			}
			else if (!self->client->ps.saberBlocking)
			{
				//turn blocking on!
				self->client->ps.saberBlocking = BLK_TIGHT;
			}
		}
		if (no_blocking)
		{
			G_SetOrigin(saberent, self->currentOrigin);
		}
		else if (self->client->ps.saberBlocking == BLK_TIGHT || self->client->ps.saberBlocking == BLK_WIDE)
		{
			vec3_t saber_org;

			if (!force_block
				&& (self->s.number && !jedi_saber_busy(self)
					|| self->s.number == 0 && self->client->ps.saberBlocking == BLK_WIDE
					&& (g_saberAutoBlocking->integer || self->client->ps.saberBlockingTime > level.time))
				&& self->client->ps.weaponTime <= 0
				&& !G_InCinematicSaberAnim(self))
			{
				//Just standing not attacking
				if (is_holding_block_button && !holding_block_and_attack)
				{
					// holding block small box
					int num_sabers = 1;
					if (self->client->ps.dualSabers)
					{
						num_sabers = 2;
					}
					for (int saber_num = 0; saber_num < num_sabers; saber_num++)
					{
						for (int blade_num = 0; blade_num < self->client->ps.saber[saber_num].numBlades; blade_num++)
						{
							vec3_t saber_tip;
							vec3_t saber_base;
							if (self->client->ps.saber[saber_num].blade[blade_num].length <= 0.0f)
							{
								//don't include blades that are not on...
								continue;
							}
							if (force_block)
							{
								//doing blade-specific bbox-sizing only, see if this blade should be counted
								if (!always_block[saber_num][blade_num])
								{
									//this blade doesn't count right now
									continue;
								}
							}
							VectorCopy(self->client->ps.saber[saber_num].blade[blade_num].muzzlePoint, saber_base);
							VectorMA(saber_base, self->client->ps.saber[saber_num].blade[blade_num].length,
								self->client->ps.saber[saber_num].blade[blade_num].muzzleDir, saber_tip);
							VectorMA(saber_base, self->client->ps.saber[saber_num].blade[blade_num].length * 0.5,
								self->client->ps.saber[saber_num].blade[blade_num].muzzleDir, saber_org);
							for (int i = 0; i < 3; i++)
							{
								float new_size_tip = saber_tip[i] - saber_org[i];
								new_size_tip += new_size_tip >= 0 ? 8 : -8;
								float new_size_base = saber_base[i] - saber_org[i];
								new_size_base += new_size_base >= 0 ? 8 : -8;
								if (new_size_tip > saberent->maxs[i])
								{
									saberent->maxs[i] = new_size_tip;
								}
								if (new_size_base > saberent->maxs[i])
								{
									saberent->maxs[i] = new_size_base;
								}
								if (new_size_tip < saberent->mins[i])
								{
									saberent->mins[i] = new_size_tip;
								}
								if (new_size_base < saberent->mins[i])
								{
									saberent->mins[i] = new_size_base;
								}
							}
						}
					}
					if (!force_block)
					{
						//not doing special "alwaysBlock" bbox
						if (self->client->ps.weaponTime > 0
							|| self->s.number
							|| g_saberAutoBlocking->integer
							|| self->client->ps.saberBlockingTime > level.time)
						{
							//if attacking or blocking (or an NPC), inflate to a minimum size
							for (int i = 0; i < 3; i++)
							{
								if (saberent->maxs[i] < minsize)
								{
									saberent->maxs[i] = minsize;
								}
								if (saberent->mins[i] > -minsize)
								{
									saberent->mins[i] = -minsize;
								}
							}
						}
					}
					saberent->contents = CONTENTS_LIGHTSABER;
					G_SetOrigin(saberent, saber_org);

					if (d_saberinfo->integer || g_DebugSaberCombat->integer)
					{
						//gi.Printf(S_COLOR_ORANGE" holding block small box\n");
					}
				}
				else if (holding_block_and_attack)
				{
					// holding block + attack big box
					vec3_t fwd;
					vec3_t saberang = { 0, 0, 0 };
					constexpr vec3_t sabermaxs = { 8, 8, 8 };
					constexpr vec3_t sabermins = { -8, -8, -8 };

					saberang[YAW] = self->client->ps.viewangles[YAW];
					AngleVectors(saberang, fwd, nullptr, nullptr);

					VectorMA(self->currentOrigin, 12, fwd, saber_org);

					VectorAdd(self->mins, sabermins, saberent->mins);
					VectorAdd(self->maxs, sabermaxs, saberent->maxs);

					saberent->contents = CONTENTS_LIGHTSABER;

					G_SetOrigin(saberent, saber_org);
				}
				else
				{
					// just holding nothing small box just for impact trace
					int num_sabers = 1;
					if (self->client->ps.dualSabers)
					{
						num_sabers = 2;
					}
					for (int saber_num = 0; saber_num < num_sabers; saber_num++)
					{
						for (int blade_num = 0; blade_num < self->client->ps.saber[saber_num].numBlades; blade_num++)
						{
							vec3_t saber_tip;
							vec3_t saber_base;
							if (self->client->ps.saber[saber_num].blade[blade_num].length <= 0.0f)
							{
								//don't include blades that are not on...
								continue;
							}
							if (force_block)
							{
								//doing blade-specific bbox-sizing only, see if this blade should be counted
								if (!always_block[saber_num][blade_num])
								{
									//this blade doesn't count right now
									continue;
								}
							}
							VectorCopy(self->client->ps.saber[saber_num].blade[blade_num].muzzlePoint, saber_base);
							VectorMA(saber_base, self->client->ps.saber[saber_num].blade[blade_num].length,
								self->client->ps.saber[saber_num].blade[blade_num].muzzleDir, saber_tip);
							VectorMA(saber_base, self->client->ps.saber[saber_num].blade[blade_num].length * 0.5,
								self->client->ps.saber[saber_num].blade[blade_num].muzzleDir, saber_org);
							for (int i = 0; i < 3; i++)
							{
								float new_size_tip = saber_tip[i] - saber_org[i];
								new_size_tip += new_size_tip >= 0 ? 8 : -8;
								float new_size_base = saber_base[i] - saber_org[i];
								new_size_base += new_size_base >= 0 ? 8 : -8;
								if (new_size_tip > saberent->maxs[i])
								{
									saberent->maxs[i] = new_size_tip;
								}
								if (new_size_base > saberent->maxs[i])
								{
									saberent->maxs[i] = new_size_base;
								}
								if (new_size_tip < saberent->mins[i])
								{
									saberent->mins[i] = new_size_tip;
								}
								if (new_size_base < saberent->mins[i])
								{
									saberent->mins[i] = new_size_base;
								}
							}
						}
					}
					if (!force_block)
					{
						//not doing special "alwaysBlock" bbox
						if (self->client->ps.weaponTime > 0
							|| self->s.number
							|| g_saberAutoBlocking->integer
							|| self->client->ps.saberBlockingTime > level.time)
						{
							//if attacking or blocking (or an NPC), inflate to a minimum size
							for (int i = 0; i < 3; i++)
							{
								if (saberent->maxs[i] < minsize)
								{
									saberent->maxs[i] = minsize;
								}
								if (saberent->mins[i] > -minsize)
								{
									saberent->mins[i] = -minsize;
								}
							}
						}
					}
					saberent->contents = CONTENTS_LIGHTSABER;
					G_SetOrigin(saberent, saber_org);
				}
			}
			else
			{
				// must be swinging the saber small box
				int num_sabers = 1;
				if (self->client->ps.dualSabers)
				{
					num_sabers = 2;
				}
				for (int saber_num = 0; saber_num < num_sabers; saber_num++)
				{
					for (int blade_num = 0; blade_num < self->client->ps.saber[saber_num].numBlades; blade_num++)
					{
						vec3_t saber_tip;
						vec3_t saber_base;
						if (self->client->ps.saber[saber_num].blade[blade_num].length <= 0.0f)
						{
							//don't include blades that are not on...
							continue;
						}
						if (force_block)
						{
							//doing blade-specific bbox-sizing only, see if this blade should be counted
							if (!always_block[saber_num][blade_num])
							{
								//this blade doesn't count right now
								continue;
							}
						}
						VectorCopy(self->client->ps.saber[saber_num].blade[blade_num].muzzlePoint, saber_base);
						VectorMA(saber_base, self->client->ps.saber[saber_num].blade[blade_num].length,
							self->client->ps.saber[saber_num].blade[blade_num].muzzleDir, saber_tip);
						VectorMA(saber_base, self->client->ps.saber[saber_num].blade[blade_num].length * 0.5,
							self->client->ps.saber[saber_num].blade[blade_num].muzzleDir, saber_org);
						for (int i = 0; i < 3; i++)
						{
							float new_size_tip = saber_tip[i] - saber_org[i];
							new_size_tip += new_size_tip >= 0 ? 8 : -8;
							float new_size_base = saber_base[i] - saber_org[i];
							new_size_base += new_size_base >= 0 ? 8 : -8;
							if (new_size_tip > saberent->maxs[i])
							{
								saberent->maxs[i] = new_size_tip;
							}
							if (new_size_base > saberent->maxs[i])
							{
								saberent->maxs[i] = new_size_base;
							}
							if (new_size_tip < saberent->mins[i])
							{
								saberent->mins[i] = new_size_tip;
							}
							if (new_size_base < saberent->mins[i])
							{
								saberent->mins[i] = new_size_base;
							}
						}
					}
				}
				if (!force_block)
				{
					//not doing special "alwaysBlock" bbox
					if (self->client->ps.weaponTime > 0
						|| self->s.number
						|| g_saberAutoBlocking->integer
						|| self->client->ps.saberBlockingTime > level.time)
					{
						//if attacking or blocking (or an NPC), inflate to a minimum size
						for (int i = 0; i < 3; i++)
						{
							if (saberent->maxs[i] < minsize)
							{
								saberent->maxs[i] = minsize;
							}
							if (saberent->mins[i] > -minsize)
							{
								saberent->mins[i] = -minsize;
							}
						}
					}
				}
				saberent->contents = CONTENTS_LIGHTSABER;
				G_SetOrigin(saberent, saber_org);
			}
		}
		else
		{
			// Otherwise there is no blocking possible.
			G_SetOrigin(saberent, self->currentOrigin);
		}
		saberent->clipmask = MASK_SHOT | CONTENTS_LIGHTSABER;
		gi.linkentity(saberent);
	}
	else
	{
		WP_SaberInFlightReflectCheck(self);
	}

	if (d_saberinfo->integer || g_DebugSaberCombat->integer)
	{
		CG_CubeOutline(saberent->absmin, saberent->absmax, 10,
			WPDEBUG_SaberColor(self->client->ps.saber[0].blade[0].color));
	}
}

constexpr auto MAX_RADIUS_ENTS = 256; //NOTE: This can cause entities to be lost;
qboolean G_CheckEnemyPresence(const gentity_t* ent, const int dir, const float radius, const float tolerance)
{
	gentity_t* radius_ents[MAX_RADIUS_ENTS];
	vec3_t mins{}, maxs{};
	vec3_t check_dir;
	int i;

	switch (dir)
	{
	case DIR_RIGHT:
		AngleVectors(ent->currentAngles, nullptr, check_dir, nullptr);
		break;
	case DIR_LEFT:
		AngleVectors(ent->currentAngles, nullptr, check_dir, nullptr);
		VectorScale(check_dir, -1, check_dir);
		break;
	case DIR_FRONT:
		AngleVectors(ent->currentAngles, check_dir, nullptr, nullptr);
		break;
	case DIR_BACK:
		AngleVectors(ent->currentAngles, check_dir, nullptr, nullptr);
		VectorScale(check_dir, -1, check_dir);
		break;
	default:;
	}
	//Get all ents in range, see if they're living clients and enemies, then check dot to them...

	//Setup the bbox to search in
	for (i = 0; i < 3; i++)
	{
		mins[i] = ent->currentOrigin[i] - radius;
		maxs[i] = ent->currentOrigin[i] + radius;
	}

	//Get a number of entities in a given space
	const int num_ents = gi.EntitiesInBox(mins, maxs, radius_ents, MAX_RADIUS_ENTS);

	for (i = 0; i < num_ents; i++)
	{
		vec3_t dir2_check_ent;
		//Don't consider self
		if (radius_ents[i] == ent)
			continue;

		//Must be valid
		if (G_ValidEnemy(ent, radius_ents[i]) == qfalse)
			continue;

		VectorSubtract(radius_ents[i]->currentOrigin, ent->currentOrigin, dir2_check_ent);
		const float dist = VectorNormalize(dir2_check_ent);
		if (dist <= radius
			&& DotProduct(dir2_check_ent, check_dir) >= tolerance)
		{
			//stop on the first one
			return qtrue;
		}
	}

	return qfalse;
}

//OTHER JEDI POWERS=========================================================================
//OTHER JEDI POWERS=========================================================================
//OTHER JEDI POWERS=========================================================================
//OTHER JEDI POWERS=========================================================================
//OTHER JEDI POWERS=========================================================================
extern gentity_t* TossClientItems(gentity_t* self);
extern void ChangeWeapon(const gentity_t* ent, int new_weapon);

void WP_DropWeapon(gentity_t* dropper, vec3_t velocity)
{
	if (!dropper || !dropper->client)
	{
		return;
	}
	int replace_weap = WP_NONE;
	const int old_weap = dropper->s.weapon;
	gentity_t* weapon = TossClientItems(dropper);
	if (old_weap == WP_THERMAL && dropper->NPC)
	{
		//Hmm, maybe all NPCs should go into melee?  Not too many, though, or they mob you and look silly
		replace_weap = WP_MELEE;
	}
	if (dropper->ghoul2.IsValid())
	{
		if (dropper->weaponModel[0] > 0)
		{
			//NOTE: guess you never drop the left-hand weapon, eh?
			gi.G2API_RemoveGhoul2Model(dropper->ghoul2, dropper->weaponModel[0]);
			dropper->weaponModel[0] = -1;
		}
	}
	//FIXME: does this work on the player?
	dropper->client->ps.weapons[replace_weap] = 1;
	if (!dropper->s.number)
	{
		if (old_weap == WP_THERMAL)
		{
			dropper->client->ps.ammo[weaponData[old_weap].ammoIndex] -= weaponData[old_weap].energyPerShot;
		}
		else
		{
			dropper->client->ps.weapons[old_weap] = 0;
		}
		CG_ChangeWeapon(replace_weap);
	}
	else
	{
		dropper->client->ps.weapons[old_weap] = 0;
	}
	ChangeWeapon(dropper, replace_weap);
	dropper->s.weapon = replace_weap;
	if (dropper->NPC)
	{
		dropper->NPC->last_ucmd.weapon = replace_weap;
	}
	if (weapon != nullptr && velocity && !VectorCompare(velocity, vec3_origin))
	{
		//weapon should have a direction to it's throw
		VectorScale(velocity, 3, weapon->s.pos.trDelta); //NOTE: Presumes it is moving already...?
		if (weapon->s.pos.trDelta[2] < 150)
		{
			//this is presuming you don't want them to drop the weapon down on you...
			weapon->s.pos.trDelta[2] = 150;
		}
		//FIXME: gets stuck inside it's former owner...
		weapon->forcePushTime = level.time + 600; // let the push effect last for 600 ms
	}
}

void WP_KnockdownTurret(gentity_t* pas)
{
	//knock it over
	VectorCopy(pas->currentOrigin, pas->s.pos.trBase);
	pas->s.pos.trType = TR_LINEAR_STOP;
	pas->s.pos.trDuration = 250;
	pas->s.pos.trTime = level.time;
	pas->s.pos.trDelta[2] = 12.0f / (pas->s.pos.trDuration * 0.001f);

	VectorCopy(pas->currentAngles, pas->s.apos.trBase);
	pas->s.apos.trType = TR_LINEAR_STOP;
	pas->s.apos.trDuration = 250;
	pas->s.apos.trTime = level.time;
	//FIXME: pick pitch/roll that always tilts it directly away from pusher
	pas->s.apos.trDelta[PITCH] = 100.0f / (pas->s.apos.trDuration * 0.001f);

	//kill it
	pas->count = 0;
	pas->nextthink = -1;
	G_Sound(pas, G_SoundIndex("sound/chars/turret/shutdown.wav"));
	//push effect?
	pas->forcePushTime = level.time + 600; // let the push effect last for 600 ms
}

static void WP_ForceThrowHazardTrooper(gentity_t* self, gentity_t* trooper, const qboolean pull)
{
	if (!self || !self->client)
	{
		return;
	}
	if (!trooper || !trooper->client)
	{
		return;
	}

	//all levels: see effect on them, they notice us
	trooper->forcePushTime = level.time + 600; // let the push effect last for 600 ms

	if (pull && self->client->ps.forcePowerLevel[FP_PULL] > FORCE_LEVEL_1
		|| !pull && self->client->ps.forcePowerLevel[FP_PUSH] > FORCE_LEVEL_1)
	{
		//level 2: they stop for a couple seconds and make a sound
		trooper->painDebounceTime = level.time + Q_irand(1500, 2500);
		G_AddVoiceEvent(trooper, Q_irand(EV_PUSHED1, EV_PUSHED3), Q_irand(1000, 3000));
		GEntity_PainFunc(trooper, self, self, trooper->currentOrigin, 0, MOD_MELEE);

		if (pull && self->client->ps.forcePowerLevel[FP_PULL] > FORCE_LEVEL_2
			|| !pull && self->client->ps.forcePowerLevel[FP_PUSH] > FORCE_LEVEL_2)
		{
			//level 3: they actually play a pushed anim and stumble a bit
			vec3_t haz_angles = { 0, trooper->currentAngles[YAW], 0 };
			int anim;
			if (InFront(self->currentOrigin, trooper->currentOrigin, haz_angles))
			{
				//I'm on front of him
				if (pull)
				{
					anim = BOTH_PAIN4;
				}
				else
				{
					anim = BOTH_PAIN1;
				}
			}
			else
			{
				//I'm behind him
				if (pull)
				{
					anim = BOTH_PAIN1;
				}
				else
				{
					anim = BOTH_PAIN4;
				}
			}
			if (anim != -1)
			{
				if (anim == BOTH_PAIN1)
				{
					//make them take a couple steps back
					AngleVectors(haz_angles, trooper->client->ps.velocity, nullptr, nullptr);
					VectorScale(trooper->client->ps.velocity, -40.0f, trooper->client->ps.velocity);
					trooper->client->ps.pm_flags |= PMF_TIME_NOFRICTION;
				}
				else if (anim == BOTH_PAIN4)
				{
					//make them stumble forward
					AngleVectors(haz_angles, trooper->client->ps.velocity, nullptr, nullptr);
					VectorScale(trooper->client->ps.velocity, 80.0f, trooper->client->ps.velocity);
					trooper->client->ps.pm_flags |= PMF_TIME_NOFRICTION;
				}
				NPC_SetAnim(trooper, SETANIM_BOTH, anim, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
				trooper->painDebounceTime += trooper->client->ps.torsoAnimTimer;
				trooper->client->ps.pm_time = trooper->client->ps.torsoAnimTimer;
			}
		}
		if (trooper->NPC)
		{
			if (trooper->NPC->shotTime < trooper->painDebounceTime)
			{
				trooper->NPC->shotTime = trooper->painDebounceTime;
			}
		}
		trooper->client->ps.weaponTime = trooper->painDebounceTime - level.time;
	}
	else
	{
		//level 1: no pain reaction, but they should still notice
		if (trooper->enemy == nullptr //not mad at anyone
			&& trooper->client->playerTeam != self->client->playerTeam //not on our team
			&& !(trooper->svFlags & SVF_LOCKEDENEMY) //not locked on an enemy
			&& !(trooper->svFlags & SVF_IGNORE_ENEMIES) //not ignoring enemies
			&& !(self->flags & FL_NOTARGET)) //I'm not in notarget
		{
			//not already mad at them and can get mad at them, do so
			G_SetEnemy(trooper, self);
		}
	}
}

void WP_ResistForcePush(gentity_t* self, const gentity_t* pusher, const qboolean no_penalty)
{
	int parts;
	qboolean running_resist = qfalse;

	if (!self || self->health <= 1 || !self->client || !pusher || !pusher->client)
	{
		return;
	}

	if (self->client->NPC_class == CLASS_GUARD)
	{
		return;
	}

	if (jedi_jedi_master_low(self))
	{
		return;
	}

	if (PM_KnockDownAnim(self->client->ps.legsAnim) || PM_KnockDownAnim(self->client->ps.torsoAnim) || PM_StaggerAnim(
		self->client->ps.torsoAnim))
	{
		return;
	}

	if (PM_DeathCinAnim(self->client->ps.legsAnim))
	{
		return;
	}

	if (PM_SaberInKata(static_cast<saber_moveName_t>(self->client->ps.saber_move)) || PM_InKataAnim(
		self->client->ps.torsoAnim))
	{
		//don't throw saber when in special attack (alt+attack)
		return;
	}

	if (!PM_SaberCanInterruptMove(self->client->ps.saber_move, self->client->ps.torsoAnim))
	{
		//can't interrupt my current torso anim/sabermove with this, so ignore it entirely!
		return;
	}

	if ((!self->s.number
		|| self->NPC && (self->NPC->aiFlags & NPCAI_BOSS_CHARACTER || self->NPC->aiFlags &
			NPCAI_BOSS_SERENITYJEDIENGINE)
		|| self->client && self->client->NPC_class == CLASS_SHADOWTROOPER
		|| (self->flags & FL_NOTARGET || self->client->noclip))
		&& (VectorLengthSquared(self->client->ps.velocity) > 10000 || self->client->ps.forcePowerLevel[FP_PUSH] >=
			FORCE_LEVEL_3 || self->client->ps.forcePowerLevel[FP_PULL] >= FORCE_LEVEL_3))
	{
		running_resist = qtrue;
	}

	if (!running_resist
		&& self->client->ps.groundEntityNum != ENTITYNUM_NONE
		&& !PM_SpinningSaberAnim(self->client->ps.legsAnim)
		&& !PM_FlippingAnim(self->client->ps.legsAnim)
		&& !PM_RollingAnim(self->client->ps.legsAnim)
		&& !PM_InKnockDown(&self->client->ps)
		&& !PM_CrouchAnim(self->client->ps.legsAnim))
	{
		//if on a surface and not in a spin or flip, play full body resist
		parts = SETANIM_BOTH;
	}
	else
	{
		//play resist just in torso
		parts = SETANIM_TORSO;
	}

	NPC_SetAnim(self, parts, BOTH_RESISTPUSH, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);

	if (g_SerenityJediEngineMode->integer == 2)
	{
		self->client->ps.powerups[PW_MEDITATE] = level.time + self->client->ps.torsoAnimTimer + 1000;
	}

	if (!no_penalty)
	{
		if (!running_resist)
		{
			VectorClear(self->client->ps.velocity);

			self->client->ps.weaponTime = 1000;
			if (self->client->ps.forcePowersActive & 1 << FP_SPEED)
			{
				self->client->ps.weaponTime = floor(self->client->ps.weaponTime * g_timescale->value);
			}
			self->client->ps.pm_time = self->client->ps.weaponTime;
			self->client->ps.pm_flags |= PMF_TIME_KNOCKBACK;

			self->forcePushTime = level.time + 600; // let the push effect last for 600 ms
		}
		else
		{
			self->client->ps.weaponTime = 600;
			if (self->client->ps.forcePowersActive & 1 << FP_SPEED)
			{
				self->client->ps.weaponTime = floor(self->client->ps.weaponTime * g_timescale->value);
			}
		}
	}

	if (!pusher //???
		|| pusher == self->enemy //my enemy tried to push me
		|| pusher->client && pusher->client->playerTeam != self->client->playerTeam)
		//someone not on my team tried to push me
	{
		jedi_play_blocked_push_sound(self);
	}
}

extern qboolean Boba_StopKnockdown(gentity_t* self, const gentity_t* pusher, const vec3_t push_dir,
	qboolean force_knockdown);
extern qboolean jedi_stop_knockdown(gentity_t* self, const vec3_t push_dir);

static void WP_ForceKnockdown(gentity_t* self, gentity_t* pusher, const qboolean pull, qboolean strong_knockdown,
	const qboolean breakSaberLock)
{
	if (!self || !self->client || !pusher || !pusher->client)
	{
		return;
	}

	if (self->client->NPC_class == CLASS_ROCKETTROOPER)
	{
		return;
	}
	if (PM_LockedAnim(self->client->ps.legsAnim))
	{
		//stuck doing something else
		return;
	}
	if (rosh_being_healed(self))
	{
		return;
	}

	//break out of a saberLock?
	if (self->client->ps.saberLockTime > level.time)
	{
		if (breakSaberLock
			|| pusher && self->client->ps.saberLockEnemy == pusher->s.number)
		{
			self->client->ps.saberLockTime = 0;
			self->client->ps.saberLockEnemy = ENTITYNUM_NONE;
		}
		else
		{
			return;
		}
	}

	if (self->health > 0)
	{
		if (!self->s.number)
		{
			NPC_SetPainEvent(self);
		}
		else
		{
			GEntity_PainFunc(self, pusher, pusher, self->currentOrigin, 0, MOD_MELEE);
		}

		vec3_t push_dir;
		if (pull)
		{
			VectorSubtract(pusher->currentOrigin, self->currentOrigin, push_dir);
		}
		else
		{
			VectorSubtract(self->currentOrigin, pusher->currentOrigin, push_dir);
		}

		if (self->client->moveType == MT_FLYSWIM)
		{
			//can't knock me down when I'm flying
			return;
		}
		//FIXME: sometimes do this for some NPC force-users, too!
		if (Boba_StopKnockdown(self, pusher, push_dir, qtrue))
		{
			//He can backflip instead of be knocked down
			return;
		}
		if (jedi_stop_knockdown(self, push_dir))
		{
			//They can backflip instead of be knocked down
			return;
		}

		G_CheckLedgeDive(self, 72, push_dir, qfalse, qfalse);

		if (self->client->ps.SaberActive())
		{
			if (self->client->ps.saber[1].Active())
			{
				//turn off second saber
				G_Sound(self, self->client->ps.saber[1].soundOff);
			}
			else if (self->client->ps.saber[0].Active())
			{
				//turn off first
				G_Sound(self, self->client->ps.saber[0].soundOff);
			}
			self->client->ps.SaberDeactivate();
		}

		if (!PM_SpinningSaberAnim(self->client->ps.legsAnim)
			&& !PM_FlippingAnim(self->client->ps.legsAnim)
			&& !PM_RollingAnim(self->client->ps.legsAnim)
			&& !PM_InKnockDown(&self->client->ps))
		{
			int knock_anim = BOTH_KNOCKDOWN1; //default knockdown

			if (pusher->client->NPC_class == CLASS_DESANN || pusher->client->NPC_class == CLASS_SITHLORD || pusher->
				client->NPC_class == CLASS_VADER && self->client->NPC_class != CLASS_LUKE)
			{
				//desann always knocks down, unless you're Luke
				strong_knockdown = qtrue;
			}
			if (!self->s.number
				&& !strong_knockdown
				&& (!pull && (self->client->ps.forcePowerLevel[FP_PUSH] > FORCE_LEVEL_1 || !g_spskill->integer) || pull
					&& (self->client->ps.forcePowerLevel[FP_PULL] > FORCE_LEVEL_1 || !g_spskill->integer)))
			{
				//player only knocked down if pushed *hard*
				if (self->s.weapon == WP_SABER)
				{
					//temp HACK: these are the only 2 pain anims that look good when holding a saber
					knock_anim = PM_PickAnim(self, BOTH_PAIN2, BOTH_PAIN3);
				}
				else
				{
					knock_anim = PM_PickAnim(self, BOTH_PAIN1, BOTH_PAIN18);
				}
			}
			else if (PM_CrouchAnim(self->client->ps.legsAnim))
			{
				//crouched knockdown
				if (jedi_is_kick_resistant(self))
				{
					G_Stagger(self);
					WP_DeactivateSaber(self, qtrue);
					if (jedi_is_kick_resistant(self))
					{
						G_AddVoiceEvent(self, EV_PUSHFAIL, 2000);
					}
				}
				else
				{
					knock_anim = BOTH_KNOCKDOWN4;
				}
			}
			else
			{
				//plain old knockdown
				vec3_t p_l_fwd;
				const vec3_t p_l_angles = { 0, self->client->ps.viewangles[YAW], 0 };
				vec3_t s_fwd;
				const vec3_t s_angles = { 0, pusher->client->ps.viewangles[YAW], 0 };
				AngleVectors(p_l_angles, p_l_fwd, nullptr, nullptr);
				AngleVectors(s_angles, s_fwd, nullptr, nullptr);
				if (DotProduct(s_fwd, p_l_fwd) > 0.2f)
				{
					//pushing him from behind
					if (jedi_is_kick_resistant(self))
					{
						G_Stagger(self);
						WP_DeactivateSaber(self, qtrue);
						if (jedi_is_kick_resistant(self))
						{
							G_AddVoiceEvent(self, EV_PUSHFAIL, 2000);
						}
					}
					else
					{
						if (pull)
						{
							knock_anim = BOTH_KNOCKDOWN1;
						}
						else
						{
							knock_anim = BOTH_KNOCKDOWN3;
						}
					}
				}
				else
				{
					//pushing him from front
					if (jedi_is_kick_resistant(self))
					{
						G_Stagger(self);
						WP_DeactivateSaber(self, qtrue);
						if (jedi_is_kick_resistant(self))
						{
							G_AddVoiceEvent(self, EV_PUSHFAIL, 2000);
						}
					}
					else
					{
						if (pull)
						{
							knock_anim = BOTH_KNOCKDOWN3;
						}
						else
						{
							knock_anim = BOTH_KNOCKDOWN1;
						}
					}
				}
			}
			if (knock_anim == BOTH_KNOCKDOWN1 && strong_knockdown)
			{
				//push *hard*
				if (jedi_is_kick_resistant(self))
				{
					G_Stagger(self);
					WP_DeactivateSaber(self, qtrue);
					if (jedi_is_kick_resistant(self))
					{
						G_AddVoiceEvent(self, EV_PUSHFAIL, 2000);
					}
				}
				else
				{
					knock_anim = BOTH_KNOCKDOWN2;
				}
			}
			NPC_SetAnim(self, SETANIM_BOTH, knock_anim, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);

			if (self->s.number >= MAX_CLIENTS)
			{
				//randomize getup times - but not for boba
				int add_time;
				if (jedi_is_kick_resistant(self))
				{
					add_time = 0;
				}
				else if (self->client->NPC_class == CLASS_BOBAFETT || self->client->NPC_class == CLASS_MANDALORIAN ||
					self->client->NPC_class == CLASS_JANGO || self->client->NPC_class == CLASS_JANGODUAL)
				{
					add_time = Q_irand(-500, 0);
				}
				else
				{
					add_time = Q_irand(-300, 300);
				}
				self->client->ps.legsAnimTimer += add_time;
				self->client->ps.torsoAnimTimer += add_time;
			}
			else
			{
				//player holds extra long so you have more time to decide to do the quick getup
				if (PM_KnockDownAnim(self->client->ps.legsAnim))
				{
					self->client->ps.legsAnimTimer += PLAYER_KNOCKDOWN_HOLD_EXTRA_TIME;
					self->client->ps.torsoAnimTimer += PLAYER_KNOCKDOWN_HOLD_EXTRA_TIME;
				}
			}

			if (pusher->NPC && pusher->enemy == self)
			{
				//pushed pushed down his enemy
				G_AddVoiceEvent(pusher, Q_irand(EV_GLOAT1, EV_GLOAT3), 10000);
				pusher->NPC->blockedSpeechDebounceTime = level.time + 10000;
			}
		}
	}
	self->forcePushTime = level.time + 600; // let the push effect last for 600 ms
}

qboolean WP_ForceThrowable(gentity_t* ent, const gentity_t* forward_ent, const gentity_t* self, const qboolean pull,
	const float cone,
	const float radius, vec3_t forward)
{
	if (ent == self)
		return qfalse;
	if (ent->owner == self && ent->s.weapon != WP_THERMAL) //can push your own thermals
		return qfalse;
	if (!ent->inuse)
		return qfalse;
	if (ent->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(ent))
	{
		if (!in_camera && ent->NPC && ent->NPC->scriptFlags & SCF_NO_FORCE)
		{
			if (PM_DeathCinAnim(ent->client->ps.legsAnim))
			{
			}
			else
			{
				if (ent->client->NPC_class != CLASS_GUARD && !jedi_jedi_master_low(ent))
				{
					if (ent->s.weapon == WP_SABER)
					{
						//Hmm, should jedi do the resist behavior?  If this is on, perhaps it's because of a cinematic?
						WP_ResistForcePush(ent, self, qtrue);
					}
					else
					{
						NPC_SetAnim(ent, SETANIM_TORSO, BOTH_WIND, SETANIM_AFLAG_PACE);
					}
					ent->client->ps.powerups[PW_MEDITATE] = level.time + ent->client->ps.torsoAnimTimer + 5000;
				}
			}
			return qfalse;
		}
	}
	if (ent->flags & FL_FORCE_PULLABLE_ONLY && !pull)
	{
		//simple HACK: cannot force-push ammo rack items (because they may start in solid)
		return qfalse;
	}
	//FIXME: don't push it if I already pushed it a little while ago
	if (ent->s.eType != ET_MISSILE)
	{
		if (ent->client)
		{
			if (ent->client->ps.pullAttackTime > level.time)
			{
				return qfalse;
			}
		}
		if (cone >= 1.0f)
		{
			//must be pointing right at them
			if (ent != forward_ent)
			{
				//must be the person I'm looking right at
				if (ent->client && !pull
					&& ent->client->ps.forceGripEntityNum == self->s.number
					&& (self->s.eFlags & EF_FORCE_GRIPPED || self->s.eFlags & EF_FORCE_GRASPED))
				{
					//this is the guy that's force-gripping me, use a wider cone regardless of force power level
				}
				else
				{
					if (ent->client && !pull
						&& ent->client->ps.forceDrainEntityNum == self->s.number
						&& self->s.eFlags & EF_FORCE_DRAINED)
					{
						//this is the guy that's force-draining me, use a wider cone regardless of force power level
					}
					else
					{
						return qfalse;
					}
				}
			}
		}
		if (ent->s.eType != ET_ITEM && ent->e_ThinkFunc != thinkF_G_RunObject)
		{
			if (ent->s.eFlags & EF_NODRAW)
			{
				return qfalse;
			}
			if (!ent->client)
			{
				if (Q_stricmp("lightsaber", ent->classname) != 0)
				{
					//not a lightsaber
					if (!(ent->svFlags & SVF_GLASS_BRUSH))
					{
						//and not glass
						if (Q_stricmp("func_door", ent->classname) != 0 || !(ent->spawnflags & 2
							/*MOVER_FORCE_ACTIVATE*/))
						{
							//not a force-usable door
							if (Q_stricmp("func_static", ent->classname) != 0 || !(ent->spawnflags & 1/*F_PUSH*/) && !(
								ent->spawnflags & 2/*F_PULL*/) || ent->spawnflags & 32/*SOLITARY*/)
							{
								//not a force-usable func_static or, it is one, but it's solitary, so you only press it when looking right at it
								if (Q_stricmp("limb", ent->classname))
								{
									//not a limb
									if (ent->s.weapon == WP_TURRET && !Q_stricmp("PAS", ent->classname) && ent->s.apos.
										trType == TR_STATIONARY)
									{
										//can knock over placed turrets
										if (!self->s.number || self->enemy != ent)
										{
											//only NPCs who are actively mad at this turret can push it over
											return qfalse;
										}
									}
									else
									{
										return qfalse;
									}
								}
							}
						}
						else if (ent->moverState != MOVER_POS1 && ent->moverState != MOVER_POS2)
						{
							//not at rest
							return qfalse;
						}
					}
				}
				//return qfalse;
			}
			else if (ent->client->NPC_class == CLASS_MARK1)
			{
				//can't push Mark1 unless push 3
				if (pull || self->client->ps.forcePowerLevel[FP_PUSH] < FORCE_LEVEL_3)
				{
					return qfalse;
				}
			}
			else if (ent->client->NPC_class == CLASS_GALAKMECH
				|| ent->client->NPC_class == CLASS_ATST
				//|| ent->client->NPC_class == CLASS_SBD
				|| ent->client->NPC_class == CLASS_RANCOR
				|| ent->client->NPC_class == CLASS_WAMPA
				|| ent->client->NPC_class == CLASS_SAND_CREATURE)
			{
				//can't push ATST or Galak or Rancor or Wampa
				return qfalse;
			}
			else if (ent->s.weapon == WP_EMPLACED_GUN)
			{
				//FIXME: maybe can pull them out?
				return qfalse;
			}
			else if (ent->client->playerTeam == self->client->playerTeam && self->enemy && self->enemy != ent)
			{
				//can't accidentally push a teammate while in combat
				return qfalse;
			}
			else if (G_IsRidingVehicle(ent)
				&& ent->s.eFlags & EF_NODRAW)
			{
				//can't push/pull anyone riding *inside* vehicle
				return qfalse;
			}
		}
		else if (ent->s.eType == ET_ITEM)
		{
			if (ent->flags & FL_NO_KNOCKBACK)
			{
				return qfalse;
			}
			if (ent->item
				&& ent->item->giType == IT_HOLDABLE
				&& ent->item->giTag == INV_SECURITY_KEY)
			{
				//dropped security keys can't be pushed?  But placed ones can...?  does this make any sense?
				if (!pull || self->s.number)
				{
					//can't push, NPC's can't do anything to it
					return qfalse;
				}
				if (g_crosshairEntNum != ent->s.number)
				{
					//player can pull it if looking *right* at it
					if (cone >= 1.0f)
					{
						//we did a forwardEnt trace
						if (forward_ent != ent)
						{
							//must be pointing right at them
							return qfalse;
						}
					}
					else if (forward)
					{
						//do a forwardEnt trace
						trace_t tr;
						vec3_t end;
						VectorMA(self->client->renderInfo.eyePoint, radius, forward, end);
						gi.trace(&tr, self->client->renderInfo.eyePoint, vec3_origin, vec3_origin, end, self->s.number,
							MASK_OPAQUE | CONTENTS_SOLID | CONTENTS_BODY | CONTENTS_ITEM | CONTENTS_CORPSE,
							static_cast<EG2_Collision>(0), 0); //was MASK_SHOT, changed to match crosshair trace
						if (tr.entityNum != ent->s.number)
						{
							//last chance
							return qfalse;
						}
					}
				}
			}
		}
	}
	else
	{
		switch (ent->s.weapon)
		{
			//only missiles with mass are force-pushable
		case WP_CONCUSSION:
		case WP_ROCKET_LAUNCHER:
			//Don't push Destruction projectiles
			if (ent->s.powerups & 1 << PW_FORCE_PROJECTILE)
			{
				return qfalse;
			}
			break;
		case WP_SABER:
		case WP_FLECHETTE:
		case WP_THERMAL:
		case WP_TRIP_MINE:
		case WP_DET_PACK:
			break;
			//only alt-fire of this weapon is force-pushable
		case WP_REPEATER:
			if (ent->methodOfDeath != MOD_REPEATER_ALT)
			{
				//not an alt-fire missile
				return qfalse;
			}
			break;
		case WP_CLONECOMMANDO:
			if (ent->methodOfDeath != MOD_CLONECOMMANDO_ALT)
			{
				return qfalse;
			}
			break;
			//everything else cannot be pushed
		case WP_ATST_SIDE:
			if (ent->methodOfDeath != MOD_EXPLOSIVE)
			{
				//not a rocket
				return qfalse;
			}
			break;
		default:
			return qfalse;
		}

		if (ent->s.pos.trType == TR_STATIONARY && ent->s.eFlags & EF_MISSILE_STICK)
		{
			//can't force-push/pull stuck missiles (detpacks, tripmines)
			return qfalse;
		}
		if (ent->s.pos.trType == TR_STATIONARY && ent->s.weapon != WP_THERMAL)
		{
			//only thermal detonators can be pushed once stopped
			return qfalse;
		}
	}
	return qtrue;
}

static qboolean PlayerisResistingForceThrow(const gentity_t* player, gentity_t* attacker)
{
	if (player->health <= 0)
	{
		return qfalse;
	}

	if (!player->client)
	{
		return qfalse;
	}

	if (player->client->ps.forceRageRecoveryTime >= level.time)
	{
		return qfalse;
	}

	if (player->client->ps.forcePowerLevel[FP_SABER_DEFENSE] < FORCE_LEVEL_1)
	{
		return qfalse;
	}

	if (player->client->NPC_class == CLASS_GUARD)
	{
		return qfalse;
	}

	if (jedi_jedi_master_low(player))
	{
		return qfalse;
	}

	if (PM_DeathCinAnim(player->client->ps.legsAnim))
	{
		return qfalse;
	}

	//wasn't trying to grip/drain anyone
	if (player->client->ps.torsoAnim == BOTH_FORCEGRIP_HOLD ||
		player->client->ps.torsoAnim == BOTH_FORCE_DRAIN_GRAB_START ||
		player->client->ps.torsoAnim == BOTH_FORCE_DRAIN_GRAB_HOLD)
	{
		return qfalse;
	}

	//on the ground
	if (player->client->ps.groundEntityNum == ENTITYNUM_NONE)
	{
		return qfalse;
	}

	//not knocked down already
	if (PM_InKnockDown(&player->client->ps))
	{
		return qfalse;
	}

	if (PM_KnockDownAnim(player->client->ps.legsAnim) || PM_KnockDownAnim(player->client->ps.torsoAnim) ||
		PM_StaggerAnim(player->client->ps.torsoAnim))
	{
		return qfalse;
	}

	if (PM_SaberInKata(static_cast<saber_moveName_t>(player->client->ps.saber_move)) || PM_InKataAnim(
		player->client->ps.torsoAnim))
	{
		//don't throw saber when in special attack (alt+attack)
		return qfalse;
	}

	//not involved in a saberLock
	if (player->client->ps.saberLockTime >= level.time)
	{
		return qfalse;
	}

	//not attacking or otherwise busy
	if (player->client->ps.weaponTime >= level.time)
	{
		return qfalse;
	}

	if (Manual_Forceblocking(player) || (player->flags & FL_NOTARGET || player->client->noclip))
	{
		// player was pushing, or player's force push/pull is high enough to try to stop me
		if (InFront(attacker->currentOrigin, player->client->renderInfo.eyePoint, player->client->ps.viewangles, 0.3f))
		{
			//I'm in front of player
			return qtrue;
		}
	}

	return qfalse;
}

static qboolean ShouldPlayerResistForceThrow(const gentity_t* player, gentity_t* attacker, const qboolean pull)
{
	if (player->health <= 1)
	{
		return qfalse;
	}

	if (!player->client)
	{
		return qfalse;
	}

	if (player->client->ps.forceRageRecoveryTime >= level.time)
	{
		return qfalse;
	}

	if (PM_DeathCinAnim(player->client->ps.legsAnim))
	{
		return qfalse;
	}

	//wasn't trying to grip/drain anyone
	if (player->client->ps.torsoAnim == BOTH_FORCEGRIP_HOLD ||
		player->client->ps.torsoAnim == BOTH_FORCE_DRAIN_GRAB_START ||
		player->client->ps.torsoAnim == BOTH_FORCE_DRAIN_GRAB_HOLD)
	{
		return qfalse;
	}

	//only 30% chance of resisting a Desann or yoda push
	if ((attacker->client->NPC_class == CLASS_DESANN
		|| attacker->client->NPC_class == CLASS_SITHLORD
		|| attacker->client->NPC_class == CLASS_VADER
		|| attacker->client->NPC_class == CLASS_GROGU
		|| Q_stricmp("Yoda", attacker->NPC_type)
		|| Q_stricmp("T_Yoda", attacker->NPC_type)
		|| Q_stricmp("jedi_kdm1", attacker->NPC_type)
		|| Q_stricmp("RebornBoss", attacker->NPC_type)
		|| Q_stricmp("T_Palpatine_sith", attacker->NPC_type) == 0)
		&& Q_irand(0, 2) > 0)
	{
		return qfalse;
	}

	//on the ground
	if (player->client->ps.groundEntityNum == ENTITYNUM_NONE)
	{
		return qfalse;
	}

	if (player->client->ps.forcePowerLevel[FP_SABER_DEFENSE] < FORCE_LEVEL_1)
	{
		return qfalse;
	}

	if (player->client->NPC_class == CLASS_GUARD)
	{
		return qfalse;
	}

	if (jedi_jedi_master_low(player))
	{
		return qfalse;
	}

	//not knocked down already
	if (PM_InKnockDown(&player->client->ps))
	{
		return qfalse;
	}

	if (PM_KnockDownAnim(player->client->ps.legsAnim) || PM_KnockDownAnim(player->client->ps.torsoAnim) ||
		PM_StaggerAnim(player->client->ps.torsoAnim))
	{
		return qfalse;
	}

	if (PM_SaberInKata(static_cast<saber_moveName_t>(player->client->ps.saber_move)) || PM_InKataAnim(
		player->client->ps.torsoAnim))
	{
		//don't throw saber when in special attack (alt+attack)
		return qfalse;
	}

	//not involved in a saberLock
	if (player->client->ps.saberLockTime >= level.time)
	{
		return qfalse;
	}

	//not attacking or otherwise busy
	if (player->client->ps.weaponTime >= level.time)
	{
		return qfalse;
	}

	//using saber or fists
	if (player->client->ps.weapon != WP_SABER && player->client->ps.weapon != WP_MELEE)
	{
		return qfalse;
	}

	const forcePowers_t force_power = pull ? FP_PULL : FP_PUSH;
	const int attacking_force_level = attacker->client->ps.forcePowerLevel[force_power];
	const int defending_force_level = player->client->ps.forcePowerLevel[force_power];

	if (player->client->ps.powerups[PW_FORCE_PUSH] > level.time || (player->flags & FL_NOTARGET || player->client->
		noclip) ||
		Q_irand(0, Q_max(0, defending_force_level - attacking_force_level) * 2 + 1) > 0)
	{
		// player was pushing, or player's force push/pull is high enough to try to stop me
		if (InFront(attacker->currentOrigin, player->client->renderInfo.eyePoint, player->client->ps.viewangles, 0.3f))
		{
			//I'm in front of player
			return qtrue;
		}
	}

	return qfalse;
}

static void RepulseDamage(gentity_t* self, gentity_t* enemy, vec3_t location, const int damage_level)
{
	switch (damage_level)
	{
	case FORCE_LEVEL_1:
		G_Damage(enemy, self, self, nullptr, location, 20, DAMAGE_DEATH_KNOCKBACK | DAMAGE_EXTRA_KNOCKBACK, MOD_SNIPER);
		break;
	case FORCE_LEVEL_2:
		G_Damage(enemy, self, self, nullptr, location, 40, DAMAGE_DEATH_KNOCKBACK | DAMAGE_EXTRA_KNOCKBACK, MOD_SNIPER);
		break;
	case FORCE_LEVEL_3:
		G_Damage(enemy, self, self, nullptr, location, 60, DAMAGE_DEATH_KNOCKBACK | DAMAGE_EXTRA_KNOCKBACK, MOD_SNIPER);
		break;
	default:
		break;
	}

	if (enemy->client->ps.stats[STAT_HEALTH] <= 1) // if we are dead
	{
		vec3_t spot;

		VectorCopy(enemy->currentOrigin, spot);

		enemy->flags |= FL_DISINTEGRATED;
		enemy->svFlags |= SVF_BROADCAST;
		gentity_t* tent = G_TempEntity(spot, EV_DISINTEGRATION);
		tent->s.eventParm = PW_DISRUPTION;
		tent->svFlags |= SVF_BROADCAST;
		tent->owner = enemy;

		if (enemy->playerModel >= 0)
		{
			// don't let 'em animate
			gi.G2API_PauseBoneAnimIndex(&enemy->ghoul2[self->playerModel], enemy->rootBone, cg.time);
			gi.G2API_PauseBoneAnimIndex(&enemy->ghoul2[self->playerModel], enemy->motionBone, cg.time);
			gi.G2API_PauseBoneAnimIndex(&enemy->ghoul2[self->playerModel], enemy->lowerLumbarBone, cg.time);
		}

		//not solid anymore
		enemy->contents = 0;
		enemy->maxs[2] = -8;

		//need to pad death time some to stick around long enough for death effect to play
		enemy->NPC->timeOfDeath = level.time + 4000;
	}
}

static qboolean IsAllowedToUseForcePowers(const gentity_t* self)
{
	if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self) //npc only
		&& self->client->ps.weapon == WP_SABER //hes got a saber
		&& (self->client->ps.blockPoints < BLOCKPOINTS_MISSILE
			|| self->client->ps.forcePower < BLOCKPOINTS_MISSILE
			|| self->health <= 0
			|| BG_InKnockDown(self->client->ps.legsAnim)
			|| BG_InKnockDown(self->client->ps.torsoAnim)
			|| PM_InRoll(&self->client->ps)
			|| PM_SuperBreakLoseAnim(self->client->ps.torsoAnim)
			|| PM_SuperBreakWinAnim(self->client->ps.torsoAnim)
			|| pm_saber_in_special_attack(self->client->ps.torsoAnim)
			|| PM_InSpecialJump(self->client->ps.torsoAnim)
			|| PM_SaberInBounce(self->client->ps.saber_move)
			|| PM_SaberInKnockaway(self->client->ps.saber_move)
			|| PM_SaberInBrokenParry(self->client->ps.saber_move)
			|| pm_saber_innonblockable_attack(self->client->ps.torsoAnim))) //npc force use limit
	{
		return qfalse;
	}

	return qtrue;
}

static void PushDamage(gentity_t* self, gentity_t* enemy, vec3_t location, const int damage_level)
{
	switch (damage_level)
	{
	case FORCE_LEVEL_1:
		G_Damage(enemy, self, self, nullptr, location, 0, DAMAGE_NO_KNOCKBACK, MOD_IMPACT);
		break;
	case FORCE_LEVEL_2:
		G_Damage(enemy, self, self, nullptr, location, 0, DAMAGE_NO_KNOCKBACK, MOD_IMPACT);
		break;
	case FORCE_LEVEL_3:
		G_Damage(enemy, self, self, nullptr, location, 0, DAMAGE_NO_KNOCKBACK, MOD_IMPACT);
		break;
	default:
		break;
	}
}

void ForceThrow_JKA(gentity_t* self, qboolean pull, qboolean fake)
{
	//shove things in front of you away
	gentity_t* forward_ent = nullptr;
	gentity_t* push_target[MAX_GENTITIES]{};
	int num_listed_entities = 0;
	int ent_count = 0;
	int radius;
	vec3_t center, size, forward, right, end, fwdangles = { 0 };
	float cone;
	trace_t tr;
	int anim, hold, sound_index, cost;
	qboolean no_resist = qfalse;
	qboolean is_class_guard = qfalse;

	if (pm_saber_innonblockable_attack(self->client->ps.torsoAnim))
	{
		return;
	}
	if (self->health <= 0)
	{
		return;
	}

	if (PM_InGetUp(&self->client->ps)
		|| PM_InForceGetUp(&self->client->ps)
		|| PM_InKnockDown(&self->client->ps)
		|| PM_KnockDownAnim(player->client->ps.legsAnim)
		|| PM_KnockDownAnim(player->client->ps.torsoAnim)
		|| PM_StaggerAnim(player->client->ps.torsoAnim))
	{
		return;
	}

	if (self->client->ps.leanofs)
	{
		//can't force-throw while leaning
		return;
	}
	if (self->client->ps.forcePowerDebounce[FP_PUSH] > level.time)
	{
		//already pushing- now you can't haul someone across the room, sorry
		return;
	}
	if (self->client->ps.forcePowerDebounce[FP_PULL] > level.time)
	{
		//already pulling- now you can't haul someone across the room, sorry
		return;
	}
	if (self->client->ps.pullAttackTime > level.time)
	{
		//already pull-attacking
		return;
	}
	if (!self->s.number && (cg.zoomMode || in_camera))
	{
		//can't force throw/pull when zoomed in or in cinematic
		return;
	}

	if (PM_InLedgeMove(self->client->ps.legsAnim))
	{
		return;
	}

	if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self) && self->client->ps.weapon == WP_SABER)
		//npc force use limit
	{
		if (self->client->ps.blockPoints < BLOCKPOINTS_HALF || self->client->ps.forcePower < BLOCKPOINTS_HALF)
		{
			return;
		}
	}

	if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self) && self->client->NPC_class == CLASS_KYLE)
		//npc force use limit
	{
		if (self->client->ps.forcePower < BLOCKPOINTS_FULL)
		{
			return;
		}
	}

	if (self->client->NPC_class == CLASS_GUARD)
	{
		return;
	}

	if (self->client->ps.saberLockTime > level.time)
	{
		if (pull || self->client->ps.forcePowerLevel[FP_PUSH] < FORCE_LEVEL_3)
		{
			//this can be a way to break out
			return;
		}
		//else, I'm breaking my half of the saberlock
		self->client->ps.saberLockTime = 0;
		self->client->ps.saberLockEnemy = ENTITYNUM_NONE;
	}

	if (self->client->ps.legsAnim == BOTH_KNOCKDOWN3
		|| self->client->ps.torsoAnim == BOTH_FORCE_GETUP_F1 && self->client->ps.torsoAnimTimer > 400
		|| self->client->ps.torsoAnim == BOTH_FORCE_GETUP_F2 && self->client->ps.torsoAnimTimer > 900
		|| self->client->ps.torsoAnim == BOTH_GETUP3 && self->client->ps.torsoAnimTimer > 500
		|| self->client->ps.torsoAnim == BOTH_GETUP4 && self->client->ps.torsoAnimTimer > 300
		|| self->client->ps.torsoAnim == BOTH_GETUP5 && self->client->ps.torsoAnimTimer > 500)
	{
		//we're face-down, so we'd only be force-push/pulling the floor
		return;
	}
	if (pull)
	{
		radius = forcePushPullRadius[self->client->ps.forcePowerLevel[FP_PULL]];
	}
	else
	{
		radius = forcePushPullRadius[self->client->ps.forcePowerLevel[FP_PUSH]];
	}

	if (!radius)
	{
		//no ability to do this yet
		return;
	}

	if (pull)
	{
		cost = forcePowerNeeded[FP_PULL];
		if (!WP_ForcePowerUsable(self, FP_PULL, cost))
		{
			return;
		}
		//make sure this plays and that you cannot press fire for about 200ms after this
		anim = BOTH_FORCEPULL;
		sound_index = G_SoundIndex("sound/weapons/force/pull.wav");
		hold = 200;
	}
	else
	{
		cost = forcePowerNeeded[FP_PUSH];
		if (!WP_ForcePowerUsable(self, FP_PUSH, cost))
		{
			return;
		}

		//make sure this plays and that you cannot press fire for about 1 second after this
		anim = BOTH_FORCEPUSH;

		if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self)) // npc push sounds
		{
			if (self->client->ps.forcePower < 50)
			{
				sound_index = G_SoundIndex("sound/weapons/force/pushlow.mp3");
			}
			else
			{
				sound_index = G_SoundIndex("sound/weapons/force/push.mp3");
			}
		}
		else
		{
			if (g_SerenityJediEngineMode->integer)
			{
				if (self->client->ps.forcePower < 30 || PM_InKnockDown(&self->client->ps))
				{
					sound_index = G_SoundIndex("sound/weapons/force/pushlow.mp3");
				}
				else
				{
					if (self->client->ps.groundEntityNum == ENTITYNUM_NONE &&
						self->client->ps.forcePower > 50)
					{
						sound_index = G_SoundIndex("sound/weapons/force/pushhard.mp3");
					}
					else
					{
						if (self->client->ps.forcePower > 90)
						{
							sound_index = G_SoundIndex("sound/weapons/force/push_md.mp3");
						}
						else
						{
							sound_index = G_SoundIndex("sound/weapons/force/push.mp3");
						}
					}
				}
			}
			else
			{
				sound_index = G_SoundIndex("sound/weapons/force/push.mp3");
			}
		}
		hold = 650;
	}

	int parts = SETANIM_TORSO;
	if (!PM_InKnockDown(&self->client->ps))
	{
		if (self->client->ps.saberLockTime > level.time)
		{
			self->client->ps.saberLockTime = 0;
			self->painDebounceTime = level.time + 2000;
			hold += 1000;
			parts = SETANIM_BOTH;
		}
		else if (!VectorLengthSquared(self->client->ps.velocity) && !(self->client->ps.pm_flags & PMF_DUCKED))
		{
			parts = SETANIM_BOTH;
		}
	}
	NPC_SetAnim(self, parts, anim, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD | SETANIM_FLAG_RESTART);
	self->client->ps.saber_move = self->client->ps.saberBounceMove = LS_READY;
	//don't finish whatever saber anim you may have been in
	self->client->ps.saberBlocked = BLOCKED_NONE;

	if (self->client->ps.forcePowersActive & 1 << FP_SPEED)
	{
		hold = floor(hold * g_timescale->value);
	}

	self->client->ps.weaponTime = hold; //was 1000, but want to swing sooner
	self->client->ps.powerups[PW_FORCE_PUSH] = level.time + self->client->ps.torsoAnimTimer + 500;
	self->client->pushEffectFadeTime = 0;

	G_Sound(self, sound_index);

	if (!pull && self->client->ps.forcePowersForced & 1 << FP_PUSH
		|| pull && self->client->ps.forcePowersForced & 1 << FP_PULL
		|| pull && self->client->NPC_class == CLASS_KYLE && self->spawnflags & 1 && TIMER_Done(self, "kyleTakesSaber"))
	{
		no_resist = qtrue;
	}

	if (self->client->NPC_class == CLASS_GUARD || jedi_jedi_master_low(self))
	{
		is_class_guard = qtrue;
	}

	VectorCopy(self->client->ps.viewangles, fwdangles);
	AngleVectors(fwdangles, forward, right, nullptr);
	VectorCopy(self->currentOrigin, center);

	if (pull)
	{
		cone = forcePullCone[self->client->ps.forcePowerLevel[FP_PULL]];
	}
	else
	{
		cone = forcePushCone[self->client->ps.forcePowerLevel[FP_PUSH]];
	}

	//	if ( cone >= 1.0f )
	{
		//must be pointing right at them
		VectorMA(self->client->renderInfo.eyePoint, radius, forward, end);
		gi.trace(&tr, self->client->renderInfo.eyePoint, vec3_origin, vec3_origin, end, self->s.number,
			MASK_OPAQUE | CONTENTS_SOLID | CONTENTS_BODY | CONTENTS_ITEM | CONTENTS_CORPSE,
			static_cast<EG2_Collision>(0), 0); //was MASK_SHOT, changed to match crosshair trace

		if (tr.entityNum < ENTITYNUM_WORLD)
		{
			//found something right in front of self,
			forward_ent = &g_entities[tr.entityNum];
			if (!forward_ent->client && !Q_stricmp("func_static", forward_ent->classname))
			{
				if (forward_ent->spawnflags & 1 || forward_ent->spawnflags & 2/*F_PULL*/)
				{
					//push/pull able
					if (forward_ent->spawnflags & 32)
					{
						//can only push/pull ME, ignore all others
						if (forward_ent->NPC_targetname == nullptr
							|| self->targetname && Q_stricmp(forward_ent->NPC_targetname, self->targetname) == 0)
						{
							//anyone can push it or only 1 person can push it and it's me
							push_target[0] = forward_ent;
							ent_count = num_listed_entities = 1;
						}
					}
				}
			}
		}
	}

	if (forward_ent)
	{
		if (G_TryingPullAttack(self, &self->client->usercmd, qtrue))
		{
			//we're going to try to do a pull attack on our forwardEnt
			if (WP_ForceThrowable(forward_ent, forward_ent, self, pull, cone, radius, forward))
			{
				//we will actually pull-attack him, so don't pull him or anything else here
				//activate the power, here, though, so the later check that actually does the pull attack knows we tried to pull
				self->client->ps.forcePowersActive |= 1 << FP_PULL;
				self->client->ps.forcePowerDebounce[FP_PULL] = level.time + 100; //force-pulling
				return;
			}
		}
	}

	if (!num_listed_entities)
	{
		int e;
		int i;
		vec3_t v{};
		gentity_t* ent;
		vec3_t maxs{};
		vec3_t mins{};
		gentity_t* entity_list[MAX_GENTITIES];
		float dist;
		for (i = 0; i < 3; i++)
		{
			mins[i] = center[i] - radius;
			maxs[i] = center[i] + radius;
		}

		num_listed_entities = gi.EntitiesInBox(mins, maxs, entity_list, MAX_GENTITIES);

		for (e = 0; e < num_listed_entities; e++)
		{
			vec3_t dir;
			float dot1;
			vec3_t ent_org;
			ent = entity_list[e];

			if (!WP_ForceThrowable(ent, forward_ent, self, pull, cone, radius, forward))
			{
				continue;
			}

			//this is all to see if we need to start a saber attack, if it's in flight, this doesn't matter
			// find the distance from the edge of the bounding box
			for (i = 0; i < 3; i++)
			{
				if (center[i] < ent->absmin[i])
				{
					v[i] = ent->absmin[i] - center[i];
				}
				else if (center[i] > ent->absmax[i])
				{
					v[i] = center[i] - ent->absmax[i];
				}
				else
				{
					v[i] = 0;
				}
			}

			VectorSubtract(ent->absmax, ent->absmin, size);
			VectorMA(ent->absmin, 0.5, size, ent_org);

			//see if they're in front of me
			VectorSubtract(ent_org, center, dir);
			VectorNormalize(dir);
			if (cone < 1.0f)
			{
				//must be within the forward cone
				if (ent->client && !pull
					&& ent->client->ps.forceGripEntityNum == self->s.number
					&& (self->s.eFlags & EF_FORCE_GRIPPED || self->s.eFlags & EF_FORCE_GRASPED))
				{
					//this is the guy that's force-gripping me, use a wider cone regardless of force power level
					if ((dot1 = DotProduct(dir, forward)) < cone - 0.3f)
						continue;
				}
				else if (ent->client && !pull
					&& ent->client->ps.forceDrainEntityNum == self->s.number
					&& self->s.eFlags & EF_FORCE_DRAINED)
				{
					//this is the guy that's force-draining me, use a wider cone regardless of force power level
					if ((dot1 = DotProduct(dir, forward)) < cone - 0.3f)
						continue;
				}
				else if (ent->s.eType == ET_MISSILE)
					//&& ent->s.eType != ET_ITEM && ent->e_ThinkFunc != thinkF_G_RunObject )
				{
					//missiles are easier to force-push, never require direct trace (FIXME: maybe also items and general physics objects)
					if ((dot1 = DotProduct(dir, forward)) < cone - 0.3f)
						continue;
				}
				else if ((dot1 = DotProduct(dir, forward)) < cone)
				{
					continue;
				}
			}
			else if (ent->s.eType == ET_MISSILE)
			{
				//a missile and we're at force level 1... just use a small cone, but not ridiculously small
				if ((dot1 = DotProduct(dir, forward)) < 0.75f)
				{
					continue;
				}
			} //else is an NPC or brush entity that our forward trace would have to hit

			dist = VectorLength(v);

			//if within a certain range, deflect it
			if (ent->s.eType == ET_MISSILE && cone >= 1.0f)
			{
				//smaller radius on missile checks at force push 1
				if (dist >= 192)
				{
					continue;
				}
			}
			else if (dist >= radius)
			{
				continue;
			}

			//in PVS?
			if (!ent->bmodel && !gi.inPVS(ent_org, self->client->renderInfo.eyePoint))
			{
				//must be in PVS
				continue;
			}

			if (ent != forward_ent)
			{
				//don't need to trace against forwardEnt again
				//really should have a clear LOS to this thing...
				gi.trace(&tr, self->client->renderInfo.eyePoint, vec3_origin, vec3_origin, ent_org, self->s.number,
					MASK_FORCE_PUSH, static_cast<EG2_Collision>(0), 0);
				//was MASK_SHOT, but changed to match above trace and crosshair trace
				if (tr.fraction < 1.0f && tr.entityNum != ent->s.number)
				{
					//must have clear LOS
					continue;
				}
			}

			// ok, we are within the radius, add us to the incoming list
			push_target[ent_count] = ent;
			ent_count++;
		}
	}

	if (ent_count)
	{
		int actual_cost;
		for (int x = 0; x < ent_count; x++)
		{
			if (push_target[x]->client)
			{
				float knockback = pull ? 0 : 200;

				//SIGH band-aid...
				if (push_target[x]->s.number >= MAX_CLIENTS
					&& self->s.number < MAX_CLIENTS)
				{
					if (push_target[x]->client->ps.forcePowersActive & 1 << FP_GRIP
						&& push_target[x]->client->ps.forceGripEntityNum == self->s.number)
					{
						WP_ForcePowerStop(push_target[x], FP_GRIP);
					}
					if (push_target[x]->client->ps.forcePowersActive & 1 << FP_GRASP
						&& push_target[x]->client->ps.forceGripEntityNum == self->s.number)
					{
						WP_ForcePowerStop(push_target[x], FP_GRASP);
					}
					if (push_target[x]->client->ps.forcePowersActive & 1 << FP_DRAIN
						&& push_target[x]->client->ps.forceDrainEntityNum == self->s.number)
					{
						WP_ForcePowerStop(push_target[x], FP_DRAIN);
					}
				}

				if (rosh_being_healed(push_target[x]))
				{
					continue;
				}
				if (push_target[x]->client->NPC_class == CLASS_HAZARD_TROOPER
					&& push_target[x]->health > 0)
				{
					//living hazard troopers resist push/pull
					WP_ForceThrowHazardTrooper(self, push_target[x], pull);
					continue;
				}
				if (fake && push_target[x]->client->NPC_class != CLASS_GUARD && !jedi_jedi_master_low(push_target[x]))
				{
					//always resist
					WP_ResistForcePush(push_target[x], self, qfalse);
					continue;
				}
				int power_level, power_use;
				if (pull)
				{
					power_level = self->client->ps.forcePowerLevel[FP_PULL];
					power_use = FP_PULL;
				}
				else
				{
					power_level = self->client->ps.forcePowerLevel[FP_PUSH];
					power_use = FP_PUSH;
				}
				int mod_power_level = WP_AbsorbConversion(push_target[x],
					push_target[x]->client->ps.forcePowerLevel[FP_ABSORB],
					power_use,
					power_level,
					forcePowerNeeded[self->client->ps.forcePowerLevel[
						power_use]]);
				if (push_target[x]->client->NPC_class == CLASS_ASSASSIN_DROID ||
					push_target[x]->client->NPC_class == CLASS_HAZARD_TROOPER ||
					push_target[x]->client->NPC_class == CLASS_DROIDEKA)
				{
					mod_power_level = 0; // divides throw by 10
				}

				//First, if this is the player we're push/pulling, see if he can counter it
				if (mod_power_level != -1
					&& !no_resist && !is_class_guard
					&& InFront(self->currentOrigin, push_target[x]->client->renderInfo.eyePoint,
						push_target[x]->client->ps.viewangles, 0.3f))
				{
					//absorbed and I'm in front of them
					//counter it
					if (push_target[x]->client->ps.forcePowerLevel[FP_ABSORB] > FORCE_LEVEL_2)
					{
						//no reaction at all
					}
					else
					{
						WP_ResistForcePush(push_target[x], self, qfalse);
						push_target[x]->client->ps.saber_move = push_target[x]->client->ps.saberBounceMove = LS_READY;
						//don't finish whatever saber anim you may have been in
						push_target[x]->client->ps.saberBlocked = BLOCKED_NONE;
					}
					continue;
				}
				if (!push_target[x]->s.number && !is_class_guard)
				{
					//player
					if (!no_resist && !is_class_guard && (ShouldPlayerResistForceThrow(push_target[x], self, pull) ||
						PlayerisResistingForceThrow(push_target[x], self))
						&& push_target[x]->client->ps.saberFatigueChainCount < MISHAPLEVEL_HEAVY)
					{
						WP_ResistForcePush(push_target[x], self, qfalse);
						push_target[x]->client->ps.saber_move = push_target[x]->client->ps.saberBounceMove = LS_READY;
						//don't finish whatever saber anim you may have been in
						push_target[x]->client->ps.saberBlocked = BLOCKED_NONE;
						continue;
					}
				}
				else if (push_target[x]->client && jedi_waiting_ambush(push_target[x]))
				{
					WP_ForceKnockdown(push_target[x], self, pull, qtrue, qfalse);
					continue;
				}
				else if (PM_SaberInBrokenParry(push_target[x]->client->ps.saber_move))
				{
					//do a knockdown if fairly close
					WP_ForceKnockdown(push_target[x], self, pull, qtrue, qfalse);
					continue;
				}
				else if (push_target[x]->client->NPC_class == CLASS_GUARD || jedi_jedi_master_low(push_target[x]))
				{
					//do a knockdown hes a twat
					WP_ForceKnockdown(push_target[x], self, pull, qtrue, qfalse);
					continue;
				}

				G_KnockOffVehicle(push_target[x], self, pull);

				if (!pull
					&& push_target[x]->client->ps.forceDrainEntityNum == self->s.number
					&& self->s.eFlags & EF_FORCE_DRAINED)
				{
					//stop them from draining me now, dammit!
					WP_ForcePowerStop(push_target[x], FP_DRAIN);
				}

				//okay, everyone else (or player who couldn't resist it)...
				if ((self->s.number == 0 && Q_irand(0, 2) || Q_irand(0, 2)) && push_target[x]->client && push_target[x]->
					health > 0 //a living client
					&& push_target[x]->client->ps.weapon == WP_SABER //Jedi
					&& push_target[x]->health > 0 //alive
					&& push_target[x]->client->ps.forceRageRecoveryTime < level.time //not recovering from rage
					&& (self->client->NPC_class != CLASS_DESANN && self->client->NPC_class != CLASS_SITHLORD && self->
						client->NPC_class != CLASS_VADER && Q_stricmp("Yoda", self->NPC_type) || !Q_irand(0, 2))
					//only 30% chance of resisting a Desann push
					&& push_target[x]->client->ps.groundEntityNum != ENTITYNUM_NONE //on the ground
					&& InFront(self->currentOrigin, push_target[x]->currentOrigin, push_target[x]->client->ps.viewangles,
						0.3f) //I'm in front of him
					&& (push_target[x]->client->ps.powerups[PW_FORCE_PUSH] > level.time || //he's pushing too
						push_target[x]->s.number != 0 && push_target[x]->client->ps.weaponTime < level.time))
				{
					//Jedi don't get pushed, they resist as long as they aren't already attacking and are on the ground
					if (push_target[x]->client->ps.saberLockTime > level.time)
					{
						//they're in a lock
						if (push_target[x]->client->ps.saberLockEnemy != self->s.number)
						{
							//they're not in a lock with me
							continue;
						}
						if (pull || self->client->ps.forcePowerLevel[FP_PUSH] < FORCE_LEVEL_3 ||
							push_target[x]->client->ps.forcePowerLevel[FP_PUSH] > FORCE_LEVEL_2)
						{
							//they're in a lock with me, but my push is too weak
							continue;
						}
						//we will knock them down
						self->painDebounceTime = 0;
						self->client->ps.weaponTime = 500;
						if (self->client->ps.forcePowersActive & 1 << FP_SPEED)
						{
							self->client->ps.weaponTime = floor(self->client->ps.weaponTime * g_timescale->value);
						}
					}
					int resist_chance = Q_irand(0, 2);
					if (push_target[x]->s.number >= MAX_CLIENTS)
					{
						//NPC
						if (g_spskill->integer == 1)
						{
							//stupid tweak for graham
							resist_chance = Q_irand(0, 3);
						}
					}
					if (no_resist || is_class_guard ||
						!pull
						&& mod_power_level == -1
						&& self->client->ps.forcePowerLevel[FP_PUSH] > FORCE_LEVEL_2
						&& !resist_chance
						&& push_target[x]->client->ps.forcePowerLevel[FP_PUSH] < FORCE_LEVEL_3)
					{
						//a level 3 push can even knock down a jedi
						if (PM_InKnockDown(&push_target[x]->client->ps))
						{
							//can't knock them down again
							continue;
						}
						WP_ForceKnockdown(push_target[x], self, pull, qfalse, qtrue);
					}
					else if (push_target[x]->client->NPC_class == CLASS_GUARD || jedi_jedi_master_low(push_target[x]))
					{
						//do a knockdown hes a twat
						WP_ForceKnockdown(push_target[x], self, pull, qtrue, qfalse);
					}
					else
					{
						if (!is_class_guard)
						{
							WP_ResistForcePush(push_target[x], self, qfalse);
						}
					}
				}
				else
				{
					vec3_t push_dir;
					//shove them
					if (push_target[x]->NPC
						&& push_target[x]->NPC->jumpState == JS_JUMPING)
					{
						//don't interrupt a scripted jump
						push_target[x]->forcePushTime = level.time + 600; // let the push effect last for 600 ms
						continue;
					}

					if (push_target[x]->s.number
						&& (push_target[x]->message || push_target[x]->flags & FL_NO_KNOCKBACK))
					{
						//an NPC who has a key
						//don't push me... FIXME: maybe can pull the key off me?
						WP_ForceKnockdown(push_target[x], self, pull, qfalse, qfalse);
						continue;
					}
					if (push_target[x]->client->NPC_class == CLASS_GUARD || jedi_jedi_master_low(push_target[x]))
					{
						//do a knockdown hes a twat
						WP_ForceKnockdown(push_target[x], self, pull, qtrue, qfalse);
						continue;
					}
					if (pull)
					{
						VectorSubtract(self->currentOrigin, push_target[x]->currentOrigin, push_dir);
						if (self->client->ps.forcePowerLevel[FP_PULL] >= FORCE_LEVEL_3
							&& self->client->NPC_class == CLASS_KYLE
							&& self->spawnflags & 1
							&& TIMER_Done(self, "kyleTakesSaber")
							&& push_target[x]->client
							&& push_target[x]->client->ps.weapon == WP_SABER
							&& !push_target[x]->client->ps.saberInFlight
							&& push_target[x]->client->ps.saberEntityNum < ENTITYNUM_WORLD
							&& !PM_InOnGroundAnim(&push_target[x]->client->ps))
						{
							vec3_t throw_vec;
							VectorScale(push_dir, 10.0f, throw_vec);
							WP_SaberLose(push_target[x], throw_vec);
							NPC_SetAnim(push_target[x], SETANIM_BOTH, BOTH_LOSE_SABER,
								SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
							push_target[x]->client->ps.torsoAnimTimer += 500;
							push_target[x]->client->ps.pm_time = push_target[x]->client->ps.weaponTime = push_target[x]->
								client->ps.torsoAnimTimer;
							push_target[x]->client->ps.pm_flags |= PMF_TIME_KNOCKBACK;
							push_target[x]->client->ps.saber_move = LS_NONE;
							push_target[x]->aimDebounceTime = level.time + push_target[x]->client->ps.torsoAnimTimer;
							VectorClear(push_target[x]->client->ps.velocity);
							VectorClear(push_target[x]->client->ps.moveDir);
							//Kyle will stand around for a bit, too...
							self->client->ps.pm_time = self->client->ps.weaponTime = 2000;
							self->client->ps.pm_flags |= PMF_TIME_KNOCKBACK;
							self->painDebounceTime = level.time + self->client->ps.weaponTime;
							TIMER_Set(self, "kyleTakesSaber", Q_irand(60000, 180000)); //don't do this again for a while
							G_AddVoiceEvent(self, Q_irand(EV_TAUNT1, EV_TAUNT5), Q_irand(8000, 12000));
							VectorClear(self->client->ps.velocity);
							VectorClear(self->client->ps.moveDir);
							continue;
						}
						if (push_target[x]->NPC
							&& push_target[x]->NPC->scriptFlags & SCF_DONT_FLEE)
						{
							//*SIGH*... if an NPC can't flee, they can't run after and pick up their weapon, do don't drop it
						}
						else if (self->client->ps.forcePowerLevel[FP_PULL] > FORCE_LEVEL_1
							&& push_target[x]->client->NPC_class != CLASS_ROCKETTROOPER
							//rockettroopers never drop their weapon
							&& push_target[x]->client->NPC_class != CLASS_VEHICLE
							&& push_target[x]->client->NPC_class != CLASS_BOBAFETT
							&& push_target[x]->client->NPC_class != CLASS_MANDALORIAN
							&& push_target[x]->client->NPC_class != CLASS_JANGO
							&& push_target[x]->client->NPC_class != CLASS_JANGODUAL
							&& push_target[x]->client->NPC_class != CLASS_TUSKEN
							&& push_target[x]->client->NPC_class != CLASS_HAZARD_TROOPER
							&& push_target[x]->client->NPC_class != CLASS_ASSASSIN_DROID
							&& push_target[x]->client->NPC_class != CLASS_DROIDEKA
							&& push_target[x]->client->NPC_class != CLASS_SBD
							&& push_target[x]->s.weapon != WP_SABER
							&& push_target[x]->s.weapon != WP_MELEE
							&& push_target[x]->s.weapon != WP_THERMAL
							&& push_target[x]->s.weapon != WP_CONCUSSION)
						{
							//yank the weapon - NOTE: level 1 just knocks them down, not take weapon
							if (InFront(self->currentOrigin, push_target[x]->currentOrigin,
								push_target[x]->client->ps.viewangles, 0.0f))
							{
								//enemy has to be facing me, too...
								WP_DropWeapon(push_target[x], push_dir);
							}
						}
						knockback += VectorNormalize(push_dir);
						if (knockback > 200)
						{
							knockback = 200;
						}
						if (self->client->ps.forcePowerLevel[FP_PULL] < FORCE_LEVEL_3)
						{
							//maybe just knock them down
							knockback /= 3;
						}
					}
					else
					{
						VectorSubtract(push_target[x]->currentOrigin, self->currentOrigin, push_dir);
						knockback -= VectorNormalize(push_dir);

						G_SoundOnEnt(push_target[x], CHAN_BODY, "sound/weapons/force/pushed.mp3");

						if (knockback < 100) // if less than 100
						{
							knockback = 100; // minimum 100
						}

						//scale for push level
						if (self->client->ps.forcePowerLevel[FP_PUSH] < FORCE_LEVEL_2) // level 1 devide by 3
						{
							if (self->s.weapon == WP_MELEE ||
								self->s.weapon == WP_NONE ||
								self->s.weapon == WP_SABER &&
								!self->client->ps.SaberActive() &&
								!PM_InKnockDown(&self->client->ps))
							{
								//maybe just knock them down
								knockback /= 2;
							}
							else
							{
								//maybe just knock them down
								knockback /= 3;
							}
						}
						else if (self->client->ps.forcePowerLevel[FP_PUSH] == FORCE_LEVEL_2) // level 2
						{
							if (self->s.weapon == WP_MELEE ||
								self->s.weapon == WP_NONE ||
								self->s.weapon == WP_SABER &&
								!self->client->ps.SaberActive() &&
								!PM_InKnockDown(&self->client->ps))
							{
								knockback = 125;
							}
							else
							{
								knockback = 100;
							}
						}
						else if (self->client->ps.forcePowerLevel[FP_PUSH] > FORCE_LEVEL_2) // level 3 add sound
						{
							if (push_target[x]->client->NPC_class == CLASS_GUARD || jedi_jedi_master_low(push_target[x]))
							{
								//do a knockdown hes a twat
								knockback *= 3; //superpush
							}
							if (self->s.weapon == WP_MELEE ||
								self->s.weapon == WP_NONE ||
								self->s.weapon == WP_SABER &&
								!self->client->ps.SaberActive() &&
								!PM_InKnockDown(&self->client->ps))
							{
								knockback *= 2; //superpush
							}
							else
							{
								knockback *= 1.5; //superpush
							}
						}
					}

					if (mod_power_level != -1)
					{
						if (!mod_power_level)
						{
							knockback /= 10.0f;
						}
						else if (mod_power_level == 1)
						{
							knockback /= 6.0f;
						}
						else
						{
							knockback /= 2.0f;
						}
					}
					//actually push/pull the enemy
					G_Throw(push_target[x], push_dir, knockback);
					//make it so they don't actually hurt me when pulled at me...
					push_target[x]->forcePuller = self->s.number;

					if (push_target[x]->client->ps.groundEntityNum != ENTITYNUM_NONE)
					{
						//if on the ground, make sure they get shoved up some
						if (push_target[x]->client->ps.velocity[2] < knockback)
						{
							push_target[x]->client->ps.velocity[2] = knockback;
						}
					}

					if (push_target[x]->health > 0)
					{
						//target is still alive
						if ((push_target[x]->s.number || cg.renderingThirdPerson && !cg.zoomMode)
							//NPC or 3rd person player
							&& (!pull && self->client->ps.forcePowerLevel[FP_PUSH] < FORCE_LEVEL_2 && push_target[x]->
								client->ps.forcePowerLevel[FP_PUSH] < FORCE_LEVEL_1 //level 1 push
								|| pull && self->client->ps.forcePowerLevel[FP_PULL] < FORCE_LEVEL_2 && push_target[x]->
								client->ps.forcePowerLevel[FP_PULL] < FORCE_LEVEL_1)) //level 1 pull
						{
							//NPC or third person player (without force push/pull skill), and force push/pull level is at 1
							WP_ForceKnockdown(push_target[x], self, pull, static_cast<qboolean>(!pull && knockback > 150),
								qfalse);
						}
						else if (!push_target[x]->s.number)
						{
							//player, have to force an anim on him
							WP_ForceKnockdown(push_target[x], self, pull, static_cast<qboolean>(!pull && knockback > 150),
								qfalse);
						}
						else if (push_target[x]->client->NPC_class == CLASS_GUARD || jedi_jedi_master_low(push_target[x]))
						{
							//do a knockdown hes a twat
							WP_ForceKnockdown(push_target[x], self, pull, static_cast<qboolean>(!pull && knockback > 100),
								qfalse);
						}
						else
						{
							//NPC and force-push/pull at level 2 or higher
							WP_ForceKnockdown(push_target[x], self, pull, static_cast<qboolean>(!pull && knockback > 100),
								qfalse);
						}
					}
					push_target[x]->forcePushTime = level.time + 600; // let the push effect last for 600 ms
				}
			}
			else if (!fake)
			{
				//not a fake push/pull
				if (push_target[x]->s.weapon == WP_SABER && push_target[x]->contents & CONTENTS_LIGHTSABER)
				{
					//a thrown saber, just send it back
					if (push_target[x]->owner && push_target[x]->owner->client && push_target[x]->owner->client->ps.
						SaberActive() && push_target[x]->s.pos.trType == TR_LINEAR && push_target[x]->owner->client->ps.
						saberEntityState != SES_RETURNING)
					{
						//it's on and being controlled
						if (self->s.number == 0 || Q_irand(0, 2))
						{
							//certain chance of throwing it aside and turning it off?
							if (Q_irand(0, 1))
							{
								VectorScale(right, -1, right);
							}

							if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self))
							{
								if (is_class_guard)
								{
									G_MissileBouncedoffSaber(self, push_target[x], right);
								}
								else
								{
									G_ReflectMissileNPC(self, push_target[x], right);
								}
							}
							else
							{
								if (g_SerenityJediEngineMode->integer)
								{
									G_ReflectMissileAuto(self, push_target[x], right);
								}
								else
								{
									G_ReflectMissile_JKA(self, push_target[x], right);
								}
							}
							WP_SaberDrop(push_target[x]->owner, push_target[x]);
						}
						else
						{
							if (g_SerenityJediEngineMode->integer && g_SaberMustReturn->integer < 1 && (G_ControlledByPlayer(push_target[x]->owner)))
							{
								WP_SaberDrop(push_target[x]->owner, push_target[x]);
							}
							else
							{
								if (push_target[x]->owner->NPC && !G_ControlledByPlayer(push_target[x]->owner))
								{
									WP_SaberDrop(push_target[x]->owner, push_target[x]);
								}
								else
								{
									WP_SaberReturn(push_target[x]->owner, push_target[x]);
								}
							}
						}
						//different effect?
					}
				}
				else if (push_target[x]->s.eType == ET_MISSILE
					&& push_target[x]->s.pos.trType != TR_STATIONARY
					&& (push_target[x]->s.pos.trType != TR_INTERPOLATE || push_target[x]->s.weapon != WP_THERMAL))
					//rolling and stationary thermal detonators are dealt with below
				{
					vec3_t dir2_me;
					VectorSubtract(self->currentOrigin, push_target[x]->currentOrigin, dir2_me);
					float dot = DotProduct(push_target[x]->s.pos.trDelta, dir2_me);
					if (pull)
					{
						//deflect rather than reflect?
					}
					else
					{
						if (push_target[x]->s.eFlags & EF_MISSILE_STICK)
						{
							//caught a sticky in-air
							push_target[x]->s.eType = ET_MISSILE;
							push_target[x]->s.eFlags &= ~EF_MISSILE_STICK;
							push_target[x]->s.eFlags |= EF_BOUNCE_HALF;
							push_target[x]->splashDamage /= 3;
							push_target[x]->splashRadius /= 3;
							push_target[x]->e_ThinkFunc = thinkF_WP_Explode;
							push_target[x]->nextthink = level.time + Q_irand(500, 3000);
						}
						if (dot >= 0)
						{
							//it's heading towards me
							if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self))
							{
								if (is_class_guard)
								{
									G_MissileBouncedoffSaber(self, push_target[x], forward);
								}
								else
								{
									G_ReflectMissileNPC(self, push_target[x], forward);
								}
							}
							else
							{
								if (g_SerenityJediEngineMode->integer)
								{
									G_ReflectMissileAuto(self, push_target[x], forward);
								}
								else
								{
									G_ReflectMissile_JKA(self, push_target[x], forward);
								}
							}
						}
						else
						{
							VectorScale(push_target[x]->s.pos.trDelta, 1.25f, push_target[x]->s.pos.trDelta);
						}
					}
					if (push_target[x]->s.eType == ET_MISSILE
						&& push_target[x]->s.weapon == WP_ROCKET_LAUNCHER
						&& push_target[x]->damage < 60)
					{
						//pushing away a rocket raises it's damage to the max for NPCs
						push_target[x]->damage = 60;
					}
				}
				else if (push_target[x]->svFlags & SVF_GLASS_BRUSH)
				{
					//break the glass
					trace_t trace;
					vec3_t push_dir;
					float damage = 800;

					AngleVectors(self->client->ps.viewangles, forward, nullptr, nullptr);
					VectorNormalize(forward);
					VectorMA(self->client->renderInfo.eyePoint, radius, forward, end);
					gi.trace(&trace, self->client->renderInfo.eyePoint, vec3_origin, vec3_origin, end, self->s.number,
						MASK_SHOT, static_cast<EG2_Collision>(0), 0);
					if (trace.entityNum != push_target[x]->s.number || trace.fraction == 1.0 || trace.allsolid || trace.
						startsolid)
					{
						//must be pointing right at it
						continue;
					}

					if (pull)
					{
						VectorSubtract(self->client->renderInfo.eyePoint, trace.endpos, push_dir);
					}
					else
					{
						VectorSubtract(trace.endpos, self->client->renderInfo.eyePoint, push_dir);
					}
					damage -= VectorNormalize(push_dir);
					if (damage < 200)
					{
						damage = 200;
					}
					VectorScale(push_dir, damage, push_dir);

					G_Damage(push_target[x], self, self, push_dir, trace.endpos, damage, 0, MOD_UNKNOWN);
				}
				else if (!Q_stricmp("func_static", push_target[x]->classname))
				{
					//force-usable func_static
					if (!pull && push_target[x]->spawnflags & 1/*F_PUSH*/)
					{
						if (push_target[x]->NPC_targetname == nullptr
							|| self->targetname && Q_stricmp(push_target[x]->NPC_targetname, self->targetname) == 0)
						{
							//anyone can pull it or only 1 person can push it and it's me
							GEntity_UseFunc(push_target[x], self, self);
						}
					}
					else if (pull && push_target[x]->spawnflags & 2/*F_PULL*/)
					{
						if (push_target[x]->NPC_targetname == nullptr
							|| self->targetname && Q_stricmp(push_target[x]->NPC_targetname, self->NPC_targetname) == 0)
						{
							//anyone can push it or only 1 person can push it and it's me
							GEntity_UseFunc(push_target[x], self, self);
						}
					}
				}
				else if (!Q_stricmp("func_door", push_target[x]->classname) && push_target[x]->spawnflags & 2)
				{
					//push/pull the door
					vec3_t pos1, pos2;

					AngleVectors(self->client->ps.viewangles, forward, nullptr, nullptr);
					VectorNormalize(forward);
					VectorMA(self->client->renderInfo.eyePoint, radius, forward, end);
					gi.trace(&tr, self->client->renderInfo.eyePoint, vec3_origin, vec3_origin, end, self->s.number,
						MASK_SHOT, static_cast<EG2_Collision>(0), 0);
					if (tr.entityNum != push_target[x]->s.number || tr.fraction == 1.0 || tr.allsolid || tr.startsolid)
					{
						//must be pointing right at it
						continue;
					}

					if (VectorCompare(vec3_origin, push_target[x]->s.origin))
					{
						//does not have an origin brush, so pos1 & pos2 are relative to world origin, need to calc center
						VectorSubtract(push_target[x]->absmax, push_target[x]->absmin, size);
						VectorMA(push_target[x]->absmin, 0.5, size, center);
						if (push_target[x]->spawnflags & 1 && push_target[x]->moverState == MOVER_POS1)
						{
							//if at pos1 and started open, make sure we get the center where it *started* because we're going to add back in the relative values pos1 and pos2
							VectorSubtract(center, push_target[x]->pos1, center);
						}
						else if (!(push_target[x]->spawnflags & 1) && push_target[x]->moverState == MOVER_POS2)
						{
							//if at pos2, make sure we get the center where it *started* because we're going to add back in the relative values pos1 and pos2
							VectorSubtract(center, push_target[x]->pos2, center);
						}
						VectorAdd(center, push_target[x]->pos1, pos1);
						VectorAdd(center, push_target[x]->pos2, pos2);
					}
					else
					{
						//actually has an origin, pos1 and pos2 are absolute
						VectorCopy(push_target[x]->currentOrigin, center);
						VectorCopy(push_target[x]->pos1, pos1);
						VectorCopy(push_target[x]->pos2, pos2);
					}

					if (Distance(pos1, self->client->renderInfo.eyePoint) < Distance(
						pos2, self->client->renderInfo.eyePoint))
					{
						//pos1 is closer
						if (push_target[x]->moverState == MOVER_POS1)
						{
							//at the closest pos
							if (pull)
							{
								//trying to pull, but already at closest point, so screw it
								continue;
							}
						}
						else if (push_target[x]->moverState == MOVER_POS2)
						{
							//at farthest pos
							if (!pull)
							{
								//trying to push, but already at farthest point, so screw it
								continue;
							}
						}
					}
					else
					{
						//pos2 is closer
						if (push_target[x]->moverState == MOVER_POS1)
						{
							//at the farthest pos
							if (!pull)
							{
								//trying to push, but already at farthest point, so screw it
								continue;
							}
						}
						else if (push_target[x]->moverState == MOVER_POS2)
						{
							//at closest pos
							if (pull)
							{
								//trying to pull, but already at closest point, so screw it
								continue;
							}
						}
					}
					GEntity_UseFunc(push_target[x], self, self);
				}
				else if (push_target[x]->s.eType == ET_MISSILE /*thermal resting on ground*/
					|| push_target[x]->s.eType == ET_ITEM
					|| push_target[x]->e_ThinkFunc == thinkF_G_RunObject || Q_stricmp("limb", push_target[x]->classname) ==
					0)
				{
					//general object, toss it
					vec3_t push_dir, kvel;
					float knockback = pull ? 0 : 200;
					float mass = 200;

					if (pull)
					{
						if (push_target[x]->s.eType == ET_ITEM)
						{
							//pull it to a little higher point
							vec3_t adjustedOrg;
							VectorCopy(self->currentOrigin, adjustedOrg);
							adjustedOrg[2] += self->maxs[2] / 3;
							VectorSubtract(adjustedOrg, push_target[x]->currentOrigin, push_dir);
						}
						else if (self->enemy //I have an enemy
							//&& push_target[x]->s.eType != ET_ITEM //not an item
							&& self->client->ps.forcePowerLevel[FP_PUSH] > FORCE_LEVEL_2 //have push 3 or greater
							&& InFront(push_target[x]->currentOrigin, self->currentOrigin, self->currentAngles, 0.25f)
							//object is generally in front of me
							&& InFront(self->enemy->currentOrigin, self->currentOrigin, self->currentAngles, 0.75f)
							//enemy is pretty much right in front of me
							&& !InFront(push_target[x]->currentOrigin, self->enemy->currentOrigin,
								self->enemy->currentAngles, -0.25f) //object is generally behind enemy
							&& (self->NPC && (no_resist || is_class_guard || Q_irand(0, RANK_CAPTAIN) < self->NPC->rank)
								//NPC with enough skill
								|| self->s.number < MAX_CLIENTS))
						{
							//if I have an auto-enemy & he's in front of me, push it toward him!
							VectorSubtract(self->enemy->currentOrigin, push_target[x]->currentOrigin, push_dir);
						}
						else
						{
							VectorSubtract(self->currentOrigin, push_target[x]->currentOrigin, push_dir);
						}
						knockback += VectorNormalize(push_dir);
						if (knockback > 200)
						{
							knockback = 200;
						}
						if (push_target[x]->s.eType == ET_ITEM
							&& push_target[x]->item
							&& push_target[x]->item->giType == IT_HOLDABLE
							&& push_target[x]->item->giTag == INV_SECURITY_KEY)
						{
							//security keys are pulled with less enthusiasm
							if (knockback > 100)
							{
								knockback = 100;
							}
						}
						else if (knockback > 200)
						{
							knockback = 200;
						}
					}
					else
					{
						if (self->enemy //I have an enemy
							&& push_target[x]->s.eType != ET_ITEM //not an item
							&& self->client->ps.forcePowerLevel[FP_PUSH] > FORCE_LEVEL_2 //have push 3 or greater
							&& InFront(push_target[x]->currentOrigin, self->currentOrigin, self->currentAngles, 0.25f)
							//object is generally in front of me
							&& InFront(self->enemy->currentOrigin, self->currentOrigin, self->currentAngles, 0.75f)
							//enemy is pretty much right in front of me
							&& InFront(push_target[x]->currentOrigin, self->enemy->currentOrigin,
								self->enemy->currentAngles, 0.25f) //object is generally in front of enemy
							&& (self->NPC && (no_resist || is_class_guard || Q_irand(0, RANK_CAPTAIN) < self->NPC->rank)
								//NPC with enough skill
								|| self->s.number < MAX_CLIENTS))
						{
							//if I have an auto-enemy & he's in front of me, push it toward him!
							VectorSubtract(self->enemy->currentOrigin, push_target[x]->currentOrigin, push_dir);
						}
						else
						{
							VectorSubtract(push_target[x]->currentOrigin, self->currentOrigin, push_dir);
						}
						knockback -= VectorNormalize(push_dir);
						if (knockback < 100)
						{
							knockback = 100;
						}
					}
					VectorCopy(push_target[x]->currentOrigin, push_target[x]->s.pos.trBase);
					push_target[x]->s.pos.trTime = level.time; // move a bit on the very first frame
					if (push_target[x]->s.pos.trType != TR_INTERPOLATE)
					{
						//don't do this to rolling missiles
						push_target[x]->s.pos.trType = TR_GRAVITY;
					}

					if (push_target[x]->e_ThinkFunc == thinkF_G_RunObject && push_target[x]->physicsBounce)
					{
						//it's a pushable misc_model_breakable, use it's mass instead of our one-size-fits-all mass
						mass = push_target[x]->physicsBounce; //same as push_target[x]->mass, right?
					}
					if (mass < 50)
					{
						//???
						mass = 50;
					}
					if (g_gravity->value > 0)
					{
						VectorScale(push_dir, g_knockback->value * knockback / mass * 0.8, kvel);
						kvel[2] = push_dir[2] * g_knockback->value * knockback / mass * 1.5;
					}
					else
					{
						VectorScale(push_dir, g_knockback->value * knockback / mass, kvel);
					}
					VectorAdd(push_target[x]->s.pos.trDelta, kvel, push_target[x]->s.pos.trDelta);
					if (g_gravity->value > 0)
					{
						if (push_target[x]->s.pos.trDelta[2] < knockback)
						{
							push_target[x]->s.pos.trDelta[2] = knockback;
						}
					}
					//no trDuration?
					if (push_target[x]->e_ThinkFunc != thinkF_G_RunObject)
					{
						//objects spin themselves?
						push_target[x]->s.apos.trTime = level.time;
						push_target[x]->s.apos.trType = TR_LINEAR;
						VectorClear(push_target[x]->s.apos.trDelta);
						push_target[x]->s.apos.trDelta[1] = Q_irand(-800, 800);
					}

					if (Q_stricmp("limb", push_target[x]->classname) == 0)
					{
						//make sure it runs it's physics
						push_target[x]->e_ThinkFunc = thinkF_LimbThink;
						push_target[x]->nextthink = level.time + FRAMETIME;
					}
					push_target[x]->forcePushTime = level.time + 600; // let the push effect last for 600 ms
					push_target[x]->forcePuller = self->s.number; //remember this regardless
					if (push_target[x]->item && push_target[x]->item->giTag == INV_SECURITY_KEY)
					{
						AddSightEvent(player, push_target[x]->currentOrigin, 128, AEL_DISCOVERED);
						//security keys are more important
					}
					else
					{
						AddSightEvent(player, push_target[x]->currentOrigin, 128, AEL_SUSPICIOUS);
						//hmm... or should this always be discovered?
					}
				}
				else if (push_target[x]->s.weapon == WP_TURRET
					&& !Q_stricmp("PAS", push_target[x]->classname)
					&& push_target[x]->s.apos.trType == TR_STATIONARY)
				{
					//a portable turret
					WP_KnockdownTurret(push_target[x]);
				}
			}
		}
		if (pull)
		{
			if (self->client->ps.forcePowerLevel[FP_PULL] > FORCE_LEVEL_2)
			{
				//at level 3, can pull multiple, so it costs more
				actual_cost = forcePowerNeeded[FP_PULL] * ent_count;
				if (actual_cost > 50)
				{
					actual_cost = 50;
				}
				else if (actual_cost < cost)
				{
					actual_cost = cost;
				}
			}
			else
			{
				actual_cost = cost;
			}
			WP_ForcePowerStart(self, FP_PULL, actual_cost);
		}
		else
		{
			if (self->client->ps.forcePowerLevel[FP_PUSH] > FORCE_LEVEL_2)
			{
				//at level 3, can push multiple, so costs more
				actual_cost = forcePowerNeeded[FP_PUSH] * ent_count;
				if (actual_cost > 50)
				{
					actual_cost = 50;
				}
				else if (actual_cost < cost)
				{
					actual_cost = cost;
				}
			}
			else if (self->client->ps.forcePowerLevel[FP_PUSH] > FORCE_LEVEL_1)
			{
				//at level 2, can push multiple, so costs more
				actual_cost = floor(forcePowerNeeded[FP_PUSH] * ent_count / 1.5f);
				if (actual_cost > 50)
				{
					actual_cost = 50;
				}
				else if (actual_cost < cost)
				{
					actual_cost = cost;
				}
			}
			else
			{
				actual_cost = cost;
			}
			WP_ForcePowerStart(self, FP_PUSH, actual_cost);
		}
	}
	else
	{
		//didn't push or pull anything?  don't penalize them too much
		if (pull)
		{
			WP_ForcePowerStart(self, FP_PULL, 5);
		}
		else
		{
			WP_ForcePowerStart(self, FP_PUSH, 5);
		}
	}
	if (pull)
	{
		if (self->NPC)
		{
			//NPCs can push more often
			self->client->ps.forcePowerDebounce[FP_PULL] = level.time + 200;
		}
		else
		{
			self->client->ps.forcePowerDebounce[FP_PULL] = level.time + self->client->ps.torsoAnimTimer + 500;
		}
	}
	else
	{
		if (self->NPC)
		{
			//NPCs can push more often
			self->client->ps.forcePowerDebounce[FP_PUSH] = level.time + 200;
		}
		else
		{
			self->client->ps.forcePowerDebounce[FP_PUSH] = level.time + self->client->ps.torsoAnimTimer + 500;
		}
	}
}

void ForceThrow_MD(gentity_t* self, qboolean pull, qboolean fake) //MD Mode Push
{
	//shove things in front of you away
	gentity_t* forward_ent = nullptr;
	gentity_t* push_target[MAX_GENTITIES];
	int num_listed_entities = 0;
	int ent_count = 0;
	int radius;
	vec3_t center, size, forward, right, end, fwdangles = { 0 };
	float cone;
	trace_t tr;
	int anim, hold, sound_index, cost;
	qboolean no_resist = qfalse;
	int damage_level = FORCE_LEVEL_0;
	qboolean is_class_guard = qfalse;

	if (self->client->ps.groundEntityNum == ENTITYNUM_NONE && self->client->ps.forcePowerLevel[FP_PUSH] > FORCE_LEVEL_2
		&& (self->s.weapon == WP_MELEE ||
			self->s.weapon == WP_NONE ||
			self->s.weapon == WP_SABER && !self->client->ps.SaberActive()))
	{
		damage_level = FORCE_LEVEL_3;
	}
	else if (self->client->ps.groundEntityNum == ENTITYNUM_NONE && self->client->ps.forcePowerLevel[FP_PUSH] <
		FORCE_LEVEL_3
		&& (self->s.weapon == WP_MELEE ||
			self->s.weapon == WP_NONE ||
			self->s.weapon == WP_SABER && !self->client->ps.SaberActive()))
	{
		damage_level = FORCE_LEVEL_2;
	}
	else
	{
		damage_level = FORCE_LEVEL_1;
	}

	if (pm_saber_innonblockable_attack(self->client->ps.torsoAnim))
	{
		return;
	}

	if (PM_InGetUp(&self->client->ps)
		|| PM_InForceGetUp(&self->client->ps)
		|| PM_InKnockDown(&self->client->ps)
		|| PM_KnockDownAnim(player->client->ps.legsAnim)
		|| PM_KnockDownAnim(player->client->ps.torsoAnim)
		|| PM_StaggerAnim(player->client->ps.torsoAnim))
	{
		return;
	}
	if (self->health <= 0)
	{
		return;
	}
	if (self->client->ps.leanofs)
	{
		//can't force-throw while leaning
		return;
	}
	if (self->client->ps.forcePowerDebounce[FP_PUSH] > level.time)
	{
		//already pushing- now you can't haul someone across the room, sorry
		return;
	}
	if (self->client->ps.forcePowerDebounce[FP_PULL] > level.time)
	{
		//already pulling- now you can't haul someone across the room, sorry
		return;
	}
	if (self->client->ps.pullAttackTime > level.time)
	{
		//already pull-attacking
		return;
	}
	if (!self->s.number && (cg.zoomMode || in_camera))
	{
		//can't force throw/pull when zoomed in or in cinematic
		return;
	}

	if (PM_InLedgeMove(self->client->ps.legsAnim))
	{
		return;
	}

	if (self->client->ps.saberLockTime > level.time)
	{
		if (pull || self->client->ps.forcePowerLevel[FP_PUSH] < FORCE_LEVEL_3)
		{
			//this can be a way to break out
			return;
		}
		//else, I'm breaking my half of the saberlock
		self->client->ps.saberLockTime = 0;
		self->client->ps.saberLockEnemy = ENTITYNUM_NONE;
	}

	if (self->client->NPC_class == CLASS_GUARD)
	{
		return;
	}

	if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self) && self->client->ps.weapon == WP_SABER)
		//npc force use limit
	{
		if (self->client->ps.blockPoints < BLOCKPOINTS_HALF || self->client->ps.forcePower < BLOCKPOINTS_HALF)
		{
			return;
		}
	}

	if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self) && self->client->NPC_class == CLASS_KYLE)
		//npc force use limit
	{
		if (self->client->ps.forcePower < BLOCKPOINTS_FULL)
		{
			return;
		}
	}

	if (self->client->ps.legsAnim == BOTH_KNOCKDOWN3
		|| self->client->ps.torsoAnim == BOTH_FORCE_GETUP_F1 && self->client->ps.torsoAnimTimer > 400
		|| self->client->ps.torsoAnim == BOTH_FORCE_GETUP_F2 && self->client->ps.torsoAnimTimer > 900
		|| self->client->ps.torsoAnim == BOTH_GETUP3 && self->client->ps.torsoAnimTimer > 500
		|| self->client->ps.torsoAnim == BOTH_GETUP4 && self->client->ps.torsoAnimTimer > 300
		|| self->client->ps.torsoAnim == BOTH_GETUP5 && self->client->ps.torsoAnimTimer > 500)
	{
		//we're face-down, so we'd only be force-push/pulling the floor
		return;
	}
	if (pull)
	{
		radius = forcePushPullRadius[self->client->ps.forcePowerLevel[FP_PULL]];
	}
	else
	{
		radius = forcePushPullRadius[self->client->ps.forcePowerLevel[FP_PUSH]];
	}

	if (!radius)
	{
		//no ability to do this yet
		return;
	}

	if (pull)
	{
		cost = forcePowerNeeded[FP_PULL];
		if (!WP_ForcePowerUsable(self, FP_PULL, cost))
		{
			return;
		}
		//make sure this plays and that you cannot press fire for about 200ms after this
		anim = BOTH_FORCEPULL;
		sound_index = G_SoundIndex("sound/weapons/force/pull.wav");
		hold = 200;
	}
	else
	{
		cost = forcePowerNeeded[FP_PUSH];
		if (!WP_ForcePowerUsable(self, FP_PUSH, cost))
		{
			return;
		}

		//make sure this plays and that you cannot press fire for about 1 second after this
		if (self->s.weapon == WP_MELEE || self->s.weapon == WP_NONE
			|| self->s.weapon == WP_SABER && !self->client->ps.SaberActive())
		{
			//2-handed PUSH
			if (self->client->ps.groundEntityNum == ENTITYNUM_NONE && self->client->NPC_class == CLASS_GALEN)
			{
				anim = BOTH_FORCE_REPULSE;
			}
			else
			{
				if (self->s.eFlags & EF_FORCE_DRAINED || self->s.eFlags & EF_FORCE_GRIPPED || self->s.eFlags &
					EF_FORCE_GRASPED)
				{
					anim = BOTH_FORCEPUSH;
				}
				else
				{
					anim = BOTH_DUAL_PUSH;
				}
			}
		}
		else
		{
			anim = BOTH_FORCEPUSH;
		}

		if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self)) // npc push sounds
		{
			if (self->client->ps.forcePower < 50)
			{
				sound_index = G_SoundIndex("sound/weapons/force/pushlow.mp3");
			}
			else
			{
				sound_index = G_SoundIndex("sound/weapons/force/push.mp3");
			}
		}
		else
		{
			if (g_SerenityJediEngineMode->integer)
			{
				if (self->client->ps.forcePower < 30 || PM_InKnockDown(&self->client->ps))
				{
					sound_index = G_SoundIndex("sound/weapons/force/pushlow.mp3");
				}
				else
				{
					if (self->client->ps.groundEntityNum == ENTITYNUM_NONE &&
						self->client->ps.forcePower > 50)
					{
						sound_index = G_SoundIndex("sound/weapons/force/pushhard.mp3");
					}
					else
					{
						if (self->client->ps.forcePower > 90)
						{
							sound_index = G_SoundIndex("sound/weapons/force/push_md.mp3");
						}
						else
						{
							sound_index = G_SoundIndex("sound/weapons/force/push.mp3");
						}
					}
				}
			}
			else
			{
				sound_index = G_SoundIndex("sound/weapons/force/push.mp3");
			}
		}
		hold = 650;
	}

	int parts = SETANIM_TORSO;
	if (!PM_InKnockDown(&self->client->ps))
	{
		if (self->client->ps.saberLockTime > level.time)
		{
			self->client->ps.saberLockTime = 0;
			self->painDebounceTime = level.time + 2000;
			hold += 1000;
			parts = SETANIM_BOTH;
		}
		else if (!VectorLengthSquared(self->client->ps.velocity) && !(self->client->ps.pm_flags & PMF_DUCKED))
		{
			parts = SETANIM_BOTH;
		}
	}
	NPC_SetAnim(self, parts, anim, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD | SETANIM_FLAG_RESTART);
	self->client->ps.saber_move = self->client->ps.saberBounceMove = LS_READY;
	//don't finish whatever saber anim you may have been in
	self->client->ps.saberBlocked = BLOCKED_NONE;
	if (self->client->ps.forcePowersActive & 1 << FP_SPEED)
	{
		hold = floor(hold * g_timescale->value);
	}
	self->client->ps.weaponTime = hold; //was 1000, but want to swing sooner
	self->client->ps.powerups[PW_FORCE_PUSH] = level.time + self->client->ps.torsoAnimTimer + 500;
	self->client->pushEffectFadeTime = 0;

	G_Sound(self, sound_index);

	if (!pull && self->client->ps.forcePowersForced & 1 << FP_PUSH
		|| pull && self->client->ps.forcePowersForced & 1 << FP_PULL
		|| pull && self->client->NPC_class == CLASS_KYLE && self->spawnflags & 1 && TIMER_Done(self, "kyleTakesSaber"))
	{
		no_resist = qtrue;
	}

	if (self->client->NPC_class == CLASS_GUARD || jedi_jedi_master_low(self))
	{
		is_class_guard = qtrue;
	}

	VectorCopy(self->client->ps.viewangles, fwdangles);
	//fwdangles[1] = self->client->ps.viewangles[1];
	AngleVectors(fwdangles, forward, right, nullptr);
	VectorCopy(self->currentOrigin, center);

	if (pull)
	{
		cone = forcePullCone[self->client->ps.forcePowerLevel[FP_PULL]];
	}
	else
	{
		cone = forcePushCone[self->client->ps.forcePowerLevel[FP_PUSH]];
	}

	//	if ( cone >= 1.0f )
	{
		//must be pointing right at them
		VectorMA(self->client->renderInfo.eyePoint, radius, forward, end);
		gi.trace(&tr, self->client->renderInfo.eyePoint, vec3_origin, vec3_origin, end, self->s.number,
			MASK_OPAQUE | CONTENTS_SOLID | CONTENTS_BODY | CONTENTS_ITEM | CONTENTS_CORPSE,
			static_cast<EG2_Collision>(0), 0); //was MASK_SHOT, changed to match crosshair trace
		if (tr.entityNum < ENTITYNUM_WORLD)
		{
			//found something right in front of self,
			forward_ent = &g_entities[tr.entityNum];
			if (!forward_ent->client && !Q_stricmp("func_static", forward_ent->classname))
			{
				if (forward_ent->spawnflags & 1/*F_PUSH*/ || forward_ent->spawnflags & 2/*F_PULL*/)
				{
					//push/pullable
					if (forward_ent->spawnflags & 32/*SOLITARY*/)
					{
						//can only push/pull ME, ignore all others
						if (forward_ent->NPC_targetname == nullptr
							|| self->targetname && Q_stricmp(forward_ent->NPC_targetname, self->targetname) == 0)
						{
							//anyone can push it or only 1 person can push it and it's me
							push_target[0] = forward_ent;
							ent_count = num_listed_entities = 1;
						}
					}
				}
			}
		}
	}

	if (forward_ent)
	{
		if (G_TryingPullAttack(self, &self->client->usercmd, qtrue))
		{
			//we're going to try to do a pull attack on our forwardEnt
			if (WP_ForceThrowable(forward_ent, forward_ent, self, pull, cone, radius, forward))
			{
				//we will actually pull-attack him, so don't pull him or anything else here
				//activate the power, here, though, so the later check that actually does the pull attack knows we tried to pull
				self->client->ps.forcePowersActive |= 1 << FP_PULL;
				self->client->ps.forcePowerDebounce[FP_PULL] = level.time + 100; //force-pulling
				return;
			}
		}
	}

	if (!num_listed_entities)
	{
		int e;
		int i;
		vec3_t v{};
		vec3_t maxs{};
		vec3_t mins{};
		gentity_t* entity_list[MAX_GENTITIES];
		gentity_t* ent;
		float dist;
		for (i = 0; i < 3; i++)
		{
			mins[i] = center[i] - radius;
			maxs[i] = center[i] + radius;
		}

		num_listed_entities = gi.EntitiesInBox(mins, maxs, entity_list, MAX_GENTITIES);

		for (e = 0; e < num_listed_entities; e++)
		{
			float dot1;
			vec3_t dir;
			vec3_t ent_org;
			ent = entity_list[e];

			if (!WP_ForceThrowable(ent, forward_ent, self, pull, cone, radius, forward))
			{
				continue;
			}

			//this is all to see if we need to start a saber attack, if it's in flight, this doesn't matter
			// find the distance from the edge of the bounding box
			for (i = 0; i < 3; i++)
			{
				if (center[i] < ent->absmin[i])
				{
					v[i] = ent->absmin[i] - center[i];
				}
				else if (center[i] > ent->absmax[i])
				{
					v[i] = center[i] - ent->absmax[i];
				}
				else
				{
					v[i] = 0;
				}
			}

			VectorSubtract(ent->absmax, ent->absmin, size);
			VectorMA(ent->absmin, 0.5, size, ent_org);

			//see if they're in front of me
			VectorSubtract(ent_org, center, dir);
			VectorNormalize(dir);
			if (cone < 1.0f)
			{
				//must be within the forward cone
				if (ent->client && !pull
					&& ent->client->ps.forceGripEntityNum == self->s.number
					&& (self->s.eFlags & EF_FORCE_GRIPPED || self->s.eFlags & EF_FORCE_GRASPED))
				{
					//this is the guy that's force-gripping me, use a wider cone regardless of force power level
					if ((dot1 = DotProduct(dir, forward)) < cone - 0.3f)
						continue;
				}
				else if (ent->client && !pull
					&& ent->client->ps.forceDrainEntityNum == self->s.number
					&& self->s.eFlags & EF_FORCE_DRAINED)
				{
					//this is the guy that's force-draining me, use a wider cone regardless of force power level
					if ((dot1 = DotProduct(dir, forward)) < cone - 0.3f)
						continue;
				}
				else if (ent->s.eType == ET_MISSILE)
					//&& ent->s.eType != ET_ITEM && ent->e_ThinkFunc != thinkF_G_RunObject )
				{
					//missiles are easier to force-push, never require direct trace (FIXME: maybe also items and general physics objects)
					if ((dot1 = DotProduct(dir, forward)) < cone - 0.3f)
						continue;
				}
				else if ((dot1 = DotProduct(dir, forward)) < cone)
				{
					continue;
				}
			}
			else if (ent->s.eType == ET_MISSILE)
			{
				//a missile and we're at force level 1... just use a small cone, but not ridiculously small
				if ((dot1 = DotProduct(dir, forward)) < 0.75f)
				{
					continue;
				}
			} //else is an NPC or brush entity that our forward trace would have to hit

			dist = VectorLength(v);

			//if within a certain range, deflect it
			if (ent->s.eType == ET_MISSILE && cone >= 1.0f)
			{
				//smaller radius on missile checks at force push 1
				if (dist >= 192)
				{
					continue;
				}
			}
			else if (dist >= radius)
			{
				continue;
			}

			//in PVS?
			if (!ent->bmodel && !gi.inPVS(ent_org, self->client->renderInfo.eyePoint))
			{
				//must be in PVS
				continue;
			}

			if (ent != forward_ent)
			{
				//don't need to trace against forwardEnt again
				//really should have a clear LOS to this thing...
				gi.trace(&tr, self->client->renderInfo.eyePoint, vec3_origin, vec3_origin, ent_org, self->s.number,
					MASK_FORCE_PUSH, static_cast<EG2_Collision>(0), 0);
				//was MASK_SHOT, but changed to match above trace and crosshair trace
				if (tr.fraction < 1.0f && tr.entityNum != ent->s.number)
				{
					//must have clear LOS
					continue;
				}
			}

			// ok, we are within the radius, add us to the incoming list
			push_target[ent_count] = ent;
			ent_count++;
		}
	}

	if (ent_count)
	{
		int actual_cost;
		for (int x = 0; x < ent_count; x++)
		{
			if (push_target[x]->client)
			{
				float knockback = pull ? 0 : 200;

				//SIGH band-aid...
				if (push_target[x]->s.number >= MAX_CLIENTS
					&& self->s.number < MAX_CLIENTS)
				{
					if (push_target[x]->client->ps.forcePowersActive & 1 << FP_GRIP
						&& push_target[x]->client->ps.forceGripEntityNum == self->s.number)
					{
						WP_ForcePowerStop(push_target[x], FP_GRIP);
					}
					if (push_target[x]->client->ps.forcePowersActive & 1 << FP_GRASP
						&& push_target[x]->client->ps.forceGripEntityNum == self->s.number)
					{
						WP_ForcePowerStop(push_target[x], FP_GRASP);
					}
					if (push_target[x]->client->ps.forcePowersActive & 1 << FP_DRAIN
						&& push_target[x]->client->ps.forceDrainEntityNum == self->s.number)
					{
						WP_ForcePowerStop(push_target[x], FP_DRAIN);
					}
				}

				if (rosh_being_healed(push_target[x]))
				{
					continue;
				}
				if (push_target[x]->client->NPC_class == CLASS_HAZARD_TROOPER
					&& push_target[x]->health > 0)
				{
					//living hazard troopers resist push/pull
					WP_ForceThrowHazardTrooper(self, push_target[x], pull);
					continue;
				}
				if (fake && !is_class_guard)
				{
					//always resist
					WP_ResistForcePush(push_target[x], self, qfalse);
					continue;
				}

				int power_level, power_use;

				if (pull)
				{
					power_level = self->client->ps.forcePowerLevel[FP_PULL];
					power_use = FP_PULL;
				}
				else
				{
					power_level = self->client->ps.forcePowerLevel[FP_PUSH];
					power_use = FP_PUSH;
				}
				int mod_power_level = WP_AbsorbConversion(push_target[x],
					push_target[x]->client->ps.forcePowerLevel[FP_ABSORB], power_use,
					power_level,
					forcePowerNeeded[self->client->ps.forcePowerLevel[power_use]]);
				if (push_target[x]->client->NPC_class == CLASS_ASSASSIN_DROID ||
					push_target[x]->client->NPC_class == CLASS_HAZARD_TROOPER ||
					push_target[x]->client->NPC_class == CLASS_DROIDEKA)
				{
					mod_power_level = 0; // divides throw by 10
				}

				//First, if this is the player we're push/pulling, see if he can counter it
				if (mod_power_level != -1
					&& !no_resist && !is_class_guard
					&& InFront(self->currentOrigin, push_target[x]->client->renderInfo.eyePoint,
						push_target[x]->client->ps.viewangles, 0.3f))
				{
					//absorbed and I'm in front of them
					//counter it
					if (push_target[x]->client->ps.forcePowerLevel[FP_ABSORB] > FORCE_LEVEL_2)
					{
						//no reaction at all
					}
					else
					{
						WP_ResistForcePush(push_target[x], self, qfalse);
						push_target[x]->client->ps.saber_move = push_target[x]->client->ps.saberBounceMove = LS_READY;
						//don't finish whatever saber anim you may have been in
						push_target[x]->client->ps.saberBlocked = BLOCKED_NONE;
					}
					continue;
				}
				if (!push_target[x]->s.number && !is_class_guard)
				{
					//player
					if (!no_resist && !is_class_guard && (ShouldPlayerResistForceThrow(push_target[x], self, pull) ||
						PlayerisResistingForceThrow(push_target[x], self))
						&& push_target[x]->client->ps.saberFatigueChainCount < MISHAPLEVEL_HEAVY)
					{
						WP_ResistForcePush(push_target[x], self, qfalse);
						push_target[x]->client->ps.saber_move = push_target[x]->client->ps.saberBounceMove = LS_READY;
						//don't finish whatever saber anim you may have been in
						push_target[x]->client->ps.saberBlocked = BLOCKED_NONE;
						continue;
					}
				}
				else if (push_target[x]->client && jedi_waiting_ambush(push_target[x]))
				{
					WP_ForceKnockdown(push_target[x], self, pull, qtrue, qfalse);
					if (g_SerenityJediEngineMode->integer)
					{
						if (pull)
						{
							//
						}
						else
						{
							PushDamage(self, push_target[x], tr.endpos, damage_level);
						}
					}
					continue;
				}
				else if (PM_SaberInBrokenParry(push_target[x]->client->ps.saber_move))
				{
					//do a knockdown if fairly close
					WP_ForceKnockdown(push_target[x], self, pull, qtrue, qfalse);
					if (g_SerenityJediEngineMode->integer)
					{
						if (pull)
						{
							//
						}
						else
						{
							PushDamage(self, push_target[x], tr.endpos, damage_level);
						}
					}
					continue;
				}
				else if (push_target[x]->client->NPC_class == CLASS_GUARD || jedi_jedi_master_low(push_target[x]))
				{
					//do a knockdown hes a twat
					WP_ForceKnockdown(push_target[x], self, pull, qtrue, qfalse);
					if (g_SerenityJediEngineMode->integer)
					{
						if (pull)
						{
							//
						}
						else
						{
							PushDamage(self, push_target[x], tr.endpos, damage_level);
						}
					}
					continue;
				}

				G_KnockOffVehicle(push_target[x], self, pull);

				if (!pull
					&& push_target[x]->client->ps.forceDrainEntityNum == self->s.number
					&& self->s.eFlags & EF_FORCE_DRAINED)
				{
					//stop them from draining me now, dammit!
					WP_ForcePowerStop(push_target[x], FP_DRAIN);
				}

				//okay, everyone else (or player who couldn't resist it)...
				if ((self->s.number == 0 && Q_irand(0, 2) || Q_irand(0, 2)) && push_target[x]->client && push_target[x]->
					health > 0 //a living client
					&& push_target[x]->client->ps.weapon == WP_SABER //Jedi
					&& push_target[x]->health > 0 //alive
					&& push_target[x]->client->ps.forceRageRecoveryTime < level.time //not recovering from rage
					&& (self->client->NPC_class != CLASS_DESANN && self->client->NPC_class != CLASS_SITHLORD && self->
						client->NPC_class != CLASS_VADER && Q_stricmp("Yoda", self->NPC_type) || !Q_irand(0, 2))
					//only 30% chance of resisting a Desann push
					&& push_target[x]->client->ps.groundEntityNum != ENTITYNUM_NONE //on the ground
					&& InFront(self->currentOrigin, push_target[x]->currentOrigin, push_target[x]->client->ps.viewangles,
						0.3f) //I'm in front of him
					&& (push_target[x]->client->ps.powerups[PW_FORCE_PUSH] > level.time || //he's pushing too
						push_target[x]->s.number != 0 && push_target[x]->client->ps.weaponTime < level.time))
				{
					//Jedi don't get pushed, they resist as long as they aren't already attacking and are on the ground
					if (push_target[x]->client->ps.saberLockTime > level.time)
					{
						//they're in a lock
						if (push_target[x]->client->ps.saberLockEnemy != self->s.number)
						{
							//they're not in a lock with me
							continue;
						}
						if (pull || self->client->ps.forcePowerLevel[FP_PUSH] < FORCE_LEVEL_3 ||
							push_target[x]->client->ps.forcePowerLevel[FP_PUSH] > FORCE_LEVEL_2)
						{
							//they're in a lock with me, but my push is too weak
							continue;
						}
						//we will knock them down
						self->painDebounceTime = 0;
						self->client->ps.weaponTime = 500;
						if (self->client->ps.forcePowersActive & 1 << FP_SPEED)
						{
							self->client->ps.weaponTime = floor(self->client->ps.weaponTime * g_timescale->value);
						}
					}
					int resist_chance = Q_irand(0, 2);
					if (push_target[x]->s.number >= MAX_CLIENTS)
					{
						//NPC
						if (g_spskill->integer == 1)
						{
							//stupid tweak for graham
							resist_chance = Q_irand(0, 3);
						}
					}
					if (no_resist || is_class_guard ||
						!pull
						&& mod_power_level == -1
						&& self->client->ps.forcePowerLevel[FP_PUSH] > FORCE_LEVEL_2
						&& !resist_chance
						&& push_target[x]->client->ps.forcePowerLevel[FP_PUSH] < FORCE_LEVEL_3)
					{
						//a level 3 push can even knock down a jedi
						if (PM_InKnockDown(&push_target[x]->client->ps))
						{
							//can't knock them down again
							continue;
						}
						WP_ForceKnockdown(push_target[x], self, pull, qfalse, qtrue);
						if (g_SerenityJediEngineMode->integer)
						{
							if (pull)
							{
								//
							}
							else
							{
								PushDamage(self, push_target[x], tr.endpos, damage_level);
							}
						}
					}
					else
					{
						if (!is_class_guard)
						{
							WP_ResistForcePush(push_target[x], self, qfalse);
						}
					}
				}
				else
				{
					vec3_t push_dir;
					//shove them
					if (push_target[x]->NPC
						&& push_target[x]->NPC->jumpState == JS_JUMPING)
					{
						//don't interrupt a scripted jump
						push_target[x]->forcePushTime = level.time + 600; // let the push effect last for 600 ms
						continue;
					}

					if (push_target[x]->s.number
						&& (push_target[x]->message || push_target[x]->flags & FL_NO_KNOCKBACK))
					{
						//an NPC who has a key
						//don't push me... FIXME: maybe can pull the key off me?
						WP_ForceKnockdown(push_target[x], self, pull, qfalse, qfalse);
						if (g_SerenityJediEngineMode->integer)
						{
							if (pull)
							{
								//
							}
							else
							{
								PushDamage(self, push_target[x], tr.endpos, damage_level);
							}
						}
						continue;
					}
					if (pull)
					{
						VectorSubtract(self->currentOrigin, push_target[x]->currentOrigin, push_dir);
						if (self->client->ps.forcePowerLevel[FP_PULL] >= FORCE_LEVEL_3
							&& self->client->NPC_class == CLASS_KYLE
							&& self->spawnflags & 1
							&& TIMER_Done(self, "kyleTakesSaber")
							&& push_target[x]->client
							&& push_target[x]->client->ps.weapon == WP_SABER
							&& !push_target[x]->client->ps.saberInFlight
							&& push_target[x]->client->ps.saberEntityNum < ENTITYNUM_WORLD
							&& !PM_InOnGroundAnim(&push_target[x]->client->ps))
						{
							vec3_t throw_vec;
							VectorScale(push_dir, 10.0f, throw_vec);
							WP_SaberLose(push_target[x], throw_vec);
							NPC_SetAnim(push_target[x], SETANIM_BOTH, BOTH_LOSE_SABER,
								SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
							push_target[x]->client->ps.torsoAnimTimer += 500;
							push_target[x]->client->ps.pm_time = push_target[x]->client->ps.weaponTime = push_target[x]->
								client->ps.torsoAnimTimer;
							push_target[x]->client->ps.pm_flags |= PMF_TIME_KNOCKBACK;
							push_target[x]->client->ps.saber_move = LS_NONE;
							push_target[x]->aimDebounceTime = level.time + push_target[x]->client->ps.torsoAnimTimer;
							VectorClear(push_target[x]->client->ps.velocity);
							VectorClear(push_target[x]->client->ps.moveDir);
							//Kyle will stand around for a bit, too...
							self->client->ps.pm_time = self->client->ps.weaponTime = 2000;
							self->client->ps.pm_flags |= PMF_TIME_KNOCKBACK;
							self->painDebounceTime = level.time + self->client->ps.weaponTime;
							TIMER_Set(self, "kyleTakesSaber", Q_irand(60000, 180000)); //don't do this again for a while
							G_AddVoiceEvent(self, Q_irand(EV_TAUNT1, EV_TAUNT5), Q_irand(8000, 12000));
							VectorClear(self->client->ps.velocity);
							VectorClear(self->client->ps.moveDir);
							continue;
						}
						if (push_target[x]->NPC
							&& push_target[x]->NPC->scriptFlags & SCF_DONT_FLEE)
						{
							//*SIGH*... if an NPC can't flee, they can't run after and pick up their weapon, do don't drop it
						}
						else if (self->client->ps.forcePowerLevel[FP_PULL] > FORCE_LEVEL_1
							&& push_target[x]->client->NPC_class != CLASS_ROCKETTROOPER
							//rockettroopers never drop their weapon
							&& push_target[x]->client->NPC_class != CLASS_VEHICLE
							&& push_target[x]->client->NPC_class != CLASS_BOBAFETT
							&& push_target[x]->client->NPC_class != CLASS_MANDALORIAN
							&& push_target[x]->client->NPC_class != CLASS_JANGO
							&& push_target[x]->client->NPC_class != CLASS_JANGODUAL
							&& push_target[x]->client->NPC_class != CLASS_TUSKEN
							&& push_target[x]->client->NPC_class != CLASS_HAZARD_TROOPER
							&& push_target[x]->client->NPC_class != CLASS_ASSASSIN_DROID
							&& push_target[x]->client->NPC_class != CLASS_DROIDEKA
							&& push_target[x]->client->NPC_class != CLASS_SBD
							&& push_target[x]->s.weapon != WP_SABER
							&& push_target[x]->s.weapon != WP_MELEE
							&& push_target[x]->s.weapon != WP_THERMAL
							&& push_target[x]->s.weapon != WP_CONCUSSION // so rax can't drop his
							)
						{
							//yank the weapon - NOTE: level 1 just knocks them down, not take weapon
							//FIXME: weapon yank anim if not a knockdown?
							if (InFront(self->currentOrigin, push_target[x]->currentOrigin,
								push_target[x]->client->ps.viewangles, 0.0f))
							{
								//enemy has to be facing me, too...
								WP_DropWeapon(push_target[x], push_dir);
							}
						}
						knockback += VectorNormalize(push_dir);
						if (knockback > 300)
						{
							knockback = 300;
						}
						if (self->client->ps.forcePowerLevel[FP_PULL] < FORCE_LEVEL_3)
						{
							//maybe just knock them down
							knockback /= 3;
						}
					}
					else
					{
						VectorSubtract(push_target[x]->currentOrigin, self->currentOrigin, push_dir);
						knockback -= VectorNormalize(push_dir);

						G_SoundOnEnt(push_target[x], CHAN_BODY, "sound/weapons/force/pushed.mp3");

						if (knockback < 100) // if less than 100
						{
							knockback = 100; // minimum 100
						}

						//scale for push level
						if (self->client->ps.forcePowerLevel[FP_PUSH] < FORCE_LEVEL_2) // level 1 devide by 3
						{
							if (self->s.weapon == WP_MELEE ||
								self->s.weapon == WP_NONE ||
								self->s.weapon == WP_SABER &&
								!self->client->ps.SaberActive() &&
								!PM_InKnockDown(&self->client->ps))
							{
								//maybe just knock them down
								knockback /= 2;
							}
							else
							{
								//maybe just knock them down
								knockback /= 3;
							}
						}
						else if (self->client->ps.forcePowerLevel[FP_PUSH] == FORCE_LEVEL_2) // level 2
						{
							if (self->s.weapon == WP_MELEE ||
								self->s.weapon == WP_NONE ||
								self->s.weapon == WP_SABER &&
								!self->client->ps.SaberActive() &&
								!PM_InKnockDown(&self->client->ps))
							{
								knockback = 125;
							}
							else
							{
								knockback = 100;
							}
						}
						else if (self->client->ps.forcePowerLevel[FP_PUSH] > FORCE_LEVEL_2) // level 3 add sound
						{
							if (push_target[x]->client->NPC_class == CLASS_GUARD || jedi_jedi_master_low(push_target[x]))
							{
								//do a knockdown hes a twat
								knockback *= 3; //superpush
							}
							if (self->s.weapon == WP_MELEE ||
								self->s.weapon == WP_NONE ||
								self->s.weapon == WP_SABER &&
								!self->client->ps.SaberActive() &&
								!PM_InKnockDown(&self->client->ps))
							{
								knockback *= 4; //superpush
							}
							else
							{
								knockback *= 2; //superpush
							}
						}
					}

					if (mod_power_level != -1)
					{
						if (!mod_power_level)
						{
							knockback /= 10.0f;
						}
						else if (mod_power_level == 1)
						{
							knockback /= 6.0f;
						}
						else
						{
							knockback /= 2.0f;
						}
					}
					//actually push/pull the enemy
					G_Throw(push_target[x], push_dir, knockback);
					//make it so they don't actually hurt me when pulled at me...
					push_target[x]->forcePuller = self->s.number;

					if (push_target[x]->client->ps.groundEntityNum != ENTITYNUM_NONE)
					{
						//if on the ground, make sure they get shoved up some
						if (push_target[x]->client->ps.velocity[2] < knockback)
						{
							push_target[x]->client->ps.velocity[2] = knockback;
						}
					}

					if (push_target[x]->health > 0)
					{
						//target is still alive
						if ((push_target[x]->s.number || cg.renderingThirdPerson && !cg.zoomMode)
							//NPC or 3rd person player
							&& (!pull && self->client->ps.forcePowerLevel[FP_PUSH] < FORCE_LEVEL_2 && push_target[x]->
								client->ps.forcePowerLevel[FP_PUSH] < FORCE_LEVEL_1 //level 1 push
								|| pull && self->client->ps.forcePowerLevel[FP_PULL] < FORCE_LEVEL_2 && push_target[x]->
								client->ps.forcePowerLevel[FP_PULL] < FORCE_LEVEL_1)) //level 1 pull
						{
							//NPC or third person player (without force push/pull skill), and force push/pull level is at 1
							WP_ForceKnockdown(push_target[x], self, pull, static_cast<qboolean>(!pull && knockback > 150),
								qfalse);
							if (g_SerenityJediEngineMode->integer)
							{
								if (pull)
								{
									//
								}
								else
								{
									PushDamage(self, push_target[x], tr.endpos, damage_level);
								}
							}
						}
						else if (!push_target[x]->s.number)
						{
							//player, have to force an anim on him
							WP_ForceKnockdown(push_target[x], self, pull, static_cast<qboolean>(!pull && knockback > 150),
								qfalse);
							if (g_SerenityJediEngineMode->integer)
							{
								if (pull)
								{
									//
								}
								else
								{
									PushDamage(self, push_target[x], tr.endpos, damage_level);
								}
							}
						}
						else
						{
							//NPC and force-push/pull at level 2 or higher
							WP_ForceKnockdown(push_target[x], self, pull, static_cast<qboolean>(!pull && knockback > 100),
								qfalse);
							if (g_SerenityJediEngineMode->integer)
							{
								if (pull)
								{
									//
								}
								else
								{
									PushDamage(self, push_target[x], tr.endpos, damage_level);
								}
							}
						}
					}
					push_target[x]->forcePushTime = level.time + 600; // let the push effect last for 600 ms
				}
			}
			else if (!fake)
			{
				//not a fake push/pull
				if (push_target[x]->s.weapon == WP_SABER && push_target[x]->contents & CONTENTS_LIGHTSABER)
				{
					//a thrown saber, just send it back
					if (push_target[x]->owner && push_target[x]->owner->client && push_target[x]->owner->client->ps.
						SaberActive() && push_target[x]->s.pos.trType == TR_LINEAR && push_target[x]->owner->client->ps.
						saberEntityState != SES_RETURNING)
					{
						//it's on and being controlled
						if (self->s.number == 0 || Q_irand(0, 2))
						{
							//certain chance of throwing it aside and turning it off?
							if (Q_irand(0, 1))
							{
								VectorScale(right, -1, right);
							}

							if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self))
							{
								if (is_class_guard)
								{
									G_MissileBouncedoffSaber(self, push_target[x], right);
								}
								else
								{
									G_ReflectMissileNPC(self, push_target[x], right);
								}
							}
							else
							{
								if (g_SerenityJediEngineMode->integer)
								{
									G_ReflectMissileAuto(self, push_target[x], right);
								}
								else
								{
									G_ReflectMissile_JKA(self, push_target[x], right);
								}
							}
							WP_SaberDrop(push_target[x]->owner, push_target[x]);
						}
						else
						{
							if (g_SerenityJediEngineMode->integer && g_SaberMustReturn->integer < 1 && (G_ControlledByPlayer(push_target[x]->owner)))
							{
								WP_SaberDrop(push_target[x]->owner, push_target[x]);
							}
							else
							{
								if (push_target[x]->owner->NPC && !G_ControlledByPlayer(push_target[x]->owner))
								{
									WP_SaberDrop(push_target[x]->owner, push_target[x]);
								}
								else
								{
									WP_SaberReturn(push_target[x]->owner, push_target[x]);
								}
							}
						}
						//different effect?
					}
				}
				else if (push_target[x]->s.eType == ET_MISSILE
					&& push_target[x]->s.pos.trType != TR_STATIONARY
					&& (push_target[x]->s.pos.trType != TR_INTERPOLATE || push_target[x]->s.weapon != WP_THERMAL))
					//rolling and stationary thermal detonators are dealt with below
				{
					vec3_t dir2_me;
					VectorSubtract(self->currentOrigin, push_target[x]->currentOrigin, dir2_me);
					float dot = DotProduct(push_target[x]->s.pos.trDelta, dir2_me);
					if (pull)
					{
						//deflect rather than reflect?
					}
					else
					{
						if (push_target[x]->s.eFlags & EF_MISSILE_STICK)
						{
							//caught a sticky in-air
							push_target[x]->s.eType = ET_MISSILE;
							push_target[x]->s.eFlags &= ~EF_MISSILE_STICK;
							push_target[x]->s.eFlags |= EF_BOUNCE_HALF;
							push_target[x]->splashDamage /= 3;
							push_target[x]->splashRadius /= 3;
							push_target[x]->e_ThinkFunc = thinkF_WP_Explode;
							push_target[x]->nextthink = level.time + Q_irand(500, 3000);
						}
						if (dot >= 0)
						{
							//it's heading towards me
							if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self))
							{
								if (is_class_guard)
								{
									G_MissileBouncedoffSaber(self, push_target[x], forward);
								}
								else
								{
									G_ReflectMissileNPC(self, push_target[x], forward);
								}
							}
							else
							{
								if (g_SerenityJediEngineMode->integer)
								{
									G_ReflectMissileAuto(self, push_target[x], forward);
								}
								else
								{
									G_ReflectMissile_JKA(self, push_target[x], forward);
								}
							}
						}
						else
						{
							VectorScale(push_target[x]->s.pos.trDelta, 1.25f, push_target[x]->s.pos.trDelta);
						}
					}
					if (push_target[x]->s.eType == ET_MISSILE
						&& push_target[x]->s.weapon == WP_ROCKET_LAUNCHER
						&& push_target[x]->damage < 60)
					{
						//pushing away a rocket raises it's damage to the max for NPCs
						push_target[x]->damage = 60;
					}
				}
				else if (push_target[x]->svFlags & SVF_GLASS_BRUSH)
				{
					//break the glass
					trace_t trace;
					vec3_t push_dir;
					float damage = 800;

					AngleVectors(self->client->ps.viewangles, forward, nullptr, nullptr);
					VectorNormalize(forward);
					VectorMA(self->client->renderInfo.eyePoint, radius, forward, end);
					gi.trace(&trace, self->client->renderInfo.eyePoint, vec3_origin, vec3_origin, end, self->s.number,
						MASK_SHOT, static_cast<EG2_Collision>(0), 0);
					if (trace.entityNum != push_target[x]->s.number || trace.fraction == 1.0 || trace.allsolid || trace.
						startsolid)
					{
						//must be pointing right at it
						continue;
					}

					if (pull)
					{
						VectorSubtract(self->client->renderInfo.eyePoint, trace.endpos, push_dir);
					}
					else
					{
						VectorSubtract(trace.endpos, self->client->renderInfo.eyePoint, push_dir);
					}
					damage -= VectorNormalize(push_dir);
					if (damage < 200)
					{
						damage = 200;
					}
					VectorScale(push_dir, damage, push_dir);

					G_Damage(push_target[x], self, self, push_dir, trace.endpos, damage, 0, MOD_UNKNOWN);
				}
				else if (!Q_stricmp("func_static", push_target[x]->classname))
				{
					//force-usable func_static
					if (!pull && push_target[x]->spawnflags & 1/*F_PUSH*/)
					{
						if (push_target[x]->NPC_targetname == nullptr
							|| self->targetname && Q_stricmp(push_target[x]->NPC_targetname, self->targetname) == 0)
						{
							//anyone can pull it or only 1 person can push it and it's me
							GEntity_UseFunc(push_target[x], self, self);
						}
					}
					else if (pull && push_target[x]->spawnflags & 2/*F_PULL*/)
					{
						if (push_target[x]->NPC_targetname == nullptr
							|| self->targetname && Q_stricmp(push_target[x]->NPC_targetname, self->NPC_targetname) == 0)
						{
							//anyone can push it or only 1 person can push it and it's me
							GEntity_UseFunc(push_target[x], self, self);
						}
					}
				}
				else if (!Q_stricmp("func_door", push_target[x]->classname) && push_target[x]->spawnflags & 2
					/*MOVER_FORCE_ACTIVATE*/)
				{
					//push/pull the door
					vec3_t pos1, pos2;

					AngleVectors(self->client->ps.viewangles, forward, nullptr, nullptr);
					VectorNormalize(forward);
					VectorMA(self->client->renderInfo.eyePoint, radius, forward, end);
					gi.trace(&tr, self->client->renderInfo.eyePoint, vec3_origin, vec3_origin, end, self->s.number,
						MASK_SHOT, static_cast<EG2_Collision>(0), 0);
					if (tr.entityNum != push_target[x]->s.number || tr.fraction == 1.0 || tr.allsolid || tr.startsolid)
					{
						//must be pointing right at it
						continue;
					}

					if (VectorCompare(vec3_origin, push_target[x]->s.origin))
					{
						//does not have an origin brush, so pos1 & pos2 are relative to world origin, need to calc center
						VectorSubtract(push_target[x]->absmax, push_target[x]->absmin, size);
						VectorMA(push_target[x]->absmin, 0.5, size, center);
						if (push_target[x]->spawnflags & 1 && push_target[x]->moverState == MOVER_POS1)
						{
							//if at pos1 and started open, make sure we get the center where it *started* because we're going to add back in the relative values pos1 and pos2
							VectorSubtract(center, push_target[x]->pos1, center);
						}
						else if (!(push_target[x]->spawnflags & 1) && push_target[x]->moverState == MOVER_POS2)
						{
							//if at pos2, make sure we get the center where it *started* because we're going to add back in the relative values pos1 and pos2
							VectorSubtract(center, push_target[x]->pos2, center);
						}
						VectorAdd(center, push_target[x]->pos1, pos1);
						VectorAdd(center, push_target[x]->pos2, pos2);
					}
					else
					{
						//actually has an origin, pos1 and pos2 are absolute
						VectorCopy(push_target[x]->currentOrigin, center);
						VectorCopy(push_target[x]->pos1, pos1);
						VectorCopy(push_target[x]->pos2, pos2);
					}

					if (Distance(pos1, self->client->renderInfo.eyePoint) < Distance(
						pos2, self->client->renderInfo.eyePoint))
					{
						//pos1 is closer
						if (push_target[x]->moverState == MOVER_POS1)
						{
							//at the closest pos
							if (pull)
							{
								//trying to pull, but already at closest point, so screw it
								continue;
							}
						}
						else if (push_target[x]->moverState == MOVER_POS2)
						{
							//at farthest pos
							if (!pull)
							{
								//trying to push, but already at farthest point, so screw it
								continue;
							}
						}
					}
					else
					{
						//pos2 is closer
						if (push_target[x]->moverState == MOVER_POS1)
						{
							//at the farthest pos
							if (!pull)
							{
								//trying to push, but already at farthest point, so screw it
								continue;
							}
						}
						else if (push_target[x]->moverState == MOVER_POS2)
						{
							//at closest pos
							if (pull)
							{
								//trying to pull, but already at closest point, so screw it
								continue;
							}
						}
					}
					GEntity_UseFunc(push_target[x], self, self);
				}
				else if (push_target[x]->s.eType == ET_MISSILE /*thermal resting on ground*/
					|| push_target[x]->s.eType == ET_ITEM
					|| push_target[x]->e_ThinkFunc == thinkF_G_RunObject || Q_stricmp("limb", push_target[x]->classname) ==
					0)
				{
					//general object, toss it
					vec3_t push_dir, kvel;
					float knockback = pull ? 0 : 200;
					float mass = 200;

					if (pull)
					{
						if (push_target[x]->s.eType == ET_ITEM)
						{
							//pull it to a little higher point
							vec3_t adjustedOrg;
							VectorCopy(self->currentOrigin, adjustedOrg);
							adjustedOrg[2] += self->maxs[2] / 3;
							VectorSubtract(adjustedOrg, push_target[x]->currentOrigin, push_dir);
						}
						else if (self->enemy //I have an enemy
							//&& push_target[x]->s.eType != ET_ITEM //not an item
							&& self->client->ps.forcePowerLevel[FP_PUSH] > FORCE_LEVEL_2 //have push 3 or greater
							&& InFront(push_target[x]->currentOrigin, self->currentOrigin, self->currentAngles, 0.25f)
							//object is generally in front of me
							&& InFront(self->enemy->currentOrigin, self->currentOrigin, self->currentAngles, 0.75f)
							//enemy is pretty much right in front of me
							&& !InFront(push_target[x]->currentOrigin, self->enemy->currentOrigin,
								self->enemy->currentAngles, -0.25f) //object is generally behind enemy
							//FIXME: check dist to enemy and clear LOS to enemy and clear Path between object and enemy?
							&& (self->NPC && (no_resist || is_class_guard || Q_irand(0, RANK_CAPTAIN) < self->NPC->rank)
								//NPC with enough skill
								|| self->s.number < MAX_CLIENTS))
						{
							//if I have an auto-enemy & he's in front of me, push it toward him!
							VectorSubtract(self->enemy->currentOrigin, push_target[x]->currentOrigin, push_dir);
						}
						else
						{
							VectorSubtract(self->currentOrigin, push_target[x]->currentOrigin, push_dir);
						}
						knockback += VectorNormalize(push_dir);
						if (knockback > 200)
						{
							knockback = 200;
						}
						if (push_target[x]->s.eType == ET_ITEM
							&& push_target[x]->item
							&& push_target[x]->item->giType == IT_HOLDABLE
							&& push_target[x]->item->giTag == INV_SECURITY_KEY)
						{
							//security keys are pulled with less enthusiasm
							if (knockback > 100)
							{
								knockback = 100;
							}
						}
						else if (knockback > 200)
						{
							knockback = 200;
						}
					}
					else
					{
						if (self->enemy //I have an enemy
							&& push_target[x]->s.eType != ET_ITEM //not an item
							&& self->client->ps.forcePowerLevel[FP_PUSH] > FORCE_LEVEL_2 //have push 3 or greater
							&& InFront(push_target[x]->currentOrigin, self->currentOrigin, self->currentAngles, 0.25f)
							//object is generally in front of me
							&& InFront(self->enemy->currentOrigin, self->currentOrigin, self->currentAngles, 0.75f)
							//enemy is pretty much right in front of me
							&& InFront(push_target[x]->currentOrigin, self->enemy->currentOrigin,
								self->enemy->currentAngles, 0.25f) //object is generally in front of enemy
							&& (self->NPC && (no_resist || is_class_guard || Q_irand(0, RANK_CAPTAIN) < self->NPC->rank)
								//NPC with enough skill
								|| self->s.number < MAX_CLIENTS))
						{
							//if I have an auto-enemy & he's in front of me, push it toward him!
							VectorSubtract(self->enemy->currentOrigin, push_target[x]->currentOrigin, push_dir);
						}
						else
						{
							VectorSubtract(push_target[x]->currentOrigin, self->currentOrigin, push_dir);
						}
						knockback -= VectorNormalize(push_dir);
						if (knockback < 100)
						{
							knockback = 100;
						}
					}
					//FIXME: if pull a FL_FORCE_PULLABLE_ONLY, clear the flag, assuming it's no longer in solid?  or check?
					VectorCopy(push_target[x]->currentOrigin, push_target[x]->s.pos.trBase);
					push_target[x]->s.pos.trTime = level.time; // move a bit on the very first frame
					if (push_target[x]->s.pos.trType != TR_INTERPOLATE)
					{
						//don't do this to rolling missiles
						push_target[x]->s.pos.trType = TR_GRAVITY;
					}

					if (push_target[x]->e_ThinkFunc == thinkF_G_RunObject && push_target[x]->physicsBounce)
					{
						//it's a pushable misc_model_breakable, use it's mass instead of our one-size-fits-all mass
						mass = push_target[x]->physicsBounce; //same as push_target[x]->mass, right?
					}
					if (mass < 50)
					{
						//???
						mass = 50;
					}
					if (g_gravity->value > 0)
					{
						VectorScale(push_dir, g_knockback->value * knockback / mass * 0.8, kvel);
						kvel[2] = push_dir[2] * g_knockback->value * knockback / mass * 1.5;
					}
					else
					{
						VectorScale(push_dir, g_knockback->value * knockback / mass, kvel);
					}
					VectorAdd(push_target[x]->s.pos.trDelta, kvel, push_target[x]->s.pos.trDelta);
					if (g_gravity->value > 0)
					{
						if (push_target[x]->s.pos.trDelta[2] < knockback)
						{
							push_target[x]->s.pos.trDelta[2] = knockback;
						}
					}
					//no trDuration?
					if (push_target[x]->e_ThinkFunc != thinkF_G_RunObject)
					{
						//objects spin themselves?
						//spin it
						//FIXME: messing with roll ruins the rotational center???
						push_target[x]->s.apos.trTime = level.time;
						push_target[x]->s.apos.trType = TR_LINEAR;
						VectorClear(push_target[x]->s.apos.trDelta);
						push_target[x]->s.apos.trDelta[1] = Q_irand(-800, 800);
					}

					if (Q_stricmp("limb", push_target[x]->classname) == 0)
					{
						//make sure it runs it's physics
						push_target[x]->e_ThinkFunc = thinkF_LimbThink;
						push_target[x]->nextthink = level.time + FRAMETIME;
					}
					push_target[x]->forcePushTime = level.time + 600; // let the push effect last for 600 ms
					push_target[x]->forcePuller = self->s.number; //remember this regardless
					if (push_target[x]->item && push_target[x]->item->giTag == INV_SECURITY_KEY)
					{
						AddSightEvent(player, push_target[x]->currentOrigin, 128, AEL_DISCOVERED);
						//security keys are more important
					}
					else
					{
						AddSightEvent(player, push_target[x]->currentOrigin, 128, AEL_SUSPICIOUS);
						//hmm... or should this always be discovered?
					}
				}
				else if (push_target[x]->s.weapon == WP_TURRET
					&& !Q_stricmp("PAS", push_target[x]->classname)
					&& push_target[x]->s.apos.trType == TR_STATIONARY)
				{
					//a portable turret
					WP_KnockdownTurret(push_target[x]);
				}
			}
		}
		if (pull)
		{
			if (self->client->ps.forcePowerLevel[FP_PULL] > FORCE_LEVEL_2)
			{
				//at level 3, can pull multiple, so it costs more
				actual_cost = forcePowerNeeded[FP_PULL] * ent_count;
				if (actual_cost > 50)
				{
					actual_cost = 50;
				}
				else if (actual_cost < cost)
				{
					actual_cost = cost;
				}
			}
			else
			{
				actual_cost = cost;
			}
			WP_ForcePowerStart(self, FP_PULL, actual_cost);
		}
		else
		{
			if (self->client->ps.forcePowerLevel[FP_PUSH] > FORCE_LEVEL_2)
			{
				//at level 3, can push multiple, so costs more
				actual_cost = forcePowerNeeded[FP_PUSH] * ent_count;
				if (actual_cost > 50)
				{
					actual_cost = 50;
				}
				else if (actual_cost < cost)
				{
					actual_cost = cost;
				}
			}
			else if (self->client->ps.forcePowerLevel[FP_PUSH] > FORCE_LEVEL_1)
			{
				//at level 2, can push multiple, so costs more
				actual_cost = floor(forcePowerNeeded[FP_PUSH] * ent_count / 1.5f);
				if (actual_cost > 50)
				{
					actual_cost = 50;
				}
				else if (actual_cost < cost)
				{
					actual_cost = cost;
				}
			}
			else
			{
				actual_cost = cost;
			}
			WP_ForcePowerStart(self, FP_PUSH, actual_cost);
		}
	}
	else
	{
		//didn't push or pull anything?  don't penalize them too much
		if (pull)
		{
			WP_ForcePowerStart(self, FP_PULL, 5);
		}
		else
		{
			WP_ForcePowerStart(self, FP_PUSH, 5);
		}
	}
	if (pull)
	{
		if (self->NPC)
		{
			//NPCs can push more often
			//FIXME: vary by rank and game skill?
			self->client->ps.forcePowerDebounce[FP_PULL] = level.time + 200;
		}
		else
		{
			self->client->ps.forcePowerDebounce[FP_PULL] = level.time + self->client->ps.torsoAnimTimer + 500;
		}
	}
	else
	{
		if (self->NPC)
		{
			//NPCs can push more often
			self->client->ps.forcePowerDebounce[FP_PUSH] = level.time + 200;
		}
		else
		{
			self->client->ps.forcePowerDebounce[FP_PUSH] = level.time + self->client->ps.torsoAnimTimer + 500;
		}
	}
}

void ForceRepulse(gentity_t* self, qboolean pull, qboolean fake)
{
	//shove things in front of you away
	float dist;
	gentity_t* ent, * forward_ent = nullptr;
	gentity_t* entity_list[MAX_GENTITIES];
	gentity_t* push_target[MAX_GENTITIES]{};
	int num_listed_entities = 0;
	vec3_t mins{}, maxs{};
	vec3_t v{};
	int i, e;
	int ent_count = 0;
	int radius;
	vec3_t center, ent_org, size, forward, right, end, dir, fwdangles = { 0 };
	float dot1, cone;
	trace_t tr;
	int anim, hold, sound_index, cost, actual_cost;
	qboolean no_resist = qfalse;
	int damage_level = FORCE_LEVEL_0;
	qboolean is_class_guard = qfalse;

	if (self->client->ps.userInt3 & 1 << FLAG_PREBLOCK)
	{
		return;
	}

	if (self->client->ps.weaponTime > 0 && (!PM_SaberInParry(self->client->ps.saber_move) || !(self->client->ps.userInt3
		& 1 << FLAG_PREBLOCK)))
	{
		return;
	}

	if (self->health <= 0)
	{
		return;
	}
	if (self->client->ps.leanofs)
	{
		//can't force-throw while leaning
		return;
	}

	if (PM_InLedgeMove(self->client->ps.legsAnim))
	{
		return;
	}

	if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self) && self->client->NPC_class == CLASS_KYLE)
		//npc force use limit
	{
		if (self->client->ps.forcePower < BLOCKPOINTS_FULL)
		{
			return;
		}
	}

	if (self->NPC && !G_ControlledByPlayer(self))
	{
		if (self->client->ps.forcePowerDebounce[FP_PUSH] > level.time)
		{
			//already pushing- now you can't haul someone across the room, sorry
			return;
		}
		if (self->client->ps.forcePowerDebounce[FP_PULL] > level.time)
		{
			//already pulling- now you can't haul someone across the room, sorry
			return;
		}
		if (self->client->ps.pullAttackTime > level.time)
		{
			//already pull-attacking
			return;
		}
	}

	if (!self->s.number && (cg.zoomMode || in_camera))
	{
		//can't force throw/pull when zoomed in or in cinematic
		return;
	}
	if (self->client->ps.saberLockTime > level.time)
	{
		if (pull || self->client->ps.forcePowerLevel[FP_PUSH] < FORCE_LEVEL_3)
		{
			//this can be a way to break out
			return;
		}
		//else, I'm breaking my half of the saberlock
		self->client->ps.saberLockTime = 0;
		self->client->ps.saberLockEnemy = ENTITYNUM_NONE;
	}

	if (self->client->ps.groundEntityNum == ENTITYNUM_NONE && self->client->ps.forcePowerLevel[FP_PUSH] > FORCE_LEVEL_2
		&& (self->s.weapon == WP_MELEE ||
			self->s.weapon == WP_NONE ||
			self->s.weapon == WP_SABER && !self->client->ps.SaberActive()))
	{
		damage_level = FORCE_LEVEL_3;
	}
	else if (self->client->ps.groundEntityNum == ENTITYNUM_NONE && self->client->ps.forcePowerLevel[FP_PUSH] <
		FORCE_LEVEL_3
		&& (self->s.weapon == WP_MELEE ||
			self->s.weapon == WP_NONE ||
			self->s.weapon == WP_SABER && !self->client->ps.SaberActive()))
	{
		damage_level = FORCE_LEVEL_2;
	}
	else
	{
		damage_level = FORCE_LEVEL_1;
	}

	if (self->client->ps.legsAnim == BOTH_KNOCKDOWN3
		|| self->client->ps.torsoAnim == BOTH_FORCE_GETUP_F1 && self->client->ps.torsoAnimTimer > 400
		|| self->client->ps.torsoAnim == BOTH_FORCE_GETUP_F2 && self->client->ps.torsoAnimTimer > 900
		|| self->client->ps.torsoAnim == BOTH_GETUP3 && self->client->ps.torsoAnimTimer > 500
		|| self->client->ps.torsoAnim == BOTH_GETUP4 && self->client->ps.torsoAnimTimer > 300
		|| self->client->ps.torsoAnim == BOTH_GETUP5 && self->client->ps.torsoAnimTimer > 500)
	{
		//we're face-down, so we'd only be force-push/pulling the floor
		return;
	}
	if (pull)
	{
		radius = forcePushPullRadiusMD[self->client->ps.forcePowerLevel[FP_PULL]];
	}
	else
	{
		radius = forcePushPullRadiusMD[self->client->ps.forcePowerLevel[FP_PUSH]];
	}

	if (!radius)
	{
		//no ability to do this yet
		return;
	}

	if (pull)
	{
		cost = forcePowerNeeded[FP_PULL];
		if (!WP_ForcePowerUsable(self, FP_PULL, cost))
		{
			return;
		}
		//make sure this plays and that you cannot press fire for about 200ms after this
		anim = BOTH_FORCEPULL;
		sound_index = G_SoundIndex("sound/weapons/force/pull.wav");
		hold = 200;
	}
	else
	{
		cost = forcePowerNeeded[FP_PUSH];
		if (!WP_ForcePowerUsable(self, FP_PUSH, cost))
		{
			return;
		}

		//make sure this plays and that you cannot press fire for about 1 second after this
		if (self->s.weapon == WP_MELEE || self->s.weapon == WP_NONE
			|| self->s.weapon == WP_SABER && !self->client->ps.SaberActive())
		{
			//2-handed PUSH
			if (self->client->ps.groundEntityNum == ENTITYNUM_NONE && self->client->NPC_class == CLASS_GALEN)
			{
				anim = BOTH_FORCE_REPULSE;
			}
			else
			{
				if (self->s.eFlags & EF_FORCE_DRAINED || self->s.eFlags & EF_FORCE_GRIPPED || self->s.eFlags &
					EF_FORCE_GRASPED)
				{
					anim = BOTH_FORCEPUSH;
				}
				else
				{
					anim = BOTH_DUAL_PUSH;
				}
			}
		}
		else
		{
			anim = BOTH_FORCEPUSH;
		}

		if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self)) // npc push sounds
		{
			if (self->client->ps.forcePower < 50)
			{
				sound_index = G_SoundIndex("sound/weapons/force/pushlow.mp3");
			}
			else
			{
				sound_index = G_SoundIndex("sound/weapons/force/push.mp3");
			}
		}
		else
		{
			if (g_SerenityJediEngineMode->integer)
			{
				if (self->client->ps.forcePower < 30 || PM_InKnockDown(&self->client->ps))
				{
					sound_index = G_SoundIndex("sound/weapons/force/pushlow.mp3");
				}
				else
				{
					if (self->client->ps.groundEntityNum == ENTITYNUM_NONE &&
						self->client->ps.forcePower > 50)
					{
						sound_index = G_SoundIndex("sound/weapons/force/pushhard.mp3");
					}
					else
					{
						if (self->client->ps.forcePower > 90)
						{
							sound_index = G_SoundIndex("sound/weapons/force/push_md.mp3");
						}
						else
						{
							sound_index = G_SoundIndex("sound/weapons/force/push.mp3");
						}
					}
				}
			}
			else
			{
				sound_index = G_SoundIndex("sound/weapons/force/push.mp3");
			}
		}
		hold = 650;
	}

	int parts = SETANIM_TORSO;
	if (!PM_InKnockDown(&self->client->ps))
	{
		if (self->client->ps.saberLockTime > level.time)
		{
			self->client->ps.saberLockTime = 0;
			self->painDebounceTime = level.time + 2000;
			hold += 1000;
			parts = SETANIM_BOTH;
		}
		else if (!VectorLengthSquared(self->client->ps.velocity) && !(self->client->ps.pm_flags & PMF_DUCKED))
		{
			parts = SETANIM_BOTH;
		}
	}

	NPC_SetAnim(self, parts, anim, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD | SETANIM_FLAG_RESTART);
	self->client->ps.saber_move = self->client->ps.saberBounceMove = LS_READY;
	//don't finish whatever saber anim you may have been in
	self->client->ps.saberBlocked = BLOCKED_NONE;

	if (self->client->ps.forcePowersActive & 1 << FP_SPEED)
	{
		hold = floor(hold * g_timescale->value);
	}

	self->client->ps.weaponTime = hold;
	self->client->ps.powerups[PW_FORCE_PUSH] = level.time + self->client->ps.torsoAnimTimer + 500;
	self->client->pushEffectFadeTime = 0;

	G_Sound(self, sound_index);

	if (!pull && self->client->ps.forcePowersForced & 1 << FP_PUSH
		|| pull && self->client->ps.forcePowersForced & 1 << FP_PULL
		|| pull && self->client->NPC_class == CLASS_KYLE && self->spawnflags & 1 && TIMER_Done(self, "kyleTakesSaber"))
	{
		no_resist = qtrue;
	}

	if (self->client->NPC_class == CLASS_GUARD || jedi_jedi_master_low(self))
	{
		is_class_guard = qtrue;
	}

	VectorCopy(self->client->ps.viewangles, fwdangles);
	AngleVectors(fwdangles, forward, right, nullptr);
	VectorCopy(self->currentOrigin, center);

	if (pull)
	{
		cone = forcePullCone[self->client->ps.forcePowerLevel[FP_PULL]];
	}
	else
	{
		cone = forcePushCone[self->client->ps.forcePowerLevel[FP_PUSH]];
	}

	VectorMA(self->client->renderInfo.eyePoint, radius, forward, end);
	gi.trace(&tr, self->client->renderInfo.eyePoint, vec3_origin, vec3_origin, end, self->s.number,
		MASK_OPAQUE | CONTENTS_SOLID | CONTENTS_BODY | CONTENTS_ITEM | CONTENTS_CORPSE,
		static_cast<EG2_Collision>(0), 0);

	if (tr.entityNum < ENTITYNUM_WORLD)
	{
		//found something right in front of self,
		forward_ent = &g_entities[tr.entityNum];
		if (!forward_ent->client && !Q_stricmp("func_static", forward_ent->classname))
		{
			if (forward_ent->spawnflags & 1 || forward_ent->spawnflags & 2)
			{
				//push/pullable
				if (forward_ent->spawnflags & 32)
				{
					//can only push/pull ME, ignore all others
					if (forward_ent->NPC_targetname == nullptr
						|| self->targetname && Q_stricmp(forward_ent->NPC_targetname, self->targetname) == 0)
					{
						//anyone can push it or only 1 person can push it and it's me
						push_target[0] = forward_ent;
						ent_count = num_listed_entities = 1;
					}
				}
			}
		}
	}

	if (forward_ent)
	{
		if (G_TryingPullAttack(self, &self->client->usercmd, qtrue))
		{
			//we're going to try to do a pull attack on our forwardEnt
			if (WP_ForceThrowable(forward_ent, forward_ent, self, pull, cone, radius, forward))
			{
				self->client->ps.forcePowersActive |= 1 << FP_PULL;
				self->client->ps.forcePowerDebounce[FP_PULL] = level.time + 100;
				return;
			}
		}
	}

	//REPULSE ########################################################################## IN THE AIR PUSH
	if ((self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self))
		&& self->client->NPC_class == CLASS_GALEN
		&& self->client->ps.groundEntityNum == ENTITYNUM_NONE
		&& (self->s.weapon == WP_MELEE || self->s.weapon == WP_NONE || self->s.weapon == WP_SABER && !self->client->ps.
			SaberActive()))
	{
		if (pull)
		{
			if (!num_listed_entities)
			{
				for (i = 0; i < 3; i++)
				{
					mins[i] = center[i] - radius;
					maxs[i] = center[i] + radius;
				}

				num_listed_entities = gi.EntitiesInBox(mins, maxs, entity_list, MAX_GENTITIES);

				for (e = 0; e < num_listed_entities; e++)
				{
					ent = entity_list[e];

					if (!WP_ForceThrowable(ent, forward_ent, self, pull, cone, radius, forward))
					{
						continue;
					}

					//this is all to see if we need to start a saber attack, if it's in flight, this doesn't matter
					// find the distance from the edge of the bounding box
					for (i = 0; i < 3; i++)
					{
						if (center[i] < ent->absmin[i])
						{
							v[i] = ent->absmin[i] - center[i];
						}
						else if (center[i] > ent->absmax[i])
						{
							v[i] = center[i] - ent->absmax[i];
						}
						else
						{
							v[i] = 0;
						}
					}

					VectorSubtract(ent->absmax, ent->absmin, size);
					VectorMA(ent->absmin, 0.5, size, ent_org);

					//see if they're in front of me
					VectorSubtract(ent_org, center, dir);
					VectorNormalize(dir);
					if (cone < 1.0f)
					{
						//must be within the forward cone
						if (ent->client && !pull
							&& ent->client->ps.forceGripEntityNum == self->s.number
							&& (self->s.eFlags & EF_FORCE_GRIPPED || self->s.eFlags & EF_FORCE_GRASPED))
						{
							//this is the guy that's force-gripping me, use a wider cone regardless of force power level
							if ((dot1 = DotProduct(dir, forward)) < cone - 0.3f)
								continue;
						}
						else if (ent->client && !pull
							&& ent->client->ps.forceDrainEntityNum == self->s.number
							&& self->s.eFlags & EF_FORCE_DRAINED)
						{
							//this is the guy that's force-draining me, use a wider cone regardless of force power level
							if ((dot1 = DotProduct(dir, forward)) < cone - 0.3f)
								continue;
						}
						else if (ent->s.eType == ET_MISSILE)
							//&& ent->s.eType != ET_ITEM && ent->e_ThinkFunc != thinkF_G_RunObject )
						{
							//missiles are easier to force-push, never require direct trace (FIXME: maybe also items and general physics objects)
							if ((dot1 = DotProduct(dir, forward)) < cone - 0.3f)
								continue;
						}
						else if ((dot1 = DotProduct(dir, forward)) < cone)
						{
							continue;
						}
					}
					else if (ent->s.eType == ET_MISSILE)
					{
						//a missile and we're at force level 1... just use a small cone, but not ridiculously small
						if ((dot1 = DotProduct(dir, forward)) < 0.75f)
						{
							continue;
						}
					} //else is an NPC or brush entity that our forward trace would have to hit

					dist = VectorLength(v);

					//Now check and see if we can actually deflect it
					//method1
					//if within a certain range, deflect it
					if (ent->s.eType == ET_MISSILE && cone >= 1.0f)
					{
						//smaller radius on missile checks at force push 1
						if (dist >= 192)
						{
							continue;
						}
					}
					else if (dist >= radius)
					{
						continue;
					}

					//in PVS?
					if (!ent->bmodel && !gi.inPVS(ent_org, self->client->renderInfo.eyePoint))
					{
						//must be in PVS
						continue;
					}

					if (ent != forward_ent)
					{
						//don't need to trace against forwardEnt again
						//really should have a clear LOS to this thing...
						gi.trace(&tr, self->client->renderInfo.eyePoint, vec3_origin, vec3_origin, ent_org,
							self->s.number, MASK_FORCE_PUSH, static_cast<EG2_Collision>(0), 0);
						//was MASK_SHOT, but changed to match above trace and crosshair trace
						if (tr.fraction < 1.0f && tr.entityNum != ent->s.number)
						{
							//must have clear LOS
							continue;
						}
					}

					// ok, we are within the radius, add us to the incoming list
					push_target[ent_count] = ent;
					ent_count++;
				}
			}
		}
		else
		{
			if (!num_listed_entities)
			{
				for (i = 0; i < 3; i++)
				{
					mins[i] = center[i] - radius;
					maxs[i] = center[i] + radius;
				}

				num_listed_entities = gi.EntitiesInBox(mins, maxs, entity_list, MAX_GENTITIES);

				for (e = 0; e < num_listed_entities; e++)
				{
					ent = entity_list[e];

					if (!WP_ForceThrowable(ent, forward_ent, self, pull, cone, radius, forward))
					{
						continue;
					}

					// find the distance from the edge of the bounding box
					for (i = 0; i < 3; i++)
					{
						if (center[i] < ent->absmin[i])
						{
							v[i] = ent->absmin[i] - center[i];
						}
						else if (center[i] > ent->absmax[i])
						{
							v[i] = center[i] - ent->absmax[i];
						}
						else
						{
							v[i] = 0;
						}
					}

					VectorSubtract(ent->absmax, ent->absmin, size);
					VectorMA(ent->absmin, 0.5, size, ent_org);

					//see if they're in front of me
					VectorSubtract(ent_org, center, dir);
					VectorNormalize(dir);

					if (self->client->ps.groundEntityNum != ENTITYNUM_NONE)
					{
						if (cone < 1.0f)
						{
							//must be within the forward cone
							if (ent->client && !pull
								&& ent->client->ps.forceGripEntityNum == self->s.number
								&& (self->s.eFlags & EF_FORCE_GRIPPED || self->s.eFlags & EF_FORCE_GRASPED))
							{
								//this is the guy that's force-gripping me, use a wider cone regardless of force power level
								if ((dot1 = DotProduct(dir, forward)) < cone - 0.3f)
									continue;
							}
							else if (ent->client && !pull
								&& ent->client->ps.forceDrainEntityNum == self->s.number
								&& self->s.eFlags & EF_FORCE_DRAINED)
							{
								//this is the guy that's force-draining me, use a wider cone regardless of force power level
								if ((dot1 = DotProduct(dir, forward)) < cone - 0.3f)
									continue;
							}
							else if (ent->s.eType == ET_MISSILE)
							{
								//missiles are easier to force-push, never require direct trace (FIXME: maybe also items and general physics objects)
								if ((dot1 = DotProduct(dir, forward)) < cone - 0.3f)
									continue;
							}
							else if ((dot1 = DotProduct(dir, forward)) < cone)
							{
								continue;
							}
						}
						else if (ent->s.eType == ET_MISSILE)
						{
							//a missile and we're at force level 1... just use a small cone, but not ridiculously small
							if ((dot1 = DotProduct(dir, forward)) < 0.75f)
							{
								continue;
							}
						} //else is an NPC or brush entity that our forward trace would have to hit
					}
					else if (ent->s.eType == ET_MISSILE)
					{
						//a missile and we're at force level 1... just use a small cone, but not ridiculously small
						if ((dot1 = DotProduct(dir, forward)) < 0.75f)
						{
							continue;
						}
					}

					dist = VectorLength(v);

					if (self->client->ps.groundEntityNum != ENTITYNUM_NONE)
					{
						//if within a certain range, deflect it
						if (ent->s.eType == ET_MISSILE && cone >= 1.0f)
						{
							//smaller radius on missile checks at force push 1
							if (dist >= 192)
							{
								continue;
							}
						}
						else if (dist >= radius)
						{
							continue;
						}
					}
					else if (self->client->NPC_class == CLASS_GALEN)
					{
						if (dist >= radius)
						{
							continue;
						}
					}
					else if (dist >= radius)
					{
						continue;
					}

					//in PVS?
					if (!ent->bmodel && !gi.inPVS(ent_org, self->client->renderInfo.eyePoint))
					{
						//must be in PVS
						continue;
					}

					if (ent != forward_ent)
					{
						gi.trace(&tr, self->client->renderInfo.eyePoint, vec3_origin, vec3_origin, ent_org,
							self->s.number, MASK_FORCE_PUSH, static_cast<EG2_Collision>(0), 0);
						if (tr.fraction < 1.0f && tr.entityNum != ent->s.number)
						{
							//must have clear LOS
							continue;
						}
					}

					// ok, we are within the radius, add us to the incoming list
					push_target[ent_count] = ent;
					ent_count++;
				}
			}
		}
	}
	else // ON THE GROUND ################################## NORMAL PUSH
	{
		if (!num_listed_entities)
		{
			for (i = 0; i < 3; i++)
			{
				mins[i] = center[i] - radius;
				maxs[i] = center[i] + radius;
			}

			num_listed_entities = gi.EntitiesInBox(mins, maxs, entity_list, MAX_GENTITIES);

			for (e = 0; e < num_listed_entities; e++)
			{
				ent = entity_list[e];

				if (!WP_ForceThrowable(ent, forward_ent, self, pull, cone, radius, forward))
				{
					continue;
				}

				//this is all to see if we need to start a saber attack, if it's in flight, this doesn't matter
				// find the distance from the edge of the bounding box
				for (i = 0; i < 3; i++)
				{
					if (center[i] < ent->absmin[i])
					{
						v[i] = ent->absmin[i] - center[i];
					}
					else if (center[i] > ent->absmax[i])
					{
						v[i] = center[i] - ent->absmax[i];
					}
					else
					{
						v[i] = 0;
					}
				}

				VectorSubtract(ent->absmax, ent->absmin, size);
				VectorMA(ent->absmin, 0.5, size, ent_org);

				//see if they're in front of me
				VectorSubtract(ent_org, center, dir);
				VectorNormalize(dir);
				if (cone < 1.0f)
				{
					//must be within the forward cone
					if (ent->client && !pull
						&& ent->client->ps.forceGripEntityNum == self->s.number
						&& (self->s.eFlags & EF_FORCE_GRIPPED || self->s.eFlags & EF_FORCE_GRASPED))
					{
						//this is the guy that's force-gripping me, use a wider cone regardless of force power level
						if ((dot1 = DotProduct(dir, forward)) < cone - 0.3f)
							continue;
					}
					else if (ent->client && !pull
						&& ent->client->ps.forceDrainEntityNum == self->s.number
						&& self->s.eFlags & EF_FORCE_DRAINED)
					{
						//this is the guy that's force-draining me, use a wider cone regardless of force power level
						if ((dot1 = DotProduct(dir, forward)) < cone - 0.3f)
							continue;
					}
					else if (ent->s.eType == ET_MISSILE)
						//&& ent->s.eType != ET_ITEM && ent->e_ThinkFunc != thinkF_G_RunObject )
					{
						//missiles are easier to force-push, never require direct trace (FIXME: maybe also items and general physics objects)
						if ((dot1 = DotProduct(dir, forward)) < cone - 0.3f)
							continue;
					}
					else if ((dot1 = DotProduct(dir, forward)) < cone)
					{
						continue;
					}
				}
				else if (ent->s.eType == ET_MISSILE)
				{
					//a missile and we're at force level 1... just use a small cone, but not ridiculously small
					if ((dot1 = DotProduct(dir, forward)) < 0.75f)
					{
						continue;
					}
				} //else is an NPC or brush entity that our forward trace would have to hit

				dist = VectorLength(v);

				//if within a certain range, deflect it
				if (ent->s.eType == ET_MISSILE && cone >= 1.0f)
				{
					//smaller radius on missile checks at force push 1
					if (dist >= 192)
					{
						continue;
					}
				}
				else if (dist >= radius)
				{
					continue;
				}

				//in PVS?
				if (!ent->bmodel && !gi.inPVS(ent_org, self->client->renderInfo.eyePoint))
				{
					//must be in PVS
					continue;
				}

				if (ent != forward_ent)
				{
					//don't need to trace against forwardEnt again
					//really should have a clear LOS to this thing...
					gi.trace(&tr, self->client->renderInfo.eyePoint, vec3_origin, vec3_origin, ent_org, self->s.number,
						MASK_FORCE_PUSH, static_cast<EG2_Collision>(0), 0);
					//was MASK_SHOT, but changed to match above trace and crosshair trace
					if (tr.fraction < 1.0f && tr.entityNum != ent->s.number)
					{
						//must have clear LOS
						continue;
					}
				}

				// ok, we are within the radius, add us to the incoming list
				push_target[ent_count] = ent;
				ent_count++;
			}
		}
	}

	//REPULSE ########################################################################## IN THE AIR PUSH
	if (self->client->NPC_class == CLASS_GALEN
		&& self->client->ps.groundEntityNum == ENTITYNUM_NONE
		&& (self->s.weapon == WP_MELEE || self->s.weapon == WP_NONE || self->s.weapon == WP_SABER && !self->client->ps.
			SaberActive()))
	{
		if (ent_count)
		{
			for (int x = 0; x < ent_count; x++)
			{
				if (push_target[x]->client)
				{
					float knockback = pull ? 0 : 200;

					//SIGH band-aid...
					if (push_target[x]->s.number >= MAX_CLIENTS
						&& self->s.number < MAX_CLIENTS)
					{
						if (push_target[x]->client->ps.forcePowersActive & 1 << FP_GRIP
							&& push_target[x]->client->ps.forceGripEntityNum == self->s.number)
						{
							WP_ForcePowerStop(push_target[x], FP_GRIP);
						}
						if (push_target[x]->client->ps.forcePowersActive & 1 << FP_GRASP
							&& push_target[x]->client->ps.forceGripEntityNum == self->s.number)
						{
							WP_ForcePowerStop(push_target[x], FP_GRASP);
						}
						if (push_target[x]->client->ps.forcePowersActive & 1 << FP_DRAIN
							&& push_target[x]->client->ps.forceDrainEntityNum == self->s.number)
						{
							WP_ForcePowerStop(push_target[x], FP_DRAIN);
						}
					}

					if (rosh_being_healed(push_target[x]))
					{
						continue;
					}
					if (push_target[x]->client->NPC_class == CLASS_HAZARD_TROOPER
						&& push_target[x]->health > 0)
					{
						//living hazard troopers resist push/pull
						WP_ForceThrowHazardTrooper(self, push_target[x], pull);
						continue;
					}
					if (fake && !is_class_guard)
					{
						//always resist
						WP_ResistForcePush(push_target[x], self, qfalse);
						continue;
					}

					if (push_target[x]->client->NPC_class == CLASS_GUARD || jedi_jedi_master_low(push_target[x]))
					{
						//do a knockdown hes a twat
						WP_ForceKnockdown(push_target[x], self, pull, qtrue, qfalse);
						if (g_SerenityJediEngineMode->integer)
						{
							if (pull)
							{
								//
							}
							else
							{
								PushDamage(self, push_target[x], tr.endpos, damage_level);
							}
						}
						continue;
					}

					int power_level, power_use;
					if (pull)
					{
						power_level = self->client->ps.forcePowerLevel[FP_PULL];
						power_use = FP_PULL;
					}
					else
					{
						power_level = self->client->ps.forcePowerLevel[FP_PUSH];
						power_use = FP_PUSH;
					}

					int mod_power_level = WP_AbsorbConversion(push_target[x],
						push_target[x]->client->ps.forcePowerLevel[FP_ABSORB],
						power_use,
						power_level,
						forcePowerNeeded[self->client->ps.forcePowerLevel[
							power_use]]);

					if (push_target[x]->client->NPC_class == CLASS_ASSASSIN_DROID ||
						push_target[x]->client->NPC_class == CLASS_DROIDEKA ||
						//push_target[x]->client->NPC_class == CLASS_SBD ||
						push_target[x]->client->NPC_class == CLASS_HAZARD_TROOPER)
					{
						mod_power_level = 0; // divides throw by 10
					}

					//First, if this is the player we're push/pulling, see if he can counter it
					if (mod_power_level != -1
						&& !no_resist && !is_class_guard
						&& InFront(self->currentOrigin, push_target[x]->client->renderInfo.eyePoint,
							push_target[x]->client->ps.viewangles, 0.3f))
					{
						//absorbed and I'm in front of them
						//counter it
						if (push_target[x]->client->ps.forcePowerLevel[FP_ABSORB] > FORCE_LEVEL_2)
						{
							//no reaction at all
						}
						else
						{
							if (!is_class_guard)
							{
								WP_ResistForcePush(push_target[x], self, qfalse);
							}
							push_target[x]->client->ps.saber_move = push_target[x]->client->ps.saberBounceMove = LS_READY;
							//don't finish whatever saber anim you may have been in
							push_target[x]->client->ps.saberBlocked = BLOCKED_NONE;
						}
						continue;
					}
					if (!push_target[x]->s.number && !is_class_guard)
					{
						//player
						if (!no_resist && !is_class_guard && (ShouldPlayerResistForceThrow(push_target[x], self, pull) ||
							PlayerisResistingForceThrow(push_target[x], self))
							&& push_target[x]->client->ps.saberFatigueChainCount < MISHAPLEVEL_HEAVY)
						{
							WP_ResistForcePush(push_target[x], self, qfalse);
							push_target[x]->client->ps.saber_move = push_target[x]->client->ps.saberBounceMove = LS_READY;
							//don't finish whatever saber anim you may have been in
							push_target[x]->client->ps.saberBlocked = BLOCKED_NONE;
							continue;
						}
					}
					else if (push_target[x]->client && jedi_waiting_ambush(push_target[x]))
					{
						WP_ForceKnockdown(push_target[x], self, pull, qtrue, qfalse);
						if (g_SerenityJediEngineMode->integer)
						{
							if (self->client->NPC_class == CLASS_GALEN
								&& (self->s.weapon == WP_MELEE || self->s.weapon == WP_NONE || self->s.weapon ==
									WP_SABER && !self->client->ps.SaberActive())
								&& self->client->ps.groundEntityNum == ENTITYNUM_NONE)
							{
								RepulseDamage(self, push_target[x], tr.endpos, damage_level);
								knockback = 200;
							}
							else
							{
								if (pull)
								{
									//
								}
								else
								{
									PushDamage(self, push_target[x], tr.endpos, damage_level);
								}
							}
						}
						continue;
					}
					else if (PM_SaberInBrokenParry(push_target[x]->client->ps.saber_move))
					{
						//do a knockdown if fairly close
						WP_ForceKnockdown(push_target[x], self, pull, qtrue, qfalse);
						if (g_SerenityJediEngineMode->integer)
						{
							if (self->client->NPC_class == CLASS_GALEN
								&& (self->s.weapon == WP_MELEE || self->s.weapon == WP_NONE || self->s.weapon ==
									WP_SABER && !self->client->ps.SaberActive())
								&& self->client->ps.groundEntityNum == ENTITYNUM_NONE)
							{
								RepulseDamage(self, push_target[x], tr.endpos, damage_level);
								knockback = 200;
							}
							else
							{
								if (pull)
								{
									//
								}
								else
								{
									PushDamage(self, push_target[x], tr.endpos, damage_level);
								}
							}
						}
						continue;
					}

					G_KnockOffVehicle(push_target[x], self, pull);

					if (!pull
						&& push_target[x]->client->ps.forceDrainEntityNum == self->s.number
						&& self->s.eFlags & EF_FORCE_DRAINED)
					{
						//stop them from draining me now, dammit!
						WP_ForcePowerStop(push_target[x], FP_DRAIN);
					}

					//okay, everyone else (or player who couldn't resist it)...
					if ((self->s.number == 0 && Q_irand(0, 2) || Q_irand(0, 2)) && push_target[x]->client && push_target[x]
						->health > 0 //a living client
						&& push_target[x]->client->ps.weapon == WP_SABER //Jedi
						&& push_target[x]->health > 0 //alive
						&& push_target[x]->client->ps.forceRageRecoveryTime < level.time //not recovering from rage
						&& (self->client->NPC_class != CLASS_DESANN && self->client->NPC_class != CLASS_SITHLORD && self
							->client->NPC_class != CLASS_VADER && Q_stricmp("Yoda", self->NPC_type) || !Q_irand(0, 2))
						//only 30% chance of resisting a Desann push
						&& push_target[x]->client->ps.groundEntityNum != ENTITYNUM_NONE //on the ground
						&& InFront(self->currentOrigin, push_target[x]->currentOrigin,
							push_target[x]->client->ps.viewangles, 0.3f) //I'm in front of him
						&& (push_target[x]->client->ps.powerups[PW_FORCE_PUSH] > level.time || //he's pushing too
							push_target[x]->s.number != 0 && push_target[x]->client->ps.weaponTime < level.time))
					{
						//Jedi don't get pushed, they resist as long as they aren't already attacking and are on the ground
						if (push_target[x]->client->ps.saberLockTime > level.time)
						{
							//they're in a lock
							if (push_target[x]->client->ps.saberLockEnemy != self->s.number)
							{
								//they're not in a lock with me
								continue;
							}
							if (pull || self->client->ps.forcePowerLevel[FP_PUSH] < FORCE_LEVEL_3 ||
								push_target[x]->client->ps.forcePowerLevel[FP_PUSH] > FORCE_LEVEL_2)
							{
								//they're in a lock with me, but my push is too weak
								continue;
							}
							//we will knock them down
							self->painDebounceTime = 0;
							self->client->ps.weaponTime = 500;
							if (self->client->ps.forcePowersActive & 1 << FP_SPEED)
							{
								self->client->ps.weaponTime = floor(self->client->ps.weaponTime * g_timescale->value);
							}
						}
						int resist_chance = Q_irand(0, 2);
						if (!push_target[x]->s.number && (self->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCK || self
							->client->ps.ManualBlockingFlags & 1 << MBF_NPCBLOCKING))
						{
							resist_chance = 1;
						}
						else if (push_target[x]->s.number >= MAX_CLIENTS)
						{
							//NPC
							if (g_spskill->integer == 1)
							{
								//stupid tweak for graham
								resist_chance = Q_irand(0, 3);
							}
						}
						if (no_resist || is_class_guard ||
							!pull
							&& mod_power_level == -1
							&& self->client->ps.forcePowerLevel[FP_PUSH] > FORCE_LEVEL_2
							&& !resist_chance
							&& push_target[x]->client->ps.forcePowerLevel[FP_PUSH] < FORCE_LEVEL_3)
						{
							//a level 3 push can even knock down a jedi
							if (PM_InKnockDown(&push_target[x]->client->ps))
							{
								//can't knock them down again
								continue;
							}
							WP_ForceKnockdown(push_target[x], self, pull, qfalse, qtrue);
							if (g_SerenityJediEngineMode->integer)
							{
								if (self->client->NPC_class == CLASS_GALEN
									&& (self->s.weapon == WP_MELEE || self->s.weapon == WP_NONE || self->s.weapon ==
										WP_SABER && !self->client->ps.SaberActive())
									&& self->client->ps.groundEntityNum == ENTITYNUM_NONE)
								{
									RepulseDamage(self, push_target[x], tr.endpos, damage_level);
									knockback = 200;
								}
								else
								{
									if (pull)
									{
										//
									}
									else
									{
										PushDamage(self, push_target[x], tr.endpos, damage_level);
									}
								}
							}
						}
						else
						{
							if (!is_class_guard)
							{
								WP_ResistForcePush(push_target[x], self, qfalse);
							}
						}
					}
					else
					{
						vec3_t push_dir;
						//shove them
						if (push_target[x]->NPC
							&& push_target[x]->NPC->jumpState == JS_JUMPING)
						{
							//don't interrupt a scripted jump
							push_target[x]->forcePushTime = level.time + 600; // let the push effect last for 600 ms
							continue;
						}

						if (push_target[x]->s.number
							&& (push_target[x]->message || push_target[x]->flags & FL_NO_KNOCKBACK))
						{
							//an NPC who has a key
							WP_ForceKnockdown(push_target[x], self, pull, qfalse, qfalse);
							if (g_SerenityJediEngineMode->integer)
							{
								if (self->client->NPC_class == CLASS_GALEN
									&& (self->s.weapon == WP_MELEE || self->s.weapon == WP_NONE || self->s.weapon ==
										WP_SABER && !self->client->ps.SaberActive())
									&& self->client->ps.groundEntityNum == ENTITYNUM_NONE)
								{
									RepulseDamage(self, push_target[x], tr.endpos, damage_level);
									knockback = 200;
								}
								else
								{
									if (pull)
									{
										//
									}
									else
									{
										PushDamage(self, push_target[x], tr.endpos, damage_level);
									}
								}
							}
							continue;
						}
						if (pull)
						{
							VectorSubtract(self->currentOrigin, push_target[x]->currentOrigin, push_dir);
							if (self->client->ps.forcePowerLevel[FP_PULL] >= FORCE_LEVEL_3
								&& self->client->NPC_class == CLASS_KYLE
								&& self->spawnflags & 1
								&& TIMER_Done(self, "kyleTakesSaber")
								&& push_target[x]->client
								&& push_target[x]->client->ps.weapon == WP_SABER
								&& !push_target[x]->client->ps.saberInFlight
								&& push_target[x]->client->ps.saberEntityNum < ENTITYNUM_WORLD
								&& !PM_InOnGroundAnim(&push_target[x]->client->ps))
							{
								vec3_t throw_vec;
								VectorScale(push_dir, 10.0f, throw_vec);
								WP_SaberLose(push_target[x], throw_vec);
								NPC_SetAnim(push_target[x], SETANIM_BOTH, BOTH_LOSE_SABER,
									SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
								push_target[x]->client->ps.torsoAnimTimer += 500;
								push_target[x]->client->ps.pm_time = push_target[x]->client->ps.weaponTime = push_target[x]->
									client->ps.torsoAnimTimer;
								push_target[x]->client->ps.pm_flags |= PMF_TIME_KNOCKBACK;
								push_target[x]->client->ps.saber_move = LS_NONE;
								push_target[x]->aimDebounceTime = level.time + push_target[x]->client->ps.torsoAnimTimer;
								VectorClear(push_target[x]->client->ps.velocity);
								VectorClear(push_target[x]->client->ps.moveDir);
								//Kyle will stand around for a bit, too...
								self->client->ps.pm_time = self->client->ps.weaponTime = 2000;
								self->client->ps.pm_flags |= PMF_TIME_KNOCKBACK;
								self->painDebounceTime = level.time + self->client->ps.weaponTime;
								TIMER_Set(self, "kyleTakesSaber", Q_irand(60000, 180000));
								//don't do this again for a while
								G_AddVoiceEvent(self, Q_irand(EV_TAUNT1, EV_TAUNT5), Q_irand(8000, 12000));
								VectorClear(self->client->ps.velocity);
								VectorClear(self->client->ps.moveDir);
								continue;
							}
							if (push_target[x]->NPC
								&& push_target[x]->NPC->scriptFlags & SCF_DONT_FLEE)
							{
								//*SIGH*... if an NPC can't flee, they can't run after and pick up their weapon, do don't drop it
							}
							else if (self->client->ps.forcePowerLevel[FP_PULL] > FORCE_LEVEL_1
								&& push_target[x]->client->NPC_class != CLASS_ROCKETTROOPER
								//rockettroopers never drop their weapon
								&& push_target[x]->client->NPC_class != CLASS_VEHICLE
								&& push_target[x]->client->NPC_class != CLASS_BOBAFETT
								&& push_target[x]->client->NPC_class != CLASS_MANDALORIAN
								&& push_target[x]->client->NPC_class != CLASS_JANGO
								&& push_target[x]->client->NPC_class != CLASS_JANGODUAL
								&& push_target[x]->client->NPC_class != CLASS_TUSKEN
								&& push_target[x]->client->NPC_class != CLASS_HAZARD_TROOPER
								&& push_target[x]->client->NPC_class != CLASS_ASSASSIN_DROID
								&& push_target[x]->client->NPC_class != CLASS_DROIDEKA
								&& push_target[x]->client->NPC_class != CLASS_SBD
								&& push_target[x]->s.weapon != WP_SABER
								&& push_target[x]->s.weapon != WP_MELEE
								&& push_target[x]->s.weapon != WP_THERMAL
								&& push_target[x]->s.weapon != WP_CONCUSSION)
							{
								//yank the weapon
								if (InFront(self->currentOrigin, push_target[x]->currentOrigin,
									push_target[x]->client->ps.viewangles, 0.0f))
								{
									//enemy has to be facing me, too...
									WP_DropWeapon(push_target[x], push_dir);
								}
							}
							knockback += VectorNormalize(push_dir);
							if (knockback > 200)
							{
								knockback = 200;
							}
							if (self->client->ps.forcePowerLevel[FP_PULL] < FORCE_LEVEL_3)
							{
								//maybe just knock them down
								knockback /= 3;
							}
						}
						else
						{
							VectorSubtract(push_target[x]->currentOrigin, self->currentOrigin, push_dir);
							knockback -= VectorNormalize(push_dir);

							G_SoundOnEnt(push_target[x], CHAN_BODY, "sound/weapons/force/pushed.mp3");

							if (knockback < 100) // if less than 100
							{
								knockback = 100; // minimum 100
							}

							//scale for push level
							if (self->client->ps.forcePowerLevel[FP_PUSH] < FORCE_LEVEL_2) // level 1 devide by 3
							{
								if (self->s.weapon == WP_MELEE ||
									self->s.weapon == WP_NONE ||
									self->s.weapon == WP_SABER &&
									!self->client->ps.SaberActive() &&
									!PM_InKnockDown(&self->client->ps))
								{
									//maybe just knock them down
									knockback /= 2;
								}
								else
								{
									//maybe just knock them down
									knockback /= 3;
								}
							}
							else if (self->client->ps.forcePowerLevel[FP_PUSH] == FORCE_LEVEL_2) // level 2
							{
								if (self->s.weapon == WP_MELEE ||
									self->s.weapon == WP_NONE ||
									self->s.weapon == WP_SABER &&
									!self->client->ps.SaberActive() &&
									!PM_InKnockDown(&self->client->ps))
								{
									knockback = 125;
								}
								else
								{
									knockback = 100;
								}
							}
							else if (self->client->ps.forcePowerLevel[FP_PUSH] > FORCE_LEVEL_2) // level 3 add sound
							{
								if (push_target[x]->client->NPC_class == CLASS_GUARD || jedi_jedi_master_low(push_target[x]))
								{
									//do a knockdown hes a twat
									knockback *= 3; //superpush
								}
								if (self->s.weapon == WP_MELEE ||
									self->s.weapon == WP_NONE ||
									self->s.weapon == WP_SABER &&
									!self->client->ps.SaberActive() &&
									!PM_InKnockDown(&self->client->ps))
								{
									knockback *= 4; //superpush
								}
								else
								{
									knockback *= 2; //superpush
								}
							}
						}

						if (mod_power_level != -1)
						{
							if (!mod_power_level)
							{
								knockback /= 10.0f;
							}
							else if (mod_power_level == 1)
							{
								knockback /= 6.0f;
							}
							else
							{
								knockback /= 2.0f;
							}
						}
						//actually push/pull the enemy
						G_Throw(push_target[x], push_dir, knockback);
						//make it so they don't actually hurt me when pulled at me...
						push_target[x]->forcePuller = self->s.number;

						if (push_target[x]->client->ps.groundEntityNum != ENTITYNUM_NONE)
						{
							//if on the ground, make sure they get shoved up some
							if (push_target[x]->client->ps.velocity[2] < knockback)
							{
								push_target[x]->client->ps.velocity[2] = knockback;
							}
						}

						if (push_target[x]->health > 0)
						{
							//target is still alive
							if ((push_target[x]->s.number || cg.renderingThirdPerson && !cg.zoomMode)
								//NPC or 3rd person player
								&& (!pull && self->client->ps.forcePowerLevel[FP_PUSH] < FORCE_LEVEL_2 && push_target[x]->
									client->ps.forcePowerLevel[FP_PUSH] < FORCE_LEVEL_1 //level 1 push
									|| pull && self->client->ps.forcePowerLevel[FP_PULL] < FORCE_LEVEL_2 && push_target[x]
									->client->ps.forcePowerLevel[FP_PULL] < FORCE_LEVEL_1)) //level 1 pull
							{
								//NPC or third person player (without force push/pull skill), and force push/pull level is at 1
								WP_ForceKnockdown(push_target[x], self, pull,
									static_cast<qboolean>(!pull && knockback > 150), qfalse);
								if (g_SerenityJediEngineMode->integer)
								{
									if (self->client->NPC_class == CLASS_GALEN
										&& (self->s.weapon == WP_MELEE || self->s.weapon == WP_NONE || self->s.weapon ==
											WP_SABER && !self->client->ps.SaberActive())
										&& self->client->ps.groundEntityNum == ENTITYNUM_NONE)
									{
										RepulseDamage(self, push_target[x], tr.endpos, damage_level);
										knockback = 200;
									}
									else
									{
										if (pull)
										{
											//
										}
										else
										{
											PushDamage(self, push_target[x], tr.endpos, damage_level);
										}
									}
								}
							}
							else if (!push_target[x]->s.number)
							{
								//player, have to force an anim on him
								WP_ForceKnockdown(push_target[x], self, pull,
									static_cast<qboolean>(!pull && knockback > 150), qfalse);
								if (g_SerenityJediEngineMode->integer)
								{
									if (self->client->NPC_class == CLASS_GALEN
										&& (self->s.weapon == WP_MELEE || self->s.weapon == WP_NONE || self->s.weapon ==
											WP_SABER && !self->client->ps.SaberActive())
										&& self->client->ps.groundEntityNum == ENTITYNUM_NONE)
									{
										RepulseDamage(self, push_target[x], tr.endpos, damage_level);
										knockback = 200;
									}
									else
									{
										if (pull)
										{
											//
										}
										else
										{
											PushDamage(self, push_target[x], tr.endpos, damage_level);
										}
									}
								}
							}
							else
							{
								//NPC and force-push/pull at level 2 or higher
								WP_ForceKnockdown(push_target[x], self, pull,
									static_cast<qboolean>(!pull && knockback > 100), qfalse);
								if (g_SerenityJediEngineMode->integer)
								{
									if (self->client->NPC_class == CLASS_GALEN
										&& (self->s.weapon == WP_MELEE || self->s.weapon == WP_NONE || self->s.weapon ==
											WP_SABER && !self->client->ps.SaberActive())
										&& self->client->ps.groundEntityNum == ENTITYNUM_NONE)
									{
										RepulseDamage(self, push_target[x], tr.endpos, damage_level);
										knockback = 200;
									}
									else
									{
										if (pull)
										{
											//
										}
										else
										{
											PushDamage(self, push_target[x], tr.endpos, damage_level);
										}
									}
								}
							}
						}
						push_target[x]->forcePushTime = level.time + 600; // let the push effect last for 600 ms
					}
				}
				else if (!fake)
				{
					//not a fake push/pull
					if (push_target[x]->s.weapon == WP_SABER && push_target[x]->contents & CONTENTS_LIGHTSABER)
					{
						//a thrown saber, just send it back
						if (push_target[x]->owner && push_target[x]->owner->client && push_target[x]->owner->client->ps.
							SaberActive() && push_target[x]->s.pos.trType == TR_LINEAR && push_target[x]->owner->client->ps.
							saberEntityState != SES_RETURNING)
						{
							//it's on and being controlled
							if (self->s.number == 0 || Q_irand(0, 2))
							{
								//certain chance of throwing it aside and turning it off?
								if (Q_irand(0, 1))
								{
									VectorScale(right, -1, right);
								}

								if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self))
								{
									if (is_class_guard)
									{
										G_MissileBouncedoffSaber(self, push_target[x], right);
									}
									else
									{
										G_ReflectMissileNPC(self, push_target[x], right);
									}
								}
								else
								{
									if (g_SerenityJediEngineMode->integer)
									{
										G_ReflectMissileAuto(self, push_target[x], right);
									}
									else
									{
										G_ReflectMissile_JKA(self, push_target[x], right);
									}
								}
								WP_SaberDrop(push_target[x]->owner, push_target[x]);
							}
							else
							{
								if (g_SerenityJediEngineMode->integer && g_SaberMustReturn->integer < 1 && (G_ControlledByPlayer(push_target[x]->owner)))
								{
									WP_SaberDrop(push_target[x]->owner, push_target[x]);
								}
								else
								{
									if (push_target[x]->owner->NPC && !G_ControlledByPlayer(push_target[x]->owner))
									{
										WP_SaberDrop(push_target[x]->owner, push_target[x]);
									}
									else
									{
										WP_SaberReturn(push_target[x]->owner, push_target[x]);
									}
								}
							}
						}
					}
					else if (push_target[x]->s.eType == ET_MISSILE
						&& push_target[x]->s.pos.trType != TR_STATIONARY
						&& (push_target[x]->s.pos.trType != TR_INTERPOLATE || push_target[x]->s.weapon != WP_THERMAL))
						//rolling and stationary thermal detonators are dealt with below
					{
						vec3_t dir2_me;
						VectorSubtract(self->currentOrigin, push_target[x]->currentOrigin, dir2_me);
						float dot = DotProduct(push_target[x]->s.pos.trDelta, dir2_me);
						if (pull)
						{
							//deflect rather than reflect?
						}
						else
						{
							if (push_target[x]->s.eFlags & EF_MISSILE_STICK)
							{
								//caught a sticky in-air
								push_target[x]->s.eType = ET_MISSILE;
								push_target[x]->s.eFlags &= ~EF_MISSILE_STICK;
								push_target[x]->s.eFlags |= EF_BOUNCE_HALF;
								push_target[x]->splashDamage /= 3;
								push_target[x]->splashRadius /= 3;
								push_target[x]->e_ThinkFunc = thinkF_WP_Explode;
								push_target[x]->nextthink = level.time + Q_irand(500, 3000);
							}
							if (dot >= 0)
							{
								//it's heading towards me
								if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self))
								{
									if (is_class_guard)
									{
										G_MissileBouncedoffSaber(self, push_target[x], forward);
									}
									else
									{
										G_ReflectMissileNPC(self, push_target[x], forward);
									}
								}
								else
								{
									if (g_SerenityJediEngineMode->integer)
									{
										G_ReflectMissileAuto(self, push_target[x], forward);
									}
									else
									{
										G_ReflectMissile_JKA(self, push_target[x], forward);
									}
								}
							}
							else
							{
								VectorScale(push_target[x]->s.pos.trDelta, 1.25f, push_target[x]->s.pos.trDelta);
							}
						}
						if (push_target[x]->s.eType == ET_MISSILE
							&& push_target[x]->s.weapon == WP_ROCKET_LAUNCHER
							&& push_target[x]->damage < 60)
						{
							//pushing away a rocket raises it's damage to the max for NPCs
							push_target[x]->damage = 60;
						}
					}
					else if (push_target[x]->svFlags & SVF_GLASS_BRUSH)
					{
						//break the glass
						trace_t trace;
						vec3_t push_dir;
						float damage = 800;

						AngleVectors(self->client->ps.viewangles, forward, nullptr, nullptr);
						VectorNormalize(forward);
						VectorMA(self->client->renderInfo.eyePoint, radius, forward, end);
						gi.trace(&trace, self->client->renderInfo.eyePoint, vec3_origin, vec3_origin, end,
							self->s.number, MASK_SHOT, static_cast<EG2_Collision>(0), 0);
						if (trace.entityNum != push_target[x]->s.number || trace.fraction == 1.0 || trace.allsolid ||
							trace.startsolid)
						{
							//must be pointing right at it
							continue;
						}

						if (pull)
						{
							VectorSubtract(self->client->renderInfo.eyePoint, trace.endpos, push_dir);
						}
						else
						{
							VectorSubtract(trace.endpos, self->client->renderInfo.eyePoint, push_dir);
						}
						damage -= VectorNormalize(push_dir);
						if (damage < 200)
						{
							damage = 200;
						}
						VectorScale(push_dir, damage, push_dir);

						G_Damage(push_target[x], self, self, push_dir, trace.endpos, damage, 0, MOD_UNKNOWN);
					}
					else if (!Q_stricmp("func_static", push_target[x]->classname))
					{
						//force-usable func_static
						if (!pull && push_target[x]->spawnflags & 1/*F_PUSH*/)
						{
							if (push_target[x]->NPC_targetname == nullptr
								|| self->targetname && Q_stricmp(push_target[x]->NPC_targetname, self->targetname) == 0)
							{
								//anyone can pull it or only 1 person can push it and it's me
								GEntity_UseFunc(push_target[x], self, self);
							}
						}
						else if (pull && push_target[x]->spawnflags & 2/*F_PULL*/)
						{
							if (push_target[x]->NPC_targetname == nullptr
								|| self->targetname && Q_stricmp(push_target[x]->NPC_targetname, self->NPC_targetname) ==
								0)
							{
								//anyone can push it or only 1 person can push it and it's me
								GEntity_UseFunc(push_target[x], self, self);
							}
						}
					}
					else if (!Q_stricmp("func_door", push_target[x]->classname) && push_target[x]->spawnflags & 2
						/*MOVER_FORCE_ACTIVATE*/)
					{
						//push/pull the door
						vec3_t pos1, pos2;

						AngleVectors(self->client->ps.viewangles, forward, nullptr, nullptr);
						VectorNormalize(forward);
						VectorMA(self->client->renderInfo.eyePoint, radius, forward, end);
						gi.trace(&tr, self->client->renderInfo.eyePoint, vec3_origin, vec3_origin, end, self->s.number,
							MASK_SHOT, static_cast<EG2_Collision>(0), 0);
						if (tr.entityNum != push_target[x]->s.number || tr.fraction == 1.0 || tr.allsolid || tr.
							startsolid)
						{
							//must be pointing right at it
							continue;
						}

						if (VectorCompare(vec3_origin, push_target[x]->s.origin))
						{
							//does not have an origin brush, so pos1 & pos2 are relative to world origin, need to calc center
							VectorSubtract(push_target[x]->absmax, push_target[x]->absmin, size);
							VectorMA(push_target[x]->absmin, 0.5, size, center);
							if (push_target[x]->spawnflags & 1 && push_target[x]->moverState == MOVER_POS1)
							{
								//if at pos1 and started open, make sure we get the center where it *started* because we're going to add back in the relative values pos1 and pos2
								VectorSubtract(center, push_target[x]->pos1, center);
							}
							else if (!(push_target[x]->spawnflags & 1) && push_target[x]->moverState == MOVER_POS2)
							{
								//if at pos2, make sure we get the center where it *started* because we're going to add back in the relative values pos1 and pos2
								VectorSubtract(center, push_target[x]->pos2, center);
							}
							VectorAdd(center, push_target[x]->pos1, pos1);
							VectorAdd(center, push_target[x]->pos2, pos2);
						}
						else
						{
							//actually has an origin, pos1 and pos2 are absolute
							VectorCopy(push_target[x]->currentOrigin, center);
							VectorCopy(push_target[x]->pos1, pos1);
							VectorCopy(push_target[x]->pos2, pos2);
						}

						if (Distance(pos1, self->client->renderInfo.eyePoint) < Distance(
							pos2, self->client->renderInfo.eyePoint))
						{
							//pos1 is closer
							if (push_target[x]->moverState == MOVER_POS1)
							{
								//at the closest pos
								if (pull)
								{
									//trying to pull, but already at closest point, so screw it
									continue;
								}
							}
							else if (push_target[x]->moverState == MOVER_POS2)
							{
								//at farthest pos
								if (!pull)
								{
									//trying to push, but already at farthest point, so screw it
									continue;
								}
							}
						}
						else
						{
							//pos2 is closer
							if (push_target[x]->moverState == MOVER_POS1)
							{
								//at the farthest pos
								if (!pull)
								{
									//trying to push, but already at farthest point, so screw it
									continue;
								}
							}
							else if (push_target[x]->moverState == MOVER_POS2)
							{
								//at closest pos
								if (pull)
								{
									//trying to pull, but already at closest point, so screw it
									continue;
								}
							}
						}
						GEntity_UseFunc(push_target[x], self, self);
					}
					else if (push_target[x]->s.eType == ET_MISSILE /*thermal resting on ground*/
						|| push_target[x]->s.eType == ET_ITEM
						|| push_target[x]->e_ThinkFunc == thinkF_G_RunObject || Q_stricmp("limb", push_target[x]->classname)
						== 0)
					{
						//general object, toss it
						vec3_t push_dir, kvel;
						float knockback = pull ? 0 : 200;
						float mass = 200;

						if (pull)
						{
							if (push_target[x]->s.eType == ET_ITEM)
							{
								//pull it to a little higher point
								vec3_t adjustedOrg;
								VectorCopy(self->currentOrigin, adjustedOrg);
								adjustedOrg[2] += self->maxs[2] / 3;
								VectorSubtract(adjustedOrg, push_target[x]->currentOrigin, push_dir);
							}
							else if (self->enemy //I have an enemy
								&& self->client->ps.forcePowerLevel[FP_PUSH] > FORCE_LEVEL_2 //have push 3 or greater
								&& InFront(push_target[x]->currentOrigin, self->currentOrigin, self->currentAngles, 0.25f)
								//object is generally in front of me
								&& InFront(self->enemy->currentOrigin, self->currentOrigin, self->currentAngles, 0.75f)
								//enemy is pretty much right in front of me
								&& !InFront(push_target[x]->currentOrigin, self->enemy->currentOrigin,
									self->enemy->currentAngles, -0.25f) //object is generally behind enemy
								&& (self->NPC && (no_resist || is_class_guard || Q_irand(0, RANK_CAPTAIN) < self->NPC->
									rank) //NPC with enough skill
									|| self->s.number < MAX_CLIENTS))
							{
								VectorSubtract(self->enemy->currentOrigin, push_target[x]->currentOrigin, push_dir);
							}
							else
							{
								VectorSubtract(self->currentOrigin, push_target[x]->currentOrigin, push_dir);
							}
							knockback += VectorNormalize(push_dir);
							if (knockback > 200)
							{
								knockback = 200;
							}
							if (push_target[x]->s.eType == ET_ITEM
								&& push_target[x]->item
								&& push_target[x]->item->giType == IT_HOLDABLE
								&& push_target[x]->item->giTag == INV_SECURITY_KEY)
							{
								//security keys are pulled with less enthusiasm
								if (knockback > 100)
								{
									knockback = 100;
								}
							}
							else if (knockback > 200)
							{
								knockback = 200;
							}
						}
						else
						{
							if (self->enemy //I have an enemy
								&& push_target[x]->s.eType != ET_ITEM //not an item
								&& self->client->ps.forcePowerLevel[FP_PUSH] > FORCE_LEVEL_2 //have push 3 or greater
								&& InFront(push_target[x]->currentOrigin, self->currentOrigin, self->currentAngles, 0.25f)
								//object is generally in front of me
								&& InFront(self->enemy->currentOrigin, self->currentOrigin, self->currentAngles, 0.75f)
								//enemy is pretty much right in front of me
								&& InFront(push_target[x]->currentOrigin, self->enemy->currentOrigin,
									self->enemy->currentAngles, 0.25f) //object is generally in front of enemy
								&& (self->NPC && (no_resist || is_class_guard || Q_irand(0, RANK_CAPTAIN) < self->NPC->
									rank) //NPC with enough skill
									|| self->s.number < MAX_CLIENTS))
							{
								VectorSubtract(self->enemy->currentOrigin, push_target[x]->currentOrigin, push_dir);
							}
							else
							{
								VectorSubtract(push_target[x]->currentOrigin, self->currentOrigin, push_dir);
							}
							knockback -= VectorNormalize(push_dir);
							if (knockback < 100)
							{
								knockback = 100;
							}
						}
						VectorCopy(push_target[x]->currentOrigin, push_target[x]->s.pos.trBase);
						push_target[x]->s.pos.trTime = level.time; // move a bit on the very first frame
						if (push_target[x]->s.pos.trType != TR_INTERPOLATE)
						{
							//don't do this to rolling missiles
							push_target[x]->s.pos.trType = TR_GRAVITY;
						}

						if (push_target[x]->e_ThinkFunc == thinkF_G_RunObject && push_target[x]->physicsBounce)
						{
							//it's a pushable misc_model_breakable, use it's mass instead of our one-size-fits-all mass
							mass = push_target[x]->physicsBounce; //same as push_target[x]->mass, right?
						}
						if (mass < 50)
						{
							//???
							mass = 50;
						}
						if (g_gravity->value > 0)
						{
							VectorScale(push_dir, g_knockback->value * knockback / mass * 0.8, kvel);
							kvel[2] = push_dir[2] * g_knockback->value * knockback / mass * 1.5;
						}
						else
						{
							VectorScale(push_dir, g_knockback->value * knockback / mass, kvel);
						}
						VectorAdd(push_target[x]->s.pos.trDelta, kvel, push_target[x]->s.pos.trDelta);
						if (g_gravity->value > 0)
						{
							if (push_target[x]->s.pos.trDelta[2] < knockback)
							{
								push_target[x]->s.pos.trDelta[2] = knockback;
							}
						}
						//no trDuration?
						if (push_target[x]->e_ThinkFunc != thinkF_G_RunObject)
						{
							//objects spin themselves?
							push_target[x]->s.apos.trTime = level.time;
							push_target[x]->s.apos.trType = TR_LINEAR;
							VectorClear(push_target[x]->s.apos.trDelta);
							push_target[x]->s.apos.trDelta[1] = Q_irand(-800, 800);
						}

						if (Q_stricmp("limb", push_target[x]->classname) == 0)
						{
							//make sure it runs it's physics
							push_target[x]->e_ThinkFunc = thinkF_LimbThink;
							push_target[x]->nextthink = level.time + FRAMETIME;
						}
						push_target[x]->forcePushTime = level.time + 600; // let the push effect last for 600 ms
						push_target[x]->forcePuller = self->s.number; //remember this regardless
						if (push_target[x]->item && push_target[x]->item->giTag == INV_SECURITY_KEY)
						{
							AddSightEvent(player, push_target[x]->currentOrigin, 128, AEL_DISCOVERED);
							//security keys are more important
						}
						else
						{
							AddSightEvent(player, push_target[x]->currentOrigin, 128, AEL_SUSPICIOUS);
							//hmm... or should this always be discovered?
						}
					}
					else if (push_target[x]->s.weapon == WP_TURRET
						&& !Q_stricmp("PAS", push_target[x]->classname)
						&& push_target[x]->s.apos.trType == TR_STATIONARY)
					{
						//a portable turret
						WP_KnockdownTurret(push_target[x]);
					}
				}
			}
			if (pull)
			{
				if (self->client->ps.forcePowerLevel[FP_PULL] > FORCE_LEVEL_2)
				{
					//at level 3, can pull multiple, so it costs more
					actual_cost = forcePowerNeeded[FP_PULL] * ent_count;
					if (actual_cost > 50)
					{
						actual_cost = 50;
					}
					else if (actual_cost < cost)
					{
						actual_cost = cost;
					}
				}
				else
				{
					actual_cost = cost;
				}
				WP_ForcePowerStart(self, FP_PULL, actual_cost);
			}
			else
			{
				if (self->client->ps.forcePowerLevel[FP_PUSH] > FORCE_LEVEL_2)
				{
					//at level 3, can push multiple, so costs more
					actual_cost = forcePowerNeeded[FP_PUSH] * ent_count;
					if (actual_cost > 50)
					{
						actual_cost = 50;
					}
					else if (actual_cost < cost)
					{
						actual_cost = cost;
					}
				}
				else if (self->client->ps.forcePowerLevel[FP_PUSH] > FORCE_LEVEL_1)
				{
					//at level 2, can push multiple, so costs more
					actual_cost = floor(forcePowerNeeded[FP_PUSH] * ent_count / 1.5f);
					if (actual_cost > 50)
					{
						actual_cost = 50;
					}
					else if (actual_cost < cost)
					{
						actual_cost = cost;
					}
				}
				else
				{
					actual_cost = cost;
				}
				WP_ForcePowerStart(self, FP_PUSH, actual_cost);
			}
		}
		else
		{
			//didn't push or pull anything?  don't penalize them too much
			if (pull)
			{
				WP_ForcePowerStart(self, FP_PULL, 5);
			}
			else
			{
				WP_ForcePowerStart(self, FP_PUSH, 5);
			}
		}
	}
	else // ON THE GROUND ################################## NORMAL PUSH
	{
		if (ent_count)
		{
			for (int x = 0; x < ent_count; x++)
			{
				if (push_target[x]->client)
				{
					float knockback = pull ? 0 : 200;

					//SIGH band-aid...
					if (push_target[x]->s.number >= MAX_CLIENTS
						&& self->s.number < MAX_CLIENTS)
					{
						if (push_target[x]->client->ps.forcePowersActive & 1 << FP_GRIP
							&& push_target[x]->client->ps.forceGripEntityNum == self->s.number)
						{
							WP_ForcePowerStop(push_target[x], FP_GRIP);
						}
						if (push_target[x]->client->ps.forcePowersActive & 1 << FP_GRASP
							&& push_target[x]->client->ps.forceGripEntityNum == self->s.number)
						{
							WP_ForcePowerStop(push_target[x], FP_GRASP);
						}
						if (push_target[x]->client->ps.forcePowersActive & 1 << FP_DRAIN
							&& push_target[x]->client->ps.forceDrainEntityNum == self->s.number)
						{
							WP_ForcePowerStop(push_target[x], FP_DRAIN);
						}
					}

					if (rosh_being_healed(push_target[x]))
					{
						continue;
					}
					if (push_target[x]->client->NPC_class == CLASS_HAZARD_TROOPER
						&& push_target[x]->health > 0)
					{
						//living hazard troopers resist push/pull
						WP_ForceThrowHazardTrooper(self, push_target[x], pull);
						continue;
					}
					if (fake && !is_class_guard)
					{
						//always resist
						WP_ResistForcePush(push_target[x], self, qfalse);
						continue;
					}

					if (push_target[x]->client->NPC_class == CLASS_GUARD || jedi_jedi_master_low(push_target[x]))
					{
						//do a knockdown hes a twat
						WP_ForceKnockdown(push_target[x], self, pull, qtrue, qfalse);
						if (g_SerenityJediEngineMode->integer)
						{
							if (pull)
							{
								//
							}
							else
							{
								PushDamage(self, push_target[x], tr.endpos, damage_level);
							}
						}
						continue;
					}

					int power_level, power_use;
					if (pull)
					{
						power_level = self->client->ps.forcePowerLevel[FP_PULL];
						power_use = FP_PULL;
					}
					else
					{
						power_level = self->client->ps.forcePowerLevel[FP_PUSH];
						power_use = FP_PUSH;
					}

					int mod_power_level = WP_AbsorbConversion(push_target[x],
						push_target[x]->client->ps.forcePowerLevel[FP_ABSORB],
						power_use,
						power_level,
						forcePowerNeeded[self->client->ps.forcePowerLevel[
							power_use]]);

					if (push_target[x]->client->NPC_class == CLASS_ASSASSIN_DROID ||
						push_target[x]->client->NPC_class == CLASS_DROIDEKA ||
						//push_target[x]->client->NPC_class == CLASS_SBD ||
						push_target[x]->client->NPC_class == CLASS_HAZARD_TROOPER)
					{
						mod_power_level = 0; // divides throw by 10
					}

					//First, if this is the player we're push/pulling, see if he can counter it
					if (mod_power_level != -1
						&& !no_resist && !is_class_guard
						&& InFront(self->currentOrigin, push_target[x]->client->renderInfo.eyePoint,
							push_target[x]->client->ps.viewangles, 0.3f))
					{
						//absorbed and I'm in front of them
						//counter it
						if (push_target[x]->client->ps.forcePowerLevel[FP_ABSORB] > FORCE_LEVEL_2)
						{
							//no reaction at all
						}
						else
						{
							WP_ResistForcePush(push_target[x], self, qfalse);
							push_target[x]->client->ps.saber_move = push_target[x]->client->ps.saberBounceMove = LS_READY;
							//don't finish whatever saber anim you may have been in
							push_target[x]->client->ps.saberBlocked = BLOCKED_NONE;
						}
						continue;
					}
					if (!push_target[x]->s.number && !is_class_guard)
					{
						//player
						if (!no_resist && !is_class_guard && (ShouldPlayerResistForceThrow(push_target[x], self, pull) ||
							PlayerisResistingForceThrow(push_target[x], self))
							&& push_target[x]->client->ps.saberFatigueChainCount < MISHAPLEVEL_HEAVY)
						{
							WP_ResistForcePush(push_target[x], self, qfalse);
							push_target[x]->client->ps.saber_move = push_target[x]->client->ps.saberBounceMove = LS_READY;
							//don't finish whatever saber anim you may have been in
							push_target[x]->client->ps.saberBlocked = BLOCKED_NONE;
							continue;
						}
					}
					else if (push_target[x]->client && jedi_waiting_ambush(push_target[x]))
					{
						WP_ForceKnockdown(push_target[x], self, pull, qtrue, qfalse);
						if (g_SerenityJediEngineMode->integer)
						{
							if (pull)
							{
								//
							}
							else
							{
								PushDamage(self, push_target[x], tr.endpos, damage_level);
							}
						}
						continue;
					}
					else if (PM_SaberInBrokenParry(push_target[x]->client->ps.saber_move))
					{
						//do a knockdown if fairly close
						WP_ForceKnockdown(push_target[x], self, pull, qtrue, qfalse);
						if (g_SerenityJediEngineMode->integer)
						{
							if (pull)
							{
								//
							}
							else
							{
								PushDamage(self, push_target[x], tr.endpos, damage_level);
							}
						}
						continue;
					}
					else if (push_target[x]->client->NPC_class == CLASS_GUARD || jedi_jedi_master_low(push_target[x]))
					{
						//do a knockdown hes a twat
						WP_ForceKnockdown(push_target[x], self, pull, qtrue, qfalse);
						if (g_SerenityJediEngineMode->integer)
						{
							if (pull)
							{
								//
							}
							else
							{
								PushDamage(self, push_target[x], tr.endpos, damage_level);
							}
						}
						continue;
					}

					G_KnockOffVehicle(push_target[x], self, pull);

					if (!pull
						&& push_target[x]->client->ps.forceDrainEntityNum == self->s.number
						&& self->s.eFlags & EF_FORCE_DRAINED)
					{
						//stop them from draining me now, dammit!
						WP_ForcePowerStop(push_target[x], FP_DRAIN);
					}

					//okay, everyone else (or player who couldn't resist it)...
					if ((self->s.number == 0 && Q_irand(0, 2) || Q_irand(0, 2)) && push_target[x]->client && push_target[x]
						->health > 0 //a living client
						&& push_target[x]->client->ps.weapon == WP_SABER //Jedi
						&& push_target[x]->health > 0 //alive
						&& push_target[x]->client->ps.forceRageRecoveryTime < level.time //not recovering from rage
						&& (self->client->NPC_class != CLASS_DESANN && self->client->NPC_class != CLASS_SITHLORD && self
							->client->NPC_class != CLASS_VADER && Q_stricmp("Yoda", self->NPC_type) || !Q_irand(0, 2))
						//only 30% chance of resisting a Desann push
						&& push_target[x]->client->ps.groundEntityNum != ENTITYNUM_NONE //on the ground
						&& InFront(self->currentOrigin, push_target[x]->currentOrigin,
							push_target[x]->client->ps.viewangles, 0.3f) //I'm in front of him
						&& (push_target[x]->client->ps.powerups[PW_FORCE_PUSH] > level.time || //he's pushing too
							push_target[x]->s.number != 0 && push_target[x]->client->ps.weaponTime < level.time))
						//not the player and not attacking (NPC jedi auto-defend against pushes)
					{
						//Jedi don't get pushed, they resist as long as they aren't already attacking and are on the ground
						if (push_target[x]->client->ps.saberLockTime > level.time)
						{
							//they're in a lock
							if (push_target[x]->client->ps.saberLockEnemy != self->s.number)
							{
								//they're not in a lock with me
								continue;
							}
							if (pull || self->client->ps.forcePowerLevel[FP_PUSH] < FORCE_LEVEL_3 ||
								push_target[x]->client->ps.forcePowerLevel[FP_PUSH] > FORCE_LEVEL_2)
							{
								//they're in a lock with me, but my push is too weak
								continue;
							}
							//we will knock them down
							self->painDebounceTime = 0;
							self->client->ps.weaponTime = 500;
							if (self->client->ps.forcePowersActive & 1 << FP_SPEED)
							{
								self->client->ps.weaponTime = floor(self->client->ps.weaponTime * g_timescale->value);
							}
						}
						int resist_chance = Q_irand(0, 2);
						if (!push_target[x]->s.number && (self->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCK || self
							->client->ps.ManualBlockingFlags & 1 << MBF_NPCBLOCKING))
						{
							resist_chance = 1;
						}
						else if (push_target[x]->s.number >= MAX_CLIENTS)
						{
							//NPC
							if (g_spskill->integer == 1)
							{
								//stupid tweak for graham
								resist_chance = Q_irand(0, 3);
							}
						}
						if (no_resist || is_class_guard ||
							!pull
							&& mod_power_level == -1
							&& self->client->ps.forcePowerLevel[FP_PUSH] > FORCE_LEVEL_2
							&& !resist_chance
							&& push_target[x]->client->ps.forcePowerLevel[FP_PUSH] < FORCE_LEVEL_3)
						{
							//a level 3 push can even knock down a jedi
							if (PM_InKnockDown(&push_target[x]->client->ps))
							{
								//can't knock them down again
								continue;
							}
							WP_ForceKnockdown(push_target[x], self, pull, qfalse, qtrue);
							if (g_SerenityJediEngineMode->integer)
							{
								if (pull)
								{
									//
								}
								else
								{
									PushDamage(self, push_target[x], tr.endpos, damage_level);
								}
							}
						}
						else
						{
							if (!is_class_guard)
							{
								WP_ResistForcePush(push_target[x], self, qfalse);
							}
						}
					}
					else
					{
						vec3_t push_dir;
						//shove them
						if (push_target[x]->NPC
							&& push_target[x]->NPC->jumpState == JS_JUMPING)
						{
							//don't interrupt a scripted jump
							push_target[x]->forcePushTime = level.time + 600; // let the push effect last for 600 ms
							continue;
						}

						if (push_target[x]->s.number
							&& (push_target[x]->message || push_target[x]->flags & FL_NO_KNOCKBACK))
						{
							//an NPC who has a key
							WP_ForceKnockdown(push_target[x], self, pull, qfalse, qfalse);
							if (g_SerenityJediEngineMode->integer)
							{
								if (pull)
								{
									//
								}
								else
								{
									PushDamage(self, push_target[x], tr.endpos, damage_level);
								}
							}
							continue;
						}
						if (pull)
						{
							VectorSubtract(self->currentOrigin, push_target[x]->currentOrigin, push_dir);
							if (self->client->ps.forcePowerLevel[FP_PULL] >= FORCE_LEVEL_3
								&& self->client->NPC_class == CLASS_KYLE
								&& self->spawnflags & 1
								&& TIMER_Done(self, "kyleTakesSaber")
								&& push_target[x]->client
								&& push_target[x]->client->ps.weapon == WP_SABER
								&& !push_target[x]->client->ps.saberInFlight
								&& push_target[x]->client->ps.saberEntityNum < ENTITYNUM_WORLD
								&& !PM_InOnGroundAnim(&push_target[x]->client->ps))
							{
								vec3_t throwVec;
								VectorScale(push_dir, 10.0f, throwVec);
								WP_SaberLose(push_target[x], throwVec);
								NPC_SetAnim(push_target[x], SETANIM_BOTH, BOTH_LOSE_SABER,
									SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
								push_target[x]->client->ps.torsoAnimTimer += 500;
								push_target[x]->client->ps.pm_time = push_target[x]->client->ps.weaponTime = push_target[x]->
									client->ps.torsoAnimTimer;
								push_target[x]->client->ps.pm_flags |= PMF_TIME_KNOCKBACK;
								push_target[x]->client->ps.saber_move = LS_NONE;
								push_target[x]->aimDebounceTime = level.time + push_target[x]->client->ps.torsoAnimTimer;
								VectorClear(push_target[x]->client->ps.velocity);
								VectorClear(push_target[x]->client->ps.moveDir);
								//Kyle will stand around for a bit, too...
								self->client->ps.pm_time = self->client->ps.weaponTime = 2000;
								self->client->ps.pm_flags |= PMF_TIME_KNOCKBACK;
								self->painDebounceTime = level.time + self->client->ps.weaponTime;
								TIMER_Set(self, "kyleTakesSaber", Q_irand(60000, 180000));
								//don't do this again for a while
								G_AddVoiceEvent(self, Q_irand(EV_TAUNT1, EV_TAUNT5), Q_irand(8000, 12000));
								VectorClear(self->client->ps.velocity);
								VectorClear(self->client->ps.moveDir);
								continue;
							}
							if (push_target[x]->NPC
								&& push_target[x]->NPC->scriptFlags & SCF_DONT_FLEE)
							{
								//*SIGH*... if an NPC can't flee, they can't run after and pick up their weapon, do don't drop it
							}
							else if (self->client->ps.forcePowerLevel[FP_PULL] > FORCE_LEVEL_1
								&& push_target[x]->client->NPC_class != CLASS_ROCKETTROOPER
								//rockettroopers never drop their weapon
								&& push_target[x]->client->NPC_class != CLASS_VEHICLE
								&& push_target[x]->client->NPC_class != CLASS_BOBAFETT
								&& push_target[x]->client->NPC_class != CLASS_MANDALORIAN
								&& push_target[x]->client->NPC_class != CLASS_JANGO
								&& push_target[x]->client->NPC_class != CLASS_JANGODUAL
								&& push_target[x]->client->NPC_class != CLASS_TUSKEN
								&& push_target[x]->client->NPC_class != CLASS_HAZARD_TROOPER
								&& push_target[x]->client->NPC_class != CLASS_ASSASSIN_DROID
								&& push_target[x]->client->NPC_class != CLASS_DROIDEKA
								&& push_target[x]->client->NPC_class != CLASS_SBD
								&& push_target[x]->s.weapon != WP_SABER
								&& push_target[x]->s.weapon != WP_MELEE
								&& push_target[x]->s.weapon != WP_THERMAL
								&& push_target[x]->s.weapon != WP_CONCUSSION)
							{
								//yank the weapon
								if (InFront(self->currentOrigin, push_target[x]->currentOrigin,
									push_target[x]->client->ps.viewangles, 0.0f))
								{
									//enemy has to be facing me, too...
									WP_DropWeapon(push_target[x], push_dir);
								}
							}
							knockback += VectorNormalize(push_dir);
							if (knockback > 200)
							{
								knockback = 200;
							}
							if (self->client->ps.forcePowerLevel[FP_PULL] < FORCE_LEVEL_3)
							{
								//maybe just knock them down
								knockback /= 3;
							}
						}
						else
						{
							VectorSubtract(push_target[x]->currentOrigin, self->currentOrigin, push_dir);
							knockback -= VectorNormalize(push_dir);

							G_SoundOnEnt(push_target[x], CHAN_BODY, "sound/weapons/force/pushed.mp3");

							if (knockback < 100) // if less than 100
							{
								knockback = 100; // minimum 100
							}

							//scale for push level
							if (self->client->ps.forcePowerLevel[FP_PUSH] < FORCE_LEVEL_2) // level 1 devide by 3
							{
								if (self->s.weapon == WP_MELEE ||
									self->s.weapon == WP_NONE ||
									self->s.weapon == WP_SABER &&
									!self->client->ps.SaberActive() &&
									!PM_InKnockDown(&self->client->ps))
								{
									//maybe just knock them down
									knockback /= 2;
								}
								else
								{
									//maybe just knock them down
									knockback /= 3;
								}
							}
							else if (self->client->ps.forcePowerLevel[FP_PUSH] == FORCE_LEVEL_2) // level 2
							{
								if (self->s.weapon == WP_MELEE ||
									self->s.weapon == WP_NONE ||
									self->s.weapon == WP_SABER &&
									!self->client->ps.SaberActive() &&
									!PM_InKnockDown(&self->client->ps))
								{
									knockback = 125;
								}
								else
								{
									knockback = 100;
								}
							}
							else if (self->client->ps.forcePowerLevel[FP_PUSH] > FORCE_LEVEL_2) // level 3 add sound
							{
								if (push_target[x]->client->NPC_class == CLASS_GUARD || jedi_jedi_master_low(push_target[x]))
								{
									//do a knockdown hes a twat
									knockback *= 3; //superpush
								}
								if (self->s.weapon == WP_MELEE ||
									self->s.weapon == WP_NONE ||
									self->s.weapon == WP_SABER &&
									!self->client->ps.SaberActive() &&
									!PM_InKnockDown(&self->client->ps))
								{
									knockback *= 4; //superpush
								}
								else
								{
									knockback *= 2; //superpush
								}
							}
						}

						if (mod_power_level != -1)
						{
							if (!mod_power_level)
							{
								knockback /= 10.0f;
							}
							else if (mod_power_level == 1)
							{
								knockback /= 6.0f;
							}
							else
							{
								knockback /= 2.0f;
							}
						}
						//actually push/pull the enemy
						G_Throw(push_target[x], push_dir, knockback);
						//make it so they don't actually hurt me when pulled at me...
						push_target[x]->forcePuller = self->s.number;

						if (push_target[x]->client->ps.groundEntityNum != ENTITYNUM_NONE)
						{
							//if on the ground, make sure they get shoved up some
							if (push_target[x]->client->ps.velocity[2] < knockback)
							{
								push_target[x]->client->ps.velocity[2] = knockback;
							}
						}

						if (push_target[x]->health > 0)
						{
							//target is still alive
							if ((push_target[x]->s.number || cg.renderingThirdPerson && !cg.zoomMode)
								//NPC or 3rd person player
								&& (!pull && self->client->ps.forcePowerLevel[FP_PUSH] < FORCE_LEVEL_2 && push_target[x]->
									client->ps.forcePowerLevel[FP_PUSH] < FORCE_LEVEL_1 //level 1 push
									|| pull && self->client->ps.forcePowerLevel[FP_PULL] < FORCE_LEVEL_2 && push_target[x]
									->client->ps.forcePowerLevel[FP_PULL] < FORCE_LEVEL_1)) //level 1 pull
							{
								//NPC or third person player (without force push/pull skill), and force push/pull level is at 1
								WP_ForceKnockdown(push_target[x], self, pull,
									static_cast<qboolean>(!pull && knockback > 150), qfalse);
								if (g_SerenityJediEngineMode->integer)
								{
									if (pull)
									{
										//
									}
									else
									{
										PushDamage(self, push_target[x], tr.endpos, damage_level);
									}
								}
							}
							else if (!push_target[x]->s.number)
							{
								//player, have to force an anim on him
								WP_ForceKnockdown(push_target[x], self, pull,
									static_cast<qboolean>(!pull && knockback > 150), qfalse);
								if (g_SerenityJediEngineMode->integer)
								{
									if (pull)
									{
										//
									}
									else
									{
										PushDamage(self, push_target[x], tr.endpos, damage_level);
									}
								}
							}
							else
							{
								//NPC and force-push/pull at level 2 or higher
								WP_ForceKnockdown(push_target[x], self, pull, static_cast<qboolean>(!pull && knockback > 100), qfalse);
								if (g_SerenityJediEngineMode->integer)
								{
									if (pull)
									{
										//
									}
									else
									{
										PushDamage(self, push_target[x], tr.endpos, damage_level);
									}
								}
							}
						}
						push_target[x]->forcePushTime = level.time + 600; // let the push effect last for 600 ms
					}
				}
				else if (!fake)
				{
					//not a fake push/pull
					if (push_target[x]->s.weapon == WP_SABER && push_target[x]->contents & CONTENTS_LIGHTSABER)
					{
						//a thrown saber, just send it back
						if (push_target[x]->owner && push_target[x]->owner->client && push_target[x]->owner->client->ps.
							SaberActive() && push_target[x]->s.pos.trType == TR_LINEAR && push_target[x]->owner->client->ps.
							saberEntityState != SES_RETURNING)
						{
							//it's on and being controlled
							if (self->s.number == 0 || Q_irand(0, 2))
							{
								//certain chance of throwing it aside and turning it off?
								if (Q_irand(0, 1))
								{
									VectorScale(right, -1, right);
								}

								if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self))
								{
									if (is_class_guard)
									{
										G_MissileBouncedoffSaber(self, push_target[x], right);
									}
									else
									{
										G_ReflectMissileNPC(self, push_target[x], right);
									}
								}
								else
								{
									if (g_SerenityJediEngineMode->integer)
									{
										G_ReflectMissileAuto(self, push_target[x], right);
									}
									else
									{
										G_ReflectMissile_JKA(self, push_target[x], right);
									}
								}
								WP_SaberDrop(push_target[x]->owner, push_target[x]);
							}
							else
							{
								if (g_SerenityJediEngineMode->integer && g_SaberMustReturn->integer < 1 && (G_ControlledByPlayer(push_target[x]->owner)))
								{
									WP_SaberDrop(push_target[x]->owner, push_target[x]);
								}
								else
								{
									if (push_target[x]->owner->NPC && !G_ControlledByPlayer(push_target[x]->owner))
									{
										WP_SaberDrop(push_target[x]->owner, push_target[x]);
									}
									else
									{
										WP_SaberReturn(push_target[x]->owner, push_target[x]);
									}
								}
							}
						}
					}
					else if (push_target[x]->s.eType == ET_MISSILE
						&& push_target[x]->s.pos.trType != TR_STATIONARY
						&& (push_target[x]->s.pos.trType != TR_INTERPOLATE || push_target[x]->s.weapon != WP_THERMAL))
						//rolling and stationary thermal detonators are dealt with below
					{
						vec3_t dir2_me;
						VectorSubtract(self->currentOrigin, push_target[x]->currentOrigin, dir2_me);
						float dot = DotProduct(push_target[x]->s.pos.trDelta, dir2_me);
						if (pull)
						{
							//deflect rather than reflect?
						}
						else
						{
							if (push_target[x]->s.eFlags & EF_MISSILE_STICK)
							{
								//caught a sticky in-air
								push_target[x]->s.eType = ET_MISSILE;
								push_target[x]->s.eFlags &= ~EF_MISSILE_STICK;
								push_target[x]->s.eFlags |= EF_BOUNCE_HALF;
								push_target[x]->splashDamage /= 3;
								push_target[x]->splashRadius /= 3;
								push_target[x]->e_ThinkFunc = thinkF_WP_Explode;
								push_target[x]->nextthink = level.time + Q_irand(500, 3000);
							}
							if (dot >= 0)
							{
								//it's heading towards me
								if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self))
								{
									if (is_class_guard)
									{
										G_MissileBouncedoffSaber(self, push_target[x], forward);
									}
									else
									{
										G_ReflectMissileNPC(self, push_target[x], forward);
									}
								}
								else
								{
									if (g_SerenityJediEngineMode->integer)
									{
										G_ReflectMissileAuto(self, push_target[x], forward);
									}
									else
									{
										G_ReflectMissile_JKA(self, push_target[x], forward);
									}
								}
							}
							else
							{
								VectorScale(push_target[x]->s.pos.trDelta, 1.25f, push_target[x]->s.pos.trDelta);
							}
						}
						if (push_target[x]->s.eType == ET_MISSILE
							&& push_target[x]->s.weapon == WP_ROCKET_LAUNCHER
							&& push_target[x]->damage < 60)
						{
							//pushing away a rocket raises it's damage to the max for NPCs
							push_target[x]->damage = 60;
						}
					}
					else if (push_target[x]->svFlags & SVF_GLASS_BRUSH)
					{
						//break the glass
						trace_t trace;
						vec3_t push_dir;
						float damage = 800;

						AngleVectors(self->client->ps.viewangles, forward, nullptr, nullptr);
						VectorNormalize(forward);
						VectorMA(self->client->renderInfo.eyePoint, radius, forward, end);
						gi.trace(&trace, self->client->renderInfo.eyePoint, vec3_origin, vec3_origin, end,
							self->s.number, MASK_SHOT, static_cast<EG2_Collision>(0), 0);
						if (trace.entityNum != push_target[x]->s.number || trace.fraction == 1.0 || trace.allsolid ||
							trace.startsolid)
						{
							//must be pointing right at it
							continue;
						}

						if (pull)
						{
							VectorSubtract(self->client->renderInfo.eyePoint, trace.endpos, push_dir);
						}
						else
						{
							VectorSubtract(trace.endpos, self->client->renderInfo.eyePoint, push_dir);
						}
						damage -= VectorNormalize(push_dir);
						if (damage < 200)
						{
							damage = 200;
						}
						VectorScale(push_dir, damage, push_dir);

						G_Damage(push_target[x], self, self, push_dir, trace.endpos, damage, 0, MOD_UNKNOWN);
					}
					else if (!Q_stricmp("func_static", push_target[x]->classname))
					{
						//force-usable func_static
						if (!pull && push_target[x]->spawnflags & 1)
						{
							if (push_target[x]->NPC_targetname == nullptr
								|| self->targetname && Q_stricmp(push_target[x]->NPC_targetname, self->targetname) == 0)
							{
								//anyone can pull it or only 1 person can push it and it's me
								GEntity_UseFunc(push_target[x], self, self);
							}
						}
						else if (pull && push_target[x]->spawnflags & 2)
						{
							if (push_target[x]->NPC_targetname == nullptr
								|| self->targetname && Q_stricmp(push_target[x]->NPC_targetname, self->NPC_targetname) ==
								0)
							{
								//anyone can push it or only 1 person can push it and it's me
								GEntity_UseFunc(push_target[x], self, self);
							}
						}
					}
					else if (!Q_stricmp("func_door", push_target[x]->classname) && push_target[x]->spawnflags & 2
						/*MOVER_FORCE_ACTIVATE*/)
					{
						//push/pull the door
						vec3_t pos1, pos2;

						AngleVectors(self->client->ps.viewangles, forward, nullptr, nullptr);
						VectorNormalize(forward);
						VectorMA(self->client->renderInfo.eyePoint, radius, forward, end);
						gi.trace(&tr, self->client->renderInfo.eyePoint, vec3_origin, vec3_origin, end, self->s.number,
							MASK_SHOT, static_cast<EG2_Collision>(0), 0);
						if (tr.entityNum != push_target[x]->s.number || tr.fraction == 1.0 || tr.allsolid || tr.
							startsolid)
						{
							//must be pointing right at it
							continue;
						}

						if (VectorCompare(vec3_origin, push_target[x]->s.origin))
						{
							//does not have an origin brush, so pos1 & pos2 are relative to world origin, need to calc center
							VectorSubtract(push_target[x]->absmax, push_target[x]->absmin, size);
							VectorMA(push_target[x]->absmin, 0.5, size, center);
							if (push_target[x]->spawnflags & 1 && push_target[x]->moverState == MOVER_POS1)
							{
								//if at pos1 and started open, make sure we get the center where it *started* because we're going to add back in the relative values pos1 and pos2
								VectorSubtract(center, push_target[x]->pos1, center);
							}
							else if (!(push_target[x]->spawnflags & 1) && push_target[x]->moverState == MOVER_POS2)
							{
								//if at pos2, make sure we get the center where it *started* because we're going to add back in the relative values pos1 and pos2
								VectorSubtract(center, push_target[x]->pos2, center);
							}
							VectorAdd(center, push_target[x]->pos1, pos1);
							VectorAdd(center, push_target[x]->pos2, pos2);
						}
						else
						{
							//actually has an origin, pos1 and pos2 are absolute
							VectorCopy(push_target[x]->currentOrigin, center);
							VectorCopy(push_target[x]->pos1, pos1);
							VectorCopy(push_target[x]->pos2, pos2);
						}

						if (Distance(pos1, self->client->renderInfo.eyePoint) < Distance(
							pos2, self->client->renderInfo.eyePoint))
						{
							//pos1 is closer
							if (push_target[x]->moverState == MOVER_POS1)
							{
								//at the closest pos
								if (pull)
								{
									//trying to pull, but already at closest point, so screw it
									continue;
								}
							}
							else if (push_target[x]->moverState == MOVER_POS2)
							{
								//at farthest pos
								if (!pull)
								{
									//trying to push, but already at farthest point, so screw it
									continue;
								}
							}
						}
						else
						{
							//pos2 is closer
							if (push_target[x]->moverState == MOVER_POS1)
							{
								//at the farthest pos
								if (!pull)
								{
									//trying to push, but already at farthest point, so screw it
									continue;
								}
							}
							else if (push_target[x]->moverState == MOVER_POS2)
							{
								//at closest pos
								if (pull)
								{
									//trying to pull, but already at closest point, so screw it
									continue;
								}
							}
						}
						GEntity_UseFunc(push_target[x], self, self);
					}
					else if (push_target[x]->s.eType == ET_MISSILE /*thermal resting on ground*/
						|| push_target[x]->s.eType == ET_ITEM
						|| push_target[x]->e_ThinkFunc == thinkF_G_RunObject || Q_stricmp("limb", push_target[x]->classname)
						== 0)
					{
						//general object, toss it
						vec3_t push_dir, kvel;
						float knockback = pull ? 0 : 200;
						float mass = 200;

						if (pull)
						{
							if (push_target[x]->s.eType == ET_ITEM)
							{
								//pull it to a little higher point
								vec3_t adjustedOrg;
								VectorCopy(self->currentOrigin, adjustedOrg);
								adjustedOrg[2] += self->maxs[2] / 3;
								VectorSubtract(adjustedOrg, push_target[x]->currentOrigin, push_dir);
							}
							else if (self->enemy //I have an enemy
								&& self->client->ps.forcePowerLevel[FP_PUSH] > FORCE_LEVEL_2 //have push 3 or greater
								&& InFront(push_target[x]->currentOrigin, self->currentOrigin, self->currentAngles, 0.25f)
								//object is generally in front of me
								&& InFront(self->enemy->currentOrigin, self->currentOrigin, self->currentAngles, 0.75f)
								//enemy is pretty much right in front of me
								&& !InFront(push_target[x]->currentOrigin, self->enemy->currentOrigin,
									self->enemy->currentAngles, -0.25f) //object is generally behind enemy
								&& (self->NPC && (no_resist || is_class_guard || Q_irand(0, RANK_CAPTAIN) < self->NPC->
									rank) //NPC with enough skill
									|| self->s.number < MAX_CLIENTS))
							{
								VectorSubtract(self->enemy->currentOrigin, push_target[x]->currentOrigin, push_dir);
							}
							else
							{
								VectorSubtract(self->currentOrigin, push_target[x]->currentOrigin, push_dir);
							}
							knockback += VectorNormalize(push_dir);
							if (knockback > 200)
							{
								knockback = 200;
							}
							if (push_target[x]->s.eType == ET_ITEM
								&& push_target[x]->item
								&& push_target[x]->item->giType == IT_HOLDABLE
								&& push_target[x]->item->giTag == INV_SECURITY_KEY)
							{
								//security keys are pulled with less enthusiasm
								if (knockback > 100)
								{
									knockback = 100;
								}
							}
							else if (knockback > 200)
							{
								knockback = 200;
							}
						}
						else
						{
							if (self->enemy //I have an enemy
								&& push_target[x]->s.eType != ET_ITEM //not an item
								&& self->client->ps.forcePowerLevel[FP_PUSH] > FORCE_LEVEL_2 //have push 3 or greater
								&& InFront(push_target[x]->currentOrigin, self->currentOrigin, self->currentAngles, 0.25f)
								//object is generally in front of me
								&& InFront(self->enemy->currentOrigin, self->currentOrigin, self->currentAngles, 0.75f)
								//enemy is pretty much right in front of me
								&& InFront(push_target[x]->currentOrigin, self->enemy->currentOrigin,
									self->enemy->currentAngles, 0.25f) //object is generally in front of enemy
								&& (self->NPC && (no_resist || is_class_guard || Q_irand(0, RANK_CAPTAIN) < self->NPC->
									rank) //NPC with enough skill
									|| self->s.number < MAX_CLIENTS))
							{
								VectorSubtract(self->enemy->currentOrigin, push_target[x]->currentOrigin, push_dir);
							}
							else
							{
								VectorSubtract(push_target[x]->currentOrigin, self->currentOrigin, push_dir);
							}
							knockback -= VectorNormalize(push_dir);
							if (knockback < 100)
							{
								knockback = 100;
							}
						}
						//FIXME: if pull a FL_FORCE_PULLABLE_ONLY, clear the flag, assuming it's no longer in solid?  or check?
						VectorCopy(push_target[x]->currentOrigin, push_target[x]->s.pos.trBase);
						push_target[x]->s.pos.trTime = level.time; // move a bit on the very first frame
						if (push_target[x]->s.pos.trType != TR_INTERPOLATE)
						{
							//don't do this to rolling missiles
							push_target[x]->s.pos.trType = TR_GRAVITY;
						}

						if (push_target[x]->e_ThinkFunc == thinkF_G_RunObject && push_target[x]->physicsBounce)
						{
							//it's a pushable misc_model_breakable, use it's mass instead of our one-size-fits-all mass
							mass = push_target[x]->physicsBounce; //same as push_target[x]->mass, right?
						}
						if (mass < 50)
						{
							//???
							mass = 50;
						}
						if (g_gravity->value > 0)
						{
							VectorScale(push_dir, g_knockback->value * knockback / mass * 0.8, kvel);
							kvel[2] = push_dir[2] * g_knockback->value * knockback / mass * 1.5;
						}
						else
						{
							VectorScale(push_dir, g_knockback->value * knockback / mass, kvel);
						}
						VectorAdd(push_target[x]->s.pos.trDelta, kvel, push_target[x]->s.pos.trDelta);
						if (g_gravity->value > 0)
						{
							if (push_target[x]->s.pos.trDelta[2] < knockback)
							{
								push_target[x]->s.pos.trDelta[2] = knockback;
							}
						}
						//no trDuration?
						if (push_target[x]->e_ThinkFunc != thinkF_G_RunObject)
						{
							//objects spin themselves?
							push_target[x]->s.apos.trTime = level.time;
							push_target[x]->s.apos.trType = TR_LINEAR;
							VectorClear(push_target[x]->s.apos.trDelta);
							push_target[x]->s.apos.trDelta[1] = Q_irand(-800, 800);
						}

						if (Q_stricmp("limb", push_target[x]->classname) == 0)
						{
							//make sure it runs it's physics
							push_target[x]->e_ThinkFunc = thinkF_LimbThink;
							push_target[x]->nextthink = level.time + FRAMETIME;
						}
						push_target[x]->forcePushTime = level.time + 600; // let the push effect last for 600 ms
						push_target[x]->forcePuller = self->s.number; //remember this regardless
						if (push_target[x]->item && push_target[x]->item->giTag == INV_SECURITY_KEY)
						{
							AddSightEvent(player, push_target[x]->currentOrigin, 128, AEL_DISCOVERED);
							//security keys are more important
						}
						else
						{
							AddSightEvent(player, push_target[x]->currentOrigin, 128, AEL_SUSPICIOUS);
							//hmm... or should this always be discovered?
						}
					}
					else if (push_target[x]->s.weapon == WP_TURRET
						&& !Q_stricmp("PAS", push_target[x]->classname)
						&& push_target[x]->s.apos.trType == TR_STATIONARY)
					{
						//a portable turret
						WP_KnockdownTurret(push_target[x]);
					}
				}
			}
			if (pull)
			{
				if (self->client->ps.forcePowerLevel[FP_PULL] > FORCE_LEVEL_2)
				{
					//at level 3, can pull multiple, so it costs more
					actual_cost = forcePowerNeeded[FP_PULL] * ent_count;
					if (actual_cost > 50)
					{
						actual_cost = 50;
					}
					else if (actual_cost < cost)
					{
						actual_cost = cost;
					}
				}
				else
				{
					actual_cost = cost;
				}
				WP_ForcePowerStart(self, FP_PULL, actual_cost);
			}
			else
			{
				if (self->client->ps.forcePowerLevel[FP_PUSH] > FORCE_LEVEL_2)
				{
					//at level 3, can push multiple, so costs more
					actual_cost = forcePowerNeeded[FP_PUSH] * ent_count;
					if (actual_cost > 50)
					{
						actual_cost = 50;
					}
					else if (actual_cost < cost)
					{
						actual_cost = cost;
					}
				}
				else if (self->client->ps.forcePowerLevel[FP_PUSH] > FORCE_LEVEL_1)
				{
					//at level 2, can push multiple, so costs more
					actual_cost = floor(forcePowerNeeded[FP_PUSH] * ent_count / 1.5f);
					if (actual_cost > 50)
					{
						actual_cost = 50;
					}
					else if (actual_cost < cost)
					{
						actual_cost = cost;
					}
				}
				else
				{
					actual_cost = cost;
				}
				WP_ForcePowerStart(self, FP_PUSH, actual_cost);
			}
		}
		else
		{
			//didn't push or pull anything?  don't penalize them too much
			if (pull)
			{
				WP_ForcePowerStart(self, FP_PULL, 5);
			}
			else
			{
				WP_ForcePowerStart(self, FP_PUSH, 5);
			}
		}
	}

	if (pull)
	{
		if (self->NPC)
		{
			//NPCs can push more often
			self->client->ps.forcePowerDebounce[FP_PULL] = level.time + 200;
		}
		else
		{
			self->client->ps.forcePowerDebounce[FP_PULL] = level.time + self->client->ps.torsoAnimTimer + 500;
		}
	}
	else
	{
		if (self->NPC)
		{
			//NPCs can push more often
			self->client->ps.forcePowerDebounce[FP_PUSH] = level.time + 200;
		}
		else
		{
			self->client->ps.forcePowerDebounce[FP_PUSH] = level.time + self->client->ps.torsoAnimTimer + 500;
		}
	}
}

static void ForceRepulseDamage(gentity_t* self, gentity_t* enemy, vec3_t location, const int damage_level)
{
	switch (damage_level)
	{
	case FORCE_LEVEL_1:
		G_Damage(enemy, self, self, nullptr, location, 10, DAMAGE_NO_KNOCKBACK, MOD_UNKNOWN);
		break;
	case FORCE_LEVEL_2:
		G_Damage(enemy, self, self, nullptr, location, 25, DAMAGE_NO_KNOCKBACK, MOD_UNKNOWN);
		break;
	case FORCE_LEVEL_3:
		G_Damage(enemy, self, self, nullptr, location, 50, DAMAGE_NO_KNOCKBACK, MOD_UNKNOWN);
		break;
	default:
		break;
	}
}

static void ForceRepulseThrow(gentity_t* self, int charge_time)
{
	//shove things around you away
	qboolean fake = qfalse;
	gentity_t* push_target[MAX_GENTITIES];
	int num_listed_entities = 0;
	int ent_count = 0;
	int radius;
	vec3_t center, forward, right, fwdangles = { 0 };
	trace_t tr;
	int anim, hold, sound_index, cost;
	int damage_level = FORCE_LEVEL_0;
	qboolean is_class_guard = qfalse;

	if (self->health <= 0)
	{
		return;
	}
	if (self->client->ps.leanofs)
	{
		//can't force-throw while leaning
		return;
	}
	if (self->client->ps.forcePowerDebounce[FP_REPULSE] > level.time)
	{
		//already pushing- now you can't haul someone across the room, sorry
		return;
	}
	if (!self->s.number && (cg.zoomMode || in_camera))
	{
		//can't force throw/pull when zoomed in or in cinematic
		return;
	}

	if (PM_InLedgeMove(self->client->ps.legsAnim))
	{
		return;
	}

	if (self->client->ps.saberLockTime > level.time)
	{
		if (self->client->ps.forcePowerLevel[FP_REPULSE] < FORCE_LEVEL_3)
		{
			//this can be a way to break out
			return;
		}
		//else, I'm breaking my half of the saberlock
		self->client->ps.saberLockTime = 0;
		self->client->ps.saberLockEnemy = ENTITYNUM_NONE;
	}

	if (self->client->ps.legsAnim == BOTH_KNOCKDOWN3
		|| self->client->ps.torsoAnim == BOTH_FORCE_GETUP_F1 && self->client->ps.torsoAnimTimer > 400
		|| self->client->ps.torsoAnim == BOTH_FORCE_GETUP_F2 && self->client->ps.torsoAnimTimer > 900
		|| self->client->ps.torsoAnim == BOTH_GETUP3 && self->client->ps.torsoAnimTimer > 500
		|| self->client->ps.torsoAnim == BOTH_GETUP4 && self->client->ps.torsoAnimTimer > 300
		|| self->client->ps.torsoAnim == BOTH_GETUP5 && self->client->ps.torsoAnimTimer > 500)
	{
		//we're face-down, so we'd only be force-push/pulling the floor
		return;
	}

	if (self->client->NPC_class == CLASS_GUARD || jedi_jedi_master_low(self))
	{
		is_class_guard = qtrue;
	}

	radius = forcePushPullRadius[self->client->ps.forcePowerLevel[FP_REPULSE]];

	if (!radius)
	{
		//no ability to do this yet
		return;
	}

	if (charge_time > 2500.0f)
	{
		damage_level = FORCE_LEVEL_3;
	}
	else if (charge_time > 1250.0f)
	{
		damage_level = FORCE_LEVEL_2;
	}
	else if (charge_time > 500.0f)
	{
		damage_level = FORCE_LEVEL_1;
	}

	cost = forcePowerNeeded[FP_REPULSE];
	if (!WP_ForcePowerUsable(self, FP_REPULSE, cost))
	{
		return;
	}
	//make sure this plays and that you cannot press fire for about 1 second after this
	anim = BOTH_FORCE_REPULSE;
	sound_index = G_SoundIndex("sound/weapons/force/repulsepush.mp3");
	hold = 650;

	int parts = SETANIM_TORSO;
	if (!PM_InKnockDown(&self->client->ps))
	{
		if (self->client->ps.saberLockTime > level.time)
		{
			self->client->ps.saberLockTime = 0;
			self->painDebounceTime = level.time + 2000;
			hold += 1000;
			parts = SETANIM_BOTH;
		}
	}
	NPC_SetAnim(self, parts, anim, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD | SETANIM_FLAG_RESTART);
	self->client->ps.saber_move = self->client->ps.saberBounceMove = LS_READY;
	//don't finish whatever saber anim you may have been in
	self->client->ps.saberBlocked = BLOCKED_NONE;
	if (self->client->ps.forcePowersActive & 1 << FP_SPEED)
	{
		hold = floor(hold * g_timescale->value);
	}
	self->client->ps.weaponTime = hold; //was 1000, but want to swing sooner
	//do effect... FIXME: build-up or delay this until in proper part of anim
	self->client->ps.powerups[PW_FORCE_REPULSE] = level.time + self->client->ps.torsoAnimTimer + 500;
	//reset to 0 in case it's still > 0 from a previous push
	self->client->pushEffectFadeTime = 0;

	G_Sound(self, sound_index);

	VectorCopy(self->client->ps.viewangles, fwdangles);
	//fwdangles[1] = self->client->ps.viewangles[1];
	AngleVectors(fwdangles, forward, right, nullptr);
	VectorCopy(self->currentOrigin, center);

	if (!num_listed_entities)
	{
		int e;
		int i;
		vec3_t v{};
		vec3_t maxs{};
		vec3_t mins{};
		gentity_t* entity_list[MAX_GENTITIES];
		gentity_t* ent;
		float dist;
		for (i = 0; i < 3; i++)
		{
			mins[i] = center[i] - radius;
			maxs[i] = center[i] + radius;
		}

		num_listed_entities = gi.EntitiesInBox(mins, maxs, entity_list, MAX_GENTITIES);

		for (e = 0; e < num_listed_entities; e++)
		{
			vec3_t dir;
			vec3_t size;
			vec3_t ent_org;
			gentity_t* forward_ent = nullptr;
			ent = entity_list[e];

			if (!WP_ForceThrowable(ent, forward_ent, self, qfalse, 0.0f, radius, forward))
			{
				continue;
			}

			//this is all to see if we need to start a saber attack, if it's in flight, this doesn't matter
			// find the distance from the edge of the bounding box
			for (i = 0; i < 3; i++)
			{
				if (center[i] < ent->absmin[i])
				{
					v[i] = ent->absmin[i] - center[i];
				}
				else if (center[i] > ent->absmax[i])
				{
					v[i] = center[i] - ent->absmax[i];
				}
				else
				{
					v[i] = 0;
				}
			}

			VectorSubtract(ent->absmax, ent->absmin, size);
			VectorMA(ent->absmin, 0.5, size, ent_org);

			//see if they're in front of me
			VectorSubtract(ent_org, center, dir);
			VectorNormalize(dir);

			dist = VectorLength(v);

			if (dist >= radius)
			{
				continue;
			}

			//in PVS?
			if (!ent->bmodel && !gi.inPVS(ent_org, self->client->renderInfo.eyePoint))
			{
				//must be in PVS
				continue;
			}

			if (ent != forward_ent)
			{
				//don't need to trace against forwardEnt again
				//really should have a clear LOS to this thing...
				gi.trace(&tr, self->client->renderInfo.eyePoint, vec3_origin, vec3_origin, ent_org, self->s.number,
					MASK_FORCE_PUSH, static_cast<EG2_Collision>(0), 0);
				//was MASK_SHOT, but changed to match above trace and crosshair trace
				if (tr.fraction < 1.0f && tr.entityNum != ent->s.number)
				{
					//must have clear LOS
					continue;
				}
			}

			// ok, we are within the radius, add us to the incoming list
			push_target[ent_count] = ent;
			ent_count++;
		}
	}

	for (int x = 0; x < ent_count; x++)
	{
		if (push_target[x]->client)
		{
			//SIGH band-aid...
			if (push_target[x]->s.number >= MAX_CLIENTS
				&& self->s.number < MAX_CLIENTS)
			{
				if (push_target[x]->client->ps.forcePowersActive & 1 << FP_GRIP
					&& push_target[x]->client->ps.forceGripEntityNum == self->s.number)
				{
					WP_ForcePowerStop(push_target[x], FP_GRIP);
				}
				if (push_target[x]->client->ps.forcePowersActive & 1 << FP_GRASP
					&& push_target[x]->client->ps.forceGripEntityNum == self->s.number)
				{
					WP_ForcePowerStop(push_target[x], FP_GRASP);
				}
				if (push_target[x]->client->ps.forcePowersActive & 1 << FP_DRAIN
					&& push_target[x]->client->ps.forceDrainEntityNum == self->s.number)
				{
					WP_ForcePowerStop(push_target[x], FP_DRAIN);
				}
			}

			if (rosh_being_healed(push_target[x]))
			{
				continue;
			}
			if (push_target[x]->client->NPC_class == CLASS_HAZARD_TROOPER
				&& push_target[x]->health > 0)
			{
				//living hazard troopers resist push/pull
				WP_ForceThrowHazardTrooper(self, push_target[x], qfalse);
				continue;
			}
			if (fake && !is_class_guard)
			{
				//always resist
				WP_ResistForcePush(push_target[x], self, qfalse);
				continue;
			}

			int power_level, powerUse;
			power_level = self->client->ps.forcePowerLevel[FP_REPULSE];
			powerUse = FP_REPULSE;

			int mod_power_level = WP_AbsorbConversion(push_target[x], push_target[x]->client->ps.forcePowerLevel[FP_ABSORB],
				powerUse, power_level,
				forcePowerNeeded[self->client->ps.forcePowerLevel[powerUse]]);
			if (push_target[x]->client->NPC_class == CLASS_ASSASSIN_DROID ||
				push_target[x]->client->NPC_class == CLASS_HAZARD_TROOPER ||
				push_target[x]->client->NPC_class == CLASS_DROIDEKA)
			{
				mod_power_level = 0; // divides throw by 10
			}

			//First, if this is the player we're push/pulling, see if he can counter it
			if (mod_power_level != -1
				&& !is_class_guard
				&& InFront(self->currentOrigin, push_target[x]->client->renderInfo.eyePoint,
					push_target[x]->client->ps.viewangles, 0.3f))
			{
				//absorbed and I'm in front of them
				//counter it
				if (push_target[x]->client->ps.forcePowerLevel[FP_ABSORB] > FORCE_LEVEL_2)
				{
					//no reaction at all
				}
				else
				{
					WP_ResistForcePush(push_target[x], self, qfalse);
					push_target[x]->client->ps.saber_move = push_target[x]->client->ps.saberBounceMove = LS_READY;
					//don't finish whatever saber anim you may have been in
					push_target[x]->client->ps.saberBlocked = BLOCKED_NONE;
				}
				continue;
			}
			if (!push_target[x]->s.number && !is_class_guard)
			{
				//player
				if (ShouldPlayerResistForceThrow(push_target[x], self, qfalse))
				{
					WP_ResistForcePush(push_target[x], self, qfalse);
					push_target[x]->client->ps.saber_move = push_target[x]->client->ps.saberBounceMove = LS_READY;
					//don't finish whatever saber anim you may have been in
					push_target[x]->client->ps.saberBlocked = BLOCKED_NONE;
					continue;
				}
			}
			else if (push_target[x]->client && jedi_waiting_ambush(push_target[x]))
			{
				WP_ForceKnockdown(push_target[x], self, qfalse, qtrue, qfalse);
				ForceRepulseDamage(self, push_target[x], tr.endpos, damage_level);
				continue;
			}
			else if (push_target[x]->client->NPC_class == CLASS_GUARD || jedi_jedi_master_low(push_target[x]))
			{
				WP_ForceKnockdown(push_target[x], self, qfalse, qtrue, qfalse);
				ForceRepulseDamage(self, push_target[x], tr.endpos, damage_level);
				continue;
			}

			G_KnockOffVehicle(push_target[x], self, qfalse);

			if (push_target[x]->client->ps.forceDrainEntityNum == self->s.number
				&& self->s.eFlags & EF_FORCE_DRAINED)
			{
				//stop them from draining me now, dammit!
				WP_ForcePowerStop(push_target[x], FP_DRAIN);
			}

			//okay, everyone else (or player who couldn't resist it)...
			if ((self->s.number == 0 && Q_irand(0, 2) || Q_irand(0, 2)) && push_target[x]->client && push_target[x]->health
				> 0 //a living client
				&& push_target[x]->client->ps.weapon == WP_SABER //Jedi
				&& push_target[x]->health > 0 //alive
				&& push_target[x]->client->ps.forceRageRecoveryTime < level.time //not recovering from rage
				&& (self->client->NPC_class != CLASS_DESANN && Q_stricmp("Yoda", self->NPC_type) || !Q_irand(0, 2))
				//only 30% chance of resisting a Desann push
				&& push_target[x]->client->ps.groundEntityNum != ENTITYNUM_NONE //on the ground
				&& InFront(self->currentOrigin, push_target[x]->currentOrigin, push_target[x]->client->ps.viewangles,
					0.3f) //I'm in front of him
				&& (push_target[x]->client->ps.powerups[PW_FORCE_PUSH] > level.time || //he's pushing too
					push_target[x]->s.number != 0 && push_target[x]->client->ps.weaponTime < level.time))
				//not the player and not attacking (NPC jedi auto-defend against pushes)
			{
				//Jedi don't get pushed, they resist as long as they aren't already attacking and are on the ground
				if (push_target[x]->client->ps.saberLockTime > level.time)
				{
					//they're in a lock
					if (push_target[x]->client->ps.saberLockEnemy != self->s.number)
					{
						//they're not in a lock with me
						continue;
					}
					if (self->client->ps.forcePowerLevel[FP_REPULSE] < FORCE_LEVEL_3 ||
						push_target[x]->client->ps.forcePowerLevel[FP_PUSH] > FORCE_LEVEL_2)
					{
						//they're in a lock with me, but my push is too weak
						continue;
					}
					//we will knock them down
					self->painDebounceTime = 0;
					self->client->ps.weaponTime = 500;
					if (self->client->ps.forcePowersActive & 1 << FP_SPEED)
					{
						self->client->ps.weaponTime = floor(self->client->ps.weaponTime * g_timescale->value);
					}
				}
				int resist_chance = Q_irand(0, 2);
				if (push_target[x]->s.number >= MAX_CLIENTS)
				{
					//NPC
					if (g_spskill->integer == 1)
					{
						//stupid tweak for graham
						resist_chance = Q_irand(0, 3);
					}
				}
				if (is_class_guard || mod_power_level == -1
					&& self->client->ps.forcePowerLevel[FP_REPULSE] > FORCE_LEVEL_2
					&& !resist_chance
					&& push_target[x]->client->ps.forcePowerLevel[FP_PUSH] < FORCE_LEVEL_3)
				{
					//a level 3 push can even knock down a jedi
					if (PM_InKnockDown(&push_target[x]->client->ps))
					{
						//can't knock them down again
						continue;
					}
					WP_ForceKnockdown(push_target[x], self, qfalse, qfalse, qtrue);
					ForceRepulseDamage(self, push_target[x], tr.endpos, damage_level);
				}
				else if (push_target[x]->client->NPC_class == CLASS_GUARD || jedi_jedi_master_low(push_target[x]))
				{
					//do a knockdown hes a twat
					if (PM_InKnockDown(&push_target[x]->client->ps))
					{
						//can't knock them down again
						continue;
					}
					WP_ForceKnockdown(push_target[x], self, qfalse, qfalse, qtrue);
					ForceRepulseDamage(self, push_target[x], tr.endpos, damage_level);
				}
				else
				{
					if (!is_class_guard)
					{
						WP_ResistForcePush(push_target[x], self, qfalse);
					}
				}
			}
			else
			{
				float knockback = 200;
				vec3_t push_dir;
				//UGH: FIXME: for enemy jedi, they should probably always do force pull 3, and not your weapon (if player?)!
				//shove them
				if (push_target[x]->NPC
					&& push_target[x]->NPC->jumpState == JS_JUMPING)
				{
					//don't interrupt a scripted jump
					push_target[x]->forcePushTime = level.time + 600; // let the push effect last for 600 ms
					continue;
				}

				if (push_target[x]->s.number
					&& (push_target[x]->message || push_target[x]->flags & FL_NO_KNOCKBACK))
				{
					//an NPC who has a key
					//don't push me... FIXME: maybe can pull the key off me?
					WP_ForceKnockdown(push_target[x], self, qfalse, qfalse, qfalse);
					ForceRepulseDamage(self, push_target[x], tr.endpos, damage_level);
					continue;
				}
				if (push_target[x]->client->NPC_class == CLASS_GUARD || jedi_jedi_master_low(push_target[x]))
				{
					//do a knockdown hes a twat
					WP_ForceKnockdown(push_target[x], self, qfalse, qfalse, qfalse);
					ForceRepulseDamage(self, push_target[x], tr.endpos, damage_level);
					continue;
				}
				{
					VectorSubtract(push_target[x]->currentOrigin, self->currentOrigin, push_dir);
					knockback -= VectorNormalize(push_dir);
					if (knockback < 100)
					{
						knockback = 100;
					}
					//scale for push level
					if (self->client->ps.forcePowerLevel[FP_REPULSE] < FORCE_LEVEL_2)
					{
						//maybe just knock them down
						knockback /= 3;
					}
					else if (self->client->ps.forcePowerLevel[FP_REPULSE] > FORCE_LEVEL_2)
					{
						//super-hard push
						knockback *= 3;
					}
				}

				if (mod_power_level != -1)
				{
					if (!mod_power_level)
					{
						knockback /= 10.0f;
					}
					else if (mod_power_level == 1)
					{
						knockback /= 6.0f;
					}
					else // if ( modPowerLevel == 2 )
					{
						knockback /= 2.0f;
					}
				}
				//actually push/pull the enemy
				G_Throw(push_target[x], push_dir, knockback);
				//make it so they don't actually hurt me when pulled at me...
				push_target[x]->forcePuller = self->s.number;

				if (push_target[x]->client->ps.groundEntityNum != ENTITYNUM_NONE)
				{
					//if on the ground, make sure they get shoved up some
					if (push_target[x]->client->ps.velocity[2] < knockback)
					{
						push_target[x]->client->ps.velocity[2] = knockback;
					}
				}

				if (push_target[x]->health > 0)
				{
					//target is still alive
					if ((push_target[x]->s.number || cg.renderingThirdPerson && !cg.zoomMode) //NPC or 3rd person player
						&& (self->client->ps.forcePowerLevel[FP_REPULSE] < FORCE_LEVEL_2 && push_target[x]->client->ps.
							forcePowerLevel[FP_PUSH] < FORCE_LEVEL_1))
					{
						//NPC or third person player (without force push/pull skill), and force push/pull level is at 1
						WP_ForceKnockdown(push_target[x], self, qfalse, static_cast<qboolean>(knockback > 150), qfalse);
						ForceRepulseDamage(self, push_target[x], tr.endpos, damage_level);
					}
					else if (!push_target[x]->s.number)
					{
						//player, have to force an anim on him
						WP_ForceKnockdown(push_target[x], self, qfalse, static_cast<qboolean>(knockback > 150), qfalse);
						ForceRepulseDamage(self, push_target[x], tr.endpos, damage_level);
					}
					else if (push_target[x]->client->NPC_class == CLASS_GUARD || jedi_jedi_master_low(push_target[x]))
					{
						//do a knockdown hes a twat
						WP_ForceKnockdown(push_target[x], self, qfalse, static_cast<qboolean>(knockback > 150), qfalse);
						ForceRepulseDamage(self, push_target[x], tr.endpos, damage_level);
					}
					else
					{
						//NPC and force-push/pull at level 2 or higher
						WP_ForceKnockdown(push_target[x], self, qfalse, static_cast<qboolean>(knockback > 100), qfalse);
						ForceRepulseDamage(self, push_target[x], tr.endpos, damage_level);
					}
				}
				push_target[x]->forcePushTime = level.time + 600; // let the push effect last for 600 ms
			}
		}
		else if (!fake)
		{
			//not a fake push/pull
			if (push_target[x]->s.weapon == WP_SABER && push_target[x]->contents & CONTENTS_LIGHTSABER)
			{
				//a thrown saber, just send it back
				if (push_target[x]->owner && push_target[x]->owner->client && push_target[x]->owner->client->ps.SaberActive()
					&& push_target[x]->s.pos.trType == TR_LINEAR && push_target[x]->owner->client->ps.saberEntityState !=
					SES_RETURNING)
				{
					//it's on and being controlled
					if (self->s.number == 0 || Q_irand(0, 2))
					{
						//certain chance of throwing it aside and turning it off?
						if (Q_irand(0, 1))
						{
							VectorScale(right, -1, right);
						}

						if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self))
						{
							if (is_class_guard)
							{
								G_MissileBouncedoffSaber(self, push_target[x], right);
							}
							else
							{
								G_ReflectMissileNPC(self, push_target[x], right);
							}
						}
						else
						{
							if (g_SerenityJediEngineMode->integer)
							{
								G_ReflectMissileAuto(self, push_target[x], right);
							}
							else
							{
								G_ReflectMissile_JKA(self, push_target[x], right);
							}
						}
						WP_SaberDrop(push_target[x]->owner, push_target[x]);
					}
					else
					{
						if (g_SerenityJediEngineMode->integer && g_SaberMustReturn->integer < 1 && (G_ControlledByPlayer(push_target[x]->owner)))
						{
							WP_SaberDrop(push_target[x]->owner, push_target[x]);
						}
						else
						{
							if (push_target[x]->owner->NPC && !G_ControlledByPlayer(push_target[x]->owner))
							{
								WP_SaberDrop(push_target[x]->owner, push_target[x]);
							}
							else
							{
								WP_SaberReturn(push_target[x]->owner, push_target[x]);
							}
						}
					}
				}
			}
			else if (push_target[x]->s.eType == ET_MISSILE
				&& push_target[x]->s.pos.trType != TR_STATIONARY
				&& (push_target[x]->s.pos.trType != TR_INTERPOLATE || push_target[x]->s.weapon != WP_THERMAL))
				//rolling and stationary thermal detonators are dealt with below
			{
				vec3_t dir2_me;
				VectorSubtract(self->currentOrigin, push_target[x]->currentOrigin, dir2_me);
				float dot = DotProduct(push_target[x]->s.pos.trDelta, dir2_me);

				if (push_target[x]->s.eFlags & EF_MISSILE_STICK)
				{
					//caught a sticky in-air
					push_target[x]->s.eType = ET_MISSILE;
					push_target[x]->s.eFlags &= ~EF_MISSILE_STICK;
					push_target[x]->s.eFlags |= EF_BOUNCE_HALF;
					push_target[x]->splashDamage /= 3;
					push_target[x]->splashRadius /= 3;
					push_target[x]->e_ThinkFunc = thinkF_WP_Explode;
					push_target[x]->nextthink = level.time + Q_irand(500, 3000);
				}
				if (dot >= 0)
				{
					//it's heading towards me
					if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self))
					{
						if (is_class_guard)
						{
							G_MissileBouncedoffSaber(self, push_target[x], forward);
						}
						else
						{
							G_ReflectMissileNPC(self, push_target[x], forward);
						}
					}
					else
					{
						if (g_SerenityJediEngineMode->integer)
						{
							G_ReflectMissileAuto(self, push_target[x], forward);
						}
						else
						{
							G_ReflectMissile_JKA(self, push_target[x], forward);
						}
					}
				}
				else
				{
					VectorScale(push_target[x]->s.pos.trDelta, 1.25f, push_target[x]->s.pos.trDelta);
				}

				if (push_target[x]->s.eType == ET_MISSILE
					&& push_target[x]->s.weapon == WP_ROCKET_LAUNCHER
					&& push_target[x]->damage < 60)
				{
					//pushing away a rocket raises it's damage to the max for NPCs
					push_target[x]->damage = 60;
				}
			}
			else if (push_target[x]->svFlags & SVF_GLASS_BRUSH)
			{
				vec3_t end;
				//break the glass
				trace_t trace;
				vec3_t push_dir;
				float damage = 800;

				AngleVectors(self->client->ps.viewangles, forward, nullptr, nullptr);
				VectorNormalize(forward);
				VectorMA(self->client->renderInfo.eyePoint, radius, forward, end);
				gi.trace(&trace, self->client->renderInfo.eyePoint, vec3_origin, vec3_origin, end, self->s.number,
					MASK_SHOT, static_cast<EG2_Collision>(0), 0);
				if (trace.entityNum != push_target[x]->s.number || trace.fraction == 1.0 || trace.allsolid || trace.
					startsolid)
				{
					//must be pointing right at it
					continue;
				}

				VectorSubtract(trace.endpos, self->client->renderInfo.eyePoint, push_dir);

				damage -= VectorNormalize(push_dir);
				if (damage < 200)
				{
					damage = 200;
				}
				VectorScale(push_dir, damage, push_dir);

				G_Damage(push_target[x], self, self, push_dir, trace.endpos, damage, 0, MOD_UNKNOWN);
			}
			else if (push_target[x]->s.eType == ET_MISSILE /*thermal resting on ground*/
				|| push_target[x]->s.eType == ET_ITEM
				|| push_target[x]->e_ThinkFunc == thinkF_G_RunObject || Q_stricmp("limb", push_target[x]->classname) == 0)
			{
				//general object, toss it
				vec3_t push_dir, kvel;
				float knockback = 200;
				float mass = 200;

				if (self->enemy //I have an enemy
					&& push_target[x]->s.eType != ET_ITEM //not an item
					&& self->client->ps.forcePowerLevel[FP_REPULSE] > FORCE_LEVEL_2 //have push 3 or greater
					&& InFront(push_target[x]->currentOrigin, self->currentOrigin, self->currentAngles, 0.25f)
					//object is generally in front of me
					&& InFront(self->enemy->currentOrigin, self->currentOrigin, self->currentAngles, 0.75f)
					//enemy is pretty much right in front of me
					&& InFront(push_target[x]->currentOrigin, self->enemy->currentOrigin, self->enemy->currentAngles,
						0.25f) //object is generally in front of enemy
					//FIXME: check dist to enemy and clear LOS to enemy and clear Path between object and enemy?
					&& (self->NPC && Q_irand(is_class_guard, RANK_CAPTAIN) < self->NPC->rank //NPC with enough skill
						|| self->s.number < MAX_CLIENTS))
				{
					//if I have an auto-enemy & he's in front of me, push it toward him!
					VectorSubtract(self->enemy->currentOrigin, push_target[x]->currentOrigin, push_dir);
				}
				else
				{
					VectorSubtract(push_target[x]->currentOrigin, self->currentOrigin, push_dir);
				}
				knockback -= VectorNormalize(push_dir);
				if (knockback < 100)
				{
					knockback = 100;
				}

				//FIXME: if pull a FL_FORCE_PULLABLE_ONLY, clear the flag, assuming it's no longer in solid?  or check?
				VectorCopy(push_target[x]->currentOrigin, push_target[x]->s.pos.trBase);
				push_target[x]->s.pos.trTime = level.time; // move a bit on the very first frame
				if (push_target[x]->s.pos.trType != TR_INTERPOLATE)
				{
					//don't do this to rolling missiles
					push_target[x]->s.pos.trType = TR_GRAVITY;
				}

				if (push_target[x]->e_ThinkFunc == thinkF_G_RunObject && push_target[x]->physicsBounce)
				{
					//it's a pushable misc_model_breakable, use it's mass instead of our one-size-fits-all mass
					mass = push_target[x]->physicsBounce; //same as push_target[x]->mass, right?
				}
				if (mass < 50)
				{
					//???
					mass = 50;
				}
				if (g_gravity->value > 0)
				{
					VectorScale(push_dir, g_knockback->value * knockback / mass * 0.8, kvel);
					kvel[2] = push_dir[2] * g_knockback->value * knockback / mass * 1.5;
				}
				else
				{
					VectorScale(push_dir, g_knockback->value * knockback / mass, kvel);
				}
				VectorAdd(push_target[x]->s.pos.trDelta, kvel, push_target[x]->s.pos.trDelta);
				if (g_gravity->value > 0)
				{
					if (push_target[x]->s.pos.trDelta[2] < knockback)
					{
						push_target[x]->s.pos.trDelta[2] = knockback;
					}
				}
				//no trDuration?
				if (push_target[x]->e_ThinkFunc != thinkF_G_RunObject)
				{
					//objects spin themselves?
					//spin it
					//FIXME: messing with roll ruins the rotational center???
					push_target[x]->s.apos.trTime = level.time;
					push_target[x]->s.apos.trType = TR_LINEAR;
					VectorClear(push_target[x]->s.apos.trDelta);
					push_target[x]->s.apos.trDelta[1] = Q_irand(-800, 800);
				}

				if (Q_stricmp("limb", push_target[x]->classname) == 0)
				{
					//make sure it runs it's physics
					push_target[x]->e_ThinkFunc = thinkF_LimbThink;
					push_target[x]->nextthink = level.time + FRAMETIME;
				}
				push_target[x]->forcePushTime = level.time + 600; // let the push effect last for 600 ms
				push_target[x]->forcePuller = self->s.number; //remember this regardless
				if (push_target[x]->item && push_target[x]->item->giTag == INV_SECURITY_KEY)
				{
					AddSightEvent(player, push_target[x]->currentOrigin, 128, AEL_DISCOVERED);
					//security keys are more important
				}
				else
				{
					AddSightEvent(player, push_target[x]->currentOrigin, 128, AEL_SUSPICIOUS);
					//hmm... or should this always be discovered?
				}
			}
			else if (push_target[x]->s.weapon == WP_TURRET
				&& !Q_stricmp("PAS", push_target[x]->classname)
				&& push_target[x]->s.apos.trType == TR_STATIONARY)
			{
				//a portable turret
				WP_KnockdownTurret(push_target[x]);
			}
		}
	}

	WP_ForcePowerDrain(self, FP_REPULSE, cost);

	if (self->NPC)
	{
		//NPCs can push more often
		//FIXME: vary by rank and game skill?
		self->client->ps.forcePowerDebounce[FP_REPULSE] = level.time + 200;
	}
	else
	{
		self->client->ps.forcePowerDebounce[FP_REPULSE] = level.time + self->client->ps.torsoAnimTimer + 500;
	}
}

static void WP_DebounceForceDeactivateTime(const gentity_t* self)
{
	if (self && self->client)
	{
		if (self->client->ps.forcePowersActive & 1 << FP_SPEED
			|| self->client->ps.forcePowersActive & 1 << FP_PROTECT
			|| self->client->ps.forcePowersActive & 1 << FP_PROJECTION
			|| self->client->ps.forcePowersActive & 1 << FP_ABSORB
			|| self->client->ps.forcePowersActive & 1 << FP_RAGE
			|| self->client->ps.forcePowersActive & 1 << FP_SEE
			|| self->client->ps.forcePowersActive & 1 << FP_DEADLYSIGHT)
		{
			//already running another power that can be manually, stopped don't debounce so long
			self->client->ps.forceAllowDeactivateTime = level.time + 500;
		}
		else
		{
			//not running one of the interpretable powers
			self->client->ps.forceAllowDeactivateTime = level.time + 1500;
		}
	}
}

void ForceDeadlySight(gentity_t* self)
{
	if (self->health <= 0)
	{
		return;
	}

	if (self->client->ps.forcePowerDebounce[FP_DEADLYSIGHT] > level.time)
	{
		//already pushing- now you can't haul someone across the room, sorry
		return;
	}

	if (self->client->ps.forceAllowDeactivateTime < level.time &&
		self->client->ps.forcePowersActive & 1 << FP_DEADLYSIGHT)
	{
		WP_ForcePowerStop(self, FP_DEADLYSIGHT);
		return;
	}

	if (!WP_ForcePowerUsable(self, FP_DEADLYSIGHT, 0))
	{
		return;
	}

	WP_DebounceForceDeactivateTime(self);

	WP_ForcePowerStart(self, FP_DEADLYSIGHT, 0);

	if (self->client->ps.saberLockTime < level.time && !PM_InKnockDown(&self->client->ps))
	{
		if (self->client->ps.forcePowerLevel[FP_DEADLYSIGHT] < FORCE_LEVEL_3)
		{
			//animate
			int parts = SETANIM_BOTH;
			if (self->client->ps.forcePowerLevel[FP_DEADLYSIGHT] > FORCE_LEVEL_1)
			{
				//level 2 only does it on torso (can keep running)
				parts = SETANIM_TORSO;
			}
			else
			{
				if (self->client->ps.groundEntityNum != ENTITYNUM_NONE)
				{
					VectorClear(self->client->ps.velocity);
				}
				if (self->NPC)
				{
					VectorClear(self->client->ps.moveDir);
					self->client->ps.speed = 0;
				}
			}
			NPC_SetAnim(self, parts, BOTH_FORCE_DRAIN_HOLD, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
		}
		else
		{
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_FORCE_DRAIN_HOLD, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
			self->client->ps.weaponTime = self->client->ps.torsoAnimTimer;
		}
	}

	if (self->headBolt != -1)
	{
		G_PlayEffect(G_EffectIndex("force/drain_hand"), self->playerModel, self->headBolt, self->s.number,
			self->currentOrigin, 3000, qtrue);
	}

	CG_PlayEffectBolted("misc/breath.efx", self->playerModel, self->headBolt, self->s.number, self->currentOrigin);

	self->client->ps.forcePowerDebounce[FP_DEADLYSIGHT] = level.time + self->client->ps.torsoAnimTimer + 5000;
}

void ForceSpeed(gentity_t* self, const int duration)
{
	if (self->health <= 0)
	{
		return;
	}

	if (BG_InKnockDown(self->client->ps.legsAnim) || PM_InKnockDown(&self->client->ps))
	{
		return;
	}

	if (PM_InLedgeMove(self->client->ps.legsAnim))
	{
		return;
	}

	if (self->client->ps.forceAllowDeactivateTime < level.time &&
		self->client->ps.forcePowersActive & 1 << FP_SPEED)
	{
		//stop using it
		WP_ForcePowerStop(self, FP_SPEED);
		return;
	}
	if (!WP_ForcePowerUsable(self, FP_SPEED, 0))
	{
		return;
	}
	if (self->client->ps.saberLockTime > level.time)
	{
		//FIXME: can this be a way to break out?
		return;
	}

	if (g_SerenityJediEngineMode->integer)
	{
		if (self->client->ps.forcePowersActive & 1 << FP_SPEED)
		{
			//it's already turned on.  turn it off.
			WP_ForcePowerStop(self, FP_SPEED);
			return;
		}
	}

	WP_DebounceForceDeactivateTime(self);

	WP_ForcePowerStart(self, FP_SPEED, 0);
	if (duration)
	{
		self->client->ps.forcePowerDuration[FP_SPEED] = level.time + duration;
	}
	G_Sound(self, G_SoundIndex("sound/weapons/force/speed.wav"));
}

//Dash stuff

int IsPressingDashButton(const gentity_t* self)
{
	if (PM_RunningAnim(self->client->ps.legsAnim)
		&& !PM_SaberInAttack(self->client->ps.saber_move)
		&& !PM_KickMove(self->client->ps.saber_move)
		&& self->client->pers.cmd.upmove == 0
		&& !self->client->hookhasbeenfired
		&& (!(self->client->buttons & BUTTON_KICK))
		&& (!(self->client->buttons & BUTTON_USE))
		&& self->client->buttons & BUTTON_DASH)
	{
		return qtrue;
	}
	return qfalse;
}

int IsPressingDestructButton(const gentity_t* self)
{
	if (self->client->ps.forcePowerDebounce[FP_DESTRUCTION] > level.time || self->client->ps.forcePowersActive & 1 <<
		FP_DESTRUCTION || self->s.powerups & 1 << PW_FORCE_PROJECTILE)
	{
		return qtrue;
	}
	return qfalse;
}

static void ForceDashAnim(gentity_t* self)
{
	constexpr int set_anim_override = SETANIM_AFLAG_PACE;

	if (self->client->pers.cmd.rightmove > 0)
	{
		NPC_SetAnim(self, SETANIM_BOTH, BOTH_HOP_R, set_anim_override);
	}
	else if (self->client->pers.cmd.rightmove < 0)
	{
		NPC_SetAnim(self, SETANIM_BOTH, BOTH_HOP_L, set_anim_override);
	}
	else if (self->client->pers.cmd.forwardmove < 0)
	{
		NPC_SetAnim(self, SETANIM_BOTH, BOTH_HOP_B, set_anim_override);
	}
	else
	{
		NPC_SetAnim(self, SETANIM_BOTH, BOTH_HOP_F, set_anim_override);
	}
}

static void ForceDashAnimDash(gentity_t* self)
{
	constexpr int set_anim_override = SETANIM_AFLAG_PACE;

	if (self->client->pers.cmd.rightmove > 0)
	{
		NPC_SetAnim(self, SETANIM_BOTH, BOTH_DASH_R, set_anim_override);
	}
	else if (self->client->pers.cmd.rightmove < 0)
	{
		NPC_SetAnim(self, SETANIM_BOTH, BOTH_DASH_L, set_anim_override);
	}
	else if (self->client->pers.cmd.forwardmove < 0)
	{
		NPC_SetAnim(self, SETANIM_BOTH, BOTH_DASH_B, set_anim_override);
	}
	else
	{
		NPC_SetAnim(self, SETANIM_BOTH, BOTH_DASH_F, set_anim_override);
	}
}

extern qboolean PM_InSlopeAnim(int anim);

static void ForceSpeedDash(gentity_t* self)
{
	if (self->health <= 0)
	{
		return;
	}

	if (self->client->ps.groundEntityNum == ENTITYNUM_NONE)
	{
		//can't dash in mid-air
		return;
	}

	if (PM_InLedgeMove(self->client->ps.legsAnim))
	{
		return;
	}

	if (PM_SaberInAttack(self->client->ps.saber_move))
	{
		return;
	}

	if (PM_KickMove(self->client->ps.saber_move))
	{
		return;
	}

	if (PM_InSlopeAnim(self->client->ps.legsAnim))
	{
		return;
	}

	if (self->client->ps.forcePowerDebounce[FP_SPEED] > level.time)
	{
		//stops it while using it and also after using it, up to 3 second delay
		return;
	}

	if (self->client->ps.forceSpeedRecoveryTime >= level.time)
	{
		return;
	}

	if (BG_InKnockDown(self->client->ps.legsAnim) || PM_InKnockDown(&self->client->ps))
	{
		return;
	}

	if (self->client->NPC_class == CLASS_DROIDEKA ||
		self->client->NPC_class == CLASS_VEHICLE ||
		self->client->NPC_class == CLASS_SBD ||
		self->client->NPC_class == CLASS_OBJECT ||
		self->client->NPC_class == CLASS_ASSASSIN_DROID)
	{
		return;
	}

	if (self->client->ps.forceAllowDeactivateTime < level.time && self->client->ps.forcePowersActive & 1 << FP_SPEED)
	{
		WP_ForcePowerStop(self, FP_SPEED);
		return;
	}

	if (self->client->ps.forcePowersActive & 1 << FP_SPEED) //If using speed at same time just in case
	{
		if (PM_RunningAnim(self->client->ps.legsAnim))
		{
			ForceDashAnim(self);
			WP_ForcePowerStop(self, FP_SPEED);
		}
		else
		{
			return;
		}
	}

	if (self->client->ps.saberLockTime > level.time)
	{
		return;
	}

	if (!IsPressingDashButton(self))
	{
		//it's already turned on.  turn it off.
		return;
	}

	if (!(self->client->ps.communicatingflags & 1 << DASHING))
	{
		return;
	}

	if (self->client->ps.groundEntityNum != ENTITYNUM_NONE)
	{
		vec3_t dir;

		AngleVectors(self->client->ps.viewangles, dir, nullptr, nullptr);
		self->client->ps.velocity[0] = self->client->ps.velocity[0] * 4;
		self->client->ps.velocity[1] = self->client->ps.velocity[1] * 4;

		ForceDashAnimDash(self);
	}
	else if (self->client->ps.groundEntityNum == ENTITYNUM_NONE)
	{
		NPC_SetAnim(self, SETANIM_BOTH, BOTH_FORCEINAIR1, SETANIM_AFLAG_PACE);
	}

	G_Sound(self, G_SoundIndex("sound/weapons/force/dash.mp3"));
	CG_PlayEffectBolted("misc/breath.efx", self->playerModel, self->headBolt, self->s.number, self->currentOrigin);
}

void player_Burn(const gentity_t* self);

static void player_StopBurn(const gentity_t* self)
{
	if (self && self->client)
	{
		if (self->client->ps.PlayerEffectFlags & 1 << PEF_BURNING)
		{
			//Un burn
			self->client->ps.PlayerEffectFlags &= ~(1 << PEF_BURNING);
		}
		else
		{
			//Un burn
			self->client->ps.PlayerEffectFlags &= ~(1 << PEF_BURNING);
		}
	}
}

void Player_CheckBurn(const gentity_t* self)
{
	if (self && self->client)
	{
		if (self->health <= 0 || self->painDebounceTime < level.time)
		{
			player_StopBurn(self);
		}
		else if (PM_InRoll(&self->client->ps))
		{
			player_StopBurn(self);
		}
		else if (TIMER_Done(self, "BurnDebounce"))
		{
			player_StopBurn(self);
		}
		else if (self->client->ps.saberEventFlags & SEF_INWATER)
		{
			player_StopBurn(self);
		}
		/*else
		{
			player_StopBurn(self);
		}*/
	}
}

void player_Burn(const gentity_t* self)
{
	if ((self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self)) && self && self->client)
	{
		if (!(self->client->ps.PlayerEffectFlags & 1 << PEF_BURNING))
		{
			self->client->ps.PlayerEffectFlags |= 1 << PEF_BURNING;
		}
	}

	TIMER_Set(self, "BurnDebounce", 1000);
}

static void WP_StartForceHealEffects(const gentity_t* self)
{
	if (self->ghoul2.size())
	{
		if (self->chestBolt != -1)
		{
			G_PlayEffect(G_EffectIndex("force/heal2"), self->playerModel, self->chestBolt, self->s.number,
				self->currentOrigin, 3000, qtrue);
		}
	}
}

void WP_StopForceHealEffects(const gentity_t* self)
{
	if (self->ghoul2.size())
	{
		if (self->chestBolt != -1)
		{
			G_StopEffect(G_EffectIndex("force/heal2"), self->playerModel, self->chestBolt, self->s.number);
		}
	}
}

static int FP_MaxForceHeal(const gentity_t* self)
{
	if (self->s.number >= MAX_CLIENTS)
	{
		return MAX_FORCE_HEAL_MEDIUM;
	}
	switch (g_spskill->integer)
	{
	case 0: //easy
		return MAX_FORCE_HEAL_EASY;
	case 1: //medium
		return MAX_FORCE_HEAL_MEDIUM;
	case 2: //hard
	default:
		return MAX_FORCE_HEAL_HARD;
	}
}

static int FP_ForceHealInterval(const gentity_t* self)
{
	return self->client->ps.forcePowerLevel[FP_HEAL] > FORCE_LEVEL_2 ? 50 : FORCE_HEAL_INTERVAL;
}

void ForceHeal(gentity_t* self)
{
	if (self->health <= 0 || self->client->ps.stats[STAT_MAX_HEALTH] <= self->health)
	{
		return;
	}

	if (!WP_ForcePowerUsable(self, FP_HEAL, 20))
	{
		//must have enough force power for at least 5 points of health
		return;
	}

	if (PM_InLedgeMove(self->client->ps.legsAnim))
	{
		return;
	}

	if (self->painDebounceTime > level.time || self->client->ps.weaponTime && self->client->ps.weapon != WP_NONE)
	{
		//can't initiate a heal while taking pain or attacking
		return;
	}

	if (self->client->ps.saberLockTime > level.time)
	{
		//FIXME: can this be a way to break out?
		return;
	}

	WP_ForcePowerStart(self, FP_HEAL, 0);

	if (self->client->ps.forcePowerLevel[FP_HEAL] < FORCE_LEVEL_2)
	{
		//must meditate
		if (self->client->NPC_class == CLASS_VADER || self->client->NPC_class == CLASS_DESANN)
		{
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_FORCEHEAL_QUICK, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
			self->client->ps.saber_move = self->client->ps.saberBounceMove = LS_READY;
			//don't finish whatever saber anim you may have been in
			self->client->ps.saberBlocked = BLOCKED_NONE;
			WP_DeactivateSaber(self); //turn off saber when meditating
		}
		else
		{
			NPC_SetAnim(self, SETANIM_BOTH, BOTH_FORCEHEAL_START, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
			self->client->ps.saber_move = self->client->ps.saberBounceMove = LS_READY;
			//don't finish whatever saber anim you may have been in
			self->client->ps.saberBlocked = BLOCKED_NONE;
			self->client->ps.torsoAnimTimer = self->client->ps.legsAnimTimer = FP_ForceHealInterval(self) *
				FP_MaxForceHeal(self) + 2000; //???
			WP_DeactivateSaber(self); //turn off saber when meditating
		}
	}
	else
	{
		//just a quick gesture
		if (g_SerenityJediEngineMode->integer)
		{
			if (g_SerenityJediEngineMode->integer == 2) //block point mode
			{
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_FORCEHEAL_QUICK, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
			}
			else
			{
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_TOSS1, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
			}
		}
		else //Back up JKA Mode
		{
			//
		}
		self->client->ps.saber_move = self->client->ps.saberBounceMove = LS_READY;
		//don't finish whatever saber anim you may have been in
		self->client->ps.saberBlocked = BLOCKED_NONE;
	}

	//FIXME: always play healing effect
	G_SoundOnEnt(self, CHAN_ITEM, "sound/weapons/force/heal.mp3");
}

extern void NPC_PlayConfusionSound(gentity_t* self);
extern void npc_jedi_play_confusion_sound(const gentity_t* self);

static qboolean WP_CheckBreakControl(gentity_t* self)
{
	if (!self)
	{
		return qfalse;
	}
	if (!self->s.number)
	{
		//player
		if (self->client && self->client->ps.forcePowerLevel[FP_TELEPATHY] > FORCE_LEVEL_3)
		{
			//control-level
			if (self->client->ps.viewEntity > 0 && self->client->ps.viewEntity < ENTITYNUM_WORLD)
			{
				//we are in a viewentity
				const gentity_t* controlled = &g_entities[self->client->ps.viewEntity];
				if (controlled->NPC && controlled->NPC->controlledTime > level.time)
				{
					//it is an NPC we controlled
					//clear it and return
					G_ClearViewEntity(self);
					return qtrue;
				}
			}
		}
	}
	else
	{
		//NPC
		if (self->NPC && self->NPC->controlledTime > level.time)
		{
			//being controlled
			gentity_t* controller = &g_entities[0];
			if (controller->client && controller->client->ps.viewEntity == self->s.number)
			{
				//we are being controlled by player
				if (controller->client->ps.forcePowerLevel[FP_TELEPATHY] > FORCE_LEVEL_3)
				{
					//control-level mind trick
					//clear the control and return
					G_ClearViewEntity(controller);
					return qtrue;
				}
			}
		}
	}
	return qfalse;
}

extern bool Pilot_AnyVehiclesRegistered();

void ForceTelepathy(gentity_t* self)
{
	trace_t tr;
	vec3_t end, forward;
	qboolean target_live = qfalse;

	if (WP_CheckBreakControl(self))
	{
		return;
	}
	if (self->health <= 0)
	{
		return;
	}

	if (self->client->ps.weapon == WP_TURRET)
	{
		return;
	}

	if (PM_InLedgeMove(self->client->ps.legsAnim))
	{
		return;
	}
	//FIXME: if mind trick 3 and aiming at an enemy need more force power
	if (!WP_ForcePowerUsable(self, FP_TELEPATHY, 0))
	{
		return;
	}

	if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self) && self->client->ps.weapon == WP_SABER)
		//npc force use limit
	{
		if (self->client->ps.blockPoints < BLOCKPOINTS_HALF || self->client->ps.forcePower < BLOCKPOINTS_HALF)
		{
			return;
		}
	}

	if (self->client->ps.weaponTime >= 800)
	{
		//just did one!
		return;
	}
	if (self->client->ps.saberLockTime > level.time)
	{
		//FIXME: can this be a way to break out?
		return;
	}

	AngleVectors(self->client->ps.viewangles, forward, nullptr, nullptr);
	VectorNormalize(forward);
	VectorMA(self->client->renderInfo.eyePoint, 2048, forward, end);

	//Cause a distraction if enemy is not fighting
	gi.trace(&tr, self->client->renderInfo.eyePoint, vec3_origin, vec3_origin, end, self->s.number,
		MASK_OPAQUE | CONTENTS_BODY, static_cast<EG2_Collision>(0), 0);
	if (tr.entityNum == ENTITYNUM_NONE || tr.fraction == 1.0 || tr.allsolid || tr.startsolid)
	{
		return;
	}

	gentity_t* traceEnt = &g_entities[tr.entityNum];

	if (traceEnt->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(traceEnt))
	{
		if (!in_camera && traceEnt->NPC && traceEnt->NPC->scriptFlags & SCF_NO_FORCE)
		{
			return;
		}
	}

	if (traceEnt && traceEnt->client)
	{
		switch (traceEnt->client->NPC_class)
		{
		case CLASS_GALAKMECH: //cant grip him, he's in armor
			G_AddVoiceEvent(traceEnt, Q_irand(EV_PUSHED1, EV_PUSHED3), Q_irand(3000, 5000));
			return;
		case CLASS_ATST: //much too big to grip!
			//no droids either
		case CLASS_PROBE:
		case CLASS_GONK:
		case CLASS_R2D2:
		case CLASS_R5D2:
		case CLASS_MARK1:
		case CLASS_MARK2:
		case CLASS_MOUSE:
		case CLASS_SEEKER:
		case CLASS_REMOTE:
		case CLASS_PROTOCOL:
		case CLASS_ASSASSIN_DROID:
		case CLASS_SABER_DROID:
		case CLASS_BOBAFETT:
		case CLASS_MANDALORIAN:
		case CLASS_JANGO:
		case CLASS_JANGODUAL:
		case CLASS_DROIDEKA:
			break;
		case CLASS_RANCOR:
			if (!(traceEnt->spawnflags & 1))
			{
				target_live = qtrue;
			}
			break;
		default:
			target_live = qtrue;
			break;
		}
	}
	if (target_live
		&& traceEnt->NPC
		&& traceEnt->health > 0)
	{
		//hit an organic non-player
		if (G_ActivateBehavior(traceEnt, BSET_MINDTRICK))
		{
			//activated a script on him
			//FIXME: do the visual sparkles effect on their heads, still?
			WP_ForcePowerStart(self, FP_TELEPATHY, 0);
		}
		else if (traceEnt->client->playerTeam != self->client->playerTeam)
		{
			//an enemy
			int override = 0;
			if (traceEnt->NPC->scriptFlags & SCF_NO_MIND_TRICK)
			{
				if (traceEnt->client->NPC_class == CLASS_GALAKMECH)
				{
					G_AddVoiceEvent(traceEnt, Q_irand(EV_CONFUSE1, EV_CONFUSE3), Q_irand(3000, 5000));
				}
			}
			else if (self->client->ps.forcePowerLevel[FP_TELEPATHY] > FORCE_LEVEL_3)
			{
				//control them, even jedi
				G_SetViewEntity(self, traceEnt);
				traceEnt->NPC->controlledTime = level.time + 30000;
			}
			else if (traceEnt->s.weapon != WP_SABER
				&& traceEnt->client->NPC_class != CLASS_REBORN)
			{
				//haha!  Jedi aren't easily confused!
				if (self->client->ps.forcePowerLevel[FP_TELEPATHY] > FORCE_LEVEL_2
					&& traceEnt->s.weapon != WP_NONE
					//don't charm people who aren't capable of fighting... like ugnaughts and droids, just confuse them
					&& traceEnt->client->NPC_class != CLASS_TUSKEN //don't charm them, just confuse them
					&& traceEnt->client->NPC_class != CLASS_NOGHRI //don't charm them, just confuse them
					&& !Pilot_AnyVehiclesRegistered() //also, don't charm guys when bikes are near
					)
				{
					//turn them to our side
					//if mind trick 3 and aiming at an enemy need more force power
					override = 50;
					if (self->client->ps.forcePower < 50)
					{
						return;
					}
					if (traceEnt->enemy)
					{
						G_ClearEnemy(traceEnt);
					}
					if (traceEnt->NPC)
					{
						//traceEnt->NPC->tempBehavior = BS_FOLLOW_LEADER;
						traceEnt->client->leader = self;
					}
					//FIXME: maybe pick an enemy right here?
					const team_t save_team = traceEnt->client->enemyTeam;
					traceEnt->client->enemyTeam = traceEnt->client->playerTeam;
					traceEnt->client->playerTeam = save_team;
					//FIXME: need a *charmed* timer on this...?  Or do TEAM_PLAYERS assume that "confusion" means they should switch to team_enemy when done?
					traceEnt->NPC->charmedTime = level.time + mindTrickTime[self->client->ps.forcePowerLevel[FP_TELEPATHY]];

					if (traceEnt->ghoul2.size() && traceEnt->headBolt != -1)
					{
						//FIXME: what if already playing effect?
						G_PlayEffect(G_EffectIndex("force/confusion"), traceEnt->playerModel, traceEnt->headBolt,
							traceEnt->s.number, traceEnt->currentOrigin,
							mindTrickTime[self->client->ps.forcePowerLevel[FP_TELEPATHY]], qtrue);
					}
				}
				else
				{
					//just confuse them
					//somehow confuse them?  Set don't fire to true for a while?  Drop their aggression?  Maybe just take their enemy away and don't let them pick one up for a while unless shot?
					traceEnt->NPC->confusionTime = level.time + mindTrickTime[self->client->ps.forcePowerLevel[
						FP_TELEPATHY]]; //confused for about 10 seconds

					if (traceEnt->ghoul2.size() && traceEnt->headBolt != -1)
					{
						//FIXME: what if already playing effect?
						G_PlayEffect(G_EffectIndex("force/confusion"), traceEnt->playerModel, traceEnt->headBolt,
							traceEnt->s.number, traceEnt->currentOrigin,
							mindTrickTime[self->client->ps.forcePowerLevel[FP_TELEPATHY]], qtrue);
					}
					NPC_PlayConfusionSound(traceEnt);
					if (traceEnt->enemy)
					{
						G_ClearEnemy(traceEnt);
					}
				}
			}
			else
			{
				npc_jedi_play_confusion_sound(traceEnt);
			}
			WP_ForcePowerStart(self, FP_TELEPATHY, override);
		}
		else if (traceEnt->client->playerTeam == self->client->playerTeam)
		{
			//an ally
			//maybe just have him look at you?  Respond?  Take your enemy?
			if (traceEnt->client->ps.pm_type < PM_DEAD && traceEnt->NPC != nullptr && !(traceEnt->NPC->scriptFlags &
				SCF_NO_RESPONSE))
			{
				NPC_UseResponse(traceEnt, self, qfalse);
				WP_ForcePowerStart(self, FP_TELEPATHY, 1);
			}
		}
		vec3_t eyeDir;
		AngleVectors(traceEnt->client->renderInfo.eyeAngles, eyeDir, nullptr, nullptr);
		VectorNormalize(eyeDir);
		G_PlayEffect("force/force_touch", traceEnt->client->renderInfo.eyePoint, eyeDir);

		NPC_SetAnim(self, SETANIM_TORSO, BOTH_MINDTRICK1,
			SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_RESTART | SETANIM_FLAG_HOLD);
	}
	else
	{
		if (self->client->ps.forcePowerLevel[FP_TELEPATHY] > FORCE_LEVEL_1 && tr.fraction * 2048 > 64)
		{
			//don't create a diversion less than 64 from you of if at power level 1
			//use distraction anim instead
			G_PlayEffect(G_EffectIndex("force/force_touch"), tr.endpos, tr.plane.normal);
			AddSoundEvent(self, tr.endpos, 512, AEL_SUSPICIOUS, qtrue, qtrue);
			AddSightEvent(self, tr.endpos, 512, AEL_SUSPICIOUS, 50);
			WP_ForcePowerStart(self, FP_TELEPATHY, 0);
		}
		NPC_SetAnim(self, SETANIM_TORSO, BOTH_MINDTRICK2,
			SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_RESTART | SETANIM_FLAG_HOLD);
	}
	self->client->ps.saber_move = self->client->ps.saberBounceMove = LS_READY;
	//don't finish whatever saber anim you may have been in
	self->client->ps.saberBlocked = BLOCKED_NONE;
	self->client->ps.weaponTime = 1000;
	if (self->client->ps.forcePowersActive & 1 << FP_SPEED)
	{
		self->client->ps.weaponTime = floor(self->client->ps.weaponTime * g_timescale->value);
	}
}

void ForceAbsorb(gentity_t* self);

void ForceGrip(gentity_t* self)
{
	//FIXME: make enemy Jedi able to use this
	trace_t tr;
	vec3_t end, forward;
	gentity_t* traceEnt = nullptr;

	if (self->health <= 0)
	{
		return;
	}
	if (!self->s.number && (cg.zoomMode || in_camera))
	{
		//can't force grip when zoomed in or in cinematic
		return;
	}

	if (PM_InLedgeMove(self->client->ps.legsAnim))
	{
		return;
	}
	if (self->client->ps.leanofs)
	{
		//can't force-grip while leaning
		return;
	}

	if (self->client->ps.forceGripEntityNum <= ENTITYNUM_WORLD)
	{
		//already gripping
		if (self->client->ps.forcePowerLevel[FP_GRIP] > FORCE_LEVEL_1)
		{
			self->client->ps.forcePowerDuration[FP_GRIP] = level.time + 100;
			self->client->ps.weaponTime = 1000;
			if (self->client->ps.forcePowersActive & 1 << FP_SPEED)
			{
				self->client->ps.weaponTime = floor(self->client->ps.weaponTime * g_timescale->value);
			}
		}
		return;
	}

	if (!WP_ForcePowerUsable(self, FP_GRIP, 0))
	{
		//can't use it right now
		return;
	}

	if (self->client->ps.forcePower < 26)
	{
		//need 20 to start, 6 to hold it for any decent amount of time...
		return;
	}

	if (self->client->ps.weaponTime)
	{
		//busy
		return;
	}

	if (self->client->ps.saberLockTime > level.time)
	{
		//FIXME: can this be a way to break out?
		return;
	}

	//Cause choking anim + health drain in ent in front of me
	NPC_SetAnim(self, SETANIM_TORSO, BOTH_FORCEGRIP_HOLD, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);

	self->client->ps.saber_move = self->client->ps.saberBounceMove = LS_READY;
	//don't finish whatever saber anim you may have been in
	self->client->ps.saberBlocked = BLOCKED_NONE;

	self->client->ps.weaponTime = 2000;

	if (self->client->ps.forcePowersActive & 1 << FP_SPEED)
	{
		self->client->ps.weaponTime = floor(self->client->ps.weaponTime * g_timescale->value);
	}

	AngleVectors(self->client->ps.viewangles, forward, nullptr, nullptr);
	VectorNormalize(forward);
	VectorMA(self->client->renderInfo.handLPoint, FORCE_GRIP_DIST, forward, end);

	if (self->enemy)
	{
		//I have an enemy
		if (!self->enemy->message
			&& !(self->flags & FL_NO_KNOCKBACK))
		{
			//don't auto-pickup guys with keys
			if (DistanceSquared(self->enemy->currentOrigin, self->currentOrigin) < FORCE_GRIP_DIST_SQUARED)
			{
				//close enough to grab
				float min_dot = 0.5f;
				if (self->s.number < MAX_CLIENTS)
				{
					//player needs to be facing more directly
					min_dot = 0.2f;
				}
				if (InFront(self->enemy->currentOrigin, self->client->renderInfo.eyePoint, self->client->ps.viewangles,
					min_dot))
					//self->s.number || //NPCs can always lift enemy since we assume they're looking at them...?
				{
					//need to be facing the enemy
					if (gi.inPVS(self->enemy->currentOrigin, self->client->renderInfo.eyePoint))
					{
						//must be in PVS
						gi.trace(&tr, self->client->renderInfo.eyePoint, vec3_origin, vec3_origin,
							self->enemy->currentOrigin, self->s.number, MASK_SHOT, static_cast<EG2_Collision>(0),
							0);
						if (tr.fraction == 1.0f || tr.entityNum == self->enemy->s.number)
						{
							//must have clear LOS
							traceEnt = self->enemy;
						}
					}
				}
			}
		}
	}
	if (!traceEnt)
	{
		//okay, trace straight ahead and see what's there
		gi.trace(&tr, self->client->renderInfo.handLPoint, vec3_origin, vec3_origin, end, self->s.number, MASK_SHOT,
			static_cast<EG2_Collision>(0), 0);
		if (tr.entityNum >= ENTITYNUM_WORLD || tr.fraction == 1.0 || tr.allsolid || tr.startsolid)
		{
			return;
		}

		traceEnt = &g_entities[tr.entityNum];
	}
	//rww - RAGDOLL_BEGIN
#ifdef JK2_RAGDOLL_GRIPNOHEALTH
	if (!traceEnt || traceEnt == self/*???*/ || traceEnt->bmodel || traceEnt->NPC && traceEnt->NPC->scriptFlags &
		SCF_NO_FORCE)
	{
		return;
	}
#else
//rww - RAGDOLL_END
	if (!traceEnt || traceEnt == self/*???*/ || traceEnt->bmodel || (traceEnt->health <= 0 && traceEnt->takedamage) || (traceEnt->NPC && traceEnt->NPC->scriptFlags & SCF_NO_FORCE))
	{
		return;
	}
	//rww - RAGDOLL_BEGIN
#endif
	//rww - RAGDOLL_END

	if (traceEnt->m_pVehicle != nullptr)
	{
		//is it a vehicle
		//grab pilot if there is one
		if (traceEnt->m_pVehicle->m_pPilot != nullptr
			&& traceEnt->m_pVehicle->m_pPilot->client != nullptr)
		{
			//grip the pilot
			traceEnt = traceEnt->m_pVehicle->m_pPilot;
		}
		else
		{
			//can't grip a vehicle
			return;
		}
	}

	if (traceEnt->client)
	{
		if (traceEnt->client->ps.forceJumpZStart)
		{
			//can't catch them in mid force jump - FIXME: maybe base it on velocity?
			return;
		}
		if (traceEnt->client->ps.pullAttackTime > level.time)
		{
			//can't grip someone who is being pull-attacked or is pull-attacking
			return;
		}

		if (!Q_stricmp("Yoda", traceEnt->NPC_type)
			|| !Q_stricmp("T_Yoda", traceEnt->NPC_type)
			|| !Q_stricmp("md_Yoda", traceEnt->NPC_type)
			|| !Q_stricmp("md_yoda_ep2", traceEnt->NPC_type)
			|| !Q_stricmp("md_yoda_ot", traceEnt->NPC_type)
			|| !Q_stricmp("md_yoda_hr", traceEnt->NPC_type)
			|| !Q_stricmp("T_Palpatine_sith", traceEnt->NPC_type)
			|| !Q_stricmp("md_palpatine", traceEnt->NPC_type)
			|| !Q_stricmp("md_sidious_ep2", traceEnt->NPC_type)
			|| !Q_stricmp("md_sidious", traceEnt->NPC_type)
			|| !Q_stricmp("md_sidious_ep3_red", traceEnt->NPC_type)
			|| !Q_stricmp("md_pal_mof", traceEnt->NPC_type)
			|| char_is_force_user_attacker(traceEnt))
		{
			jedi_play_deflect_sound(traceEnt);
			if (g_SerenityJediEngineMode->integer)
			{
				if (traceEnt->client->NPC_class == CLASS_GALEN
					&& (traceEnt->s.weapon == WP_MELEE || traceEnt->s.weapon == WP_NONE || traceEnt->s.weapon ==
						WP_SABER && !traceEnt->client->ps.SaberActive())
					&& traceEnt->client->ps.groundEntityNum == ENTITYNUM_NONE)
				{
					ForceRepulse(traceEnt, qfalse);
				}
				else
				{
					ForceThrow_MD(traceEnt, qfalse);
				}
			}
			else
			{
				ForceThrow_JKA(traceEnt, qfalse);
			}
			return;
		}

		if (jedi_jedi_master_high(traceEnt))
		{
			jedi_play_deflect_sound(traceEnt);
			if (g_SerenityJediEngineMode->integer)
			{
				ForceThrow_MD(traceEnt, qfalse);
			}
			else
			{
				ForceThrow_JKA(traceEnt, qfalse);
			}

			if (traceEnt->NPC && !G_ControlledByPlayer(traceEnt)) //NPC only
			{
				if ((traceEnt->client->ps.forcePowersKnown & 1 << FP_ABSORB) != 0
					&& (traceEnt->client->ps.forcePowersActive & 1 << FP_ABSORB) == 0)
				{
					//know absorb and not already using it
					if (!Q_irand(0, 5))
					{
						ForceAbsorb(traceEnt);
					}
				}
				G_AddVoiceEvent(traceEnt, Q_irand(EV_TAUNT1, EV_TAUNT5), Q_irand(8000, 12000));
			}
			return;
		}

		if (G_IsRidingVehicle(traceEnt)
			&& traceEnt->s.eFlags & EF_NODRAW)
		{
			//riding *inside* vehicle
			return;
		}

		switch (traceEnt->client->NPC_class)
		{
		case CLASS_GALAKMECH: //cant grip him, he's in armor
			G_AddVoiceEvent(traceEnt, Q_irand(EV_PUSHED1, EV_PUSHED3), Q_irand(3000, 5000));
			return;
		case CLASS_HAZARD_TROOPER: //cant grip him, he's in armor
			return;
		case CLASS_ATST: //much too big to grip!
		case CLASS_RANCOR: //much too big to grip!
		case CLASS_WAMPA: //much too big to grip!
		case CLASS_SAND_CREATURE: //much too big to grip!
			return;
			//no droids either...?
		case CLASS_GONK:
		case CLASS_R2D2:
		case CLASS_R5D2:
		case CLASS_MARK1:
		case CLASS_MARK2:
		case CLASS_MOUSE: //?
		case CLASS_PROTOCOL:
			//*sigh*... in JK3, you'll be able to grab and move *anything*...
			return;
			//not even combat droids?  (No animation for being gripped...)
		case CLASS_SABER_DROID:
		case CLASS_ASSASSIN_DROID:
		case CLASS_DROIDEKA:
			//*sigh*... in JK3, you'll be able to grab and move *anything*...
			return;
		case CLASS_PROBE:
		case CLASS_SEEKER:
		case CLASS_REMOTE:
		case CLASS_SENTRY:
		case CLASS_INTERROGATOR:
			//*sigh*... in JK3, you'll be able to grab and move *anything*...
			return;
		case CLASS_SITHLORD:
		case CLASS_DESANN: //Desann cannot be gripped, he just pushes you back instantly
		case CLASS_VADER:
		case CLASS_KYLE:
		case CLASS_GALEN:
		case CLASS_TAVION:
		case CLASS_YODA:
		case CLASS_LUKE:
			jedi_play_deflect_sound(traceEnt);
			if (g_SerenityJediEngineMode->integer)
			{
				if (traceEnt->client->NPC_class == CLASS_GALEN
					&& (traceEnt->s.weapon == WP_MELEE || traceEnt->s.weapon == WP_NONE || traceEnt->s.weapon ==
						WP_SABER && !traceEnt->client->ps.SaberActive())
					&& traceEnt->client->ps.groundEntityNum == ENTITYNUM_NONE)
				{
					ForceRepulse(traceEnt, qfalse);
				}
				else
				{
					ForceThrow_MD(traceEnt, qfalse);
				}
			}
			else
			{
				ForceThrow_JKA(traceEnt, qfalse);
			}
			return;
		case CLASS_REBORN:
		case CLASS_BOC:
		case CLASS_SHADOWTROOPER:
		case CLASS_ALORA:
		case CLASS_JEDI:
		case CLASS_AHSOKA:
		case CLASS_PROJECTION:
		case CLASS_GROGU:
			if (traceEnt->NPC && traceEnt->NPC->rank > RANK_CIVILIAN && self->client->ps.forcePowerLevel[FP_GRIP] <
				FORCE_LEVEL_2)
			{
				jedi_play_deflect_sound(traceEnt);
				if (g_SerenityJediEngineMode->integer)
				{
					if (traceEnt->client->NPC_class == CLASS_GALEN
						&& (traceEnt->s.weapon == WP_MELEE || traceEnt->s.weapon == WP_NONE || traceEnt->s.weapon ==
							WP_SABER && !traceEnt->client->ps.SaberActive())
						&& traceEnt->client->ps.groundEntityNum == ENTITYNUM_NONE)
					{
						ForceRepulse(traceEnt, qfalse);
					}
					else
					{
						ForceThrow_MD(traceEnt, qfalse);
					}
				}
				else
				{
					ForceThrow_JKA(traceEnt, qfalse);
				}
				return;
			}
			break;
		default:
			break;
		}
		if (traceEnt->s.weapon == WP_EMPLACED_GUN)
		{
			//FIXME: maybe can pull them out?
			return;
		}
		if (self->enemy && traceEnt != self->enemy && traceEnt->client->playerTeam == self->client->playerTeam)
		{
			//can't accidentally grip your teammate in combat
			return;
		}
		//=CHECKABSORB===
		if (-1 != WP_AbsorbConversion(traceEnt, traceEnt->client->ps.forcePowerLevel[FP_ABSORB], FP_GRIP,
			self->client->ps.forcePowerLevel[FP_GRIP],
			forcePowerNeeded[self->client->ps.forcePowerLevel[FP_GRIP]]))
		{
			//WP_ForcePowerStop( self, FP_GRIP );
			return;
		}
		//===============
	}
	else
	{
		//can't grip non-clients... right?
		//FIXME: Make it so objects flagged as "grabbable" are let through
		//if ( Q_stricmp( "misc_model_breakable", traceEnt->classname ) || !(traceEnt->s.eFlags&EF_BOUNCE_HALF) || !traceEnt->physicsBounce )
		{
			return;
		}
	}

	// Make sure to turn off Force Protection and Force Absorb.
	if (self->client->ps.forcePowersActive & 1 << FP_PROTECT)
	{
		WP_ForcePowerStop(self, FP_PROTECT);
	}
	if (self->client->ps.forcePowersActive & 1 << FP_PROJECTION)
	{
		WP_ForcePowerStop(self, FP_PROJECTION);
	}
	if (self->client->ps.forcePowersActive & 1 << FP_ABSORB)
	{
		WP_ForcePowerStop(self, FP_ABSORB);
	}

	WP_ForcePowerStart(self, FP_GRIP, 20);

	self->client->ps.forceGripEntityNum = traceEnt->s.number;
	if (traceEnt->client)
	{
		Vehicle_t* p_veh;
		if ((p_veh = G_IsRidingVehicle(traceEnt)) != nullptr)
		{
			//riding vehicle? pull him off!
			p_veh->m_pVehicleInfo->Eject(p_veh, traceEnt, qtrue);
		}
		G_AddVoiceEvent(traceEnt, Q_irand(EV_PUSHED1, EV_PUSHED3), 2000);

		if (self->client->ps.forcePowerLevel[FP_GRIP] > FORCE_LEVEL_2 || traceEnt->s.weapon == WP_SABER && !
			jedi_jedi_master_high(traceEnt))
		{
			//if we pick up & carry, drop their weap
			if (traceEnt->s.weapon
				&& traceEnt->client->NPC_class != CLASS_ROCKETTROOPER
				&& traceEnt->client->NPC_class != CLASS_VEHICLE
				&& traceEnt->client->NPC_class != CLASS_HAZARD_TROOPER
				&& traceEnt->client->NPC_class != CLASS_TUSKEN
				&& traceEnt->client->NPC_class != CLASS_BOBAFETT
				&& traceEnt->client->NPC_class != CLASS_MANDALORIAN
				&& traceEnt->client->NPC_class != CLASS_JANGO
				&& traceEnt->client->NPC_class != CLASS_JANGODUAL
				&& traceEnt->client->NPC_class != CLASS_ASSASSIN_DROID
				&& traceEnt->client->NPC_class != CLASS_DROIDEKA
				&& traceEnt->client->NPC_class != CLASS_SBD
				&& traceEnt->s.weapon != WP_CONCUSSION) // so rax can't drop his
			{
				if (traceEnt->client->NPC_class == CLASS_BOBAFETT || traceEnt->client->NPC_class == CLASS_MANDALORIAN
					||
					traceEnt->client->NPC_class == CLASS_JANGO || traceEnt->client->NPC_class == CLASS_JANGODUAL)
				{
					//he doesn't drop them, just puts it away
					ChangeWeapon(traceEnt, WP_MELEE);
				}
				else if (traceEnt->s.weapon == WP_MELEE)
				{
					//they can't take that away from me, oh no...
				}
				else if (traceEnt->s.weapon == WP_SABER && (traceEnt->client->ps.ManualBlockingFlags & 1 <<
					HOLDINGBLOCK || traceEnt->client->ps.ManualBlockingFlags & 1 << MBF_NPCBLOCKING))
				{
					//they can't take that away from me, oh no...
				}
				else if (traceEnt->NPC && traceEnt->NPC->scriptFlags & SCF_DONT_FLEE)
				{
					//*SIGH*... if an NPC can't flee, they can't run after and pick up their weapon, do don't drop it
				}
				else if (traceEnt->s.weapon != WP_SABER)
				{
					WP_DropWeapon(traceEnt, nullptr);
				}
				else
				{
					traceEnt->client->ps.SaberDeactivate();
					G_SoundOnEnt(traceEnt, CHAN_WEAPON, "sound/weapons/saber/saberoffquick.wav");
				}
			}
		}
		//else FIXME: need a one-armed choke if we're not on a high enough level to make them drop their gun
		VectorCopy(traceEnt->client->renderInfo.headPoint, self->client->ps.forceGripOrg);
	}
	else
	{
		VectorCopy(traceEnt->currentOrigin, self->client->ps.forceGripOrg);
	}
	self->client->ps.forceGripOrg[2] += 48;

	if (self->client->ps.forcePowerLevel[FP_GRIP] < FORCE_LEVEL_2)
	{
		//just a duration
		self->client->ps.forcePowerDebounce[FP_GRIP] = level.time + 250;
		self->client->ps.forcePowerDuration[FP_GRIP] = level.time + 5000;

		if (self->m_pVehicle && self->m_pVehicle->m_pVehicleInfo->Inhabited(self->m_pVehicle))
		{
			//empty vehicles don't make gripped noise
			if (traceEnt
				&& traceEnt->client
				&& traceEnt->client->NPC_class == CLASS_OBJECT)
			{
				//
			}
			else
			{
				traceEnt->s.loopSound = G_SoundIndex("sound/weapons/force/grip.wav");
			}
		}
	}
	else
	{
		if (self->client->ps.forcePowerLevel[FP_GRIP] == FORCE_LEVEL_2)
		{
			//lifting sound?  or always?
		}
		//if ( traceEnt->s.number )
		{
			//picks them up for a second first
			self->client->ps.forcePowerDebounce[FP_GRIP] = level.time + 1000;
		}

		if (traceEnt
			&& traceEnt->client
			&& traceEnt->client->NPC_class == CLASS_OBJECT)
		{
			//
		}
		else
		{
			G_SoundOnEnt(self, CHAN_BODY, "sound/weapons/force/grip.wav");
		}
	}
}

static qboolean ForceLightningCheck2Handed(const gentity_t* self)
{
	if (self && self->client)
	{
		if (self->s.weapon == WP_NONE
			|| self->s.weapon == WP_MELEE
			|| self->s.weapon == WP_SABER && !self->client->ps.SaberActive())
		{
			return qtrue;
		}
	}
	return qfalse;
}

static void ForceLightningAnim(gentity_t* self)
{
	if (!self || !self->client)
	{
		return;
	}

	//one-handed lightning 2 and above
	int start_anim = BOTH_FORCELIGHTNING_START;
	int hold_anim = BOTH_FORCELIGHTNING_HOLD;
	constexpr int bobahold_anim = BOTH_FLAMETHROWER;

	if (self->client->ps.forcePowerLevel[FP_LIGHTNING] >= FORCE_LEVEL_3
		&& ForceLightningCheck2Handed(self))
	{
		//empty handed lightning 3
		start_anim = BOTH_FORCE_2HANDEDLIGHTNING_START;
		hold_anim = BOTH_FORCE_2HANDEDLIGHTNING_HOLD;
	}

	//FIXME: if standing still, play on whole body?  Especially 2-handed version
	if (self->client->ps.torsoAnim == start_anim)
	{
		if (!self->client->ps.torsoAnimTimer)
		{
			if (self->client->NPC_class == CLASS_BOBAFETT || self->client->NPC_class == CLASS_MANDALORIAN || self->
				client->NPC_class == CLASS_JANGO || self->client->NPC_class == CLASS_JANGODUAL)
			{
				NPC_SetAnim(self, SETANIM_TORSO, bobahold_anim,
					SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD | SETANIM_FLAG_RESTART);
			}
			else
			{
				NPC_SetAnim(self, SETANIM_TORSO, hold_anim,
					SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD | SETANIM_FLAG_RESTART);
			}
		}
		else
		{
			NPC_SetAnim(self, SETANIM_TORSO, start_anim,
				SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD | SETANIM_FLAG_RESTART);
		}
	}
	else
	{
		if (self->client->NPC_class == CLASS_BOBAFETT || self->client->NPC_class == CLASS_MANDALORIAN || self->client->
			NPC_class == CLASS_JANGO || self->client->NPC_class == CLASS_JANGODUAL)
		{
			NPC_SetAnim(self, SETANIM_TORSO, bobahold_anim, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
		}
		else
		{
			NPC_SetAnim(self, SETANIM_TORSO, hold_anim, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
		}
	}
}

constexpr auto PROJECTION_TOGGLE_TIME = 8000;

void ForceProjection(gentity_t* self)
{
	if (self->health <= 1 || in_camera)
	{
		return;
	}

	if (self->client->projectToggleTime >= level.time)
	{
		return;
	}

	if (self->client->ps.forceAllowDeactivateTime < level.time && self->client->ps.forcePowersActive & 1 <<
		FP_PROJECTION)
	{
		WP_ForcePowerStop(self, FP_PROJECTION);
		return;
	}

	if (!WP_ForcePowerUsable(self, FP_PROJECTION, 0))
	{
		return;
	}

	if (self->client->ps.groundEntityNum == ENTITYNUM_NONE)
	{
		return;
	}

	if (self->client->ps.forcePowersActive & 1 << FP_RAGE)
	{
		WP_ForcePowerStop(self, FP_RAGE);
	}

	WP_DebounceForceDeactivateTime(self);

	WP_ForcePowerStart(self, FP_PROJECTION, 0);

	if (self->client->ps.saberLockTime < level.time && !PM_InKnockDown(&self->client->ps))
	{
		if (self->client->ps.forcePowerLevel[FP_PROJECTION] < FORCE_LEVEL_3)
		{
			//animate
			int parts = SETANIM_BOTH;
			if (self->client->ps.forcePowerLevel[FP_PROJECTION] > FORCE_LEVEL_1)
			{
				//level 2 only does it on torso (can keep running)
				parts = SETANIM_TORSO;
			}
			else
			{
				if (self->client->ps.groundEntityNum != ENTITYNUM_NONE)
				{
					VectorClear(self->client->ps.velocity);
				}
				if (self->NPC)
				{
					VectorClear(self->client->ps.moveDir);
					self->client->ps.speed = 0;
				}
			}
			NPC_SetAnim(self, parts, BOTH_FORCE_ABSORB, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);

			//don't move or attack during this anim
			if (self->client->ps.forcePowerLevel[FP_PROJECTION] < FORCE_LEVEL_2)
			{
				self->client->ps.pm_flags |= PMF_TIME_KNOCKBACK;
				self->client->ps.pm_time = self->client->ps.weaponTime = self->client->ps.torsoAnimTimer;

				if (self->s.number)
				{
					//NPC
					self->painDebounceTime = level.time + self->client->ps.torsoAnimTimer;
				}
				else
				{
					//player
					self->aimDebounceTime = level.time + self->client->ps.torsoAnimTimer;
				}
			}
			else
			{
				self->client->ps.weaponTime = self->client->ps.torsoAnimTimer;
			}
		}
		else
		{
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_FORCE_ABSORB, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
			self->client->ps.weaponTime = self->client->ps.torsoAnimTimer;
		}
	}
}

qboolean CanBeFeared(const gentity_t* self, const gentity_t* traceEnt);

void ForceFear(gentity_t* self)
{
	trace_t tr;
	vec3_t end, forward;
	qboolean target_live = qfalse;

	if (WP_CheckBreakControl(self))
	{
		return;
	}
	if (self->health <= 0)
	{
		return;
	}
	//FIXME: if mind trick 3 and aiming at an enemy need more force power
	if (!WP_ForcePowerUsable(self, FP_FEAR, 0))
	{
		return;
	}

	if (self->client->ps.forcePower < 25 || !WP_ForcePowerUsable(self, FP_FEAR, 0))
	{
		return;
	}

	if (PM_InLedgeMove(self->client->ps.legsAnim))
	{
		return;
	}

	if (self->client->ps.weaponTime >= 800)
	{
		//just did one!
		return;
	}
	if (self->client->ps.saberLockTime > level.time)
	{
		//FIXME: can this be a way to break out?
		return;
	}

	AngleVectors(self->client->ps.viewangles, forward, nullptr, nullptr);
	VectorNormalize(forward);
	VectorMA(self->client->renderInfo.eyePoint, 2048, forward, end);

	//Cause a distraction if enemy is not fighting
	gi.trace(&tr, self->client->renderInfo.eyePoint, vec3_origin, vec3_origin, end, self->s.number,
		MASK_OPAQUE | CONTENTS_BODY, static_cast<EG2_Collision>(0), 0);
	if (tr.entityNum == ENTITYNUM_NONE || tr.fraction == 1.0 || tr.allsolid || tr.startsolid)
	{
		return;
	}

	gentity_t* traceEnt = &g_entities[tr.entityNum];

	if (traceEnt->NPC && traceEnt->NPC->scriptFlags & SCF_NO_FORCE)
	{
		return;
	}

	if (traceEnt && traceEnt->client)
	{
		switch (traceEnt->client->NPC_class)
		{
		case CLASS_GALAKMECH: //cant grip him, he's in armor
		case CLASS_ATST: //much too big to grip!
			//no droids either
		case CLASS_PROBE:
		case CLASS_GONK:
		case CLASS_R2D2:
		case CLASS_R5D2:
		case CLASS_MARK1:
		case CLASS_MARK2:
		case CLASS_MOUSE:
		case CLASS_SEEKER:
		case CLASS_REMOTE:
		case CLASS_PROTOCOL:
		case CLASS_ASSASSIN_DROID:
		case CLASS_OBJECT:
		case CLASS_SABER_DROID:
		case CLASS_BOBAFETT:
		case CLASS_MANDALORIAN:
		case CLASS_JANGO:
		case CLASS_DROIDEKA:
			break;
		case CLASS_RANCOR:
			if (!(traceEnt->spawnflags & 1))
			{
				target_live = qtrue;
			}
			break;
		default:
			target_live = qtrue;
			break;
		}
	}
	if (target_live
		&& traceEnt->NPC
		&& traceEnt->health > 0)
	{
		//hit an organic non-player
		if (traceEnt->client->playerTeam != self->client->playerTeam || traceEnt->client->playerTeam == self->client->
			playerTeam)
		{
			//an enemy
			int override = 0;
			if (traceEnt->NPC->scriptFlags & SCF_NO_MIND_TRICK)
			{
				if (traceEnt->client->NPC_class == CLASS_GALAKMECH)
				{
					G_AddVoiceEvent(traceEnt, Q_irand(EV_CONFUSE1, EV_CONFUSE3), Q_irand(3000, 5000));
				}
			}
			else if (CanBeFeared(self, traceEnt))
			{
				// Jedi can be feared, but it's quite rare
				if (!Pilot_AnyVehiclesRegistered()) //don't charm guys when bikes are near
				{
					//turn them crazy
					override = 50;
					if (self->client->ps.forcePower < 50)
					{
						return;
					}
					if (traceEnt->enemy)
					{
						G_ClearEnemy(traceEnt);
					}
					if (traceEnt->NPC)
					{
						if (traceEnt->s.weapon == WP_NONE)
						{
							CG_ChangeWeapon(WP_MELEE);
						}
					}

					if (PM_HasAnimation(traceEnt, BOTH_SONICPAIN_HOLD))
					{
						NPC_SetAnim(traceEnt, SETANIM_LEGS, BOTH_SONICPAIN_HOLD, SETANIM_FLAG_NORMAL);
						NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_SONICPAIN_HOLD,
							SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
						traceEnt->client->ps.torsoAnimTimer += 200;
						traceEnt->client->ps.weaponTime = traceEnt->client->ps.torsoAnimTimer;
					}

					if (self->client->ps.forcePowerLevel[FP_FEAR] > FORCE_LEVEL_1)
					{
						traceEnt->client->enemyTeam = TEAM_SOLO;
						traceEnt->client->playerTeam = TEAM_SOLO;
					}
					else
					{
						traceEnt->client->enemyTeam = TEAM_FREE;
						traceEnt->client->playerTeam = TEAM_FREE;
					}

					G_Sound(self, G_SoundIndex("sound/weapons/force/fear.mp3"));
					G_ClearEnemy(traceEnt);

					if (traceEnt->s.weapon == WP_SABER)
					{
						G_AddVoiceEvent(traceEnt, EV_FALL_MEDIUM, 1);
					}
					else
					{
						G_AddVoiceEvent(traceEnt, Q_irand(EV_GIVEUP1, EV_GIVEUP4), 2000);
					}

					traceEnt->NPC->charmedTime = level.time + mindTrickTime[self->client->ps.forcePowerLevel[FP_FEAR]];

					if (traceEnt->ghoul2.size() && traceEnt->headBolt != -1)
					{
						//FIXME: what if already playing effect?
						G_PlayEffect(G_EffectIndex("force/fear"), traceEnt->playerModel, traceEnt->headBolt,
							traceEnt->s.number, traceEnt->currentOrigin,
							mindTrickTime[self->client->ps.forcePowerLevel[FP_FEAR]], qtrue);
					}
				}
			}
			else
			{
				npc_jedi_play_confusion_sound(traceEnt);
			}
			WP_ForcePowerStart(self, FP_FEAR, override);
		}
		vec3_t eye_dir;
		AngleVectors(traceEnt->client->renderInfo.eyeAngles, eye_dir, nullptr, nullptr);
		VectorNormalize(eye_dir);
		G_PlayEffect("force/fear", traceEnt->client->renderInfo.eyePoint, eye_dir);
	}
	NPC_SetAnim(self, SETANIM_TORSO, BOTH_MINDTRICK1, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_RESTART | SETANIM_FLAG_HOLD);

	if (!target_live
		&& !traceEnt->NPC)
	{
		G_Sound(self, G_SoundIndex("sound/weapons/force/fearfail.mp3"));
	}
	self->client->ps.saber_move = self->client->ps.saberBounceMove = LS_READY;
	//don't finish whatever saber anim you may have been in
	self->client->ps.saberBlocked = BLOCKED_NONE;
	self->client->ps.weaponTime = 1000;
	if (self->client->ps.forcePowersActive & 1 << FP_SPEED)
	{
		self->client->ps.weaponTime = floor(self->client->ps.weaponTime * g_timescale->value);
	}
}

qboolean CanBeFeared(const gentity_t* self, const gentity_t* traceEnt)
{
	int common_fs_chance = 0;
	int powerful_fs_chance = 0;

	// Very weak force fear should pose almost zero threat against any jedi and sith
	if (self->client->ps.forcePowerLevel[FP_FEAR] < FORCE_LEVEL_2)
	{
		common_fs_chance = 1000;
		powerful_fs_chance = 1000;
	}
	// An intermediate Force Fear might pose some threat against lesser Jedi and Sith, but powerful ones should have next to no chance to be affected (but still a chance)
	else if (self->client->ps.forcePowerLevel[FP_FEAR] == FORCE_LEVEL_2)
	{
		common_fs_chance = 20;
		powerful_fs_chance = 100;
	}
	// A master of Force Fear should be able to scare a common Jedi or Sith with minimal effort, and still heavily struggle against the powerful ones.
	else if (self->client->ps.forcePowerLevel[FP_FEAR] > FORCE_LEVEL_2)
	{
		common_fs_chance = 1;
		powerful_fs_chance = 20;
	}

	if (Q_irand(0, common_fs_chance) && (traceEnt->client->NPC_class == CLASS_JEDI
		|| traceEnt->client->NPC_class == CLASS_REBORN
		|| traceEnt->client->NPC_class == CLASS_SHADOWTROOPER))
	{
		return qfalse;
	}
	// Boss NPCs should put up significant resistance, you'd have to be very extremely lucky to affect one
	if (Q_irand(0, powerful_fs_chance) &&
		(traceEnt->client->NPC_class == CLASS_KYLE
			|| traceEnt->client->NPC_class == CLASS_LUKE
			|| traceEnt->client->NPC_class == CLASS_JEDIMASTER
			|| traceEnt->client->NPC_class == CLASS_TAVION
			|| traceEnt->client->NPC_class == CLASS_VADER
			|| traceEnt->client->NPC_class == CLASS_SITHLORD
			|| traceEnt->client->NPC_class == CLASS_GROGU
			|| traceEnt->client->NPC_class == CLASS_DESANN))
	{
		return qfalse;
	}

	if (self->client->ps.forcePowerLevel[FP_FEAR] == FORCE_LEVEL_1 && !Q_irand(0, 1))
	{
		return qfalse;
	}

	// All other NPCs should just be affected
	return qtrue;
}

static qboolean ThisGuyIsAGunner(const gentity_t* self)
{
	switch (self->s.weapon)
	{
	case WP_BLASTER_PISTOL:
	case WP_BLASTER:
	case WP_DISRUPTOR:
	case WP_BOWCASTER:
	case WP_REPEATER:
	case WP_DEMP2:
	case WP_FLECHETTE:
	case WP_ROCKET_LAUNCHER:
	case WP_THERMAL:
	case WP_TRIP_MINE:
	case WP_DET_PACK:
	case WP_CONCUSSION:
	case WP_STUN_BATON:
	case WP_BRYAR_PISTOL:
	case WP_JAWA:
	case WP_TUSKEN_RIFLE:
	case WP_TUSKEN_STAFF:
	case WP_NOGHRI_STICK:
	case WP_BATTLEDROID:
	case WP_THEFIRSTORDER:
	case WP_CLONECARBINE:
	case WP_REBELBLASTER:
	case WP_CLONERIFLE:
	case WP_CLONECOMMANDO:
	case WP_Z6_ROTARY_CANNON:
	case WP_REBELRIFLE:
	case WP_REY:
	case WP_JANGO:
	case WP_BOBA:
	case WP_CLONEPISTOL:
	case WP_SBD_BLASTER:
	case WP_DUAL_PISTOL:
	case WP_DUAL_CLONEPISTOL:
		return qtrue;
	default:;
	}
	return qfalse;
}

constexpr auto STRIKE_DAMAGELOW = 10;
constexpr auto STRIKE_DAMAGEMEDIUM = 15;
constexpr auto STRIKE_DAMAGEHIGH = 20;
extern bool WP_MissileTargetHint(gentity_t* shooter, vec3_t start, vec3_t out);
extern qboolean LogAccuracyHit(const gentity_t* target, const gentity_t* attacker);
extern void G_Slapdown(gentity_t* self, gentity_t* attacker, const vec3_t push_dir, float strength, qboolean breakSaberLock);
extern int G_GetHitLocFromTrace(trace_t* trace, int mod);

static void force_shootstrike(gentity_t* self)
{
	trace_t tr;
	vec3_t end, forward, right, up, dir;
	gentity_t* traceEnt;
	constexpr int damagelow = STRIKE_DAMAGELOW;
	constexpr int damage_medium = STRIKE_DAMAGEMEDIUM;
	constexpr int damage_high = STRIKE_DAMAGEHIGH;
	qboolean render_impact = qtrue;
	vec3_t center, mins, maxs, ent_org, size, v;
	const float chance_of_fizz = Q_flrand(0.0f, 1.0f);
	constexpr int npc_saber_num = 0;
	constexpr int npc_blade_num = 0;
	float dot, dist;
	gentity_t* entity_list[MAX_GENTITIES];
	int e, num_listed_entities, i;

	if (self->health <= 0)
	{
		return;
	}
	if (!self->s.number && cg.zoomMode)
	{
		//can't force lightning when zoomed in
		return;
	}

	if (PM_InLedgeMove(self->client->ps.legsAnim))
	{
		return;
	}

	AngleVectors(self->client->ps.viewangles, forward, nullptr, nullptr);
	VectorNormalize(forward);

	// always render a shot beam, doing this the old way because I don't much feel like overriding the effect.

	G_PlayEffect("env/yellow_electricity", self->client->renderInfo.handLPoint, forward);

	if (self->client->ps.forcePowerLevel[FP_LIGHTNING_STRIKE] == FORCE_LEVEL_3)
	{
		constexpr float radius_high = 512;
		//arc
		VectorCopy(self->currentOrigin, center);

		for (i = 0; i < 3; i++)
		{
			mins[i] = center[i] - radius_high;
			maxs[i] = center[i] + radius_high;
		}
		num_listed_entities = gi.EntitiesInBox(mins, maxs, entity_list, MAX_GENTITIES);

		for (e = 0; e < num_listed_entities; e++)
		{
			traceEnt = entity_list[e];

			if (!traceEnt)
				continue;
			if (traceEnt == self)
				continue;
			if (traceEnt->owner == self && traceEnt->s.weapon != WP_THERMAL) //can push your own thermals
				continue;
			if (!traceEnt->inuse)
				continue;
			if (!traceEnt->takedamage)
				continue;
			for (i = 0; i < 3; i++)
			{
				if (center[i] < traceEnt->absmin[i])
				{
					v[i] = traceEnt->absmin[i] - center[i];
				}
				else if (center[i] > traceEnt->absmax[i])
				{
					v[i] = center[i] - traceEnt->absmax[i];
				}
				else
				{
					v[i] = 0;
				}
			}

			VectorSubtract(traceEnt->absmax, traceEnt->absmin, size);
			VectorMA(traceEnt->absmin, 0.5, size, ent_org);

			//see if they're in front of me
			//must be within the forward cone
			VectorSubtract(ent_org, center, dir);
			VectorNormalize(dir);
			if ((dot = DotProduct(dir, forward)) < 0.5)
				continue;

			//must be close enough
			dist = VectorLength(v);
			if (dist >= radius_high)
			{
				continue;
			}

			//in PVS?
			if (!traceEnt->bmodel && !gi.inPVS(ent_org, self->client->renderInfo.handLPoint))
			{
				//must be in PVS
				continue;
			}

			//Now check and see if we can actually hit it
			gi.trace(&tr, self->client->renderInfo.handLPoint, vec3_origin, vec3_origin, ent_org, self->s.number,
				MASK_SHOT, static_cast<EG2_Collision>(0), 0);

			if (tr.surfaceFlags & SURF_NOIMPACT)
			{
				render_impact = qfalse;
			}

			if (tr.fraction < 1.0f && tr.entityNum != traceEnt->s.number)
			{
				//must have clear LOS
				continue;
			}

			if (render_impact)
			{
				if (tr.entityNum < ENTITYNUM_WORLD && traceEnt->takedamage)
				{
					// Create a simple impact type mark that doesn't last long in the world
					G_PlayEffect(G_EffectIndex("tusken/hit"), tr.endpos, tr.plane.normal);

					if (traceEnt->client && LogAccuracyHit(traceEnt, self))
					{
						self->client->ps.persistant[PERS_ACCURACY_HITS]++;
					}

					if (traceEnt->client && traceEnt->client->ps.powerups[PW_CLOAKED])
					{
						//disable cloak temporarily
						player_decloak(traceEnt);
						G_AddVoiceEvent(traceEnt, Q_irand(EV_ANGER1, EV_ANGER3), 10000);
					}

					if (traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_GALAKMECH)
					{
						//hehe
						if (traceEnt->client->ps.stats[STAT_ARMOR] > 1)
						{
							traceEnt->client->ps.stats[STAT_ARMOR] = 0;
						}
						traceEnt->client->ps.powerups[PW_STUNNED] = level.time + 4000;
						G_Damage(traceEnt, self, self, dir, tr.endpos, damage_high, DAMAGE_DEATH_KNOCKBACK, MOD_LIGHTNING_STRIKE);
					}
					else if (traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_OBJECT)
					{
						traceEnt->client->ps.powerups[PW_STUNNED] = level.time + 4000;
					}
					else
					{
						if (traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_ATST ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_GONK ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_INTERROGATOR ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_MARK1 ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_MARK2 ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_MOUSE ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_PROBE ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_PROTOCOL ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_R2D2 ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_R5D2 ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_SEEKER ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_SENTRY ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_SBD ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_BATTLEDROID ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_DROIDEKA ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_OBJECT ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_ASSASSIN_DROID ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_SABER_DROID)
						{
							// special droid only behaviors
							traceEnt->client->ps.powerups[PW_STUNNED] = level.time + 4000;
							G_Damage(traceEnt, self, self, dir, tr.endpos, damage_high, DAMAGE_DEATH_KNOCKBACK, MOD_LIGHTNING_STRIKE);
						}
						else if (traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_BOBAFETT ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_MANDALORIAN ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_JANGO ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_JANGODUAL)
						{
							//he doesn't drop them, just puts it away
							if (traceEnt->health <= 50)
							{
								ChangeWeapon(traceEnt, WP_MELEE);
								G_Slapdown(traceEnt, self, dir, 80, qtrue);
							}
							else
							{
								G_Stagger(traceEnt);
							}
							Boba_FlyStop(traceEnt);
							if (traceEnt->client->jetPackOn)
							{
								//disable jetpack temporarily
								Jetpack_Off(traceEnt);
								traceEnt->client->jetPackToggleTime = level.time + Q_irand(3000, 10000);
							}
							traceEnt->client->ps.powerups[PW_STUNNED] = level.time + 4000;
							G_Damage(traceEnt, self, self, dir, tr.endpos, damage_high, DAMAGE_DEATH_KNOCKBACK,
								MOD_LIGHTNING_STRIKE);
						}
						else if (traceEnt->s.weapon == WP_MELEE)
						{
							//they can't take that away from me, oh no...
							traceEnt->client->ps.powerups[PW_STUNNED] = level.time + 4000;
							G_Damage(traceEnt, self, self, dir, tr.endpos, damage_high, DAMAGE_DEATH_KNOCKBACK,
								MOD_LIGHTNING_STRIKE);
							if (traceEnt->health <= 50)
							{
								G_Slapdown(traceEnt, self, dir, 80, qtrue);
							}
							else
							{
								G_Stagger(traceEnt);
							}
						}
						else if (ThisGuyIsAGunner(traceEnt))
						{
							if (traceEnt->health <= 50)
							{
								WP_DropWeapon(traceEnt, nullptr);
								G_Slapdown(traceEnt, self, dir, 80, qtrue);
							}
							else
							{
								G_Stagger(traceEnt);
							}
							traceEnt->client->ps.powerups[PW_STUNNED] = level.time + 4000;
							G_Damage(traceEnt, self, self, dir, tr.endpos, damage_high, DAMAGE_DEATH_KNOCKBACK,
								MOD_LIGHTNING_STRIKE);
						}
						else
						{
							if (traceEnt->s.weapon == WP_SABER
								&& traceEnt->client->ps.SaberActive()
								&& !traceEnt->client->ps.saberInFlight
								&& InFOV(self->currentOrigin, traceEnt->currentOrigin,
									traceEnt->client->ps.viewangles,
									20, 35)
								&& !PM_InKnockDown(&traceEnt->client->ps)
								&& !PM_SuperBreakLoseAnim(traceEnt->client->ps.torsoAnim)
								&& !PM_SuperBreakWinAnim(traceEnt->client->ps.torsoAnim)
								&& !pm_saber_in_special_attack(traceEnt->client->ps.torsoAnim)
								&& !PM_InSpecialJump(traceEnt->client->ps.torsoAnim)
								&& (traceEnt->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCK ||
									traceEnt->client->ps.ManualBlockingFlags & 1 << MBF_NPCBLOCKING ||
									traceEnt->NPC && traceEnt->client->ps.forcePower > 20))
							{
								//saber can block lightning make them do a parry
								VectorNegate(dir, forward);

								//randomize direction a bit
								MakeNormalVectors(forward, right, up);
								VectorMA(forward, Q_irand(0, 360), right, forward);
								VectorMA(forward, Q_irand(0, 360), up, forward);
								VectorNormalize(forward);

								if (chance_of_fizz > 0)
								{
									VectorMA(
										traceEnt->client->ps.saber[npc_saber_num].blade[npc_blade_num].muzzlePoint,
										traceEnt->client->ps.saber[npc_saber_num].blade[npc_blade_num].length *
										Q_flrand(0, 1),
										traceEnt->client->ps.saber[npc_saber_num].blade[npc_blade_num].muzzleDir, end);
									G_PlayEffect(G_EffectIndex("saber/fizz.efx"), end, forward);
								}

								switch (traceEnt->client->ps.saber_anim_level)
								{
								case SS_DUAL:
									NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P6_S6_T_, SETANIM_AFLAG_PACE);
									break;
								case SS_STAFF:
									NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P7_S7_T_, SETANIM_AFLAG_PACE);
									break;
								case SS_FAST:
								case SS_TAVION:
								case SS_STRONG:
								case SS_DESANN:
								case SS_MEDIUM:
								case SS_NONE:
								default:
									NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P1_S1_T_, SETANIM_AFLAG_PACE);
									break;
								}
								traceEnt->client->ps.weaponTime = Q_irand(300, 600);
							}
							else
							{
								if (traceEnt->s.weapon == WP_SABER)
								{
									//turn it off?
									traceEnt->client->ps.SaberDeactivate();
									G_SoundOnEnt(traceEnt, CHAN_WEAPON, "sound/weapons/saber/saberoffquick.wav");
									G_Slapdown(traceEnt, self, dir, 80, qtrue);
									G_Damage(traceEnt, self, self, dir, tr.endpos, damage_high, DAMAGE_DEATH_KNOCKBACK, MOD_LIGHTNING_STRIKE);
									traceEnt->client->ps.powerups[PW_STUNNED] = level.time + 4000;
								}
								else
								{
									const int hit_loc = G_GetHitLocFromTrace(&tr, MOD_LIGHTNING_STRIKE);
									G_Damage(traceEnt, self, self, dir, tr.endpos, damage_high, DAMAGE_DEATH_KNOCKBACK, MOD_LIGHTNING_STRIKE, hit_loc);
								}
							}
						}
					}
				}
				else
				{
					G_PlayEffect(G_EffectIndex("tusken/hitwall"), tr.endpos, tr.plane.normal);
				}
			}
		}
	}
	else if (self->client->ps.forcePowerLevel[FP_LIGHTNING_STRIKE] == FORCE_LEVEL_2)
	{
		constexpr float radiusmedium = 256;
		//arc
		VectorCopy(self->currentOrigin, center);

		for (i = 0; i < 3; i++)
		{
			mins[i] = center[i] - radiusmedium;
			maxs[i] = center[i] + radiusmedium;
		}
		num_listed_entities = gi.EntitiesInBox(mins, maxs, entity_list, MAX_GENTITIES);

		for (e = 0; e < num_listed_entities; e++)
		{
			traceEnt = entity_list[e];

			if (!traceEnt)
				continue;
			if (traceEnt == self)
				continue;
			if (traceEnt->owner == self && traceEnt->s.weapon != WP_THERMAL) //can push your own thermals
				continue;
			if (!traceEnt->inuse)
				continue;
			if (!traceEnt->takedamage)
				continue;
			for (i = 0; i < 3; i++)
			{
				if (center[i] < traceEnt->absmin[i])
				{
					v[i] = traceEnt->absmin[i] - center[i];
				}
				else if (center[i] > traceEnt->absmax[i])
				{
					v[i] = center[i] - traceEnt->absmax[i];
				}
				else
				{
					v[i] = 0;
				}
			}

			VectorSubtract(traceEnt->absmax, traceEnt->absmin, size);
			VectorMA(traceEnt->absmin, 0.5, size, ent_org);

			//see if they're in front of me
			//must be within the forward cone
			VectorSubtract(ent_org, center, dir);
			VectorNormalize(dir);
			if ((dot = DotProduct(dir, forward)) < 0.5)
				continue;

			//must be close enough
			dist = VectorLength(v);
			if (dist >= radiusmedium)
			{
				continue;
			}

			//in PVS?
			if (!traceEnt->bmodel && !gi.inPVS(ent_org, self->client->renderInfo.handLPoint))
			{
				//must be in PVS
				continue;
			}

			//Now check and see if we can actually hit it
			gi.trace(&tr, self->client->renderInfo.handLPoint, vec3_origin, vec3_origin, ent_org, self->s.number,
				MASK_SHOT, static_cast<EG2_Collision>(0), 0);

			if (tr.surfaceFlags & SURF_NOIMPACT)
			{
				render_impact = qfalse;
			}

			if (tr.fraction < 1.0f && tr.entityNum != traceEnt->s.number)
			{
				//must have clear LOS
				continue;
			}

			if (render_impact)
			{
				if (tr.entityNum < ENTITYNUM_WORLD && traceEnt->takedamage)
				{
					// Create a simple impact type mark that doesn't last long in the world
					G_PlayEffect(G_EffectIndex("tusken/hit"), tr.endpos, tr.plane.normal);

					if (traceEnt->client && LogAccuracyHit(traceEnt, self))
					{
						self->client->ps.persistant[PERS_ACCURACY_HITS]++;
					}

					if (traceEnt->client && traceEnt->client->ps.powerups[PW_CLOAKED])
					{
						//disable cloak temporarily
						player_decloak(traceEnt);
						G_AddVoiceEvent(traceEnt, Q_irand(EV_ANGER1, EV_ANGER3), 10000);
					}

					if (traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_GALAKMECH)
					{
						//hehe
						if (traceEnt->client->ps.stats[STAT_ARMOR] > 1)
						{
							traceEnt->client->ps.stats[STAT_ARMOR] = 0;
						}
						traceEnt->client->ps.powerups[PW_STUNNED] = level.time + 4000;
						G_Damage(traceEnt, self, self, dir, tr.endpos, damage_high, DAMAGE_DEATH_KNOCKBACK, MOD_LIGHTNING_STRIKE);
					}
					else if (traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_OBJECT)
					{
						traceEnt->client->ps.powerups[PW_STUNNED] = level.time + 4000;
					}
					else
					{
						if (traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_ATST ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_GONK ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_INTERROGATOR ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_MARK1 ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_MARK2 ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_MOUSE ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_PROBE ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_PROTOCOL ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_R2D2 ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_R5D2 ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_SEEKER ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_SENTRY ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_SBD ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_BATTLEDROID ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_DROIDEKA ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_OBJECT ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_ASSASSIN_DROID ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_SABER_DROID)
						{
							// special droid only behaviors
							traceEnt->client->ps.powerups[PW_STUNNED] = level.time + 4000;
							G_Damage(traceEnt, self, self, dir, tr.endpos, damage_high, DAMAGE_DEATH_KNOCKBACK, MOD_LIGHTNING_STRIKE);
						}
						else if (traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_BOBAFETT ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_MANDALORIAN ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_JANGO ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_JANGODUAL)
						{
							//he doesn't drop them, just puts it away
							if (traceEnt->health <= 50)
							{
								ChangeWeapon(traceEnt, WP_MELEE);
								G_Slapdown(traceEnt, self, dir, 80, qtrue);
							}
							else
							{
								G_Stagger(traceEnt);
							}
							Boba_FlyStop(traceEnt);
							if (traceEnt->client->jetPackOn)
							{
								//disable jetpack temporarily
								Jetpack_Off(traceEnt);
								traceEnt->client->jetPackToggleTime = level.time + Q_irand(3000, 10000);
							}
							traceEnt->client->ps.powerups[PW_STUNNED] = level.time + 2000;
							G_Damage(traceEnt, self, self, dir, tr.endpos, damage_medium, DAMAGE_DEATH_KNOCKBACK,
								MOD_LIGHTNING_STRIKE);
						}
						else if (traceEnt->s.weapon == WP_MELEE)
						{
							//they can't take that away from me, oh no...
							traceEnt->client->ps.powerups[PW_STUNNED] = level.time + 2000;
							G_Damage(traceEnt, self, self, dir, tr.endpos, damage_medium, DAMAGE_DEATH_KNOCKBACK,
								MOD_LIGHTNING_STRIKE);
							if (traceEnt->health <= 50)
							{
								G_Slapdown(traceEnt, self, dir, 80, qtrue);
							}
							else
							{
								G_Stagger(traceEnt);
							}
						}
						else if (ThisGuyIsAGunner(traceEnt))
						{
							if (traceEnt->health <= 50)
							{
								WP_DropWeapon(traceEnt, nullptr);
								G_Slapdown(traceEnt, self, dir, 80, qtrue);
							}
							else
							{
								G_Stagger(traceEnt);
							}
							traceEnt->client->ps.powerups[PW_STUNNED] = level.time + 2000;
							G_Damage(traceEnt, self, self, dir, tr.endpos, damage_medium, DAMAGE_DEATH_KNOCKBACK,
								MOD_LIGHTNING_STRIKE);
						}
						else
						{
							if (traceEnt->s.weapon == WP_SABER
								&& traceEnt->client->ps.SaberActive()
								&& !traceEnt->client->ps.saberInFlight
								&& InFOV(self->currentOrigin, traceEnt->currentOrigin,
									traceEnt->client->ps.viewangles,
									20, 35)
								&& !PM_InKnockDown(&traceEnt->client->ps)
								&& !PM_SuperBreakLoseAnim(traceEnt->client->ps.torsoAnim)
								&& !PM_SuperBreakWinAnim(traceEnt->client->ps.torsoAnim)
								&& !pm_saber_in_special_attack(traceEnt->client->ps.torsoAnim)
								&& !PM_InSpecialJump(traceEnt->client->ps.torsoAnim)
								&& (traceEnt->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCK ||
									traceEnt->client->ps.ManualBlockingFlags & 1 << MBF_NPCBLOCKING ||
									traceEnt->NPC && traceEnt->client->ps.forcePower > 20))
							{
								//saber can block lightning make them do a parry
								VectorNegate(dir, forward);

								//randomize direction a bit
								MakeNormalVectors(forward, right, up);
								VectorMA(forward, Q_irand(0, 360), right, forward);
								VectorMA(forward, Q_irand(0, 360), up, forward);
								VectorNormalize(forward);

								if (chance_of_fizz > 0)
								{
									VectorMA(
										traceEnt->client->ps.saber[npc_saber_num].blade[npc_blade_num].muzzlePoint,
										traceEnt->client->ps.saber[npc_saber_num].blade[npc_blade_num].length *
										Q_flrand(0, 1),
										traceEnt->client->ps.saber[npc_saber_num].blade[npc_blade_num].muzzleDir, end);
									G_PlayEffect(G_EffectIndex("saber/fizz.efx"), end, forward);
								}

								switch (traceEnt->client->ps.saber_anim_level)
								{
								case SS_DUAL:
									NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P6_S6_T_, SETANIM_AFLAG_PACE);
									break;
								case SS_STAFF:
									NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P7_S7_T_, SETANIM_AFLAG_PACE);
									break;
								case SS_FAST:
								case SS_TAVION:
								case SS_STRONG:
								case SS_DESANN:
								case SS_MEDIUM:
								case SS_NONE:
								default:
									NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P1_S1_T_, SETANIM_AFLAG_PACE);
									break;
								}
								traceEnt->client->ps.weaponTime = Q_irand(300, 600);
							}
							else
							{
								if (traceEnt->s.weapon == WP_SABER)
								{
									//turn it off?
									traceEnt->client->ps.SaberDeactivate();
									G_SoundOnEnt(traceEnt, CHAN_WEAPON, "sound/weapons/saber/saberoffquick.wav");
									G_Slapdown(traceEnt, self, dir, 80, qtrue);
									G_Damage(traceEnt, self, self, dir, tr.endpos, damage_medium, DAMAGE_DEATH_KNOCKBACK, MOD_LIGHTNING_STRIKE);
									traceEnt->client->ps.powerups[PW_STUNNED] = level.time + 4000;
								}
								else
								{
									const int hit_loc = G_GetHitLocFromTrace(&tr, MOD_LIGHTNING_STRIKE);
									G_Damage(traceEnt, self, self, dir, tr.endpos, damage_medium, DAMAGE_DEATH_KNOCKBACK, MOD_LIGHTNING_STRIKE, hit_loc);
								}
							}
						}
					}
				}
				else
				{
					G_PlayEffect(G_EffectIndex("tusken/hitwall"), tr.endpos, tr.plane.normal);
				}
			}
		}
	}
	else
	{
		constexpr float radiuslow = 128;
		//arc
		VectorCopy(self->currentOrigin, center);

		for (i = 0; i < 3; i++)
		{
			mins[i] = center[i] - radiuslow;
			maxs[i] = center[i] + radiuslow;
		}
		num_listed_entities = gi.EntitiesInBox(mins, maxs, entity_list, MAX_GENTITIES);

		for (e = 0; e < num_listed_entities; e++)
		{
			traceEnt = entity_list[e];

			if (!traceEnt)
				continue;
			if (traceEnt == self)
				continue;
			if (traceEnt->owner == self && traceEnt->s.weapon != WP_THERMAL) //can push your own thermals
				continue;
			if (!traceEnt->inuse)
				continue;
			if (!traceEnt->takedamage)
				continue;
			for (i = 0; i < 3; i++)
			{
				if (center[i] < traceEnt->absmin[i])
				{
					v[i] = traceEnt->absmin[i] - center[i];
				}
				else if (center[i] > traceEnt->absmax[i])
				{
					v[i] = center[i] - traceEnt->absmax[i];
				}
				else
				{
					v[i] = 0;
				}
			}

			VectorSubtract(traceEnt->absmax, traceEnt->absmin, size);
			VectorMA(traceEnt->absmin, 0.5, size, ent_org);

			//see if they're in front of me
			//must be within the forward cone
			VectorSubtract(ent_org, center, dir);
			VectorNormalize(dir);
			if ((dot = DotProduct(dir, forward)) < 0.5)
				continue;

			//must be close enough
			dist = VectorLength(v);
			if (dist >= radiuslow)
			{
				continue;
			}

			//in PVS?
			if (!traceEnt->bmodel && !gi.inPVS(ent_org, self->client->renderInfo.handLPoint))
			{
				//must be in PVS
				continue;
			}

			//Now check and see if we can actually hit it
			gi.trace(&tr, self->client->renderInfo.handLPoint, vec3_origin, vec3_origin, ent_org, self->s.number,
				MASK_SHOT, static_cast<EG2_Collision>(0), 0);

			if (tr.surfaceFlags & SURF_NOIMPACT)
			{
				render_impact = qfalse;
			}

			if (tr.fraction < 1.0f && tr.entityNum != traceEnt->s.number)
			{
				//must have clear LOS
				continue;
			}

			if (render_impact)
			{
				if (tr.entityNum < ENTITYNUM_WORLD && traceEnt->takedamage)
				{
					// Create a simple impact type mark that doesn't last long in the world
					G_PlayEffect(G_EffectIndex("tusken/hit"), tr.endpos, tr.plane.normal);

					if (traceEnt->client && LogAccuracyHit(traceEnt, self))
					{
						self->client->ps.persistant[PERS_ACCURACY_HITS]++;
					}

					if (traceEnt->client && traceEnt->client->ps.powerups[PW_CLOAKED])
					{
						//disable cloak temporarily
						player_decloak(traceEnt);
						G_AddVoiceEvent(traceEnt, Q_irand(EV_ANGER1, EV_ANGER3), 10000);
					}

					if (traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_GALAKMECH)
					{
						//hehe
						if (traceEnt->client->ps.stats[STAT_ARMOR] > 1)
						{
							traceEnt->client->ps.stats[STAT_ARMOR] = 0;
						}
						traceEnt->client->ps.powerups[PW_STUNNED] = level.time + 4000;
						G_Damage(traceEnt, self, self, dir, tr.endpos, damage_high, DAMAGE_DEATH_KNOCKBACK, MOD_LIGHTNING_STRIKE);
					}
					else if (traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_OBJECT)
					{
						traceEnt->client->ps.powerups[PW_STUNNED] = level.time + 4000;
					}
					else
					{
						if (traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_ATST ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_GONK ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_INTERROGATOR ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_MARK1 ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_MARK2 ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_MOUSE ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_PROBE ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_PROTOCOL ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_R2D2 ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_R5D2 ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_SEEKER ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_SENTRY ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_SBD ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_BATTLEDROID ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_DROIDEKA ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_OBJECT ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_ASSASSIN_DROID ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_SABER_DROID)
						{
							// special droid only behaviors
							traceEnt->client->ps.powerups[PW_STUNNED] = level.time + 4000;
							G_Damage(traceEnt, self, self, dir, tr.endpos, damage_high, DAMAGE_DEATH_KNOCKBACK, MOD_LIGHTNING_STRIKE);
						}
						else if (traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_BOBAFETT ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_MANDALORIAN ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_JANGO ||
							traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_JANGODUAL)
						{
							//he doesn't drop them, just puts it away
							if (traceEnt->health <= 50)
							{
								ChangeWeapon(traceEnt, WP_MELEE);
								G_Slapdown(traceEnt, self, dir, 80, qtrue);
							}
							else
							{
								G_Stagger(traceEnt);
							}
							Boba_FlyStop(traceEnt);
							if (traceEnt->client->jetPackOn)
							{
								//disable jetpack temporarily
								Jetpack_Off(traceEnt);
								traceEnt->client->jetPackToggleTime = level.time + Q_irand(3000, 10000);
							}
							traceEnt->client->ps.powerups[PW_STUNNED] = level.time + 1000;
							G_Damage(traceEnt, self, self, dir, tr.endpos, damagelow, DAMAGE_DEATH_KNOCKBACK,
								MOD_LIGHTNING_STRIKE);
						}
						else if (traceEnt->s.weapon == WP_MELEE)
						{
							//they can't take that away from me, oh no...
							traceEnt->client->ps.powerups[PW_STUNNED] = level.time + 1000;
							G_Damage(traceEnt, self, self, dir, tr.endpos, damagelow, DAMAGE_DEATH_KNOCKBACK,
								MOD_LIGHTNING_STRIKE);
							if (traceEnt->health <= 50)
							{
								G_Slapdown(traceEnt, self, dir, 80, qtrue);
							}
							else
							{
								G_Stagger(traceEnt);
							}
						}
						else if (ThisGuyIsAGunner(traceEnt))
						{
							if (traceEnt->health <= 50)
							{
								WP_DropWeapon(traceEnt, nullptr);
								G_Slapdown(traceEnt, self, dir, 80, qtrue);
							}
							else
							{
								G_Stagger(traceEnt);
							}
							traceEnt->client->ps.powerups[PW_STUNNED] = level.time + 1000;
							G_Damage(traceEnt, self, self, dir, tr.endpos, damagelow, DAMAGE_DEATH_KNOCKBACK,
								MOD_LIGHTNING_STRIKE);
						}
						else
						{
							if (traceEnt->s.weapon == WP_SABER
								&& traceEnt->client->ps.SaberActive()
								&& !traceEnt->client->ps.saberInFlight
								&& InFOV(self->currentOrigin, traceEnt->currentOrigin,
									traceEnt->client->ps.viewangles,
									20, 35)
								&& !PM_InKnockDown(&traceEnt->client->ps)
								&& !PM_SuperBreakLoseAnim(traceEnt->client->ps.torsoAnim)
								&& !PM_SuperBreakWinAnim(traceEnt->client->ps.torsoAnim)
								&& !pm_saber_in_special_attack(traceEnt->client->ps.torsoAnim)
								&& !PM_InSpecialJump(traceEnt->client->ps.torsoAnim)
								&& (traceEnt->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCK ||
									traceEnt->client->ps.ManualBlockingFlags & 1 << MBF_NPCBLOCKING ||
									traceEnt->NPC && traceEnt->client->ps.forcePower > 20))
							{
								//saber can block lightning make them do a parry
								VectorNegate(dir, forward);

								//randomize direction a bit
								MakeNormalVectors(forward, right, up);
								VectorMA(forward, Q_irand(0, 360), right, forward);
								VectorMA(forward, Q_irand(0, 360), up, forward);
								VectorNormalize(forward);

								if (chance_of_fizz > 0)
								{
									VectorMA(
										traceEnt->client->ps.saber[npc_saber_num].blade[npc_blade_num].muzzlePoint,
										traceEnt->client->ps.saber[npc_saber_num].blade[npc_blade_num].length *
										Q_flrand(0, 1),
										traceEnt->client->ps.saber[npc_saber_num].blade[npc_blade_num].muzzleDir, end);
									G_PlayEffect(G_EffectIndex("saber/fizz.efx"), end, forward);
								}

								switch (traceEnt->client->ps.saber_anim_level)
								{
								case SS_DUAL:
									NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P6_S6_T_, SETANIM_AFLAG_PACE);
									break;
								case SS_STAFF:
									NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P7_S7_T_, SETANIM_AFLAG_PACE);
									break;
								case SS_FAST:
								case SS_TAVION:
								case SS_STRONG:
								case SS_DESANN:
								case SS_MEDIUM:
								case SS_NONE:
								default:
									NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P1_S1_T_, SETANIM_AFLAG_PACE);
									break;
								}
								traceEnt->client->ps.weaponTime = Q_irand(300, 600);
							}
							else
							{
								if (traceEnt->s.weapon == WP_SABER)
								{
									//turn it off?
									traceEnt->client->ps.SaberDeactivate();
									G_SoundOnEnt(traceEnt, CHAN_WEAPON, "sound/weapons/saber/saberoffquick.wav");
									G_Slapdown(traceEnt, self, dir, 80, qtrue);
									G_Damage(traceEnt, self, self, dir, tr.endpos, damagelow, DAMAGE_DEATH_KNOCKBACK, MOD_LIGHTNING_STRIKE);
									traceEnt->client->ps.powerups[PW_STUNNED] = level.time + 4000;
								}
								else
								{
									const int hit_loc = G_GetHitLocFromTrace(&tr, MOD_LIGHTNING_STRIKE);
									G_Damage(traceEnt, self, self, dir, tr.endpos, damagelow, DAMAGE_DEATH_KNOCKBACK, MOD_LIGHTNING_STRIKE, hit_loc);
								}
							}
						}
					}
				}
				else
				{
					G_PlayEffect(G_EffectIndex("tusken/hitwall"), tr.endpos, tr.plane.normal);
				}
			}
		}
	}
}

void ForceLightningStrike(gentity_t* self)
{
	if (self->health <= 0)
	{
		return;
	}
	if (!WP_ForcePowerUsable(self, FP_LIGHTNING_STRIKE, 0))
	{
		return;
	}
	if (self->client->ps.forcePowerDebounce[FP_LIGHTNING_STRIKE] > level.time)
	{
		//already using lightning strike
		return;
	}

	if (self->client->ps.forcePower < 25 || !WP_ForcePowerUsable(self, FP_LIGHTNING_STRIKE, 0))
	{
		return;
	}
	if (!self->s.number && (cg.zoomMode || in_camera))
	{
		//can't destruction when zoomed in or in cinematic
		return;
	}
	if (self->client->ps.saberLockTime > level.time)
	{
		//FIXME: can this be a way to break out?
		return;
	}

	if (PM_InLedgeMove(self->client->ps.legsAnim))
	{
		return;
	}
	// Make sure to turn off Force Protection and Force Absorb.
	if (self->client->ps.forcePowersActive & 1 << FP_PROTECT)
	{
		WP_ForcePowerStop(self, FP_PROTECT);
	}
	if (self->client->ps.forcePowersActive & 1 << FP_PROJECTION)
	{
		WP_ForcePowerStop(self, FP_PROJECTION);
	}
	if (self->client->ps.forcePowersActive & 1 << FP_ABSORB)
	{
		WP_ForcePowerStop(self, FP_ABSORB);
	}

	constexpr int anim = BOTH_FORCELIGHTNING;
	const int sound_index = G_SoundIndex("sound/weapons/force/strike.wav");

	int parts = SETANIM_TORSO;
	if (!PM_InKnockDown(&self->client->ps))
	{
		if (!VectorLengthSquared(self->client->ps.velocity) && !(self->client->ps.pm_flags & PMF_DUCKED))
		{
			parts = SETANIM_BOTH;
		}
	}
	NPC_SetAnim(self, parts, anim, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD | SETANIM_FLAG_RESTART);
	self->client->ps.saber_move = self->client->ps.saberBounceMove = LS_READY;
	//don't finish whatever saber anim you may have been in
	self->client->ps.saberBlocked = BLOCKED_NONE;

	if (self->handLBolt != -1)
	{
		G_PlayEffect(G_EffectIndex("force/strike_flare"), self->playerModel, self->handLBolt, self->s.number,
			self->currentOrigin, 200, qtrue);
	}

	G_Sound(self, sound_index);

	force_shootstrike(self);

	WP_ForcePowerStart(self, FP_LIGHTNING_STRIKE, self->client->ps.torsoAnimTimer);

	self->client->ps.weaponTime = self->client->ps.torsoAnimTimer;
	self->client->ps.forcePowerDebounce[FP_LIGHTNING_STRIKE] = level.time + self->client->ps.torsoAnimTimer + 500;
}

void ForceLightning(gentity_t* self)
{
	if (self->health <= 0)
	{
		return;
	}

	if (BG_InKnockDown(self->client->ps.legsAnim) || self->client->ps.leanofs || PM_InKnockDown(&self->client->ps))
	{
		return;
	}

	if (PM_InLedgeMove(self->client->ps.legsAnim))
	{
		return;
	}

	if (!self->s.number && (cg.zoomMode || in_camera))
	{
		//can't force lightning when zoomed in or in cinematic
		return;
	}

	if (self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self))
	{
		if (self->client->ps.userInt3 & 1 << FLAG_PREBLOCK)
		{
			return;
		}

		if (self->client->ps.weaponTime > 0
			&& (!PM_SaberInParry(self->client->ps.saber_move) || !(self->client->ps.userInt3 & 1 << FLAG_PREBLOCK)))
		{
			return;
		}
	}

	if (self->client->ps.forcePower < 25 || !WP_ForcePowerUsable(self, FP_LIGHTNING, 0))
	{
		return;
	}

	if (self->client->ps.forcePowerDebounce[FP_LIGHTNING] > level.time)
	{
		//stops it while using it and also after using it, up to 3 second delay
		return;
	}
	if (self->client->ps.saberLockTime > level.time)
	{
		//FIXME: can this be a way to break out?
		return;
	}
	// Make sure to turn off Force Protection and Force Absorb.
	if (self->client->ps.forcePowersActive & 1 << FP_PROTECT)
	{
		WP_ForcePowerStop(self, FP_PROTECT);
	}
	if (self->client->ps.forcePowersActive & 1 << FP_ABSORB)
	{
		WP_ForcePowerStop(self, FP_ABSORB);
	}
	if (self->client->ps.forcePowersActive & 1 << FP_PROJECTION)
	{
		WP_ForcePowerStop(self, FP_PROJECTION);
	}
	if (self->client->ps.forcePowersActive & 1 << FP_SEE)
	{
		WP_ForcePowerStop(self, FP_SEE);
	}

	if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self) && self->client->ps.weapon == WP_SABER)
		//npc force use limit
	{
		if (self->client->ps.forcePowersActive & 1 << FP_GRIP)
		{
			WP_ForcePowerStop(self, FP_GRIP);
		}
		if (self->client->ps.forcePowersActive & 1 << FP_GRASP)
		{
			WP_ForcePowerStop(self, FP_GRASP);
		}
		if (self->client->ps.forcePowersActive & 1 << FP_LIGHTNING && PM_SaberInAttack(self->client->ps.saber_move))
		{
			WP_ForcePowerStop(self, FP_LIGHTNING);
		}
	}
	//Shoot lightning from hand
	//make sure this plays and that you cannot press fire for about 1 second after this
	if (self->client->ps.forcePowerLevel[FP_LIGHTNING] < FORCE_LEVEL_2)
	{
		NPC_SetAnim(self, SETANIM_TORSO, BOTH_FORCELIGHTNING, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
	}
	else
	{
		ForceLightningAnim(self);
	}
	self->client->ps.saber_move = self->client->ps.saberBounceMove = LS_READY;
	//don't finish whatever saber anim you may have been in
	self->client->ps.saberBlocked = BLOCKED_NONE;

	if (self->client->ps.forcePowerLevel[FP_LIGHTNING] < FORCE_LEVEL_2)
	{
		//short burst
		G_SoundOnEnt(self, CHAN_BODY, "sound/weapons/force/lightning2.wav");
	}
	else
	{
		//holding it
		G_SoundOnEnt(self, CHAN_BODY, "sound/weapons/force/lightning3.mp3");
	}

	self->client->ps.weaponTime = self->client->ps.torsoAnimTimer;
	WP_ForcePowerStart(self, FP_LIGHTNING, self->client->ps.torsoAnimTimer);
}

extern void G_KnockOver(gentity_t* self, gentity_t* attacker, const vec3_t push_dir, float strength,
	qboolean breakSaberLock);

static void ForceLightningDamage(gentity_t* self, gentity_t* traceEnt, vec3_t dir, const float dist, const float dot,
	vec3_t impact_point)
{
	qboolean lightning_blocked = qfalse;
	qboolean is_class_guard = qfalse;

	if (traceEnt->NPC && traceEnt->NPC->scriptFlags & SCF_NO_FORCE)
	{
		if (!in_camera
			&& traceEnt->health > 0)
		{
			if ((!Q_stricmp("Yoda", traceEnt->NPC_type) ||
				!Q_stricmp("Ep1_Yoda", traceEnt->NPC_type) ||
				!Q_stricmp("Ep2_Yoda", traceEnt->NPC_type) ||
				!Q_stricmp("Ep3_Yoda", traceEnt->NPC_type) ||
				!Q_stricmp("md_yoda", traceEnt->NPC_type) ||
				!Q_stricmp("md_yoda_ep2", traceEnt->NPC_type) ||
				!Q_stricmp("md_yoda_ot", traceEnt->NPC_type) ||
				!Q_stricmp("md_yoda_hr", traceEnt->NPC_type) ||
				char_is_force_user_attacker(traceEnt))
				&& traceEnt->s.weapon == WP_SABER
				&& traceEnt->client->ps.SaberActive()
				&& !traceEnt->client->ps.saberInFlight
				&& (traceEnt->client->ps.saber_move == LS_READY || PM_SaberInParry(traceEnt->client->ps.saber_move) || PM_SaberInReturn(traceEnt->client->ps.saber_move))
				&& InFOV(self->currentOrigin, traceEnt->currentOrigin, traceEnt->client->ps.viewangles, 20, 35)
				&& !PM_InKnockDown(&traceEnt->client->ps)
				&& !PM_SuperBreakLoseAnim(traceEnt->client->ps.torsoAnim)
				&& !PM_SuperBreakWinAnim(traceEnt->client->ps.torsoAnim)
				&& !pm_saber_in_special_attack(traceEnt->client->ps.torsoAnim)
				&& !PM_InSpecialJump(traceEnt->client->ps.torsoAnim))
			{
				//saber can block lightning
				//make them do a parry
				const float chance_of_fizz = Q_flrand(0.0f, 1.0f);
				vec3_t fwd{}, right, up;
				lightning_blocked = qtrue;
				VectorNegate(dir, fwd);

				//randomize direction a bit
				MakeNormalVectors(fwd, right, up);
				VectorMA(fwd, Q_irand(0, 360), right, fwd);
				VectorMA(fwd, Q_irand(0, 360), up, fwd);
				VectorNormalize(fwd);

				if (chance_of_fizz > 0)
				{
					vec3_t end;
					constexpr int npc_blade_num = 0;
					constexpr int npc_saber_num = 0;
					VectorMA(traceEnt->client->ps.saber[npc_saber_num].blade[npc_blade_num].muzzlePoint,
						traceEnt->client->ps.saber[npc_saber_num].blade[npc_blade_num].length * Q_flrand(0, 1),
						traceEnt->client->ps.saber[npc_saber_num].blade[npc_blade_num].muzzleDir, end);
					G_PlayEffect(G_EffectIndex("saber/fizz.efx"), end, fwd);
				}

				switch (traceEnt->client->ps.saber_anim_level)
				{
				case SS_DUAL:
					NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P6_S6_T_, SETANIM_AFLAG_PACE);
					break;
				case SS_STAFF:
					NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P7_S7_T_, SETANIM_AFLAG_PACE);
					break;
				case SS_FAST:
				case SS_TAVION:
				case SS_STRONG:
				case SS_DESANN:
				case SS_MEDIUM:
				case SS_NONE:
				default:
					NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P1_S1_T_, SETANIM_AFLAG_PACE);
					break;
				}
				traceEnt->client->ps.weaponTime = Q_irand(300, 600);
				if (d_combatinfo->integer || g_DebugSaberCombat->integer || g_lightningdamage->integer)
				{
					Com_Printf(S_COLOR_RED"JKA Mode NPC Saber Lightning Block No Force Correct\n");
				}
			}
			else if ((!Q_stricmp("Yoda", traceEnt->NPC_type) ||
				!Q_stricmp("Ep1_Yoda", traceEnt->NPC_type) ||
				!Q_stricmp("Ep2_Yoda", traceEnt->NPC_type) ||
				!Q_stricmp("Ep3_Yoda", traceEnt->NPC_type) ||
				!Q_stricmp("md_yoda", traceEnt->NPC_type) ||
				!Q_stricmp("md_yoda_ep2", traceEnt->NPC_type) ||
				!Q_stricmp("md_yoda_ot", traceEnt->NPC_type) ||
				!Q_stricmp("md_yoda_hr", traceEnt->NPC_type) ||
				char_is_force_user_attacker(traceEnt))
				&& traceEnt->s.weapon == WP_MELEE ||
				traceEnt->s.weapon == WP_NONE ||
				traceEnt->client->ps.weapon == WP_SABER && !traceEnt->client->ps.SaberActive()
				&& !PM_InKnockDown(&traceEnt->client->ps)
				&& !PM_InRoll(&traceEnt->client->ps)
				&& traceEnt->client->ps.groundEntityNum != ENTITYNUM_NONE
				&& !PM_RunningAnim(traceEnt->client->ps.legsAnim)
				&& InFOV(self->currentOrigin, traceEnt->currentOrigin, traceEnt->client->ps.viewangles, 20, 35))
			{
				NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_FORCE_2HANDEDLIGHTNING_HOLD, SETANIM_AFLAG_PACE);
				traceEnt->client->ps.weaponTime = Q_irand(300, 600);
				lightning_blocked = qtrue;

				if (traceEnt->enemy
					&& traceEnt->ghoul2.size())
				{
					if (traceEnt->handRBolt != -1)
					{
						G_PlayEffect(G_EffectIndex("force/HBlockLightning.efx"), traceEnt->playerModel,
							traceEnt->handRBolt, traceEnt->s.number, traceEnt->currentOrigin, 1000, qtrue);
					}
					if (traceEnt->handLBolt != -1)
					{
						G_PlayEffect(G_EffectIndex("force/HBlockLightning.efx"), traceEnt->playerModel,
							traceEnt->handLBolt, traceEnt->s.number, traceEnt->currentOrigin, 1000, qtrue);
					}
					traceEnt->client->ps.powerups[PW_MEDITATE] = level.time + traceEnt->client->ps.torsoAnimTimer + 5000;
					if (d_combatinfo->integer || g_DebugSaberCombat->integer || g_lightningdamage->integer)
					{
						Com_Printf(S_COLOR_RED"JKA Mode NPC hand Lightning Block No Force Correct\n");
					}
				}
			}
			else
			{
				NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_WIND, SETANIM_AFLAG_PACE);
				traceEnt->client->ps.weaponTime = Q_irand(300, 600);
				lightning_blocked = qtrue;
				traceEnt->client->ps.powerups[PW_MEDITATE] = level.time + traceEnt->client->ps.torsoAnimTimer + 5000;
				if (d_combatinfo->integer || g_DebugSaberCombat->integer || g_lightningdamage->integer)
				{
					Com_Printf(S_COLOR_RED"JKA Mode NPC NO Force Lightning Block Correct\n");
				}
			}
		}
		return;
	}

	if (traceEnt->flags & FL_NOTARGET || traceEnt->noclip)
	{
		return;
	}

	if (traceEnt && traceEnt->takedamage)
	{
		if (traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_GUARD)
		{
			is_class_guard = qtrue;
		}
		if (!traceEnt->client || traceEnt->client->playerTeam != self->client->playerTeam || self->enemy == traceEnt
			||
			traceEnt->enemy == self || traceEnt->client->playerTeam == TEAM_SOLO || self->client->playerTeam ==
			TEAM_SOLO || is_class_guard)
		{
			int npc_lfp_block_cost;
			//an enemy or object
			int dmg;

			if (self->client->ps.forcePowerLevel[FP_LIGHTNING] > FORCE_LEVEL_2)
			{
				//more damage if closer and more in front
				dmg = 1;

				if (self->client->NPC_class == CLASS_REBORN && self->client->ps.weapon == WP_NONE)
				{
					//Cultist: looks fancy, but does less damage
				}
				else
				{
					if (dist < 100)
					{
						dmg += 2;
					}
					else if (dist < 200)
					{
						dmg += 1;
					}
					if (dot > 0.9f)
					{
						dmg += 2;
					}
					else if (dot > 0.7f)
					{
						dmg += 1;
					}
				}
				if (self->client->ps.torsoAnim == BOTH_FORCE_2HANDEDLIGHTNING
					|| self->client->ps.torsoAnim == BOTH_FORCE_2HANDEDLIGHTNING_OLD
					|| self->client->ps.torsoAnim == BOTH_FORCE_2HANDEDLIGHTNING_NEW
					|| self->client->ps.torsoAnim == BOTH_FORCE_2HANDEDLIGHTNING_START
					|| self->client->ps.torsoAnim == BOTH_FORCE_2HANDEDLIGHTNING_HOLD
					|| self->client->ps.torsoAnim == BOTH_FORCE_2HANDEDLIGHTNING_RELEASE)
				{
					//jackin' 'em up, Palpatine-style
					dmg *= 2;
				}
			}
			else
			{
				dmg = Q_irand(1, 3);
			}

			if (traceEnt->client && traceEnt->NPC)
			{
				if (jedi_win_po(traceEnt))
				{
					npc_lfp_block_cost = Q_irand(0, 1);
				}
				else
				{
					npc_lfp_block_cost = Q_irand(1, 2);
				}
			}
			else
			{
				npc_lfp_block_cost = 1;
			}

			const int fp_block_cost = Q_irand(3, 6);
			const int np_cfp_block_cost = Q_irand(2, 4);

			if (traceEnt->client && traceEnt->health > 0)
			{
				if (traceEnt->client
					&& traceEnt->health > 0
					&& traceEnt->NPC
					&& !in_camera && !is_class_guard)
				{
					if (traceEnt->s.weapon == WP_SABER
						&& traceEnt->client->ps.SaberActive()
						&& !traceEnt->client->ps.saberInFlight
						&& (traceEnt->client->ps.saber_move == LS_READY || PM_SaberInParry(traceEnt->client->ps.saber_move) || PM_SaberInReturn(traceEnt->client->ps.saber_move))
						&& InFOV(self->currentOrigin, traceEnt->currentOrigin, traceEnt->client->ps.viewangles, 20, 35)
						&& !PM_InKnockDown(&traceEnt->client->ps)
						&& !PM_SuperBreakLoseAnim(traceEnt->client->ps.torsoAnim)
						&& !PM_SuperBreakWinAnim(traceEnt->client->ps.torsoAnim)
						&& !pm_saber_in_special_attack(traceEnt->client->ps.torsoAnim)
						&& !PM_InSpecialJump(traceEnt->client->ps.torsoAnim)
						&& !PM_SaberInKata(static_cast<saber_moveName_t>(traceEnt->client->ps.saber_move))
						&& traceEnt->client->ps.forcePower > 5)
					{
						//saber can block lightning
						//make them do a parry
						const float chance_of_fizz = Q_flrand(0.0f, 1.0f);
						vec3_t fwd{}, right, up;
						lightning_blocked = qtrue;
						VectorNegate(dir, fwd);

						//randomize direction a bit
						MakeNormalVectors(fwd, right, up);
						VectorMA(fwd, Q_irand(0, 360), right, fwd);
						VectorMA(fwd, Q_irand(0, 360), up, fwd);
						VectorNormalize(fwd);

						if (chance_of_fizz > 0)
						{
							vec3_t end;
							constexpr int npcblade_num = 0;
							constexpr int npcsaber_num = 0;
							VectorMA(traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].muzzlePoint,
								traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].length * Q_flrand(
									0, 1),
								traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].muzzleDir, end);
							G_PlayEffect(G_EffectIndex("saber/fizz.efx"), end, fwd);
						}

						switch (traceEnt->client->ps.saber_anim_level)
						{
						case SS_DUAL:
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P6_S6_T_, SETANIM_AFLAG_PACE);
							break;
						case SS_STAFF:
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P7_S7_T_, SETANIM_AFLAG_PACE);
							break;
						case SS_FAST:
						case SS_TAVION:
						case SS_STRONG:
						case SS_DESANN:
						case SS_MEDIUM:
						case SS_NONE:
						default:
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P1_S1_T_, SETANIM_AFLAG_PACE);
							break;
						}
						traceEnt->client->ps.weaponTime = Q_irand(300, 600);
						WP_ForcePowerDrain(traceEnt, FP_ABSORB, npc_lfp_block_cost);
						dmg = Q_irand(0, 1);
						if (d_combatinfo->integer || g_DebugSaberCombat->integer || g_lightningdamage->integer)
						{
							Com_Printf(S_COLOR_GREEN"JKA Mode NPC Saber Lightning Block Correct\n");
						}
					}
					else if ((traceEnt->NPC && traceEnt->NPC->rank >= RANK_LT_COMM)
						&& (traceEnt->s.weapon == WP_MELEE || traceEnt->s.weapon == WP_NONE
							|| (traceEnt->client->ps.weapon == WP_SABER && !traceEnt->client->ps.SaberActive()))
						&& !PM_InKnockDown(&traceEnt->client->ps)
						&& !PM_InRoll(&traceEnt->client->ps)
						&& traceEnt->client->ps.groundEntityNum != ENTITYNUM_NONE
						&& !PM_RunningAnim(traceEnt->client->ps.legsAnim)
						&& !PM_InSpecialJump(traceEnt->client->ps.torsoAnim)
						&& InFOV(self->currentOrigin, traceEnt->currentOrigin, traceEnt->client->ps.viewangles, 20, 35)
						&& traceEnt->client->ps.forcePower > 20)
					{
						if (Manual_Hand_Block_Lightning_NPC(self, traceEnt, FP_LIGHTNING))
						{
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_FORCE_2HANDEDLIGHTNING_HOLD, SETANIM_AFLAG_PACE);
							traceEnt->client->ps.weaponTime = Q_irand(300, 600);
							lightning_blocked = qtrue;

							if (traceEnt->ghoul2.size())
							{
								if (traceEnt->handRBolt != -1)
								{
									G_PlayEffect(G_EffectIndex("force/HBlockLightning.efx"), traceEnt->playerModel,
										traceEnt->handRBolt, traceEnt->s.number, traceEnt->currentOrigin, 1000,
										qtrue);
								}
								if (traceEnt->handLBolt != -1)
								{
									G_PlayEffect(G_EffectIndex("force/HBlockLightning.efx"), traceEnt->playerModel,
										traceEnt->handLBolt, traceEnt->s.number, traceEnt->currentOrigin, 1000,
										qtrue);
								}
							}
							traceEnt->client->ps.powerups[PW_MEDITATE] = level.time + traceEnt->client->ps.torsoAnimTimer + 5000;

							WP_ForcePowerDrain(traceEnt, FP_ABSORB, np_cfp_block_cost);

							dmg = Q_irand(0, 1);
							if (d_combatinfo->integer || g_DebugSaberCombat->integer || g_lightningdamage->integer)
							{
								Com_Printf(S_COLOR_RED"JKA Mode NPC Hand Lightning Block Correct\n");
							}
						}
					}
				}
				else if (traceEnt->s.weapon == WP_SABER && traceEnt->client->ps.SaberActive())
				{
					//saber can block lightning
					if (!in_camera && !is_class_guard
						&& !traceEnt->client->ps.saberInFlight
						&& (traceEnt->client->ps.saber_move == LS_READY || PM_SaberInParry(traceEnt->client->ps.saber_move) || PM_SaberInReturn(traceEnt->client->ps.saber_move))
						&& InFOV(self->currentOrigin, traceEnt->currentOrigin, traceEnt->client->ps.viewangles, 20, 35)
						&& !PM_InKnockDown(&traceEnt->client->ps)
						&& !PM_SuperBreakLoseAnim(traceEnt->client->ps.torsoAnim)
						&& !PM_SuperBreakWinAnim(traceEnt->client->ps.torsoAnim)
						&& !pm_saber_in_special_attack(traceEnt->client->ps.torsoAnim)
						&& !PM_InSpecialJump(traceEnt->client->ps.torsoAnim)
						&& !PM_SaberInKata(static_cast<saber_moveName_t>(traceEnt->client->ps.saber_move))
						&& traceEnt->client->ps.forcePower > 20)
					{
						if (traceEnt->client->ps.forcePowersActive & 1 << FP_ABSORB && traceEnt->client->ps.
							forcePowerLevel[FP_ABSORB] > FORCE_LEVEL_2)
						{
							//make them do a parry
							const float chance_of_fizz = Q_flrand(0.0f, 1.0f);
							vec3_t fwd{}, right, up;
							lightning_blocked = qtrue;
							VectorNegate(dir, fwd);

							//randomize direction a bit
							MakeNormalVectors(fwd, right, up);
							VectorMA(fwd, Q_irand(0, 360), right, fwd);
							VectorMA(fwd, Q_irand(0, 360), up, fwd);
							VectorNormalize(fwd);

							if (chance_of_fizz > 0)
							{
								vec3_t end;
								constexpr int npcblade_num = 0;
								constexpr int npcsaber_num = 0;
								VectorMA(traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].muzzlePoint,
									traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].length *
									Q_flrand(0, 1),
									traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].muzzleDir, end);
								G_PlayEffect(G_EffectIndex("saber/fizz.efx"), end, fwd);
							}

							switch (traceEnt->client->ps.saber_anim_level)
							{
							case SS_DUAL:
								NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P6_S6_T_, SETANIM_AFLAG_PACE);
								break;
							case SS_STAFF:
								NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P7_S7_T_, SETANIM_AFLAG_PACE);
								break;
							case SS_FAST:
							case SS_TAVION:
							case SS_STRONG:
							case SS_DESANN:
							case SS_MEDIUM:
							case SS_NONE:
							default:
								NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P1_S1_T_, SETANIM_AFLAG_PACE);
								break;
							}
							traceEnt->client->ps.weaponTime = Q_irand(300, 600);
							dmg = 0;
							WP_ForcePowerDrain(traceEnt, FP_ABSORB, fp_block_cost);
							if (d_combatinfo->integer || g_DebugSaberCombat->integer || g_lightningdamage->integer)
							{
								Com_Printf(S_COLOR_RED"JKA Mode Player Saber Absorb Lightning Block Correct\n");
							}
						}
						else
						{
							//make them do a parry
							const float chance_of_fizz = Q_flrand(0.0f, 1.0f);
							vec3_t fwd{}, right, up;
							lightning_blocked = qtrue;
							VectorNegate(dir, fwd);

							//randomize direction a bit
							MakeNormalVectors(fwd, right, up);
							VectorMA(fwd, Q_irand(0, 360), right, fwd);
							VectorMA(fwd, Q_irand(0, 360), up, fwd);
							VectorNormalize(fwd);

							if (chance_of_fizz > 0)
							{
								vec3_t end;
								constexpr int npcblade_num = 0;
								constexpr int npcsaber_num = 0;
								VectorMA(traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].muzzlePoint,
									traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].length *
									Q_flrand(0, 1),
									traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].muzzleDir, end);
								G_PlayEffect(G_EffectIndex("saber/fizz.efx"), end, fwd);
							}

							switch (traceEnt->client->ps.saber_anim_level)
							{
							case SS_DUAL:
								NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P6_S6_T_, SETANIM_AFLAG_PACE);
								break;
							case SS_STAFF:
								NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P7_S7_T_, SETANIM_AFLAG_PACE);
								break;
							case SS_FAST:
							case SS_TAVION:
							case SS_STRONG:
							case SS_DESANN:
							case SS_MEDIUM:
							case SS_NONE:
							default:
								NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P1_S1_T_, SETANIM_AFLAG_PACE);
								break;
							}
							traceEnt->client->ps.weaponTime = Q_irand(300, 600);
							dmg = 0;
							WP_ForcePowerDrain(traceEnt, FP_ABSORB, fp_block_cost);
							if (d_combatinfo->integer || g_DebugSaberCombat->integer || g_lightningdamage->integer)
							{
								Com_Printf(S_COLOR_RED"JKA Mode player Saber Lightning Block Correct\n");
							}
						}
					}
					else if (in_camera && !is_class_guard
						&& traceEnt->NPC
						&& traceEnt->client->ps.SaberActive()
						&& !traceEnt->client->ps.saberInFlight
						&& !PM_InKnockDown(&traceEnt->client->ps)
						&& InFOV(self->currentOrigin, traceEnt->currentOrigin, traceEnt->client->ps.viewangles, 20, 35))
					{
						//make them do a parry
						const float chance_of_fizz = Q_flrand(0.0f, 1.0f);
						vec3_t fwd{}, right, up;
						lightning_blocked = qtrue;
						VectorNegate(dir, fwd);

						//randomize direction a bit
						MakeNormalVectors(fwd, right, up);
						VectorMA(fwd, Q_irand(0, 360), right, fwd);
						VectorMA(fwd, Q_irand(0, 360), up, fwd);
						VectorNormalize(fwd);

						if (chance_of_fizz > 0)
						{
							vec3_t end;
							constexpr int npcblade_num = 0;
							constexpr int npcsaber_num = 0;
							VectorMA(traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].muzzlePoint,
								traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].length * Q_flrand(
									0, 1),
								traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].muzzleDir, end);
							G_PlayEffect(G_EffectIndex("saber/fizz.efx"), end, fwd);
						}

						switch (traceEnt->client->ps.saber_anim_level)
						{
						case SS_DUAL:
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P6_S6_TL, SETANIM_AFLAG_PACE);
							break;
						case SS_STAFF:
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P7_S7_TL, SETANIM_AFLAG_PACE);
							break;
						case SS_FAST:
						case SS_TAVION:
						case SS_STRONG:
						case SS_DESANN:
						case SS_MEDIUM:
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P1_S1_TL, SETANIM_AFLAG_PACE);
							break;
						case SS_NONE:
						default:
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P1_S1_TL, SETANIM_AFLAG_PACE);
							break;
						}
						traceEnt->client->ps.weaponTime = Q_irand(300, 600);
						dmg = 0;
						if (d_combatinfo->integer || g_DebugSaberCombat->integer || g_lightningdamage->integer)
						{
							Com_Printf(S_COLOR_RED"JKA Mode NPC Saber Lightning Block CIN Correct\n");
						}
					}
					else
					{
						dmg = 1;
					}
				}
				else if (traceEnt->s.weapon == WP_MELEE
					|| traceEnt->s.weapon == WP_NONE
					|| (traceEnt->client->ps.weapon == WP_SABER && !traceEnt->client->ps.SaberActive()))
				{
					if (!in_camera && !is_class_guard
						&& (Manual_Hand_Block_Lightning(traceEnt) && traceEnt->client->ps.forcePowerLevel[FP_ABSORB] > FORCE_LEVEL_2)
						&& !PM_InKnockDown(&traceEnt->client->ps)
						&& !PM_InRoll(&traceEnt->client->ps)
						&& traceEnt->client->ps.groundEntityNum != ENTITYNUM_NONE
						&& !PM_RunningAnim(traceEnt->client->ps.legsAnim)
						&& InFOV(self->currentOrigin, traceEnt->currentOrigin, traceEnt->client->ps.viewangles, 20, 35)
						&& traceEnt->client->ps.forcePower > 20)
					{
						NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_FORCE_2HANDEDLIGHTNING_HOLD, SETANIM_AFLAG_PACE);
						traceEnt->client->ps.weaponTime = Q_irand(300, 600);
						lightning_blocked = qtrue;

						if (traceEnt->ghoul2.size())
						{
							if (traceEnt->handRBolt != -1)
							{
								G_PlayEffect(G_EffectIndex("force/HBlockLightning.efx"), traceEnt->playerModel,
									traceEnt->handRBolt, traceEnt->s.number, traceEnt->currentOrigin, 1000,
									qtrue);
							}
							if (traceEnt->handLBolt != -1)
							{
								G_PlayEffect(G_EffectIndex("force/HBlockLightning.efx"), traceEnt->playerModel,
									traceEnt->handLBolt, traceEnt->s.number, traceEnt->currentOrigin, 1000,
									qtrue);
							}
						}
						traceEnt->client->ps.powerups[PW_MEDITATE] = level.time + traceEnt->client->ps.torsoAnimTimer + 5000;
						WP_ForcePowerDrain(traceEnt, FP_ABSORB, fp_block_cost);
						if (d_combatinfo->integer || g_DebugSaberCombat->integer || g_lightningdamage->integer)
						{
							Com_Printf(S_COLOR_RED"JKA Mode Player Hand Lightning Block Correct\n");
						}
					}
					else
					{
						dmg = 1;
					}
				}
			}

			if (traceEnt && traceEnt->client && traceEnt->client->ps.powerups[PW_GALAK_SHIELD])
			{
				//has shield up
				dmg = 0;
				lightning_blocked = qtrue;
			}

			if (traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_OBJECT)
			{
				dmg = 0;
				lightning_blocked = qtrue;
			}

			if (is_class_guard)
			{
				dmg = 1;
				lightning_blocked = qfalse;
			}

			int modPowerLevel = -1;

			if (traceEnt->client)
			{
				modPowerLevel = WP_AbsorbConversion(traceEnt, traceEnt->client->ps.forcePowerLevel[FP_ABSORB],
					FP_LIGHTNING,
					self->client->ps.forcePowerLevel[FP_LIGHTNING], 1);
			}

			if (modPowerLevel != -1)
			{
				if (!modPowerLevel)
				{
					dmg = 0;
				}
				else if (modPowerLevel == 1)
				{
					dmg = floor(static_cast<float>(dmg) / 4.0f);
				}
				else if (modPowerLevel == 2)
				{
					dmg = floor(static_cast<float>(dmg) / 2.0f);
				}
			}

			if (dmg && !lightning_blocked || is_class_guard) //jka
			{
				if (jedi_win_po(traceEnt))
				{
					G_Damage(traceEnt, self, self, dir, impact_point, dmg, DAMAGE_LIGHNING_KNOCKBACK,
						MOD_FORCE_LIGHTNING);
					if (g_lightningdamage->integer)
					{
						gi.Printf(S_COLOR_RED"WINDU JKA LIGHTNING KNOCKBACK TEST\n");
					}
				}
				else
				{
					G_Damage(traceEnt, self, self, dir, impact_point, dmg, DAMAGE_DEATH_KNOCKBACK,
						MOD_FORCE_LIGHTNING);
					if (g_lightningdamage->integer)
					{
						gi.Printf(S_COLOR_RED"NORMAL JKA LIGHTNING KNOCKBACK TEST\n");
					}
				}

				if (!in_camera && (traceEnt->NPC || (traceEnt->s.number < MAX_CLIENTS ||
					G_ControlledByPlayer(traceEnt))) && traceEnt->s.weapon != WP_EMPLACED_GUN
					&& !PM_SaberInKata(static_cast<saber_moveName_t>(traceEnt->client->ps.saber_move)))
				{
					if (PM_RunningAnim(traceEnt->client->ps.legsAnim) && traceEnt->client->ps.stats[STAT_HEALTH] > 1
						|| is_class_guard)
					{
						G_KnockOver(traceEnt, self, dir, 25, qtrue);
					}
					else if (!PM_RunningAnim(traceEnt->client->ps.legsAnim) && !PM_InKnockDown(&traceEnt->client->ps)
						&& traceEnt->client->ps.groundEntityNum != ENTITYNUM_NONE && traceEnt->client->ps.stats[
							STAT_HEALTH] > 1)
					{
						if (traceEnt->client->ps.stats[STAT_HEALTH] < 75)
						{
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_COWER1, SETANIM_AFLAG_PACE);
						}
						else if (traceEnt->client->ps.stats[STAT_HEALTH] < 50)
						{
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_SONICPAIN_HOLD, SETANIM_AFLAG_PACE);
						}
						else
						{
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_WIND, SETANIM_AFLAG_PACE);
						}
					}
					else if (traceEnt->client->ps.groundEntityNum == ENTITYNUM_NONE && traceEnt->client->ps.stats[
						STAT_HEALTH] > 1)
					{
						if (traceEnt->client->ps.stats[STAT_HEALTH] < 75)
						{
							NPC_SetAnim(traceEnt, SETANIM_BOTH, Q_irand(BOTH_SLAPDOWNRIGHT, BOTH_SLAPDOWNLEFT),
								SETANIM_AFLAG_PACE);
						}
						else
						{
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_WIND, SETANIM_AFLAG_PACE);
						}
					}
				}
			}

			if (traceEnt->client)
			{
				if (!Q_irand(0, 2))
				{
					G_Sound(traceEnt, G_SoundIndex(va("sound/weapons/force/lightninghit%d.mp3", Q_irand(1, 3))));
				}

				if (traceEnt->client && traceEnt->client->ps.powerups[PW_CLOAKED])
				{
					//disable cloak temporarily
					player_decloak(traceEnt);
					G_AddVoiceEvent(traceEnt, Q_irand(EV_ANGER1, EV_ANGER3), 10000);
				}
				traceEnt->s.powerups |= 1 << PW_SHOCKED;

				if (traceEnt && traceEnt->client &&
					(traceEnt->health <= 0 || traceEnt->client->NPC_class == CLASS_ATST
						|| traceEnt->client->NPC_class == CLASS_GONK
						|| traceEnt->client->NPC_class == CLASS_INTERROGATOR
						|| traceEnt->client->NPC_class == CLASS_MARK1
						|| traceEnt->client->NPC_class == CLASS_MARK2
						|| traceEnt->client->NPC_class == CLASS_MOUSE
						|| traceEnt->client->NPC_class == CLASS_PROBE
						|| traceEnt->client->NPC_class == CLASS_PROTOCOL
						|| traceEnt->client->NPC_class == CLASS_R2D2
						|| traceEnt->client->NPC_class == CLASS_R5D2
						|| traceEnt->client->NPC_class == CLASS_SEEKER
						|| traceEnt->client->NPC_class == CLASS_SENTRY
						|| traceEnt->client->NPC_class == CLASS_SBD
						|| traceEnt->client->NPC_class == CLASS_BATTLEDROID
						|| traceEnt->client->NPC_class == CLASS_DROIDEKA
						|| traceEnt->client->NPC_class == CLASS_OBJECT
						|| traceEnt->client->NPC_class == CLASS_ASSASSIN_DROID
						|| traceEnt->client->NPC_class == CLASS_SABER_DROID))
				{
					// special droid only behaviors
					traceEnt->client->ps.powerups[PW_SHOCKED] = level.time + 4000;
				}
				else if (lightning_blocked)
				{
					traceEnt->client->ps.powerups[PW_SHOCKED] = 0;
				}
				else
				{
					traceEnt->client->ps.powerups[PW_SHOCKED] = level.time + 1500;
				}
			}
		}
	}
}

static void ForceLightningDamage_AMD(gentity_t* self, gentity_t* traceEnt, vec3_t dir, const float dist, const float dot,
	vec3_t impact_point)
{
	qboolean lightning_blocked = qfalse;
	qboolean is_class_guard = qfalse;

	if (traceEnt->NPC && traceEnt->NPC->scriptFlags & SCF_NO_FORCE)
	{
		if (!in_camera
			&& traceEnt->health > 0)
		{
			if ((!Q_stricmp("Yoda", traceEnt->NPC_type) ||
				!Q_stricmp("Ep1_Yoda", traceEnt->NPC_type) ||
				!Q_stricmp("Ep2_Yoda", traceEnt->NPC_type) ||
				!Q_stricmp("Ep3_Yoda", traceEnt->NPC_type) ||
				!Q_stricmp("md_yoda", traceEnt->NPC_type) ||
				!Q_stricmp("md_yoda_ep2", traceEnt->NPC_type) ||
				!Q_stricmp("md_yoda_ot", traceEnt->NPC_type) ||
				!Q_stricmp("md_yoda_hr", traceEnt->NPC_type) ||
				char_is_force_user_attacker(traceEnt))
				&& traceEnt->s.weapon == WP_SABER
				&& traceEnt->client->ps.SaberActive()
				&& !traceEnt->client->ps.saberInFlight
				&& (traceEnt->client->ps.saber_move == LS_READY || PM_SaberInParry(traceEnt->client->ps.saber_move) ||
					PM_SaberInReturn(traceEnt->client->ps.saber_move))
				&& InFOV(self->currentOrigin, traceEnt->currentOrigin, traceEnt->client->ps.viewangles, 20, 35)
				&& !PM_InKnockDown(&traceEnt->client->ps)
				&& !PM_SuperBreakLoseAnim(traceEnt->client->ps.torsoAnim)
				&& !PM_SuperBreakWinAnim(traceEnt->client->ps.torsoAnim)
				&& !pm_saber_in_special_attack(traceEnt->client->ps.torsoAnim)
				&& !PM_InSpecialJump(traceEnt->client->ps.torsoAnim))
			{
				//saber can block lightning
				//make them do a parry
				const float chance_of_fizz = Q_flrand(0.0f, 1.0f);
				vec3_t fwd{}, right, up;
				VectorNegate(dir, fwd);

				//randomize direction a bit
				MakeNormalVectors(fwd, right, up);
				VectorMA(fwd, Q_irand(0, 360), right, fwd);
				VectorMA(fwd, Q_irand(0, 360), up, fwd);
				VectorNormalize(fwd);

				if (chance_of_fizz > 0)
				{
					vec3_t end;
					constexpr int npcblade_num = 0;
					constexpr int npcsaber_num = 0;
					VectorMA(traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].muzzlePoint,
						traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].length * Q_flrand(0, 1),
						traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].muzzleDir, end);
					G_PlayEffect(G_EffectIndex("saber/fizz.efx"), end, fwd);
				}

				switch (traceEnt->client->ps.saber_anim_level)
				{
				case SS_DUAL:
					NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P6_S6_T_, SETANIM_AFLAG_PACE);
					break;
				case SS_STAFF:
					NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P7_S7_T_, SETANIM_AFLAG_PACE);
					break;
				case SS_FAST:
				case SS_TAVION:
				case SS_STRONG:
				case SS_DESANN:
				case SS_MEDIUM:
				case SS_NONE:
				default:
					NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P1_S1_T_, SETANIM_AFLAG_PACE);
					break;
				}
				lightning_blocked = qtrue;
				traceEnt->client->ps.weaponTime = Q_irand(300, 600);
				if (d_combatinfo->integer || g_DebugSaberCombat->integer || g_lightningdamage->integer)
				{
					Com_Printf(S_COLOR_RED"AMD Mode NPC Saber Lightning Block No Force Correct\n");
				}
			}
			else if ((!Q_stricmp("Yoda", traceEnt->NPC_type) ||
				!Q_stricmp("Ep1_Yoda", traceEnt->NPC_type) ||
				!Q_stricmp("Ep2_Yoda", traceEnt->NPC_type) ||
				!Q_stricmp("Ep3_Yoda", traceEnt->NPC_type) ||
				!Q_stricmp("md_yoda", traceEnt->NPC_type) ||
				!Q_stricmp("md_yoda_ep2", traceEnt->NPC_type) ||
				!Q_stricmp("md_yoda_ot", traceEnt->NPC_type) ||
				!Q_stricmp("md_yoda_hr", traceEnt->NPC_type) ||
				char_is_force_user_attacker(traceEnt))
				&& traceEnt->s.weapon == WP_MELEE || traceEnt->s.weapon == WP_NONE || traceEnt->client->ps.weapon ==
				WP_SABER && !traceEnt->client->ps.SaberActive()
				&& !PM_InKnockDown(&traceEnt->client->ps)
				&& !PM_InRoll(&traceEnt->client->ps)
				&& traceEnt->client->ps.groundEntityNum != ENTITYNUM_NONE
				&& !PM_RunningAnim(traceEnt->client->ps.legsAnim)
				&& InFOV(self->currentOrigin, traceEnt->currentOrigin, traceEnt->client->ps.viewangles, 20, 35))
			{
				NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_FORCE_2HANDEDLIGHTNING_HOLD, SETANIM_AFLAG_PACE);
				traceEnt->client->ps.weaponTime = Q_irand(300, 600);
				lightning_blocked = qtrue;

				if (traceEnt->enemy
					&& traceEnt->ghoul2.size())
				{
					if (traceEnt->handRBolt != -1)
					{
						G_PlayEffect(G_EffectIndex("force/HBlockLightning.efx"), traceEnt->playerModel,
							traceEnt->handRBolt, traceEnt->s.number, traceEnt->currentOrigin, 1000, qtrue);
					}
					if (traceEnt->handLBolt != -1)
					{
						G_PlayEffect(G_EffectIndex("force/HBlockLightning.efx"), traceEnt->playerModel,
							traceEnt->handLBolt, traceEnt->s.number, traceEnt->currentOrigin, 1000, qtrue);
					}
					traceEnt->client->ps.powerups[PW_MEDITATE] = level.time + traceEnt->client->ps.torsoAnimTimer + 5000;
					if (d_combatinfo->integer || g_DebugSaberCombat->integer || g_lightningdamage->integer)
					{
						Com_Printf(S_COLOR_RED"AMD Mode NPC hand Lightning Block No Force Correct\n");
					}
				}
			}
			else
			{
				NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_WIND, SETANIM_AFLAG_PACE);
				traceEnt->client->ps.weaponTime = Q_irand(300, 600);
				lightning_blocked = qtrue;
				traceEnt->client->ps.powerups[PW_MEDITATE] = level.time + traceEnt->client->ps.torsoAnimTimer + 5000;
				if (d_combatinfo->integer || g_DebugSaberCombat->integer || g_lightningdamage->integer)
				{
					Com_Printf(S_COLOR_RED"AMD Mode NPC NO Force Lightning Block Correct\n");
				}
			}
		}
		return;
	}

	if (traceEnt->flags & FL_NOTARGET || traceEnt->noclip)
	{
		return;
	}

	if (traceEnt && traceEnt->takedamage)
	{
		if (traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_GUARD)
		{
			is_class_guard = qtrue;
		}
		if (!traceEnt->client || traceEnt->client->playerTeam != self->client->playerTeam || self->enemy == traceEnt
			||
			traceEnt->enemy == self || traceEnt->client->playerTeam == TEAM_SOLO || self->client->playerTeam ==
			TEAM_SOLO || is_class_guard)
		{
			int fp_block_cost;
			//an enemy or object
			int dmg;

			if (self->client->ps.forcePowerLevel[FP_LIGHTNING] > FORCE_LEVEL_2)
			{
				//more damage if closer and more in front
				dmg = 1;

				if (self->client->NPC_class == CLASS_REBORN && self->client->ps.weapon == WP_NONE)
				{
					//Cultist: looks fancy, but does less damage
				}
				else
				{
					if (dist < 100)
					{
						dmg += 2;
					}
					else if (dist < 200)
					{
						dmg += 1;
					}
					if (dot > 0.9f)
					{
						dmg += 2;
					}
					else if (dot > 0.7f)
					{
						dmg += 1;
					}
				}
				if (self->client->ps.torsoAnim == BOTH_FORCE_2HANDEDLIGHTNING
					|| self->client->ps.torsoAnim == BOTH_FORCE_2HANDEDLIGHTNING_OLD
					|| self->client->ps.torsoAnim == BOTH_FORCE_2HANDEDLIGHTNING_NEW
					|| self->client->ps.torsoAnim == BOTH_FORCE_2HANDEDLIGHTNING_START
					|| self->client->ps.torsoAnim == BOTH_FORCE_2HANDEDLIGHTNING_HOLD
					|| self->client->ps.torsoAnim == BOTH_FORCE_2HANDEDLIGHTNING_RELEASE)
				{
					//jackin' 'em up, Palpatine-style
					dmg *= 2;
				}
			}
			else
			{
				dmg = Q_irand(1, 3);
			}

			if (traceEnt->client && traceEnt->NPC)
			{
				if (jedi_win_po(traceEnt))
				{
					fp_block_cost = Q_irand(0, 1);
				}
				else
				{
					fp_block_cost = Q_irand(1, 2);
				}
			}
			else
			{
				fp_block_cost = 1;
			}
			const int np_cfp_block_cost = Q_irand(1, 3);

			if (traceEnt->client && traceEnt->health > 0)
			{
				if (traceEnt->client
					&& traceEnt->health > 0
					&& traceEnt->NPC
					&& !in_camera && !is_class_guard)
				{
					if (traceEnt->s.weapon == WP_SABER
						&& traceEnt->client->ps.SaberActive()
						&& !traceEnt->client->ps.saberInFlight
						&& (traceEnt->client->ps.saber_move == LS_READY || PM_SaberInParry(traceEnt->client->ps.saber_move) || PM_SaberInReturn(traceEnt->client->ps.saber_move))
						&& InFOV(self->currentOrigin, traceEnt->currentOrigin, traceEnt->client->ps.viewangles, 20, 35)
						&& !PM_InKnockDown(&traceEnt->client->ps)
						&& !PM_SuperBreakLoseAnim(traceEnt->client->ps.torsoAnim)
						&& !PM_SuperBreakWinAnim(traceEnt->client->ps.torsoAnim)
						&& !pm_saber_in_special_attack(traceEnt->client->ps.torsoAnim)
						&& !PM_InSpecialJump(traceEnt->client->ps.torsoAnim)
						&& !PM_SaberInKata(static_cast<saber_moveName_t>(traceEnt->client->ps.saber_move))
						&& traceEnt->client->ps.blockPoints > 5)
					{
						//saber can block lightning
						//make them do a parry
						const float chance_of_fizz = Q_flrand(0.0f, 1.0f);
						vec3_t fwd{}, right, up;
						lightning_blocked = qtrue;
						VectorNegate(dir, fwd);

						//randomize direction a bit
						MakeNormalVectors(fwd, right, up);
						VectorMA(fwd, Q_irand(0, 360), right, fwd);
						VectorMA(fwd, Q_irand(0, 360), up, fwd);
						VectorNormalize(fwd);

						if (chance_of_fizz > 0)
						{
							vec3_t end;
							constexpr int npcblade_num = 0;
							constexpr int npcsaber_num = 0;
							VectorMA(traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].muzzlePoint,
								traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].length * Q_flrand(
									0, 1),
								traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].muzzleDir, end);
							G_PlayEffect(G_EffectIndex("saber/fizz.efx"), end, fwd);
						}

						switch (traceEnt->client->ps.saber_anim_level)
						{
						case SS_DUAL:
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P6_S6_T_, SETANIM_AFLAG_PACE);
							break;
						case SS_STAFF:
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P7_S7_T_, SETANIM_AFLAG_PACE);
							break;
						case SS_FAST:
						case SS_TAVION:
						case SS_STRONG:
						case SS_DESANN:
						case SS_MEDIUM:
						case SS_NONE:
						default:
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P1_S1_T_, SETANIM_AFLAG_PACE);
							break;
						}
						traceEnt->client->ps.weaponTime = Q_irand(300, 600);

						if (traceEnt->client->ps.blockPoints < BLOCKPOINTS_HALF && jedi_win_po(traceEnt))
						{
							WP_ForcePowerDrain(traceEnt, FP_ABSORB, fp_block_cost);
						}
						else
						{
							WP_BlockPointsDrain(traceEnt, fp_block_cost);
						}

						dmg = Q_irand(0, 1);
						if (d_combatinfo->integer || g_DebugSaberCombat->integer || g_lightningdamage->integer)
						{
							Com_Printf(S_COLOR_GREEN"AMD Mode NPC Saber Lightning Block Correct\n");
						}
					}
					else if ((traceEnt->NPC && traceEnt->NPC->rank >= RANK_LT_COMM)
						&& (traceEnt->s.weapon == WP_MELEE || traceEnt->s.weapon == WP_NONE
							|| (traceEnt->client->ps.weapon == WP_SABER && !traceEnt->client->ps.SaberActive()))
						&& !PM_InKnockDown(&traceEnt->client->ps)
						&& !PM_InRoll(&traceEnt->client->ps)
						&& traceEnt->client->ps.groundEntityNum != ENTITYNUM_NONE
						&& !PM_RunningAnim(traceEnt->client->ps.legsAnim)
						&& !PM_InSpecialJump(traceEnt->client->ps.torsoAnim)
						&& InFOV(self->currentOrigin, traceEnt->currentOrigin, traceEnt->client->ps.viewangles, 20, 35)
						&& traceEnt->client->ps.forcePower > 20)
					{
						if (Manual_Hand_Block_Lightning_NPC(self, traceEnt, FP_LIGHTNING))
						{
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_FORCE_2HANDEDLIGHTNING_HOLD, SETANIM_AFLAG_PACE);
							traceEnt->client->ps.weaponTime = Q_irand(300, 600);
							lightning_blocked = qtrue;

							if (traceEnt->ghoul2.size())
							{
								if (traceEnt->handRBolt != -1)
								{
									G_PlayEffect(G_EffectIndex("force/HBlockLightning.efx"), traceEnt->playerModel,
										traceEnt->handRBolt, traceEnt->s.number, traceEnt->currentOrigin, 1000,
										qtrue);
								}
								if (traceEnt->handLBolt != -1)
								{
									G_PlayEffect(G_EffectIndex("force/HBlockLightning.efx"), traceEnt->playerModel,
										traceEnt->handLBolt, traceEnt->s.number, traceEnt->currentOrigin, 1000,
										qtrue);
								}
							}
							traceEnt->client->ps.powerups[PW_MEDITATE] = level.time + traceEnt->client->ps.torsoAnimTimer + 5000;

							WP_ForcePowerDrain(traceEnt, FP_ABSORB, np_cfp_block_cost);

							dmg = Q_irand(0, 1);
							if (d_combatinfo->integer || g_DebugSaberCombat->integer || g_lightningdamage->integer)
							{
								Com_Printf(S_COLOR_RED"AMD Mode NPC Hand Lightning Block Correct\n");
							}
						}
					}
				}
				else if (traceEnt->s.weapon == WP_SABER && traceEnt->client->ps.SaberActive())
				{
					if (!in_camera && !is_class_guard && manual_saberblocking(traceEnt)
						&& InFOV(self->currentOrigin, traceEnt->currentOrigin, traceEnt->client->ps.viewangles, 20, 35)
						&& !PM_SaberInKata(static_cast<saber_moveName_t>(traceEnt->client->ps.saber_move))
						&& traceEnt->client->ps.blockPoints > 5)
					{
						//saber can block lightning
						const qboolean active_blocking =
							traceEnt->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCKANDATTACK ? qtrue : qfalse;
						//Active Blocking
						//make them do a parry
						const float chance_of_fizz = Q_flrand(0.0f, 1.0f);
						vec3_t fwd{}, right, up;
						lightning_blocked = qtrue;
						VectorNegate(dir, fwd);
						//randomize direction a bit
						MakeNormalVectors(fwd, right, up);
						VectorMA(fwd, Q_irand(0, 360), right, fwd);
						VectorMA(fwd, Q_irand(0, 360), up, fwd);
						VectorNormalize(fwd);

						if (chance_of_fizz > 0)
						{
							vec3_t end;
							constexpr int npcblade_num = 0;
							constexpr int npcsaber_num = 0;
							VectorMA(traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].muzzlePoint,
								traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].length * Q_flrand(
									0, 1),
								traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].muzzleDir, end);
							if (traceEnt->client->ps.blockPoints > 50)
							{
								G_PlayEffect(G_EffectIndex("saber/saber_Lightninghit.efx"), end, fwd);
							}
							else
							{
								G_PlayEffect(G_EffectIndex("saber/fizz.efx"), end, fwd);
							}
						}

						switch (traceEnt->client->ps.saber_anim_level)
						{
						case SS_DUAL:
							if (active_blocking)
							{
								NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P6_S6_T__MD, SETANIM_AFLAG_PACE);
								traceEnt->client->IsBlockingLightning = qtrue;
							}
							else
							{
								if (g_RealisticBlockingMode->integer)
								{
									NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P6_S6_T__MD, SETANIM_AFLAG_PACE);
								}
								else
								{
									NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_STAND_BLOCKING_ON_DUAL,
										SETANIM_AFLAG_PACE);
								}
								traceEnt->client->IsBlockingLightning = qfalse;
							}
							break;
						case SS_STAFF:
							if (active_blocking)
							{
								NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P7_S7_T__MD, SETANIM_AFLAG_PACE);
								traceEnt->client->IsBlockingLightning = qtrue;
							}
							else
							{
								if (g_RealisticBlockingMode->integer)
								{
									NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P7_S7_T__MD, SETANIM_AFLAG_PACE);
								}
								else
								{
									NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_STAND_BLOCKING_ON_STAFF,
										SETANIM_AFLAG_PACE);
								}
								traceEnt->client->IsBlockingLightning = qfalse;
							}
							break;
						case SS_FAST:
						case SS_TAVION:
						case SS_STRONG:
						case SS_DESANN:
						case SS_MEDIUM:
							if (active_blocking)
							{
								NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P1_S1_T__MD, SETANIM_AFLAG_PACE);
								traceEnt->client->IsBlockingLightning = qtrue;
							}
							else
							{
								if (g_RealisticBlockingMode->integer)
								{
									NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P1_S1_T__MD, SETANIM_AFLAG_PACE);
								}
								else
								{
									NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_STAND_BLOCKING_ON, SETANIM_AFLAG_PACE);
								}
								traceEnt->client->IsBlockingLightning = qfalse;
							}
							break;
						case SS_NONE:
						default:
							if (active_blocking)
							{
								NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P1_S1_T__MD, SETANIM_AFLAG_PACE);
								traceEnt->client->IsBlockingLightning = qtrue;
							}
							else
							{
								if (g_RealisticBlockingMode->integer)
								{
									NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P1_S1_T__MD, SETANIM_AFLAG_PACE);
								}
								else
								{
									NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_STAND_BLOCKING_ON, SETANIM_AFLAG_PACE);
								}
								traceEnt->client->IsBlockingLightning = qfalse;
							}
							break;
						}
						traceEnt->client->ps.weaponTime = Q_irand(300, 600);
						dmg = 0;

						if (active_blocking)
						{
							PM_AddBlockFatigue(&traceEnt->client->ps, fp_block_cost);
						}
						else
						{
							WP_ForcePowerDrain(traceEnt, FP_ABSORB, fp_block_cost);
						}

						if (d_combatinfo->integer || g_DebugSaberCombat->integer || g_lightningdamage->integer)
						{
							Com_Printf(S_COLOR_RED"AMD Mode Player Saber Lightning Block Correct\n");
						}
					}
					else if (in_camera && !is_class_guard
						&& traceEnt->NPC
						&& traceEnt->client->ps.SaberActive()
						&& !traceEnt->client->ps.saberInFlight
						&& !PM_InKnockDown(&traceEnt->client->ps)
						&& InFOV(self->currentOrigin, traceEnt->currentOrigin, traceEnt->client->ps.viewangles, 20, 35))
					{
						const float chance_of_fizz = Q_flrand(0.0f, 1.0f);
						vec3_t fwd{}, right, up;
						lightning_blocked = qtrue;
						VectorNegate(dir, fwd);
						//randomize direction a bit
						MakeNormalVectors(fwd, right, up);
						VectorMA(fwd, Q_irand(0, 360), right, fwd);
						VectorMA(fwd, Q_irand(0, 360), up, fwd);
						VectorNormalize(fwd);

						if (chance_of_fizz > 0)
						{
							vec3_t end;
							constexpr int npcblade_num = 0;
							constexpr int npcsaber_num = 0;
							VectorMA(traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].muzzlePoint,
								traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].length * Q_flrand(
									0, 1),
								traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].muzzleDir, end);
							G_PlayEffect(G_EffectIndex("saber/fizz.efx"), end, fwd);
						}

						switch (traceEnt->client->ps.saber_anim_level)
						{
						case SS_DUAL:
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P6_S6_TL, SETANIM_AFLAG_PACE);
							break;
						case SS_STAFF:
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P7_S7_TL, SETANIM_AFLAG_PACE);
							break;
						case SS_FAST:
						case SS_TAVION:
						case SS_STRONG:
						case SS_DESANN:
						case SS_MEDIUM:
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P1_S1_TL, SETANIM_AFLAG_PACE);
							break;
						case SS_NONE:
						default:
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P1_S1_TL, SETANIM_AFLAG_PACE);
							break;
						}
						traceEnt->client->ps.weaponTime = Q_irand(300, 600);
						dmg = 0;
						if (d_combatinfo->integer || g_DebugSaberCombat->integer || g_lightningdamage->integer)
						{
							Com_Printf(S_COLOR_RED"AMD Mode NPC Saber Lightning Block CIN Correct\n");
						}
					}
					else if (!in_camera && !is_class_guard && (traceEnt->client->ps.forcePowersActive & 1 << FP_ABSORB
						&&
						traceEnt->client->ps.forcePowerLevel[FP_ABSORB] > FORCE_LEVEL_2)
						&& traceEnt->client->ps.forcePower > 20
						&& !PM_InKnockDown(&traceEnt->client->ps)
						&& !PM_InRoll(&traceEnt->client->ps)
						&& traceEnt->client->ps.groundEntityNum != ENTITYNUM_NONE
						&& !PM_RunningAnim(traceEnt->client->ps.legsAnim)
						&& InFOV(self->currentOrigin, traceEnt->currentOrigin, traceEnt->client->ps.viewangles, 20, 35))
					{
						//make them do a parry
						const float chance_of_fizz = Q_flrand(0.0f, 1.0f);
						vec3_t fwd{}, right, up;
						lightning_blocked = qtrue;
						VectorNegate(dir, fwd);
						//randomize direction a bit
						MakeNormalVectors(fwd, right, up);
						VectorMA(fwd, Q_irand(0, 360), right, fwd);
						VectorMA(fwd, Q_irand(0, 360), up, fwd);
						VectorNormalize(fwd);

						if (chance_of_fizz > 0)
						{
							vec3_t end;
							constexpr int npcblade_num = 0;
							constexpr int npcsaber_num = 0;
							VectorMA(traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].muzzlePoint,
								traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].length * Q_flrand(
									0, 1),
								traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].muzzleDir, end);
							if (traceEnt->client->ps.blockPoints > 50)
							{
								G_PlayEffect(G_EffectIndex("saber/saber_Lightninghit.efx"), end, fwd);
							}
							else
							{
								G_PlayEffect(G_EffectIndex("saber/fizz.efx"), end, fwd);
							}
						}

						switch (traceEnt->client->ps.saber_anim_level)
						{
						case SS_DUAL:
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P6_S6_T__MD, SETANIM_AFLAG_PACE);
							break;
						case SS_STAFF:
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P7_S7_T__MD, SETANIM_AFLAG_PACE);
							break;
						case SS_FAST:
						case SS_TAVION:
						case SS_STRONG:
						case SS_DESANN:
						case SS_MEDIUM:
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P1_S1_T__MD, SETANIM_AFLAG_PACE);
							break;
						case SS_NONE:
						default:
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P1_S1_T__MD, SETANIM_AFLAG_PACE);
							break;
						}
						traceEnt->client->ps.weaponTime = Q_irand(300, 600);
						dmg = 0;
						WP_ForcePowerDrain(traceEnt, FP_ABSORB, fp_block_cost);
						if (d_combatinfo->integer || g_DebugSaberCombat->integer || g_lightningdamage->integer)
						{
							Com_Printf(S_COLOR_RED"AMD Mode Player Saber Absorb Lightning Block Correct\n");
						}
					}
					else
					{
						dmg = 1;
					}
				}
				else if (traceEnt->s.weapon == WP_MELEE
					|| traceEnt->s.weapon == WP_NONE
					|| (traceEnt->client->ps.weapon == WP_SABER && !traceEnt->client->ps.SaberActive()))
				{
					if (!in_camera && !is_class_guard
						&& (Manual_Hand_Block_Lightning(traceEnt) && traceEnt->client->ps.forcePowerLevel[FP_ABSORB] > FORCE_LEVEL_2)
						&& !PM_InKnockDown(&traceEnt->client->ps)
						&& !PM_InRoll(&traceEnt->client->ps)
						&& traceEnt->client->ps.groundEntityNum != ENTITYNUM_NONE
						&& !PM_RunningAnim(traceEnt->client->ps.legsAnim)
						&& InFOV(self->currentOrigin, traceEnt->currentOrigin, traceEnt->client->ps.viewangles, 20, 35)
						&& traceEnt->client->ps.forcePower > 20)
					{
						NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_FORCE_2HANDEDLIGHTNING_HOLD, SETANIM_AFLAG_PACE);
						traceEnt->client->ps.weaponTime = Q_irand(300, 600);
						lightning_blocked = qtrue;

						if (traceEnt->ghoul2.size())
						{
							if (traceEnt->handRBolt != -1)
							{
								G_PlayEffect(G_EffectIndex("force/HBlockLightning.efx"), traceEnt->playerModel,
									traceEnt->handRBolt, traceEnt->s.number, traceEnt->currentOrigin, 1000,
									qtrue);
							}
							if (traceEnt->handLBolt != -1)
							{
								G_PlayEffect(G_EffectIndex("force/HBlockLightning.efx"), traceEnt->playerModel,
									traceEnt->handLBolt, traceEnt->s.number, traceEnt->currentOrigin, 1000,
									qtrue);
							}
						}
						traceEnt->client->ps.powerups[PW_MEDITATE] = level.time + traceEnt->client->ps.torsoAnimTimer + 5000;
						WP_ForcePowerDrain(traceEnt, FP_ABSORB, fp_block_cost);
						if (d_combatinfo->integer || g_DebugSaberCombat->integer || g_lightningdamage->integer)
						{
							Com_Printf(S_COLOR_RED"AMD Mode Player Hand Lightning Block Correct\n");
						}
					}
					else
					{
						dmg = 1;
					}
				}
			}

			if (traceEnt && traceEnt->client && traceEnt->client->ps.powerups[PW_GALAK_SHIELD])
			{
				//has shield up
				dmg = 0;
				lightning_blocked = qtrue;
			}

			if (traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_OBJECT)
			{
				dmg = 0;
				lightning_blocked = qtrue;
			}

			if (is_class_guard)
			{
				dmg = 1;
				lightning_blocked = qfalse;
			}

			int mod_power_level = -1;

			if (traceEnt->client)
			{
				mod_power_level = WP_AbsorbConversion(traceEnt, traceEnt->client->ps.forcePowerLevel[FP_ABSORB],
					FP_LIGHTNING,
					self->client->ps.forcePowerLevel[FP_LIGHTNING], 1);
			}

			if (mod_power_level != -1)
			{
				if (!mod_power_level)
				{
					dmg = 0;
				}
				else if (mod_power_level == 1)
				{
					dmg = floor(static_cast<float>(dmg) / 4.0f);
				}
				else if (mod_power_level == 2)
				{
					dmg = floor(static_cast<float>(dmg) / 2.0f);
				}
			}

			if (dmg && !lightning_blocked || is_class_guard) //amd
			{
				if (jedi_win_po(traceEnt))
				{
					G_Damage(traceEnt, self, self, dir, impact_point, dmg, DAMAGE_LIGHNING_KNOCKBACK,
						MOD_FORCE_LIGHTNING);
					if (g_lightningdamage->integer)
					{
						gi.Printf(S_COLOR_RED"WINDU AMD LIGHTNING DAMAGE KNOCKBACK TEST\n");
					}
				}
				else
				{
					G_Damage(traceEnt, self, self, dir, impact_point, dmg, DAMAGE_DEATH_KNOCKBACK,
						MOD_FORCE_LIGHTNING);
					if (g_lightningdamage->integer)
					{
						gi.Printf(S_COLOR_RED"NORMAL AMD LIGHTNING DAMAGE KNOCKBACK TEST\n");
					}
				}

				if (!in_camera &&
					traceEnt->s.weapon != WP_EMPLACED_GUN &&
					(traceEnt->NPC || traceEnt->s.eType == ET_PLAYER || (traceEnt->s.number < MAX_CLIENTS || G_ControlledByPlayer(traceEnt))))
				{
					if (traceEnt && traceEnt->client && traceEnt->client->ps.stats[STAT_HEALTH] <= 35)
					{
						traceEnt->client->stunDamage = 5;
						traceEnt->client->stunTime = level.time + 1000;

						gentity_t* tent = G_TempEntity(traceEnt->currentOrigin, EV_STUNNED);
						tent->owner = traceEnt;
					}

					if (PM_RunningAnim(traceEnt->client->ps.legsAnim) &&
						(traceEnt->client->ps.stats[STAT_HEALTH] > 1 || is_class_guard))
					{
						G_KnockOver(traceEnt, self, dir, 25, qtrue);
					}
					else if (!PM_RunningAnim(traceEnt->client->ps.legsAnim) && !PM_InKnockDown(&traceEnt->client->ps)
						&& traceEnt->client->ps.groundEntityNum != ENTITYNUM_NONE && traceEnt->client->ps.stats[
							STAT_HEALTH] > 1)
					{
						if (traceEnt->client->ps.stats[STAT_HEALTH] < 75)
						{
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_COWER1, SETANIM_AFLAG_PACE);
						}
						else if (traceEnt->client->ps.stats[STAT_HEALTH] < 50)
						{
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_SONICPAIN_HOLD, SETANIM_AFLAG_PACE);
						}
						else
						{
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_WIND, SETANIM_AFLAG_PACE);
						}
					}
					else if (traceEnt->client->ps.groundEntityNum == ENTITYNUM_NONE && traceEnt->client->ps.stats[
						STAT_HEALTH] > 1)
					{
						if (traceEnt->client->ps.stats[STAT_HEALTH] < 75)
						{
							NPC_SetAnim(traceEnt, SETANIM_BOTH, Q_irand(BOTH_SLAPDOWNRIGHT, BOTH_SLAPDOWNLEFT),
								SETANIM_AFLAG_PACE);
						}
						else
						{
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_WIND, SETANIM_AFLAG_PACE);
						}
					}
				}
			}

			if (traceEnt->client)
			{
				if (!Q_irand(0, 2))
				{
					G_Sound(traceEnt, G_SoundIndex(va("sound/weapons/force/lightninghit%d.mp3", Q_irand(1, 3))));
				}

				if (traceEnt->client && traceEnt->client->ps.powerups[PW_CLOAKED])
				{
					//disable cloak temporarily
					player_decloak(traceEnt);
					G_AddVoiceEvent(traceEnt, Q_irand(EV_ANGER1, EV_ANGER3), 10000);
				}
				traceEnt->s.powerups |= 1 << PW_SHOCKED;

				if (traceEnt && traceEnt->client &&
					(traceEnt->health <= 0 || traceEnt->client->NPC_class == CLASS_ATST
						|| traceEnt->client->NPC_class == CLASS_GONK
						|| traceEnt->client->NPC_class == CLASS_INTERROGATOR
						|| traceEnt->client->NPC_class == CLASS_MARK1
						|| traceEnt->client->NPC_class == CLASS_MARK2
						|| traceEnt->client->NPC_class == CLASS_MOUSE
						|| traceEnt->client->NPC_class == CLASS_PROBE
						|| traceEnt->client->NPC_class == CLASS_PROTOCOL
						|| traceEnt->client->NPC_class == CLASS_R2D2
						|| traceEnt->client->NPC_class == CLASS_R5D2
						|| traceEnt->client->NPC_class == CLASS_SEEKER
						|| traceEnt->client->NPC_class == CLASS_SENTRY
						|| traceEnt->client->NPC_class == CLASS_SBD
						|| traceEnt->client->NPC_class == CLASS_BATTLEDROID
						|| traceEnt->client->NPC_class == CLASS_DROIDEKA
						|| traceEnt->client->NPC_class == CLASS_OBJECT
						|| traceEnt->client->NPC_class == CLASS_ASSASSIN_DROID
						|| traceEnt->client->NPC_class == CLASS_SABER_DROID))
				{
					// special droid only behaviors
					traceEnt->client->ps.powerups[PW_SHOCKED] = level.time + 4000;
				}
				else if (lightning_blocked)
				{
					traceEnt->client->ps.powerups[PW_SHOCKED] = 0;
				}
				else
				{
					traceEnt->client->ps.powerups[PW_SHOCKED] = level.time + 1500;
				}
			}
		}
	}
}

static void ForceLightningDamage_MD(gentity_t* self, gentity_t* traceEnt, vec3_t dir, const float dist, const float dot,
	vec3_t impact_point)
{
	qboolean lightning_blocked = qfalse;
	qboolean is_class_guard = qfalse;

	if (traceEnt->NPC && traceEnt->NPC->scriptFlags & SCF_NO_FORCE)
	{
		if (!in_camera
			&& traceEnt->health > 0)
		{
			if ((!Q_stricmp("Yoda", traceEnt->NPC_type) ||
				!Q_stricmp("Ep1_Yoda", traceEnt->NPC_type) ||
				!Q_stricmp("Ep2_Yoda", traceEnt->NPC_type) ||
				!Q_stricmp("Ep3_Yoda", traceEnt->NPC_type) ||
				!Q_stricmp("md_yoda", traceEnt->NPC_type) ||
				!Q_stricmp("md_yoda_ep2", traceEnt->NPC_type) ||
				!Q_stricmp("md_yoda_ot", traceEnt->NPC_type) ||
				!Q_stricmp("md_yoda_hr", traceEnt->NPC_type) ||
				char_is_force_user_attacker(traceEnt))
				&& traceEnt->s.weapon == WP_SABER
				&& traceEnt->client->ps.SaberActive()
				&& !traceEnt->client->ps.saberInFlight
				&& (traceEnt->client->ps.saber_move == LS_READY || PM_SaberInParry(traceEnt->client->ps.saber_move) ||
					PM_SaberInReturn(traceEnt->client->ps.saber_move))
				&& InFOV(self->currentOrigin, traceEnt->currentOrigin, traceEnt->client->ps.viewangles, 20, 35)
				&& !PM_InKnockDown(&traceEnt->client->ps)
				&& !PM_SuperBreakLoseAnim(traceEnt->client->ps.torsoAnim)
				&& !PM_SuperBreakWinAnim(traceEnt->client->ps.torsoAnim)
				&& !pm_saber_in_special_attack(traceEnt->client->ps.torsoAnim)
				&& !PM_InSpecialJump(traceEnt->client->ps.torsoAnim))
			{
				//saber can block lightning
				//make them do a parry
				const float chance_of_fizz = Q_flrand(0.0f, 1.0f);
				vec3_t fwd{}, right, up;
				lightning_blocked = qtrue;
				VectorNegate(dir, fwd);

				//randomize direction a bit
				MakeNormalVectors(fwd, right, up);
				VectorMA(fwd, Q_irand(0, 360), right, fwd);
				VectorMA(fwd, Q_irand(0, 360), up, fwd);
				VectorNormalize(fwd);

				if (chance_of_fizz > 0)
				{
					vec3_t end;
					constexpr int npcblade_num = 0;
					constexpr int npcsaber_num = 0;
					VectorMA(traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].muzzlePoint,
						traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].length * Q_flrand(0, 1),
						traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].muzzleDir, end);
					G_PlayEffect(G_EffectIndex("saber/fizz.efx"), end, fwd);
				}

				switch (traceEnt->client->ps.saber_anim_level)
				{
				case SS_DUAL:
					NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P6_S6_T_, SETANIM_AFLAG_PACE);
					break;
				case SS_STAFF:
					NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P7_S7_T_, SETANIM_AFLAG_PACE);
					break;
				case SS_FAST:
				case SS_TAVION:
				case SS_STRONG:
				case SS_DESANN:
				case SS_MEDIUM:
				case SS_NONE:
				default:
					NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P1_S1_T_, SETANIM_AFLAG_PACE);
					break;
				}
				traceEnt->client->ps.weaponTime = Q_irand(300, 600);
				if (d_combatinfo->integer || g_DebugSaberCombat->integer || g_lightningdamage->integer)
				{
					Com_Printf(S_COLOR_RED"MD Mode NPC Saber Lightning Block No Force Correct\n");
				}
			}
			else if ((!Q_stricmp("Yoda", traceEnt->NPC_type) ||
				!Q_stricmp("Ep1_Yoda", traceEnt->NPC_type) ||
				!Q_stricmp("Ep2_Yoda", traceEnt->NPC_type) ||
				!Q_stricmp("Ep3_Yoda", traceEnt->NPC_type) ||
				!Q_stricmp("md_yoda", traceEnt->NPC_type) ||
				!Q_stricmp("md_yoda_ep2", traceEnt->NPC_type) ||
				!Q_stricmp("md_yoda_ot", traceEnt->NPC_type) ||
				!Q_stricmp("md_yoda_hr", traceEnt->NPC_type) ||
				char_is_force_user_attacker(traceEnt))
				&& traceEnt->s.weapon == WP_MELEE || traceEnt->s.weapon == WP_NONE || traceEnt->client->ps.weapon ==
				WP_SABER && !traceEnt->client->ps.SaberActive()
				&& !PM_InKnockDown(&traceEnt->client->ps)
				&& !PM_InRoll(&traceEnt->client->ps)
				&& traceEnt->client->ps.groundEntityNum != ENTITYNUM_NONE
				&& !PM_RunningAnim(traceEnt->client->ps.legsAnim)
				&& InFOV(self->currentOrigin, traceEnt->currentOrigin, traceEnt->client->ps.viewangles, 20, 35))
			{
				NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_FORCE_2HANDEDLIGHTNING_HOLD, SETANIM_AFLAG_PACE);
				traceEnt->client->ps.weaponTime = Q_irand(300, 600);
				lightning_blocked = qtrue;

				if (traceEnt->enemy
					&& traceEnt->ghoul2.size())
				{
					if (traceEnt->handRBolt != -1)
					{
						G_PlayEffect(G_EffectIndex("force/HBlockLightning.efx"), traceEnt->playerModel,
							traceEnt->handRBolt, traceEnt->s.number, traceEnt->currentOrigin, 1000, qtrue);
					}
					if (traceEnt->handLBolt != -1)
					{
						G_PlayEffect(G_EffectIndex("force/HBlockLightning.efx"), traceEnt->playerModel,
							traceEnt->handLBolt, traceEnt->s.number, traceEnt->currentOrigin, 1000, qtrue);
					}
					traceEnt->client->ps.powerups[PW_MEDITATE] = level.time + traceEnt->client->ps.torsoAnimTimer + 5000;
					if (d_combatinfo->integer || g_DebugSaberCombat->integer || g_lightningdamage->integer)
					{
						Com_Printf(S_COLOR_RED"MD Mode NPC hand Lightning Block No Force Correct\n");
					}
				}
			}
			else
			{
				NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_WIND, SETANIM_AFLAG_PACE);
				traceEnt->client->ps.weaponTime = Q_irand(300, 600);
				lightning_blocked = qtrue;
				traceEnt->client->ps.powerups[PW_MEDITATE] = level.time + traceEnt->client->ps.torsoAnimTimer + 5000;
				if (d_combatinfo->integer || g_DebugSaberCombat->integer || g_lightningdamage->integer)
				{
					Com_Printf(S_COLOR_RED"MD Mode NPC NO Force Lightning Block Correct\n");
				}
			}
		}
		return;
	}

	if (traceEnt->flags & FL_NOTARGET || traceEnt->noclip)
	{
		return;
	}

	if (traceEnt && traceEnt->takedamage)
	{
		if (traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_GUARD)
		{
			is_class_guard = qtrue;
		}
		if (!traceEnt->client || traceEnt->client->playerTeam != self->client->playerTeam || self->enemy == traceEnt
			||
			traceEnt->enemy == self || traceEnt->client->playerTeam == TEAM_SOLO || self->client->playerTeam ==
			TEAM_SOLO || is_class_guard)
		{
			int fpBlockCost;
			//an enemy or object
			int dmg;

			if (self->client->ps.forcePowerLevel[FP_LIGHTNING] > FORCE_LEVEL_2)
			{
				//more damage if closer and more in front
				dmg = 1;

				if (self->client->NPC_class == CLASS_REBORN && self->client->ps.weapon == WP_NONE)
				{
					//Cultist: looks fancy, but does less damage
				}
				else
				{
					if (dist < 100)
					{
						dmg += 2;
					}
					else if (dist < 200)
					{
						dmg += 1;
					}
					if (dot > 0.9f)
					{
						dmg += 2;
					}
					else if (dot > 0.7f)
					{
						dmg += 1;
					}
				}
				if (self->client->ps.torsoAnim == BOTH_FORCE_2HANDEDLIGHTNING
					|| self->client->ps.torsoAnim == BOTH_FORCE_2HANDEDLIGHTNING_OLD
					|| self->client->ps.torsoAnim == BOTH_FORCE_2HANDEDLIGHTNING_NEW
					|| self->client->ps.torsoAnim == BOTH_FORCE_2HANDEDLIGHTNING_START
					|| self->client->ps.torsoAnim == BOTH_FORCE_2HANDEDLIGHTNING_HOLD
					|| self->client->ps.torsoAnim == BOTH_FORCE_2HANDEDLIGHTNING_RELEASE)
				{
					//jackin' 'em up, Palpatine-style
					dmg *= 2;
				}
			}
			else
			{
				dmg = Q_irand(1, 3);
			}

			if (traceEnt->client && traceEnt->NPC)
			{
				if (jedi_win_po(traceEnt))
				{
					fpBlockCost = Q_irand(0, 1);
				}
				else
				{
					fpBlockCost = Q_irand(1, 2);
				}
			}
			else
			{
				fpBlockCost = 1;
			}
			const int np_cfp_block_cost = Q_irand(1, 3);

			if (traceEnt->client && traceEnt->health > 0)
			{
				if (traceEnt->client
					&& traceEnt->health > 0
					&& traceEnt->NPC
					&& !in_camera && !is_class_guard)
				{
					if (traceEnt->s.weapon == WP_SABER
						&& traceEnt->client->ps.SaberActive()
						&& !traceEnt->client->ps.saberInFlight
						&& (traceEnt->client->ps.saber_move == LS_READY || PM_SaberInParry(traceEnt->client->ps.saber_move) || PM_SaberInReturn(traceEnt->client->ps.saber_move))
						&& InFOV(self->currentOrigin, traceEnt->currentOrigin, traceEnt->client->ps.viewangles, 20, 35)
						&& !PM_InKnockDown(&traceEnt->client->ps)
						&& !PM_SuperBreakLoseAnim(traceEnt->client->ps.torsoAnim)
						&& !PM_SuperBreakWinAnim(traceEnt->client->ps.torsoAnim)
						&& !pm_saber_in_special_attack(traceEnt->client->ps.torsoAnim)
						&& !PM_InSpecialJump(traceEnt->client->ps.torsoAnim)
						&& !PM_SaberInKata(static_cast<saber_moveName_t>(traceEnt->client->ps.saber_move))
						&& traceEnt->client->ps.forcePower > 5)
					{
						//saber can block lightning
						//make them do a parry
						const float chance_of_fizz = Q_flrand(0.0f, 1.0f);
						vec3_t fwd{}, right, up;
						lightning_blocked = qtrue;
						VectorNegate(dir, fwd);

						//randomize direction a bit
						MakeNormalVectors(fwd, right, up);
						VectorMA(fwd, Q_irand(0, 360), right, fwd);
						VectorMA(fwd, Q_irand(0, 360), up, fwd);
						VectorNormalize(fwd);

						if (chance_of_fizz > 0)
						{
							vec3_t end;
							constexpr int npcblade_num = 0;
							constexpr int npcsaber_num = 0;
							VectorMA(traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].muzzlePoint,
								traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].length * Q_flrand(
									0, 1),
								traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].muzzleDir, end);
							G_PlayEffect(G_EffectIndex("saber/fizz.efx"), end, fwd);
						}

						switch (traceEnt->client->ps.saber_anim_level)
						{
						case SS_DUAL:
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P6_S6_T_, SETANIM_AFLAG_PACE);
							break;
						case SS_STAFF:
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P7_S7_T_, SETANIM_AFLAG_PACE);
							break;
						case SS_FAST:
						case SS_TAVION:
						case SS_STRONG:
						case SS_DESANN:
						case SS_MEDIUM:
						case SS_NONE:
						default:
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P1_S1_T_, SETANIM_AFLAG_PACE);
							break;
						}
						traceEnt->client->ps.weaponTime = Q_irand(300, 600);
						WP_ForcePowerDrain(traceEnt, FP_ABSORB, fpBlockCost);
						dmg = Q_irand(0, 1);
						if (d_combatinfo->integer || g_DebugSaberCombat->integer || g_lightningdamage->integer)
						{
							Com_Printf(S_COLOR_GREEN"MD Mode NPC Saber Lightning Block Correct\n");
						}
					}
					else if ((traceEnt->NPC && traceEnt->NPC->rank >= RANK_LT_COMM)
						&& (traceEnt->s.weapon == WP_MELEE || traceEnt->s.weapon == WP_NONE
							|| (traceEnt->client->ps.weapon == WP_SABER && !traceEnt->client->ps.SaberActive()))
						&& !PM_InKnockDown(&traceEnt->client->ps)
						&& !PM_InRoll(&traceEnt->client->ps)
						&& traceEnt->client->ps.groundEntityNum != ENTITYNUM_NONE
						&& !PM_RunningAnim(traceEnt->client->ps.legsAnim)
						&& !PM_InSpecialJump(traceEnt->client->ps.torsoAnim)
						&& InFOV(self->currentOrigin, traceEnt->currentOrigin, traceEnt->client->ps.viewangles, 20, 35)
						&& traceEnt->client->ps.forcePower > 20)
					{
						if (Manual_Hand_Block_Lightning_NPC(self, traceEnt, FP_LIGHTNING))
						{
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_FORCE_2HANDEDLIGHTNING_HOLD, SETANIM_AFLAG_PACE);
							traceEnt->client->ps.weaponTime = Q_irand(300, 600);
							lightning_blocked = qtrue;

							if (traceEnt->ghoul2.size())
							{
								if (traceEnt->handRBolt != -1)
								{
									G_PlayEffect(G_EffectIndex("force/HBlockLightning.efx"), traceEnt->playerModel,
										traceEnt->handRBolt, traceEnt->s.number, traceEnt->currentOrigin, 1000,
										qtrue);
								}
								if (traceEnt->handLBolt != -1)
								{
									G_PlayEffect(G_EffectIndex("force/HBlockLightning.efx"), traceEnt->playerModel,
										traceEnt->handLBolt, traceEnt->s.number, traceEnt->currentOrigin, 1000,
										qtrue);
								}
							}
							traceEnt->client->ps.powerups[PW_MEDITATE] = level.time + traceEnt->client->ps.torsoAnimTimer + 5000;

							WP_ForcePowerDrain(traceEnt, FP_ABSORB, np_cfp_block_cost);

							dmg = Q_irand(0, 1);
							if (d_combatinfo->integer || g_DebugSaberCombat->integer || g_lightningdamage->integer)
							{
								Com_Printf(S_COLOR_RED"MD Mode NPC Hand Lightning Block Correct\n");
							}
						}
					}
				}
				else if (traceEnt->s.weapon == WP_SABER && traceEnt->client->ps.SaberActive())
				{
					if (!in_camera && !is_class_guard && manual_saberblocking(traceEnt)
						&& InFOV(self->currentOrigin, traceEnt->currentOrigin, traceEnt->client->ps.viewangles, 20, 35)
						&& !PM_SaberInKata(static_cast<saber_moveName_t>(traceEnt->client->ps.saber_move))
						&& traceEnt->client->ps.forcePower > 20)
					{
						//saber can block lightning
						//make them do a parry
						const float chance_of_fizz = Q_flrand(0.0f, 1.0f);
						vec3_t fwd{}, right, up;
						lightning_blocked = qtrue;
						VectorNegate(dir, fwd);
						//randomize direction a bit
						MakeNormalVectors(fwd, right, up);
						VectorMA(fwd, Q_irand(0, 360), right, fwd);
						VectorMA(fwd, Q_irand(0, 360), up, fwd);
						VectorNormalize(fwd);

						if (chance_of_fizz > 0)
						{
							vec3_t end;
							constexpr int npcblade_num = 0;
							constexpr int npcsaber_num = 0;
							VectorMA(traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].muzzlePoint,
								traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].length * Q_flrand(
									0, 1),
								traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].muzzleDir, end);
							if (traceEnt->client->ps.forcePower > 50)
							{
								G_PlayEffect(G_EffectIndex("saber/saber_Lightninghit.efx"), end, fwd);
							}
							else
							{
								G_PlayEffect(G_EffectIndex("saber/fizz.efx"), end, fwd);
							}
						}

						switch (traceEnt->client->ps.saber_anim_level)
						{
						case SS_DUAL:
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P6_S6_T_, SETANIM_AFLAG_PACE);
							break;
						case SS_STAFF:
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P7_S7_T_, SETANIM_AFLAG_PACE);
							break;
						case SS_FAST:
						case SS_TAVION:
						case SS_STRONG:
						case SS_DESANN:
						case SS_MEDIUM:
						case SS_NONE:
						default:
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P1_S1_T_, SETANIM_AFLAG_PACE);
							break;
						}
						traceEnt->client->ps.weaponTime = Q_irand(300, 600);
						dmg = 0;
						WP_ForcePowerDrain(traceEnt, FP_ABSORB, fpBlockCost);
						if (d_combatinfo->integer || g_DebugSaberCombat->integer || g_lightningdamage->integer)
						{
							Com_Printf(S_COLOR_RED"MD Mode Player Saber Lightning Block Correct\n");
						}
					}
					else if (in_camera && !is_class_guard
						&& traceEnt->NPC
						&& traceEnt->client->ps.SaberActive()
						&& !traceEnt->client->ps.saberInFlight
						&& !PM_InKnockDown(&traceEnt->client->ps)
						&& InFOV(self->currentOrigin, traceEnt->currentOrigin, traceEnt->client->ps.viewangles, 20, 35))
					{
						const float chance_of_fizz = Q_flrand(0.0f, 1.0f);
						vec3_t fwd{}, right, up;
						lightning_blocked = qtrue;
						VectorNegate(dir, fwd);
						//randomize direction a bit
						MakeNormalVectors(fwd, right, up);
						VectorMA(fwd, Q_irand(0, 360), right, fwd);
						VectorMA(fwd, Q_irand(0, 360), up, fwd);
						VectorNormalize(fwd);

						if (chance_of_fizz > 0)
						{
							vec3_t end;
							constexpr int npcblade_num = 0;
							constexpr int npcsaber_num = 0;
							VectorMA(traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].muzzlePoint,
								traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].length * Q_flrand(
									0, 1),
								traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].muzzleDir, end);
							G_PlayEffect(G_EffectIndex("saber/fizz.efx"), end, fwd);
						}

						switch (traceEnt->client->ps.saber_anim_level)
						{
						case SS_DUAL:
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P6_S6_TL, SETANIM_AFLAG_PACE);
							break;
						case SS_STAFF:
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P7_S7_TL, SETANIM_AFLAG_PACE);
							break;
						case SS_FAST:
						case SS_TAVION:
						case SS_STRONG:
						case SS_DESANN:
						case SS_MEDIUM:
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P1_S1_TL, SETANIM_AFLAG_PACE);
							break;
						case SS_NONE:
						default:
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P1_S1_TL, SETANIM_AFLAG_PACE);
							break;
						}
						traceEnt->client->ps.weaponTime = Q_irand(300, 600);
						dmg = 0;
						if (d_combatinfo->integer || g_DebugSaberCombat->integer || g_lightningdamage->integer)
						{
							Com_Printf(S_COLOR_RED"MD Mode NPC Saber Lightning Block CIN Correct\n");
						}
					}
					else if (!in_camera && !is_class_guard && (traceEnt->client->ps.forcePowersActive & 1 << FP_ABSORB
						&&
						traceEnt->client->ps.forcePowerLevel[FP_ABSORB] > FORCE_LEVEL_2)
						&& traceEnt->client->ps.forcePower > 20
						&& !PM_InKnockDown(&traceEnt->client->ps)
						&& !PM_InRoll(&traceEnt->client->ps)
						&& traceEnt->client->ps.groundEntityNum != ENTITYNUM_NONE
						&& !PM_RunningAnim(traceEnt->client->ps.legsAnim)
						&& InFOV(self->currentOrigin, traceEnt->currentOrigin, traceEnt->client->ps.viewangles, 20, 35))
					{
						//make them do a parry
						const float chance_of_fizz = Q_flrand(0.0f, 1.0f);
						vec3_t fwd{}, right, up;
						lightning_blocked = qtrue;
						VectorNegate(dir, fwd);
						//randomize direction a bit
						MakeNormalVectors(fwd, right, up);
						VectorMA(fwd, Q_irand(0, 360), right, fwd);
						VectorMA(fwd, Q_irand(0, 360), up, fwd);
						VectorNormalize(fwd);

						if (chance_of_fizz > 0)
						{
							vec3_t end;
							constexpr int npcblade_num = 0;
							constexpr int npcsaber_num = 0;
							VectorMA(traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].muzzlePoint,
								traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].length * Q_flrand(
									0, 1),
								traceEnt->client->ps.saber[npcsaber_num].blade[npcblade_num].muzzleDir, end);
							if (traceEnt->client->ps.forcePower > 50)
							{
								G_PlayEffect(G_EffectIndex("saber/saber_Lightninghit.efx"), end, fwd);
							}
							else
							{
								G_PlayEffect(G_EffectIndex("saber/fizz.efx"), end, fwd);
							}
						}

						switch (traceEnt->client->ps.saber_anim_level)
						{
						case SS_DUAL:
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P6_S6_T_, SETANIM_AFLAG_PACE);
							break;
						case SS_STAFF:
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P7_S7_T_, SETANIM_AFLAG_PACE);
							break;
						case SS_FAST:
						case SS_TAVION:
						case SS_STRONG:
						case SS_DESANN:
						case SS_MEDIUM:
						case SS_NONE:
						default:
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_P1_S1_T_, SETANIM_AFLAG_PACE);
							break;
						}
						traceEnt->client->ps.weaponTime = Q_irand(300, 600);
						dmg = 0;
						WP_ForcePowerDrain(traceEnt, FP_ABSORB, fpBlockCost);
						if (d_combatinfo->integer || g_DebugSaberCombat->integer || g_lightningdamage->integer)
						{
							Com_Printf(S_COLOR_RED"MD Mode Player Saber Absorb Lightning Block Correct\n");
						}
					}
					else
					{
						dmg = 1;
					}
				}
				else if (traceEnt->s.weapon == WP_MELEE
					|| traceEnt->s.weapon == WP_NONE
					|| (traceEnt->client->ps.weapon == WP_SABER && !traceEnt->client->ps.SaberActive()))
				{
					if (!in_camera && !is_class_guard
						&& (Manual_Hand_Block_Lightning(traceEnt) && traceEnt->client->ps.forcePowerLevel[FP_ABSORB] > FORCE_LEVEL_2)
						&& !PM_InKnockDown(&traceEnt->client->ps)
						&& !PM_InRoll(&traceEnt->client->ps)
						&& traceEnt->client->ps.groundEntityNum != ENTITYNUM_NONE
						&& !PM_RunningAnim(traceEnt->client->ps.legsAnim)
						&& InFOV(self->currentOrigin, traceEnt->currentOrigin, traceEnt->client->ps.viewangles, 20, 35)
						&& traceEnt->client->ps.forcePower > 20)
					{
						NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_FORCE_2HANDEDLIGHTNING_HOLD, SETANIM_AFLAG_PACE);
						traceEnt->client->ps.weaponTime = Q_irand(300, 600);
						lightning_blocked = qtrue;

						if (traceEnt->ghoul2.size())
						{
							if (traceEnt->handRBolt != -1)
							{
								G_PlayEffect(G_EffectIndex("force/HBlockLightning.efx"), traceEnt->playerModel,
									traceEnt->handRBolt, traceEnt->s.number, traceEnt->currentOrigin, 1000,
									qtrue);
							}
							if (traceEnt->handLBolt != -1)
							{
								G_PlayEffect(G_EffectIndex("force/HBlockLightning.efx"), traceEnt->playerModel,
									traceEnt->handLBolt, traceEnt->s.number, traceEnt->currentOrigin, 1000,
									qtrue);
							}
						}
						traceEnt->client->ps.powerups[PW_MEDITATE] = level.time + traceEnt->client->ps.torsoAnimTimer + 5000;
						WP_ForcePowerDrain(traceEnt, FP_ABSORB, fpBlockCost);
						if (d_combatinfo->integer || g_DebugSaberCombat->integer || g_lightningdamage->integer)
						{
							Com_Printf(S_COLOR_RED"MD Mode Player Hand Lightning Block Correct\n");
						}
					}
					else
					{
						dmg = 1;
					}
				}
			}

			if (traceEnt && traceEnt->client && traceEnt->client->ps.powerups[PW_GALAK_SHIELD])
			{
				//has shield up
				dmg = 0;
				lightning_blocked = qtrue;
			}

			if (traceEnt && traceEnt->client && traceEnt->client->NPC_class == CLASS_OBJECT)
			{
				dmg = 0;
				lightning_blocked = qtrue;
			}

			if (is_class_guard)
			{
				dmg = 1;
				lightning_blocked = qfalse;
			}

			int modPowerLevel = -1;

			if (traceEnt->client)
			{
				modPowerLevel = WP_AbsorbConversion(traceEnt, traceEnt->client->ps.forcePowerLevel[FP_ABSORB],
					FP_LIGHTNING,
					self->client->ps.forcePowerLevel[FP_LIGHTNING], 1);
			}

			if (modPowerLevel != -1)
			{
				if (!modPowerLevel)
				{
					dmg = 0;
				}
				else if (modPowerLevel == 1)
				{
					dmg = floor(static_cast<float>(dmg) / 4.0f);
				}
				else if (modPowerLevel == 2)
				{
					dmg = floor(static_cast<float>(dmg) / 2.0f);
				}
			}

			if (dmg && !lightning_blocked || is_class_guard) //md
			{
				if (jedi_win_po(traceEnt))
				{
					G_Damage(traceEnt, self, self, dir, impact_point, dmg, DAMAGE_LIGHNING_KNOCKBACK,
						MOD_FORCE_LIGHTNING);
					if (g_lightningdamage->integer)
					{
						gi.Printf(S_COLOR_RED"WINDU MD LIGHTNING KNOCKBACK TEST\n");
					}
				}
				else
				{
					G_Damage(traceEnt, self, self, dir, impact_point, dmg, DAMAGE_DEATH_KNOCKBACK,
						MOD_FORCE_LIGHTNING);
					if (g_lightningdamage->integer)
					{
						gi.Printf(S_COLOR_RED"NORMAL MD LIGHTNING KNOCKBACK TEST\n");
					}
				}

				if (!in_camera &&
					traceEnt->s.weapon != WP_EMPLACED_GUN &&
					(traceEnt->NPC || traceEnt->s.eType == ET_PLAYER || (traceEnt->s.number < MAX_CLIENTS || G_ControlledByPlayer(traceEnt))))
				{
					if (traceEnt && traceEnt->client && traceEnt->client->ps.stats[STAT_HEALTH] <= 20)
					{
						traceEnt->client->stunDamage = 5;
						traceEnt->client->stunTime = level.time + 1000;

						gentity_t* tent = G_TempEntity(traceEnt->currentOrigin, EV_STUNNED);
						tent->owner = traceEnt;
					}

					if (PM_RunningAnim(traceEnt->client->ps.legsAnim) && (traceEnt->client->ps.stats[STAT_HEALTH] > 1
						|| is_class_guard))
					{
						G_KnockOver(traceEnt, self, dir, 25, qtrue);
					}
					else if (!PM_RunningAnim(traceEnt->client->ps.legsAnim) && !PM_InKnockDown(&traceEnt->client->ps)
						&& traceEnt->client->ps.groundEntityNum != ENTITYNUM_NONE && traceEnt->client->ps.stats[
							STAT_HEALTH] > 1)
					{
						if (traceEnt->client->ps.stats[STAT_HEALTH] < 75)
						{
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_COWER1, SETANIM_AFLAG_PACE);
						}
						else if (traceEnt->client->ps.stats[STAT_HEALTH] < 50)
						{
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_SONICPAIN_HOLD, SETANIM_AFLAG_PACE);
						}
						else
						{
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_WIND, SETANIM_AFLAG_PACE);
						}
					}
					else if (traceEnt->client->ps.groundEntityNum == ENTITYNUM_NONE && traceEnt->client->ps.stats[
						STAT_HEALTH] > 1)
					{
						if (traceEnt->client->ps.stats[STAT_HEALTH] < 75)
						{
							NPC_SetAnim(traceEnt, SETANIM_BOTH, Q_irand(BOTH_SLAPDOWNRIGHT, BOTH_SLAPDOWNLEFT),
								SETANIM_AFLAG_PACE);
						}
						else
						{
							NPC_SetAnim(traceEnt, SETANIM_TORSO, BOTH_WIND, SETANIM_AFLAG_PACE);
						}
					}
				}
			}

			if (traceEnt->client)
			{
				if (!Q_irand(0, 2))
				{
					G_Sound(traceEnt, G_SoundIndex(va("sound/weapons/force/lightninghit%d.mp3", Q_irand(1, 3))));
				}

				if (traceEnt->client && traceEnt->client->ps.powerups[PW_CLOAKED])
				{
					//disable cloak temporarily
					player_decloak(traceEnt);
					G_AddVoiceEvent(traceEnt, Q_irand(EV_ANGER1, EV_ANGER3), 10000);
				}
				traceEnt->s.powerups |= 1 << PW_SHOCKED;

				if (traceEnt && traceEnt->client &&
					(traceEnt->health <= 0 || traceEnt->client->NPC_class == CLASS_ATST
						|| traceEnt->client->NPC_class == CLASS_GONK
						|| traceEnt->client->NPC_class == CLASS_INTERROGATOR
						|| traceEnt->client->NPC_class == CLASS_MARK1
						|| traceEnt->client->NPC_class == CLASS_MARK2
						|| traceEnt->client->NPC_class == CLASS_MOUSE
						|| traceEnt->client->NPC_class == CLASS_PROBE
						|| traceEnt->client->NPC_class == CLASS_PROTOCOL
						|| traceEnt->client->NPC_class == CLASS_R2D2
						|| traceEnt->client->NPC_class == CLASS_R5D2
						|| traceEnt->client->NPC_class == CLASS_SEEKER
						|| traceEnt->client->NPC_class == CLASS_SENTRY
						|| traceEnt->client->NPC_class == CLASS_SBD
						|| traceEnt->client->NPC_class == CLASS_BATTLEDROID
						|| traceEnt->client->NPC_class == CLASS_DROIDEKA
						|| traceEnt->client->NPC_class == CLASS_OBJECT
						|| traceEnt->client->NPC_class == CLASS_ASSASSIN_DROID
						|| traceEnt->client->NPC_class == CLASS_SABER_DROID))
				{
					// special droid only behaviors
					traceEnt->client->ps.powerups[PW_SHOCKED] = level.time + 4000;
				}
				else if (lightning_blocked)
				{
					traceEnt->client->ps.powerups[PW_SHOCKED] = 0;
				}
				else
				{
					traceEnt->client->ps.powerups[PW_SHOCKED] = level.time + 1500;
				}
			}
		}
	}
}

void ForceShootLightning(gentity_t* self)
{
	trace_t tr;
	vec3_t forward;
	gentity_t* traceEnt;

	if (self->health <= 0)
	{
		return;
	}
	if (!self->s.number && cg.zoomMode)
	{
		//can't force lightning when zoomed in
		return;
	}

	if (PM_InLedgeMove(self->client->ps.legsAnim))
	{
		return;
	}

	AngleVectors(self->client->ps.viewangles, forward, nullptr, nullptr);
	VectorNormalize(forward);

	if (self->client->ps.forcePowerLevel[FP_LIGHTNING] > FORCE_LEVEL_2)
	{
		//arc
		vec3_t center, mins{}, maxs{}, v{};
		constexpr float radius = 512;
		float dot;
		gentity_t* entity_list[MAX_GENTITIES];
		int i;

		VectorCopy(self->currentOrigin, center);
		for (i = 0; i < 3; i++)
		{
			mins[i] = center[i] - radius;
			maxs[i] = center[i] + radius;
		}
		const int num_listed_entities = gi.EntitiesInBox(mins, maxs, entity_list, MAX_GENTITIES);

		for (int e = 0; e < num_listed_entities; e++)
		{
			vec3_t size;
			vec3_t ent_org;
			vec3_t dir;
			traceEnt = entity_list[e];

			if (!traceEnt)
				continue;
			if (traceEnt == self)
				continue;
			if (traceEnt->owner == self && traceEnt->s.weapon != WP_THERMAL) //can push your own thermals
				continue;
			if (!traceEnt->inuse)
				continue;
			if (!traceEnt->takedamage)
				continue;
			if (traceEnt->health <= 0) //no torturing corpses
				continue;
			//this is all to see if we need to start a saber attack, if it's in flight, this doesn't matter
			// find the distance from the edge of the bounding box
			for (i = 0; i < 3; i++)
			{
				if (center[i] < traceEnt->absmin[i])
				{
					v[i] = traceEnt->absmin[i] - center[i];
				}
				else if (center[i] > traceEnt->absmax[i])
				{
					v[i] = center[i] - traceEnt->absmax[i];
				}
				else
				{
					v[i] = 0;
				}
			}

			VectorSubtract(traceEnt->absmax, traceEnt->absmin, size);
			VectorMA(traceEnt->absmin, 0.5, size, ent_org);

			//see if they're in front of me
			//must be within the forward cone
			VectorSubtract(ent_org, center, dir);
			VectorNormalize(dir);
			if ((dot = DotProduct(dir, forward)) < 0.5)
				continue;

			//must be close enough
			const float dist = VectorLength(v);
			if (dist >= radius)
			{
				continue;
			}

			//in PVS?
			if (!traceEnt->bmodel && !gi.inPVS(ent_org, self->client->renderInfo.handLPoint))
			{
				//must be in PVS
				continue;
			}

			//Now check and see if we can actually hit it
			gi.trace(&tr, self->client->renderInfo.handLPoint, vec3_origin, vec3_origin, ent_org, self->s.number,
				MASK_SHOT, static_cast<EG2_Collision>(0), 0);
			if (tr.fraction < 1.0f && tr.entityNum != traceEnt->s.number)
			{
				//must have clear LOS
				continue;
			}

			if (g_SerenityJediEngineMode->integer)
			{
				if (g_SerenityJediEngineMode->integer == 2)
				{
					ForceLightningDamage_AMD(self, traceEnt, dir, dist, dot, ent_org);
				}
				else
				{
					ForceLightningDamage_MD(self, traceEnt, dir, dist, dot, ent_org);
				}
			}
			else
			{
				ForceLightningDamage(self, traceEnt, dir, dist, dot, ent_org);
			}
		}
	}
	else
	{
		vec3_t end;
		//trace-line
		int ignore = self->s.number;
		int traces = 0;
		vec3_t start;

		VectorCopy(self->client->renderInfo.handLPoint, start);
		VectorMA(self->client->renderInfo.handLPoint, 2048, forward, end);

		while (traces < 10)
		{
			//need to loop this in case we hit a Jedi who dodges the shot
			gi.trace(&tr, start, vec3_origin, vec3_origin, end, ignore, MASK_SHOT, G2_RETURNONHIT, 10);
			if (tr.entityNum == ENTITYNUM_NONE || tr.fraction == 1.0 || tr.allsolid || tr.startsolid)
			{
				return;
			}

			traceEnt = &g_entities[tr.entityNum];
			//NOTE: only NPCs do this auto-dodge
			if (!in_camera && traceEnt
				&& traceEnt->s.weapon != WP_SABER
				&& traceEnt->s.number >= MAX_CLIENTS
				&& traceEnt->client
				&& traceEnt->client->ps.forcePowerLevel[FP_LEVITATION] > FORCE_LEVEL_0)
			{
				if (!jedi_dodge_evasion(traceEnt, self, &tr, HL_NONE))
				{
					//act like we didn't even hit him
					VectorCopy(tr.endpos, start);
					ignore = tr.entityNum;
					traces++;
					continue;
				}
			}
			//a Jedi is not dodging this shot
			break;
		}

		traceEnt = &g_entities[tr.entityNum];

		if (g_SerenityJediEngineMode->integer)
		{
			if (g_SerenityJediEngineMode->integer == 2)
			{
				ForceLightningDamage_AMD(self, traceEnt, forward, 0, 0, tr.endpos);
			}
			else
			{
				ForceLightningDamage_MD(self, traceEnt, forward, 0, 0, tr.endpos);
			}
		}
		else
		{
			ForceLightningDamage(self, traceEnt, forward, 0, 0, tr.endpos);
		}
	}
}

void WP_DeactivateSaber(const gentity_t* self, const qboolean clear_length)
{
	const qboolean blocking = self->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCK ? qtrue : qfalse;
	//Normal Blocking
	const qboolean active_blocking = self->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCKANDATTACK ? qtrue : qfalse;
	//Active Blocking

	if (!self || !self->client)
	{
		return;
	}

	if (blocking || active_blocking)
	{
		return;
	}
	self->client->ps.ManualBlockingFlags &= ~(1 << HOLDINGBLOCK);
	self->client->ps.ManualBlockingFlags &= ~(1 << HOLDINGBLOCKANDATTACK);
	self->client->ps.ManualBlockingFlags &= ~(1 << PERFECTBLOCKING);
	self->client->ps.ManualBlockingFlags &= ~(1 << MBF_NPCBLOCKING);

	//keep my saber off!
	if (self->client->ps.SaberActive())
	{
		self->client->ps.SaberDeactivate();
		if (clear_length)
		{
			self->client->ps.SetSaberLength(0);
		}
		G_SoundIndexOnEnt(self, CHAN_WEAPON, self->client->ps.saber[0].soundOff);
	}
}

void WP_DeactivateLightSaber(const gentity_t* self, const qboolean clear_length)
{
	const qboolean blocking = self->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCK ? qtrue : qfalse;
	//Normal Blocking
	const qboolean active_blocking = self->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCKANDATTACK ? qtrue : qfalse;
	//Active Blocking

	if (!self || !self->client)
	{
		return;
	}

	if (blocking || active_blocking)
	{
		return;
	}
	self->client->ps.ManualBlockingFlags &= ~(1 << HOLDINGBLOCK);
	self->client->ps.ManualBlockingFlags &= ~(1 << HOLDINGBLOCKANDATTACK);
	self->client->ps.ManualBlockingFlags &= ~(1 << PERFECTBLOCKING);
	self->client->ps.ManualBlockingFlags &= ~(1 << MBF_NPCBLOCKING);

	//keep my saber off!
	if (self->client->ps.SaberActive())
	{
		self->client->ps.SaberDeactivate();
		if (clear_length)
		{
			self->client->ps.SetSaberLength(0);
		}
		G_SoundIndexOnEnt(self, CHAN_WEAPON, self->client->ps.saber[0].soundOff);
	}

	//if (self->NPC && !G_ControlledByPlayer(self)) //NPC only
	//{
	//	self->client->usercmd.buttons &= ~BUTTON_ATTACK;
	//}
}

void ForceDrainGrabStart(gentity_t* self)
{
	NPC_SetAnim(self, SETANIM_BOTH, BOTH_FORCE_DRAIN_GRAB_START, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
	self->client->ps.saber_move = self->client->ps.saberBounceMove = LS_READY;
	//don't finish whatever saber anim you may have been in
	self->client->ps.saberBlocked = BLOCKED_NONE;

	self->client->ps.weaponTime = 1000;
	if (self->client->ps.forcePowersActive & 1 << FP_SPEED)
	{
		self->client->ps.weaponTime = floor(self->client->ps.weaponTime * g_timescale->value);
	}
	//actually grabbing someone, so turn off the saber!
	WP_DeactivateSaber(self, qtrue);
}

qboolean ForceDrain2(gentity_t* self)
{
	trace_t tr;
	vec3_t end, forward;

	if (self->health <= 0)
	{
		return qtrue;
	}

	if (!self->s.number && (cg.zoomMode || in_camera))
	{
		//can't force grip when zoomed in or in cinematic
		return qtrue;
	}

	if (self->client->ps.leanofs)
	{
		//can't force-drain while leaning
		return qtrue;
	}
	if (self->client->ps.forcePowersActive & 1 << FP_DRAIN && PM_SaberInAttack(self->client->ps.saber_move))
	{
		WP_ForcePowerStop(self, FP_DRAIN);
	}

	if (self->client->ps.forceDrainEntityNum <= ENTITYNUM_WORLD)
	{
		//already draining
		//keep my saber off!
		WP_DeactivateSaber(self, qtrue);
		if (self->client->ps.forcePowerLevel[FP_DRAIN] > FORCE_LEVEL_1)
		{
			self->client->ps.forcePowerDuration[FP_DRAIN] = level.time + 100;
			self->client->ps.weaponTime = 1000;
			if (self->client->ps.forcePowersActive & 1 << FP_SPEED)
			{
				self->client->ps.weaponTime = floor(self->client->ps.weaponTime * g_timescale->value);
			}
		}
		return qtrue;
	}

	if (self->client->ps.forcePowerDebounce[FP_DRAIN] > level.time)
	{
		//stops it while using it and also after using it, up to 3 second delay
		return qtrue;
	}

	if (self->client->ps.weaponTime > 0)
	{
		//busy
		return qtrue;
	}

	if (self->client->ps.forcePower < 25 || !WP_ForcePowerUsable(self, FP_DRAIN, 0))
	{
		return qtrue;
	}

	if (self->client->ps.saberLockTime > level.time)
	{
		//in saberlock
		return qtrue;
	}

	//NOTE: from here on, if it fails, it's okay to try a normal drain, so return qfalse
	if (self->client->ps.groundEntityNum == ENTITYNUM_NONE)
	{
		//in air
		return qfalse;
	}

	//Cause choking anim + health drain in ent in front of me
	AngleVectors(self->client->ps.viewangles, forward, nullptr, nullptr);
	VectorNormalize(forward);
	VectorMA(self->client->renderInfo.eyePoint, FORCE_DRAIN_DIST, forward, end);

	//okay, trace straight ahead and see what's there
	gi.trace(&tr, self->client->renderInfo.eyePoint, vec3_origin, vec3_origin, end, self->s.number, MASK_SHOT,
		static_cast<EG2_Collision>(0), 0);
	if (tr.entityNum >= ENTITYNUM_WORLD || tr.fraction == 1.0 || tr.allsolid || tr.startsolid)
	{
		return qfalse;
	}
	gentity_t* traceEnt = &g_entities[tr.entityNum];
	if (!traceEnt || traceEnt == self/*???*/ || traceEnt->bmodel || traceEnt->health <= 0 && traceEnt->takedamage
		||
		traceEnt->NPC && traceEnt->NPC->scriptFlags & SCF_NO_FORCE)
	{
		return qfalse;
	}

	if (traceEnt->client)
	{
		if (traceEnt->client->ps.forceJumpZStart)
		{
			//can't catch them in mid force jump - FIXME: maybe base it on velocity?
			return qfalse;
		}
		if (traceEnt->client->ps.groundEntityNum == ENTITYNUM_NONE)
		{
			//can't catch them in mid air
			return qfalse;
		}
		if (!Q_stricmp("Yoda", traceEnt->NPC_type)
			|| !Q_stricmp("T_Yoda", traceEnt->NPC_type)
			|| !Q_stricmp("md_Yoda", traceEnt->NPC_type)
			|| !Q_stricmp("md_yoda_ep2", traceEnt->NPC_type)
			|| !Q_stricmp("md_yoda_ot", traceEnt->NPC_type)
			|| !Q_stricmp("md_yoda_hr", traceEnt->NPC_type)
			|| !Q_stricmp("T_Palpatine_sith", traceEnt->NPC_type)
			|| char_is_force_user_attacker(traceEnt))
		{
			jedi_play_deflect_sound(traceEnt);
			if (g_SerenityJediEngineMode->integer)
			{
				if (traceEnt->client->NPC_class == CLASS_GALEN
					&& (traceEnt->s.weapon == WP_MELEE || traceEnt->s.weapon == WP_NONE || traceEnt->s.weapon ==
						WP_SABER && !traceEnt->client->ps.SaberActive())
					&& traceEnt->client->ps.groundEntityNum == ENTITYNUM_NONE)
				{
					ForceRepulse(traceEnt, qfalse);
				}
				else
				{
					ForceThrow_MD(traceEnt, qfalse);
				}
			}
			else
			{
				ForceThrow_JKA(traceEnt, qfalse);
			}
			return qtrue;
		}

		if (jedi_jedi_master_high(traceEnt))
		{
			jedi_play_deflect_sound(traceEnt);
			if (g_SerenityJediEngineMode->integer)
			{
				ForceThrow_MD(traceEnt, qfalse);
			}
			else
			{
				ForceThrow_JKA(traceEnt, qfalse);
			}

			if (traceEnt->NPC && !G_ControlledByPlayer(traceEnt)) //NPC only
			{
				if ((traceEnt->client->ps.forcePowersKnown & 1 << FP_ABSORB) != 0
					&& (traceEnt->client->ps.forcePowersActive & 1 << FP_ABSORB) == 0)
				{
					//know absorb and not already using it
					if (!Q_irand(0, 5))
					{
						ForceAbsorb(traceEnt);
					}
				}
				G_AddVoiceEvent(traceEnt, Q_irand(EV_TAUNT1, EV_TAUNT5), Q_irand(8000, 12000));
			}
			return qtrue;
		}

		switch (traceEnt->client->NPC_class)
		{
		case CLASS_GALAKMECH: //cant grab him, he's in armor
			G_AddVoiceEvent(traceEnt, Q_irand(EV_PUSHED1, EV_PUSHED3), Q_irand(3000, 5000));
			return qfalse;
		case CLASS_ROCKETTROOPER: //cant grab him, he's in armor
		case CLASS_HAZARD_TROOPER: //cant grab him, he's in armor
			return qfalse;
		case CLASS_ATST: //much too big to grab!
			return qfalse;
			//no droids either
		case CLASS_GONK:
		case CLASS_R2D2:
		case CLASS_R5D2:
		case CLASS_MARK1:
		case CLASS_MARK2:
		case CLASS_MOUSE:
		case CLASS_PROTOCOL:
		case CLASS_SABER_DROID:
		case CLASS_ASSASSIN_DROID:
		case CLASS_DROIDEKA:
			return qfalse;
		case CLASS_PROBE:
		case CLASS_SEEKER:
		case CLASS_REMOTE:
		case CLASS_SENTRY:
		case CLASS_INTERROGATOR:
			return qfalse;
		case CLASS_SITHLORD:
		case CLASS_DESANN: //Desann cannot be gripped, he just pushes you back instantly
		case CLASS_VADER:
		case CLASS_KYLE:
		case CLASS_GALEN:
		case CLASS_TAVION:
		case CLASS_YODA:
		case CLASS_LUKE:
		case CLASS_GROGU:
			jedi_play_deflect_sound(traceEnt);
			if (g_SerenityJediEngineMode->integer)
			{
				if (traceEnt->client->NPC_class == CLASS_GALEN
					&& (traceEnt->s.weapon == WP_MELEE || traceEnt->s.weapon == WP_NONE || traceEnt->s.weapon ==
						WP_SABER && !traceEnt->client->ps.SaberActive())
					&& traceEnt->client->ps.groundEntityNum == ENTITYNUM_NONE)
				{
					ForceRepulse(traceEnt, qfalse);
				}
				else
				{
					ForceThrow_MD(traceEnt, qfalse);
				}
			}
			else
			{
				ForceThrow_JKA(traceEnt, qfalse);
			}
			return qtrue;
		case CLASS_REBORN:
		case CLASS_BOC:
		case CLASS_SHADOWTROOPER:
		case CLASS_JEDI:
		case CLASS_PROJECTION:
		case CLASS_AHSOKA:
			if (traceEnt->NPC
				&& traceEnt->NPC->rank > RANK_CIVILIAN
				&& self->client->ps.forcePowerLevel[FP_DRAIN] < FORCE_LEVEL_2
				&& traceEnt->client->ps.weaponTime <= 0)
			{
				ForceDrainGrabStart(self);
				jedi_play_deflect_sound(traceEnt);
				if (g_SerenityJediEngineMode->integer)
				{
					if (traceEnt->client->NPC_class == CLASS_GALEN
						&& (traceEnt->s.weapon == WP_MELEE || traceEnt->s.weapon == WP_NONE || traceEnt->s.weapon ==
							WP_SABER && !traceEnt->client->ps.SaberActive())
						&& traceEnt->client->ps.groundEntityNum == ENTITYNUM_NONE)
					{
						ForceRepulse(traceEnt, qfalse);
					}
					else
					{
						ForceThrow_MD(traceEnt, qfalse);
					}
				}
				else
				{
					ForceThrow_JKA(traceEnt, qfalse);
				}
				return qtrue;
			}
			break;
		default:
			break;
		}
		if (traceEnt->s.weapon == WP_EMPLACED_GUN)
		{
			//FIXME: maybe can pull them out?
			return qfalse;
		}
		if (traceEnt != self->enemy && OnSameTeam(self, traceEnt))
		{
			//can't accidently grip-drain your teammate
			return qfalse;
		}
		if (!FP_ForceDrainGrippableEnt(traceEnt))
		{
			return qfalse;
		}
	}
	else
	{
		//can't drain non-clients
		return qfalse;
	}

	ForceDrainGrabStart(self);

	WP_ForcePowerStart(self, FP_DRAIN, 10);
	self->client->ps.forceDrainEntityNum = traceEnt->s.number;

	G_AddVoiceEvent(traceEnt, Q_irand(EV_CHOKE1, EV_CHOKE3), 2000);

	if (traceEnt->s.weapon == WP_SABER)
	{
		//if we pick up, turn off their weapon
		WP_DeactivateSaber(traceEnt, qtrue);
	}

	G_SoundOnEnt(self, CHAN_BODY, "sound/weapons/force/drain.mp3");

	NPC_SetAnim(traceEnt, SETANIM_BOTH, BOTH_FORCE_DRAIN_GRABBED, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);

	WP_SabersCheckLock2(self, traceEnt, LOCK_FORCE_DRAIN);

	return qtrue;
}

static void ForceDrain(gentity_t* self, const qboolean tried_drain2)
{
	if (self->health <= 0)
	{
		return;
	}

	if (PM_InLedgeMove(self->client->ps.legsAnim))
	{
		return;
	}

	if (!tried_drain2 && self->client->ps.weaponTime > 0)
	{
		return;
	}

	if (self->client->ps.forcePower < 25 || !WP_ForcePowerUsable(self, FP_DRAIN, 0))
	{
		return;
	}
	if (self->client->ps.forcePowerDebounce[FP_DRAIN] > level.time)
	{
		//stops it while using it and also after using it, up to 3 second delay
		return;
	}

	if (self->client->ps.saberLockTime > level.time)
	{
		//FIXME: can this be a way to break out?
		return;
	}

	// Make sure to turn off Force Protection and Force Absorb.
	if (self->client->ps.forcePowersActive & 1 << FP_PROTECT)
	{
		WP_ForcePowerStop(self, FP_PROTECT);
	}
	if (self->client->ps.forcePowersActive & 1 << FP_PROJECTION)
	{
		WP_ForcePowerStop(self, FP_PROJECTION);
	}
	if (self->client->ps.forcePowersActive & 1 << FP_ABSORB)
	{
		WP_ForcePowerStop(self, FP_ABSORB);
	}

	G_SoundOnEnt(self, CHAN_BODY, "sound/weapons/force/drained.mp3");

	WP_ForcePowerStart(self, FP_DRAIN, 0);
}

static qboolean FP_ForceDrainableEnt(const gentity_t* victim)
{
	if (!victim || !victim->client)
	{
		return qfalse;
	}
	switch (victim->client->NPC_class)
	{
	case CLASS_SAND_CREATURE: //??
	case CLASS_ATST: // technically droid...
	case CLASS_GONK: // droid
	case CLASS_INTERROGATOR: // droid
	case CLASS_MARK1: // droid
	case CLASS_MARK2: // droid
	case CLASS_GALAKMECH: // droid
	case CLASS_MINEMONSTER:
	case CLASS_MOUSE: // droid
	case CLASS_PROBE: // droid
	case CLASS_PROTOCOL: // droid
	case CLASS_R2D2: // droid
	case CLASS_R5D2: // droid
	case CLASS_REMOTE:
	case CLASS_SEEKER: // droid
	case CLASS_SENTRY:
	case CLASS_SABER_DROID:
	case CLASS_ASSASSIN_DROID:
	case CLASS_DROIDEKA:
	case CLASS_VEHICLE:
		return qfalse;
	default:
		break;
	}
	return qtrue;
}

qboolean FP_ForceDrainGrippableEnt(const gentity_t* victim)
{
	if (!victim || !victim->client)
	{
		return qfalse;
	}
	if (!FP_ForceDrainableEnt(victim))
	{
		return qfalse;
	}
	switch (victim->client->NPC_class)
	{
	case CLASS_RANCOR:
	case CLASS_SAND_CREATURE:
	case CLASS_WAMPA:
	case CLASS_LIZARD:
	case CLASS_MINEMONSTER:
	case CLASS_MURJJ:
	case CLASS_SWAMP:
	case CLASS_ROCKETTROOPER:
	case CLASS_HAZARD_TROOPER:
		return qfalse;
	default:
		break;
	}
	return qtrue;
}

qboolean Jedi_DrainReaction(gentity_t* self);

static void ForceDrainDamage(gentity_t* self, gentity_t* traceEnt, vec3_t dir, vec3_t impact_point)
{
	if (traceEnt->flags & FL_NOTARGET || traceEnt->noclip)
	{
		return;
	}

	if (traceEnt
		&& traceEnt->health > 0
		&& traceEnt->takedamage
		&& FP_ForceDrainableEnt(traceEnt))
	{
		if (traceEnt->client
			&& (!OnSameTeam(self, traceEnt) || self->enemy == traceEnt)
			//don't drain an ally unless that is actually my current enemy
			&& self->client->ps.forceDrainTime < level.time)
		{
			//an enemy or object
			int mod_power_level = -1;
			int dmg = self->client->ps.forcePowerLevel[FP_DRAIN] + 1;
			int dflags = DAMAGE_NO_ARMOR | DAMAGE_NO_KNOCKBACK | DAMAGE_NO_HIT_LOC; //|DAMAGE_NO_KILL);
			if (traceEnt->s.number == self->client->ps.forceDrainEntityNum)
			{
				//grabbing hold of them does more damage/drains more, and can actually kill them
				dmg += 3;
				dflags |= DAMAGE_IGNORE_TEAM;
			}

			if (traceEnt->client)
			{
				mod_power_level = WP_AbsorbConversion(traceEnt, traceEnt->client->ps.forcePowerLevel[FP_ABSORB],
					FP_DRAIN,
					self->client->ps.forcePowerLevel[FP_DRAIN], 0);
			}

			if (mod_power_level != -1)
			{
				if (!mod_power_level)
				{
					dmg = 0;
				}
				else if (mod_power_level == 1)
				{
					dmg = 1;
				}
				else if (mod_power_level == 2)
				{
					dmg = 2;
				}
			}

			if (dmg)
			{
				int drain = 0;
				if (traceEnt->client->ps.forcePower)
				{
					if (dmg > traceEnt->client->ps.forcePower)
					{
						drain = traceEnt->client->ps.forcePower;
						dmg -= drain;
						traceEnt->client->ps.forcePower = 0;
					}
					else
					{
						drain = dmg;
						traceEnt->client->ps.forcePower -= dmg;
						dmg = 0;
					}
					if (g_SerenityJediEngineMode->integer)
					{
						Jedi_DrainReaction(traceEnt);
					}
				}

				int max_health = self->client->ps.stats[STAT_MAX_HEALTH];
				if (self->client->ps.forcePowerLevel[FP_DRAIN] > FORCE_LEVEL_2)
				{
					//overcharge health
					max_health = floor(static_cast<float>(self->client->ps.stats[STAT_MAX_HEALTH]) * 1.25f);
				}
				if (self->client->ps.stats[STAT_HEALTH] < max_health &&
					self->health > 0 && self->client->ps.stats[STAT_HEALTH] > 0)
				{
					self->health += drain + dmg;
					if (self->health > max_health)
					{
						self->health = max_health;
					}
					self->client->ps.stats[STAT_HEALTH] = self->health;
					if (self->health > self->client->ps.stats[STAT_MAX_HEALTH])
					{
						self->flags |= FL_OVERCHARGED_HEALTH;
					}
				}

				if (dmg)
				{
					//do damage, too
					G_Damage(traceEnt, self, self, dir, impact_point, dmg, dflags, MOD_FORCE_DRAIN);

					if (g_SerenityJediEngineMode->integer)
					{// this makes him do the pain anim
						Jedi_DrainReaction(traceEnt);
					}
				}
				else if (drain)
				{
					NPC_SetPainEvent(traceEnt);
				}

				if (!Q_irand(0, 2))
				{
					G_Sound(traceEnt, G_SoundIndex("sound/weapons/force/drained.mp3"));
				}

				traceEnt->client->ps.forcePowerRegenDebounceTime = level.time + 800;
				//don't let the client being drained get force power back right away
			}
		}
	}
}

static qboolean WP_CheckForceDraineeStopMe(gentity_t* self, gentity_t* drainee)
{
	if (drainee->NPC
		&& drainee->client
		&& drainee->client->ps.forcePowersKnown & 1 << FP_PUSH
		&& level.time - (self->client->ps.forcePowerDebounce[FP_DRAIN] > self->client->ps.forcePowerLevel[FP_DRAIN] *
			500) //at level 1, I always get at least 500ms of drain, at level 3 I get 1500ms
		&& !Q_irand(0, 100 - drainee->NPC->stats.evasion * 10 - g_spskill->integer * 12))
	{
		//a jedi who broke free
		if (g_SerenityJediEngineMode->integer)
		{
			if (drainee->client->NPC_class == CLASS_GALEN
				&& (drainee->s.weapon == WP_MELEE || drainee->s.weapon == WP_NONE || drainee->s.weapon == WP_SABER && !
					drainee->client->ps.SaberActive())
				&& drainee->client->ps.groundEntityNum == ENTITYNUM_NONE)
			{
				ForceRepulse(drainee, qfalse);
			}
			else
			{
				ForceThrow_MD(drainee, qfalse);
			}
		}
		else
		{
			ForceThrow_JKA(drainee, qfalse);
		}
		WP_ForcePowerStop(self, FP_DRAIN);
		//can't drain again for 2 seconds
		self->client->ps.forcePowerDebounce[FP_DRAIN] = level.time + 4000;
		return qtrue;
	}
	return qfalse;
}

static void ForceShootDrain(gentity_t* self)
{
	trace_t tr;
	int num_drained = 0;

	if (self->health <= 0)
	{
		return;
	}

	if (PM_InLedgeMove(self->client->ps.legsAnim))
	{
		return;
	}

	if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self) && self->client->ps.weapon == WP_SABER)
		//npc force use limit
	{
		if (self->client->ps.blockPoints < BLOCKPOINTS_HALF || self->client->ps.forcePower < BLOCKPOINTS_HALF)
		{
			return;
		}
	}

	if (self->client->ps.forcePowerDebounce[FP_DRAIN] <= level.time)
	{
		gentity_t* traceEnt;
		vec3_t forward;
		AngleVectors(self->client->ps.viewangles, forward, nullptr, nullptr);
		VectorNormalize(forward);

		if (self->client->ps.forcePowerLevel[FP_DRAIN] > FORCE_LEVEL_2)
		{
			//arc
			vec3_t center, mins, maxs, v;
			constexpr float radius = MAX_DRAIN_DISTANCE;
			gentity_t* entity_list[MAX_GENTITIES];
			int i;

			VectorCopy(self->client->ps.origin, center);
			for (i = 0; i < 3; i++)
			{
				mins[i] = center[i] - radius;
				maxs[i] = center[i] + radius;
			}
			const int num_listed_entities = gi.EntitiesInBox(mins, maxs, entity_list, MAX_GENTITIES);

			for (int e = 0; e < num_listed_entities; e++)
			{
				vec3_t size;
				float dot;
				vec3_t ent_org;
				vec3_t dir;
				traceEnt = entity_list[e];

				if (!traceEnt)
					continue;
				if (traceEnt == self)
					continue;
				if (!traceEnt->inuse)
					continue;
				if (!traceEnt->takedamage)
					continue;
				if (traceEnt->health <= 0) //no torturing corpses
					continue;
				if (!traceEnt->client)
					continue;
				if (self->enemy != traceEnt //not my enemy
					&& OnSameTeam(self, traceEnt)) //on my team
					continue;
				//this is all to see if we need to start a saber attack, if it's in flight, this doesn't matter
				// find the distance from the edge of the bounding box
				for (i = 0; i < 3; i++)
				{
					if (center[i] < traceEnt->absmin[i])
					{
						v[i] = traceEnt->absmin[i] - center[i];
					}
					else if (center[i] > traceEnt->absmax[i])
					{
						v[i] = center[i] - traceEnt->absmax[i];
					}
					else
					{
						v[i] = 0;
					}
				}

				VectorSubtract(traceEnt->absmax, traceEnt->absmin, size);
				VectorMA(traceEnt->absmin, 0.5, size, ent_org);

				//see if they're in front of me
				//must be within the forward cone
				VectorSubtract(ent_org, center, dir);
				VectorNormalize(dir);
				if ((dot = DotProduct(dir, forward)) < 0.5)
					continue;

				//must be close enough
				const float dist = VectorLength(v);
				if (dist >= radius)
				{
					continue;
				}

				//in PVS?
				if (!traceEnt->bmodel && !gi.inPVS(ent_org, self->client->renderInfo.handLPoint))
				{
					//must be in PVS
					continue;
				}

				//Now check and see if we can actually hit it
				gi.trace(&tr, self->client->ps.origin, vec3_origin, vec3_origin, ent_org, self->s.number, MASK_SHOT,
					G2_RETURNONHIT, 10);
				if (tr.fraction < 1.0f && tr.entityNum != traceEnt->s.number)
				{
					//must have clear LOS
					continue;
				}

				if (g_SerenityJediEngineMode->integer)
				{
					if (traceEnt
						&& traceEnt->s.number >= MAX_CLIENTS //npc only
						&& traceEnt->client
						&& traceEnt->client->ps.forcePowerLevel[FP_LEVITATION] > FORCE_LEVEL_0 &&
						traceEnt->client->ps.weapon != WP_SABER)
					{
						if (!Q_irand(0, 4) && !jedi_dodge_evasion(traceEnt, self, &tr, HL_NONE))
						{
							//act like we didn't even hit him
							continue;
						}
					}
				}
				else
				{
					if (traceEnt
						&& traceEnt->s.number >= MAX_CLIENTS
						&& traceEnt->client
						&& traceEnt->client->ps.forcePowerLevel[FP_LEVITATION] > FORCE_LEVEL_0)
					{
						if (!Q_irand(0, 4) && !jedi_dodge_evasion(traceEnt, self, &tr, HL_NONE))
						{
							//act like we didn't even hit him
							continue;
						}
					}
				}

				// ok, we are within the radius, add us to the incoming list
				if (WP_CheckForceDraineeStopMe(self, traceEnt))
				{
					continue;
				}
				ForceDrainDamage(self, traceEnt, dir, ent_org);
				num_drained++;
			}
		}
		else
		{
			vec3_t end;
			//trace-line
			int ignore = self->s.number;
			int traces = 0;
			vec3_t start;

			VectorCopy(self->client->renderInfo.handLPoint, start);
			VectorMA(start, MAX_DRAIN_DISTANCE, forward, end);

			while (traces < 10)
			{
				//need to loop this in case we hit a Jedi who dodges the shot
				gi.trace(&tr, start, vec3_origin, vec3_origin, end, ignore, MASK_SHOT, G2_RETURNONHIT, 10);
				if (tr.entityNum == ENTITYNUM_NONE || tr.fraction == 1.0 || tr.allsolid || tr.startsolid)
				{
					//always take 1 force point per frame that we're shooting this
					WP_ForcePowerDrain(self, FP_DRAIN, 1);
					return;
				}

				traceEnt = &g_entities[tr.entityNum];

				if (g_SerenityJediEngineMode->integer)
				{
					if (traceEnt
						&& traceEnt->s.number >= MAX_CLIENTS
						&& traceEnt->client
						&& traceEnt->client->ps.forcePowerLevel[FP_LEVITATION] > FORCE_LEVEL_0 &&
						traceEnt->client->ps.weapon != WP_SABER)
					{
						if (!Q_irand(0, 2) && !jedi_dodge_evasion(traceEnt, self, &tr, HL_NONE))
						{
							//act like we didn't even hit him
							VectorCopy(tr.endpos, start);
							ignore = tr.entityNum;
							traces++;
							continue;
						}
					}
				}
				else
				{
					if (traceEnt
						&& traceEnt->s.number >= MAX_CLIENTS
						&& traceEnt->client
						&& traceEnt->client->ps.forcePowerLevel[FP_LEVITATION] > FORCE_LEVEL_0)
					{
						if (!Q_irand(0, 2) && !jedi_dodge_evasion(traceEnt, self, &tr, HL_NONE))
						{
							//act like we didn't even hit him
							VectorCopy(tr.endpos, start);
							ignore = tr.entityNum;
							traces++;
							continue;
						}
					}
				}
				break;
			}
			traceEnt = &g_entities[tr.entityNum];
			if (!WP_CheckForceDraineeStopMe(self, traceEnt))
			{
				ForceDrainDamage(self, traceEnt, forward, tr.endpos);
			}
			num_drained = 1;
		}

		self->client->ps.forcePowerDebounce[FP_DRAIN] = level.time + 200; //so we don't drain so damn fast!
	}
	self->client->ps.forcePowerRegenDebounceTime = level.time + 500;

	if (!num_drained)
	{
		//always take 1 force point per frame that we're shooting this
		WP_ForcePowerDrain(self, FP_DRAIN, 1);
	}
	else
	{
		WP_ForcePowerDrain(self, FP_DRAIN, num_drained); //was 2, but...
	}
}

static void ForceDrainEnt(gentity_t* self, gentity_t* drain_ent)
{
	if (self->health <= 0)
	{
		return;
	}

	if (self->client->ps.forcePowerDebounce[FP_DRAIN] <= level.time)
	{
		if (!drain_ent)
			return;
		if (drain_ent == self)
			return;
		if (!drain_ent->inuse)
			return;
		if (!drain_ent->takedamage)
			return;
		if (drain_ent->health <= 0) //no torturing corpses
			return;
		if (!drain_ent->client)
			return;
		if (OnSameTeam(self, drain_ent))
			return;

		vec3_t fwd;
		AngleVectors(self->client->ps.viewangles, fwd, nullptr, nullptr);

		drain_ent->painDebounceTime = 0;

		ForceDrainDamage(self, drain_ent, fwd, drain_ent->currentOrigin);
		drain_ent->painDebounceTime = level.time + 2000;

		if (drain_ent->s.number)
		{
			if (self->client->ps.forcePowerLevel[FP_DRAIN] > FORCE_LEVEL_2)
			{
				//do damage faster at level 3
				self->client->ps.forcePowerDebounce[FP_DRAIN] = level.time + Q_irand(100, 500);
			}
			else
			{
				self->client->ps.forcePowerDebounce[FP_DRAIN] = level.time + Q_irand(200, 800);
			}
		}
		else
		{
			//player takes damage faster
			self->client->ps.forcePowerDebounce[FP_DRAIN] = level.time + Q_irand(100, 500);
		}
	}

	self->client->ps.forcePowerRegenDebounceTime = level.time + 500;
}

void ForceSeeing(gentity_t* self)
{
	if (self->health <= 0)
	{
		return;
	}

	if (PM_InLedgeMove(self->client->ps.legsAnim))
	{
		return;
	}

	if (self->client->ps.forceAllowDeactivateTime < level.time &&
		self->client->ps.forcePowersActive & 1 << FP_SEE)
	{
		WP_ForcePowerStop(self, FP_SEE);
		return;
	}

	if (!WP_ForcePowerUsable(self, FP_SEE, 0))
	{
		return;
	}

	WP_DebounceForceDeactivateTime(self);

	WP_ForcePowerStart(self, FP_SEE, 0);

	if (self->client->ps.saberLockTime < level.time && !PM_InKnockDown(&self->client->ps))
	{
		if (self->client->ps.forcePowerLevel[FP_SEE] < FORCE_LEVEL_3)
		{
			//animate
			int parts = SETANIM_BOTH;
			if (self->client->ps.forcePowerLevel[FP_SEE] > FORCE_LEVEL_1)
			{
				//level 2 only does it on torso (can keep running)
				parts = SETANIM_TORSO;
			}
			else
			{
				if (self->client->ps.groundEntityNum != ENTITYNUM_NONE)
				{
					VectorClear(self->client->ps.velocity);
				}
				if (self->NPC)
				{
					VectorClear(self->client->ps.moveDir);
					self->client->ps.speed = 0;
				}
			}
			NPC_SetAnim(self, parts, BOTH_FORCE_DRAIN_HOLD, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);

			//don't move or attack during this anim
			if (self->client->ps.forcePowerLevel[FP_SEE] < FORCE_LEVEL_2)
			{
				self->client->ps.pm_flags |= PMF_TIME_KNOCKBACK;
				self->client->ps.pm_time = self->client->ps.weaponTime = self->client->ps.torsoAnimTimer;

				if (self->s.number)
				{
					//NPC
					self->painDebounceTime = level.time + self->client->ps.torsoAnimTimer;
				}
				else
				{
					//player
					self->aimDebounceTime = level.time + self->client->ps.torsoAnimTimer;
				}
			}
			else
			{
				self->client->ps.weaponTime = self->client->ps.torsoAnimTimer;
			}
		}
		else
		{
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_FORCE_DRAIN_HOLD, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
			self->client->ps.weaponTime = self->client->ps.torsoAnimTimer;
		}
	}

	G_SoundOnEnt(self, CHAN_ITEM, "sound/weapons/force/see.wav");
}

void ForceProtect(gentity_t* self)
{
	if (self->health <= 0)
	{
		return;
	}

	if (self->client->ps.forceAllowDeactivateTime < level.time &&
		self->client->ps.forcePowersActive & 1 << FP_PROTECT)
	{
		WP_ForcePowerStop(self, FP_PROTECT);
		return;
	}
	if (self->client->ps.forcePowersActive & 1 << FP_PROJECTION)
	{
		WP_ForcePowerStop(self, FP_PROJECTION);
	}

	if (PM_InLedgeMove(self->client->ps.legsAnim))
	{
		return;
	}

	if (!WP_ForcePowerUsable(self, FP_PROTECT, 0))
	{
		return;
	}

	// Make sure to turn off Force Rage and Force Absorb.
	if (self->client->ps.forcePowersActive & 1 << FP_RAGE)
	{
		WP_ForcePowerStop(self, FP_RAGE);
	}

	WP_DebounceForceDeactivateTime(self);

	WP_ForcePowerStart(self, FP_PROTECT, 0);

	if (self->client->ps.saberLockTime < level.time && !PM_InKnockDown(&self->client->ps))
	{
		if (self->client->ps.forcePowerLevel[FP_PROTECT] < FORCE_LEVEL_3)
		{
			//animate
			int parts = SETANIM_BOTH;
			if (self->client->ps.forcePowerLevel[FP_PROTECT] > FORCE_LEVEL_1)
			{
				//level 2 only does it on torso (can keep running)
				parts = SETANIM_TORSO;
			}
			else
			{
				if (self->client->ps.groundEntityNum != ENTITYNUM_NONE)
				{
					VectorClear(self->client->ps.velocity);
				}
				if (self->NPC)
				{
					VectorClear(self->client->ps.moveDir);
					self->client->ps.speed = 0;
				}
			}
			NPC_SetAnim(self, parts, BOTH_FORCE_PROTECT, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);

			//don't move or attack during this anim
			if (self->client->ps.forcePowerLevel[FP_PROTECT] < FORCE_LEVEL_2)
			{
				self->client->ps.pm_flags |= PMF_TIME_KNOCKBACK;
				self->client->ps.pm_time = self->client->ps.weaponTime = self->client->ps.torsoAnimTimer;

				if (self->s.number)
				{
					//NPC
					self->painDebounceTime = level.time + self->client->ps.torsoAnimTimer;
				}
				else
				{
					//player
					self->aimDebounceTime = level.time + self->client->ps.torsoAnimTimer;
				}
			}
			else
			{
				self->client->ps.weaponTime = self->client->ps.torsoAnimTimer;
			}
		}
		else
		{
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_FORCE_PROTECT_FAST, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
			self->client->ps.weaponTime = self->client->ps.torsoAnimTimer;
		}
	}
}

void ForceAbsorb(gentity_t* self)
{
	if (self->health <= 0)
	{
		return;
	}

	if (self->client->ps.forceAllowDeactivateTime < level.time &&
		self->client->ps.forcePowersActive & 1 << FP_ABSORB)
	{
		WP_ForcePowerStop(self, FP_ABSORB);
		return;
	}

	if (PM_InLedgeMove(self->client->ps.legsAnim))
	{
		return;
	}

	if (!WP_ForcePowerUsable(self, FP_ABSORB, 0))
	{
		return;
	}

	// Make sure to turn off Force Rage and Force Protection.
	if (self->client->ps.forcePowersActive & 1 << FP_RAGE)
	{
		WP_ForcePowerStop(self, FP_RAGE);
	}

	WP_DebounceForceDeactivateTime(self);

	WP_ForcePowerStart(self, FP_ABSORB, 0);

	if (self->client->ps.saberLockTime < level.time && !PM_InKnockDown(&self->client->ps))
	{
		if (self->client->ps.forcePowerLevel[FP_ABSORB] < FORCE_LEVEL_3)
		{
			//animate
			int parts = SETANIM_BOTH;
			if (self->client->ps.forcePowerLevel[FP_ABSORB] > FORCE_LEVEL_1)
			{
				//level 2 only does it on torso (can keep running)
				parts = SETANIM_TORSO;
			}
			else
			{
				if (self->client->ps.groundEntityNum != ENTITYNUM_NONE)
				{
					VectorClear(self->client->ps.velocity);
				}
				if (self->NPC)
				{
					VectorClear(self->client->ps.moveDir);
					self->client->ps.speed = 0;
				}
			}
			NPC_SetAnim(self, parts, BOTH_FORCE_ABSORB, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);

			//don't move or attack during this anim
			if (self->client->ps.forcePowerLevel[FP_ABSORB] < FORCE_LEVEL_2)
			{
				self->client->ps.pm_flags |= PMF_TIME_KNOCKBACK;
				self->client->ps.pm_time = self->client->ps.weaponTime = self->client->ps.torsoAnimTimer;

				if (self->s.number)
				{
					//NPC
					self->painDebounceTime = level.time + self->client->ps.torsoAnimTimer;
				}
				else
				{
					//player
					self->aimDebounceTime = level.time + self->client->ps.torsoAnimTimer;
				}
			}
			else
			{
				self->client->ps.weaponTime = self->client->ps.torsoAnimTimer;
			}
		}
		else
		{
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_FORCE_ABSORB, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
			self->client->ps.weaponTime = self->client->ps.torsoAnimTimer;
		}
	}
}

void ForceRage(gentity_t* self)
{
	if (self->health <= 0)
	{
		return;
	}

	if (self->client->ps.forceAllowDeactivateTime < level.time &&
		self->client->ps.forcePowersActive & 1 << FP_RAGE)
	{
		WP_ForcePowerStop(self, FP_RAGE);
		return;
	}

	if (PM_InLedgeMove(self->client->ps.legsAnim))
	{
		return;
	}

	if (!WP_ForcePowerUsable(self, FP_RAGE, 0))
	{
		return;
	}

	if (self->client->ps.forceRageRecoveryTime >= level.time)
	{
		return;
	}

	if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self) && self->client->ps.weapon == WP_SABER)
		//npc force use limit
	{
		if (self->client->ps.blockPoints < BLOCKPOINTS_MISSILE || self->client->ps.forcePower < BLOCKPOINTS_MISSILE)
		{
			return;
		}
	}

	if (self->s.number < MAX_CLIENTS && self->health < 25)
	{
		//have to have at least 25 health to start it
		return;
	}

	if (self->health < 10)
	{
		return;
	}

	// Make sure to turn off Force Protection and Force Absorb.
	if (self->client->ps.forcePowersActive & 1 << FP_PROTECT)
	{
		WP_ForcePowerStop(self, FP_PROTECT);
	}
	if (self->client->ps.forcePowersActive & 1 << FP_PROJECTION)
	{
		WP_ForcePowerStop(self, FP_PROJECTION);
	}
	if (self->client->ps.forcePowersActive & 1 << FP_ABSORB)
	{
		WP_ForcePowerStop(self, FP_ABSORB);
	}

	WP_DebounceForceDeactivateTime(self);

	WP_ForcePowerStart(self, FP_RAGE, 0);

	if (self->client->ps.saberLockTime < level.time && !PM_InKnockDown(&self->client->ps))
	{
		if (self->client->ps.forcePowerLevel[FP_RAGE] < FORCE_LEVEL_3)
		{
			//must animate
			if (self->client->ps.forcePowerLevel[FP_RAGE] < FORCE_LEVEL_2)
			{
				//have to stand still for whole length of anim
				NPC_SetAnim(self, SETANIM_BOTH, BOTH_FORCE_RAGE, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
				//don't attack during this anim
				self->client->ps.weaponTime = self->client->ps.torsoAnimTimer;
				self->client->ps.pm_flags |= PMF_TIME_KNOCKBACK;
				self->client->ps.pm_time = self->client->ps.torsoAnimTimer;
				if (self->s.number)
				{
					//NPC
					self->painDebounceTime = level.time + self->client->ps.torsoAnimTimer;
				}
				else
				{
					//player
					self->aimDebounceTime = level.time + self->client->ps.torsoAnimTimer;
				}
			}
			else
			{
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_FORCE_RAGE, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
				//don't attack during this anim
				self->client->ps.weaponTime = self->client->ps.torsoAnimTimer;
			}
			//stop saber
			self->client->ps.saber_move = self->client->ps.saberBounceMove = LS_READY;
			//don't finish whatever saber anim you may have been in
			self->client->ps.saberBlocked = BLOCKED_NONE;
		}
	}
	CG_PlayEffectBolted("misc/breath.efx", self->playerModel, self->headBolt, self->s.number, self->currentOrigin);
}

int WP_GetVelocityForForceJump(const gentity_t* self, vec3_t jump_vel, const usercmd_t* ucmd)
{
	float push_fwd = 0, push_rt = 0;
	vec3_t view, forward, right;
	VectorCopy(self->client->ps.viewangles, view);
	view[0] = 0;
	AngleVectors(view, forward, right, nullptr);
	if (ucmd->forwardmove && ucmd->rightmove)
	{
		if (ucmd->forwardmove > 0)
		{
			push_fwd = 50;
		}
		else
		{
			push_fwd = -50;
		}
		if (ucmd->rightmove > 0)
		{
			push_rt = 50;
		}
		else
		{
			push_rt = -50;
		}
	}
	else if (ucmd->forwardmove || ucmd->rightmove)
	{
		if (ucmd->forwardmove > 0)
		{
			push_fwd = 100;
		}
		else if (ucmd->forwardmove < 0)
		{
			push_fwd = -100;
		}
		else if (ucmd->rightmove > 0)
		{
			push_rt = 100;
		}
		else if (ucmd->rightmove < 0)
		{
			push_rt = -100;
		}
	}
	VectorMA(self->client->ps.velocity, push_fwd, forward, jump_vel);
	VectorMA(self->client->ps.velocity, push_rt, right, jump_vel);
	jump_vel[2] += self->client->ps.forceJumpCharge; //forceJumpStrength;
	if (push_fwd > 0 && self->client->ps.forceJumpCharge > 200)
	{
		return FJ_FORWARD;
	}
	if (push_fwd < 0 && self->client->ps.forceJumpCharge > 200)
	{
		return FJ_BACKWARD;
	}
	if (push_rt > 0 && self->client->ps.forceJumpCharge > 200)
	{
		return FJ_RIGHT;
	}
	if (push_rt < 0 && self->client->ps.forceJumpCharge > 200)
	{
		return FJ_LEFT;
	}
	//FIXME: jump straight up anim
	return FJ_UP;
}

void ForceJump(gentity_t* self, const usercmd_t* ucmd)
{
	if (self->client->NPC_class == CLASS_GUARD)
	{
		return;
	}
	if (self->client->ps.forcePowerDuration[FP_LEVITATION] > level.time)
	{
		return;
	}

	if (PM_InLedgeMove(self->client->ps.legsAnim))
	{
		return;
	}
	if (!WP_ForcePowerUsable(self, FP_LEVITATION, 0))
	{
		return;
	}
	if (self->s.groundEntityNum == ENTITYNUM_NONE)
	{
		return;
	}
	if (self->client->ps.pm_flags & PMF_JUMP_HELD)
	{
		return;
	}
	if (self->health <= 0)
	{
		return;
	}
	if (!self->s.number && (cg.zoomMode || in_camera))
	{
		//can't force jump when zoomed in or in cinematic
		return;
	}
	if (self->client->ps.saberLockTime > level.time)
	{
		//FIXME: can this be a way to break out?
		return;
	}

	if (self->client->NPC_class == CLASS_BOBAFETT || self->client->NPC_class == CLASS_MANDALORIAN || self->client->
		NPC_class == CLASS_JANGO || self->client->NPC_class == CLASS_JANGODUAL
		|| self->client->NPC_class == CLASS_ROCKETTROOPER)
	{
		if (self->client->ps.forceJumpCharge > 300)
		{
			JET_FlyStart(NPC);
		}
		else
		{
			G_AddEvent(self, EV_JUMP, 0);
		}
	}
	else
	{
		if (g_SerenityJediEngineMode->integer == 2 && self->client->ps.forcePowerLevel[FP_LEVITATION] < FORCE_LEVEL_3)
		{
			//short burst
			G_SoundOnEnt(self, CHAN_BODY, "sound/weapons/force/jumpsmall.mp3");
		}
		else
		{
			//holding it
			G_SoundOnEnt(self, CHAN_BODY, "sound/weapons/force/jump.mp3");
		}
	}

	const float force_jump_charge_interval = forceJumpStrength[self->client->ps.forcePowerLevel[FP_LEVITATION]] / (
		FORCE_JUMP_CHARGE_TIME / FRAMETIME);

	int anim;
	vec3_t jump_vel{};

	switch (WP_GetVelocityForForceJump(self, jump_vel, ucmd))
	{
	case FJ_FORWARD:
		if ((self->client->NPC_class == CLASS_BOBAFETT || self->client->NPC_class == CLASS_MANDALORIAN || self->client->
			NPC_class == CLASS_JANGO || self->client->NPC_class == CLASS_JANGODUAL || self->client->NPC_class ==
			CLASS_ROCKETTROOPER) && self->client->ps.forceJumpCharge > 300
			|| self->client->ps.saber[0].saberFlags & SFL_NO_FLIPS
			|| self->client->ps.dualSabers && self->client->ps.saber[1].saberFlags & SFL_NO_FLIPS
			|| self->NPC &&
			self->NPC->rank != RANK_CREWMAN &&
			self->NPC->rank <= RANK_LT_JG)
		{
			//can't do acrobatics
			anim = BOTH_FORCEJUMP1;
		}
		else
		{
			if (self->client->NPC_class == CLASS_ALORA && Q_irand(0, 3))
			{
				anim = Q_irand(BOTH_ALORA_FLIP_1, BOTH_ALORA_FLIP_3);
			}
			else
			{
				anim = BOTH_FLIP_F;
			}
		}
		break;
	case FJ_BACKWARD:
		if ((self->client->NPC_class == CLASS_BOBAFETT || self->client->NPC_class == CLASS_MANDALORIAN || self->client->
			NPC_class == CLASS_JANGO || self->client->NPC_class == CLASS_JANGODUAL || self->client->NPC_class ==
			CLASS_ROCKETTROOPER) && self->client->ps.forceJumpCharge > 300
			|| self->client->ps.saber[0].saberFlags & SFL_NO_FLIPS
			|| self->client->ps.dualSabers && self->client->ps.saber[1].saberFlags & SFL_NO_FLIPS
			|| self->NPC &&
			self->NPC->rank != RANK_CREWMAN &&
			self->NPC->rank <= RANK_LT_JG)
		{
			//can't do acrobatics
			anim = BOTH_FORCEJUMPBACK1;
		}
		else
		{
			anim = BOTH_FLIP_B;
		}
		break;
	case FJ_RIGHT:
		if ((self->client->NPC_class == CLASS_BOBAFETT || self->client->NPC_class == CLASS_MANDALORIAN || self->client->
			NPC_class == CLASS_JANGO || self->client->NPC_class == CLASS_JANGODUAL || self->client->NPC_class ==
			CLASS_ROCKETTROOPER) && self->client->ps.forceJumpCharge > 300
			|| self->client->ps.saber[0].saberFlags & SFL_NO_FLIPS
			|| self->client->ps.dualSabers && self->client->ps.saber[1].saberFlags & SFL_NO_FLIPS
			|| self->NPC &&
			self->NPC->rank != RANK_CREWMAN &&
			self->NPC->rank <= RANK_LT_JG)
		{
			//can't do acrobatics
			anim = BOTH_FORCEJUMPRIGHT1;
		}
		else
		{
			anim = BOTH_FLIP_R;
		}
		break;
	case FJ_LEFT:
		if ((self->client->NPC_class == CLASS_BOBAFETT || self->client->NPC_class == CLASS_MANDALORIAN || self->client->
			NPC_class == CLASS_JANGO || self->client->NPC_class == CLASS_JANGODUAL || self->client->NPC_class ==
			CLASS_ROCKETTROOPER) && self->client->ps.forceJumpCharge > 300
			|| self->client->ps.saber[0].saberFlags & SFL_NO_FLIPS
			|| self->client->ps.dualSabers && self->client->ps.saber[1].saberFlags & SFL_NO_FLIPS
			|| self->NPC &&
			self->NPC->rank != RANK_CREWMAN &&
			self->NPC->rank <= RANK_LT_JG)
		{
			//can't do acrobatics
			anim = BOTH_FORCEJUMPLEFT1;
		}
		else
		{
			anim = BOTH_FLIP_L;
		}
		break;
	default:
	case FJ_UP:
		anim = BOTH_JUMP1;
		break;
	}

	int parts = SETANIM_BOTH;
	if (self->client->ps.weaponTime)
	{
		//FIXME: really only care if we're in a saber attack anim.. maybe trail length?
		parts = SETANIM_LEGS;
	}

	NPC_SetAnim(self, parts, anim, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);

	//FIXME: sound effect
	self->client->ps.forceJumpZStart = self->currentOrigin[2]; //remember this for when we land
	VectorCopy(jump_vel, self->client->ps.velocity);
	//wasn't allowing them to attack when jumping, but that was annoying
	//self->client->ps.weaponTime = self->client->ps.torsoAnimTimer;

	WP_ForcePowerStart(self, FP_LEVITATION,
		self->client->ps.forceJumpCharge / force_jump_charge_interval / (FORCE_JUMP_CHARGE_TIME /
			FRAMETIME)
		* forcePowerNeeded[FP_LEVITATION]);
	//self->client->ps.forcePowerDuration[FP_LEVITATION] = level.time + self->client->ps.weaponTime;
	self->client->ps.forceJumpCharge = 0;
}

constexpr auto DESTRUCTION_VELOCITY = 1200;

constexpr auto DESTRUCTION_DAMAGE = 100;
constexpr auto DESTRUCTION_SPLASH_DAMAGE = 80;

constexpr auto DESTRUCTION_SPLASH_RADIUS = 260;

constexpr auto DESTRUCTION_NPC_DAMAGE_EASY = 30;
constexpr auto DESTRUCTION_NPC_DAMAGE_NORMAL = 60;
constexpr auto DESTRUCTION_NPC_DAMAGE_HARD = 90;
constexpr auto DESTRUCTION_SIZE = 3;

gentity_t* create_missile(vec3_t org, vec3_t dir, float vel, int life, gentity_t* owner, qboolean alt_fire = qfalse);
//---------------------------------------------------------
static void WP_FireDestruction(gentity_t* ent, const int force_level)
//---------------------------------------------------------
{
	vec3_t start, forward;
	int damage = DESTRUCTION_DAMAGE;
	float vel = DESTRUCTION_VELOCITY;

	if (ent == player)
	{
		damage *= player->client->ps.forcePower * force_level;

		// Just in case the player's force meter is impossibly large
		if (damage <= 0)
		{
			damage = 2147483647;
		}
	}

	if (force_level == FORCE_LEVEL_2)
	{
		vel *= 1.5f;
	}
	else if (force_level == FORCE_LEVEL_3)
	{
		vel *= 2.0f;
	}

	AngleVectors(ent->client->ps.viewangles, forward, nullptr, nullptr);
	VectorNormalize(forward);

	VectorCopy(ent->client->renderInfo.eyePoint, start);

	gentity_t* missile = create_missile(start, forward, vel, 10000, ent, qfalse);

	missile->classname = "rocket_proj";
	missile->s.weapon = WP_CONCUSSION;
	missile->s.powerups |= 1 << PW_FORCE_PROJECTILE;
	missile->mass = 10;

	// Do the damages
	if (ent->s.number != 0)
	{
		if (g_spskill->integer == 0)
		{
			damage = DESTRUCTION_NPC_DAMAGE_EASY;
		}
		else if (g_spskill->integer == 1)
		{
			damage = DESTRUCTION_NPC_DAMAGE_NORMAL;
		}
		else
		{
			damage = DESTRUCTION_NPC_DAMAGE_HARD;
		}
	}

	// Make it easier to hit things
	VectorSet(missile->maxs, DESTRUCTION_SIZE, DESTRUCTION_SIZE, DESTRUCTION_SIZE);
	VectorScale(missile->maxs, -1, missile->mins);

	missile->damage = damage * (1.0f + force_level) / 2.0f;
	missile->dflags = DAMAGE_DEATH_KNOCKBACK | DAMAGE_EXTRA_KNOCKBACK;

	missile->methodOfDeath = MOD_DESTRUCTION;
	missile->splashMethodOfDeath = MOD_DESTRUCTION; // ?SPLASH;

	missile->clipmask = MASK_SHOT | CONTENTS_LIGHTSABER;
	missile->splashDamage = DESTRUCTION_SPLASH_DAMAGE * (1.0f + force_level) / 2.0f;
	missile->splashRadius = DESTRUCTION_SPLASH_RADIUS * (1.0f + force_level) / 3.0f;

	// we don't want it to ever bounce
	missile->bounceCount = 0;
}

void ForceDestruction(gentity_t* self)
{
	int anim;
	if (self->health <= 0)
	{
		return;
	}
	if (!WP_ForcePowerUsable(self, FP_DESTRUCTION, 0))
	{
		return;
	}

	if (PM_InLedgeMove(self->client->ps.legsAnim))
	{
		return;
	}
	if (self->client->ps.forcePowerDebounce[FP_DESTRUCTION] > level.time)
	{
		//already using destruction
		return;
	}
	if (!self->s.number && (cg.zoomMode || in_camera))
	{
		//can't destruction when zoomed in or in cinematic
		return;
	}
	if (self->client->ps.saberLockTime > level.time)
	{
		//FIXME: can this be a way to break out?
		return;
	}

	if (self->client->ps.forcePower < 25 || !WP_ForcePowerUsable(self, FP_DESTRUCTION, 0))
	{
		return;
	}

	if (self->s.weapon == WP_MELEE ||
		self->s.weapon == WP_NONE ||
		self->s.weapon == WP_SABER && !self->client->ps.SaberActive())
	{
		//2-handed PUSH
		if (self->client->ps.groundEntityNum == ENTITYNUM_NONE)
		{
			anim = BOTH_DUAL_PUSH;

			if (self->handLBolt != -1)
			{
				G_PlayEffect(G_EffectIndex("force/drain_hand"), self->playerModel, self->handLBolt, self->s.number,
					self->currentOrigin, 200, qtrue);
			}

			if (self->handRBolt != -1)
			{
				G_PlayEffect(G_EffectIndex("force/drain_hand"), self->playerModel, self->handRBolt, self->s.number,
					self->currentOrigin, 200, qtrue);
			}
		}
		else
		{
			if (self->s.eFlags & EF_FORCE_DRAINED || self->s.eFlags & EF_FORCE_GRIPPED || self->s.eFlags &
				EF_FORCE_GRASPED)
			{
				anim = BOTH_FORCEPUSH;

				if (self->handLBolt != -1)
				{
					G_PlayEffect(G_EffectIndex("force/drain_hand"), self->playerModel, self->handLBolt, self->s.number,
						self->currentOrigin, 200, qtrue);
				}
			}
			else
			{
				anim = BOTH_DUAL_PUSH;

				if (self->handLBolt != -1)
				{
					G_PlayEffect(G_EffectIndex("force/drain_hand"), self->playerModel, self->handLBolt, self->s.number,
						self->currentOrigin, 200, qtrue);
				}

				if (self->handRBolt != -1)
				{
					G_PlayEffect(G_EffectIndex("force/drain_hand"), self->playerModel, self->handRBolt, self->s.number,
						self->currentOrigin, 200, qtrue);
				}
			}
		}
	}
	else
	{
		anim = BOTH_FORCEPUSH;

		if (self->handLBolt != -1)
		{
			G_PlayEffect(G_EffectIndex("force/drain_hand"), self->playerModel, self->handLBolt, self->s.number,
				self->currentOrigin, 200, qtrue);
		}
	}
	const int sound_index = G_SoundIndex("sound/weapons/force/destruct.mp3");

	int parts = SETANIM_TORSO;
	if (!PM_InKnockDown(&self->client->ps))
	{
		if (!VectorLengthSquared(self->client->ps.velocity) && !(self->client->ps.pm_flags & PMF_DUCKED))
		{
			parts = SETANIM_BOTH;
		}
	}
	NPC_SetAnim(self, parts, anim, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD | SETANIM_FLAG_RESTART);
	self->client->ps.saber_move = self->client->ps.saberBounceMove = LS_READY;
	//don't finish whatever saber anim you may have been in
	self->client->ps.saberBlocked = BLOCKED_NONE;

	G_Sound(self, sound_index);

	WP_FireDestruction(self, self->client->ps.forcePowerLevel[FP_DESTRUCTION]);

	WP_ForcePowerStart(self, FP_DESTRUCTION, 0);

	self->client->ps.weaponTime = 1000;
	if (self->client->ps.forcePowersActive & 1 << FP_SPEED)
	{
		self->client->ps.weaponTime = floor(self->client->ps.weaponTime * g_timescale->value);
	}
	self->client->ps.forcePowerDebounce[FP_DESTRUCTION] = level.time + self->client->ps.torsoAnimTimer + 4000;
}

qboolean PlayerAffectedByStasis()
{
	const gentity_t* ent = &g_entities[0];
	if (ent && ent->client && ent->client->ps.stasisTime > (cg.time ? cg.time : level.time))
	{
		return qtrue;
	}
	if (ent && ent->client && ent->client->ps.stasisJediTime > (cg.time ? cg.time : level.time))
	{
		return qtrue;
	}
	return qfalse;
}

extern void PM_SetTorsoAnimTimer(gentity_t* ent, int* torso_anim_timer, int time);

static void forcestasis_anim(gentity_t* self)
{
	int anim;

	if (self->s.weapon == WP_MELEE ||
		self->s.weapon == WP_NONE ||
		self->s.weapon == WP_SABER && !self->client->ps.SaberActive())
	{
		//2-handed PUSH
		if (self->client->ps.groundEntityNum == ENTITYNUM_NONE)
		{
			anim = BOTH_FORCE_REPULSE;

			if (self->handLBolt != -1)
			{
				G_PlayEffect(G_EffectIndex("force/pushblur"), self->playerModel, self->handLBolt, self->s.number,
					self->currentOrigin, 200, qtrue);
			}

			if (self->handRBolt != -1)
			{
				G_PlayEffect(G_EffectIndex("force/pushblur"), self->playerModel, self->handRBolt, self->s.number,
					self->currentOrigin, 200, qtrue);
			}
		}
		else
		{
			if (self->s.eFlags & EF_FORCE_DRAINED || self->s.eFlags & EF_FORCE_GRIPPED || self->s.eFlags &
				EF_FORCE_GRASPED)
			{
				anim = BOTH_FORCEPUSH;

				if (self->handLBolt != -1)
				{
					G_PlayEffect(G_EffectIndex("force/pushblur"), self->playerModel, self->handLBolt, self->s.number,
						self->currentOrigin, 200, qtrue);
				}
			}
			else
			{
				anim = BOTH_DUAL_PUSH;

				if (self->handLBolt != -1)
				{
					G_PlayEffect(G_EffectIndex("force/pushblur"), self->playerModel, self->handLBolt, self->s.number,
						self->currentOrigin, 200, qtrue);
				}

				if (self->handRBolt != -1)
				{
					G_PlayEffect(G_EffectIndex("force/pushblur"), self->playerModel, self->handRBolt, self->s.number,
						self->currentOrigin, 200, qtrue);
				}
			}
		}
	}
	else
	{
		anim = BOTH_FORCEPUSH;

		if (self->handLBolt != -1)
		{
			G_PlayEffect(G_EffectIndex("force/pushblur"), self->playerModel, self->handLBolt, self->s.number,
				self->currentOrigin, 200, qtrue);
		}
	}
	const int sound_index = G_SoundIndex("sound/weapons/force/force_stasis.mp3");

	int parts = SETANIM_TORSO;

	if (!PM_InKnockDown(&self->client->ps))
	{
		if (!VectorLengthSquared(self->client->ps.velocity) && !(self->client->ps.pm_flags & PMF_DUCKED))
		{
			parts = SETANIM_BOTH;
		}
	}
	NPC_SetAnim(self, parts, anim, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD | SETANIM_FLAG_RESTART);
	self->client->ps.saber_move = self->client->ps.saberBounceMove = LS_READY;
	//don't finish whatever saber anim you may have been in
	self->client->ps.saberBlocked = BLOCKED_NONE;

	G_Sound(self, sound_index);

	WP_ForcePowerStart(self, FP_STASIS, 0);

	self->client->ps.weaponTime = 1000;

	if (self->client->ps.forcePowersActive & 1 << FP_SPEED)
	{
		self->client->ps.weaponTime = floor(self->client->ps.weaponTime * g_timescale->value);
	}
	self->client->ps.forcePowerDebounce[FP_STASIS] = level.time + self->client->ps.torsoAnimTimer + 500;
}

static void ForceStasisWide(const gentity_t* self, gentity_t* traceEnt)
{
	float current_frame, animSpeed;
	int junk;

	if (traceEnt->s.eType != ET_PLAYER)
	{
		// We hit an entity, but it wasn't an NPC.
		return;
	}

	if (traceEnt->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(traceEnt))
	{
		if (!in_camera && traceEnt->NPC && traceEnt->NPC->scriptFlags & SCF_NO_FORCE)
		{
			return;
		}
	}

	if (traceEnt && traceEnt->takedamage)
	{
		if (!traceEnt->client || traceEnt->client->playerTeam != self->client->playerTeam || self->enemy == traceEnt || traceEnt->enemy == self)
		{
			int actual_time;
			//an enemy or object
			if (traceEnt->health > 0 &&
				traceEnt->s.weapon != WP_SABER && traceEnt->client && traceEnt->client->NPC_class != CLASS_REBORN)
			{
				//doesn't affect jedi .but affects everything else??
				if (traceEnt->client)
				{
					traceEnt->client->ps.stasisTime = level.time + stasisTime[self->client->ps.forcePowerLevel[
						FP_STASIS]];
					VectorClear(traceEnt->client->ps.velocity);

					if (g_SerenityJediEngineMode->integer)
					{
						player_Freeze(traceEnt);

						if (traceEnt->client->NPC_class == CLASS_BOBAFETT ||
							traceEnt->client->NPC_class == CLASS_MANDALORIAN ||
							traceEnt->client->NPC_class == CLASS_JANGO ||
							traceEnt->client->NPC_class == CLASS_JANGODUAL ||
							traceEnt->client->NPC_class == CLASS_ROCKETTROOPER)
						{
							// also disables npc jetpack
							jet_fly_stop(traceEnt);
							if (traceEnt->client->jetPackOn)
							{
								//disable jetpack temporarily
								Jetpack_Off(traceEnt);
								traceEnt->client->jetPackToggleTime = level.time + Q_irand(3000, 10000);
							}
						}

						if (d_slowmoaction->integer && (self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self)))
						{
							if (g_SerenityJediEngineMode->integer == 2)
							{
								G_StartStasisEffect_FORCE_LEVEL_2(self);
							}
						}
					}
				}

				if (gi.G2API_HaveWeGhoul2Models(traceEnt->ghoul2))
				{
					actual_time = cg.time ? cg.time : level.time;
					gi.G2API_GetBoneAnimIndex(&traceEnt->ghoul2[traceEnt->playerModel], traceEnt->rootBone,
						level.time, &current_frame, &junk, &junk, &junk, &animSpeed, nullptr);

					gi.G2API_SetBoneAnimIndex(&traceEnt->ghoul2[traceEnt->playerModel], traceEnt->rootBone,
						current_frame, current_frame + 1,
						BONE_ANIM_OVERRIDE_FREEZE, animSpeed, level.time, current_frame, 100);
					if (traceEnt->headModel > 0)
					{
						gi.G2API_SetBoneAnimIndex(&traceEnt->ghoul2[traceEnt->headModel], traceEnt->headRootBone,
							current_frame, current_frame + 1,
							BONE_ANIM_OVERRIDE_FREEZE, animSpeed, level.time, current_frame,
							100);
					}
				}
			}
			else if (traceEnt->health > 0 &&
				traceEnt->s.weapon == WP_SABER && traceEnt->client && (traceEnt->client->ps.forcePower <=
					BLOCKPOINTS_MISSILE || traceEnt->client->ps.blockPoints <= BLOCKPOINTS_HALF) && (traceEnt->client
						->
						NPC_class != CLASS_GUARD && traceEnt->client->NPC_class != CLASS_JEDIMASTER))
			{
				//affect jedi.
				if (traceEnt->client)
				{
					traceEnt->client->ps.stasisJediTime = level.time + stasisJediTime[self->client->ps.forcePowerLevel[
						FP_STASIS]];
					VectorClear(traceEnt->client->ps.velocity);

					if (g_SerenityJediEngineMode->integer)
					{
						player_Freeze(traceEnt);

						if (traceEnt->client->NPC_class == CLASS_BOBAFETT ||
							traceEnt->client->NPC_class == CLASS_MANDALORIAN ||
							traceEnt->client->NPC_class == CLASS_JANGO ||
							traceEnt->client->NPC_class == CLASS_JANGODUAL ||
							traceEnt->client->NPC_class == CLASS_ROCKETTROOPER)
						{
							// also disables npc jetpack
							jet_fly_stop(traceEnt);
							if (traceEnt->client->jetPackOn)
							{
								//disable jetpack temporarily
								Jetpack_Off(traceEnt);
								traceEnt->client->jetPackToggleTime = level.time + Q_irand(3000, 10000);
							}
						}

						if (d_slowmoaction->integer && (self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self)))
						{
							if (g_SerenityJediEngineMode->integer == 2)
							{
								G_StartStasisEffect_FORCE_LEVEL_2(self);
							}
						}
					}
				}

				if (gi.G2API_HaveWeGhoul2Models(traceEnt->ghoul2))
				{
					actual_time = cg.time ? cg.time : level.time;
					gi.G2API_GetBoneAnimIndex(&traceEnt->ghoul2[traceEnt->playerModel], traceEnt->rootBone,
						level.time, &current_frame, &junk, &junk, &junk, &animSpeed, nullptr);

					gi.G2API_SetBoneAnimIndex(&traceEnt->ghoul2[traceEnt->playerModel], traceEnt->rootBone,
						current_frame, current_frame + 1,
						BONE_ANIM_OVERRIDE_FREEZE, animSpeed, level.time, current_frame, 100);
					if (traceEnt->headModel > 0)
					{
						gi.G2API_SetBoneAnimIndex(&traceEnt->ghoul2[traceEnt->headModel], traceEnt->headRootBone,
							current_frame, current_frame + 1,
							BONE_ANIM_OVERRIDE_FREEZE, animSpeed, level.time, current_frame,
							100);
					}
				}
			}
			else if (traceEnt->health > 0 && traceEnt->client->NPC_class == CLASS_GUARD)
			{
				//affect jedi.
				if (traceEnt->client)
				{
					traceEnt->client->ps.stasisJediTime = level.time + stasisJediTime[self->client->ps.forcePowerLevel[
						FP_STASIS]];
					VectorClear(traceEnt->client->ps.velocity);

					if (g_SerenityJediEngineMode->integer)
					{
						player_Freeze(traceEnt);

						if (d_slowmoaction->integer && (self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self)))
						{
							if (g_SerenityJediEngineMode->integer == 2)
							{
								G_StartStasisEffect_FORCE_LEVEL_2(self);
							}
						}
					}
				}

				if (gi.G2API_HaveWeGhoul2Models(traceEnt->ghoul2))
				{
					actual_time = cg.time ? cg.time : level.time;
					gi.G2API_GetBoneAnimIndex(&traceEnt->ghoul2[traceEnt->playerModel], traceEnt->rootBone,
						level.time, &current_frame, &junk, &junk, &junk, &animSpeed, nullptr);

					gi.G2API_SetBoneAnimIndex(&traceEnt->ghoul2[traceEnt->playerModel], traceEnt->rootBone,
						current_frame, current_frame + 1,
						BONE_ANIM_OVERRIDE_FREEZE, animSpeed, level.time, current_frame, 100);
					if (traceEnt->headModel > 0)
					{
						gi.G2API_SetBoneAnimIndex(&traceEnt->ghoul2[traceEnt->headModel], traceEnt->headRootBone,
							current_frame, current_frame + 1,
							BONE_ANIM_OVERRIDE_FREEZE, animSpeed, level.time, current_frame,
							100);
					}
				}
			}
			else if (traceEnt->health > 0 && jedi_jedi_master_low(traceEnt))
			{
				//affect jedi.
				if (traceEnt->client)
				{
					traceEnt->client->ps.stasisJediTime = level.time + stasisJediTime[self->client->ps.forcePowerLevel[
						FP_STASIS]];
					VectorClear(traceEnt->client->ps.velocity);

					if (g_SerenityJediEngineMode->integer)
					{
						player_Freeze(traceEnt);

						if (d_slowmoaction->integer && (self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self)))
						{
							if (g_SerenityJediEngineMode->integer == 2)
							{
								G_StartStasisEffect_FORCE_LEVEL_2(self);
							}
						}
					}
				}

				if (gi.G2API_HaveWeGhoul2Models(traceEnt->ghoul2))
				{
					actual_time = cg.time ? cg.time : level.time;
					gi.G2API_GetBoneAnimIndex(&traceEnt->ghoul2[traceEnt->playerModel], traceEnt->rootBone,
						level.time, &current_frame, &junk, &junk, &junk, &animSpeed, nullptr);

					gi.G2API_SetBoneAnimIndex(&traceEnt->ghoul2[traceEnt->playerModel], traceEnt->rootBone,
						current_frame, current_frame + 1,
						BONE_ANIM_OVERRIDE_FREEZE, animSpeed, level.time, current_frame, 100);
					if (traceEnt->headModel > 0)
					{
						gi.G2API_SetBoneAnimIndex(&traceEnt->ghoul2[traceEnt->headModel], traceEnt->headRootBone,
							current_frame, current_frame + 1,
							BONE_ANIM_OVERRIDE_FREEZE, animSpeed, level.time, current_frame,
							100);
					}
				}
			}
		}
	}
	else
	{
		Player_CheckFreeze(traceEnt);
	}
}

void ForceStasis(gentity_t* self)
{
	trace_t tr;
	vec3_t forward;
	gentity_t* traceEnt = nullptr;
	float current_frame, animSpeed;
	int junk, actual_time;

	if (self->health <= 0)
	{
		return;
	}

	if (PM_InLedgeMove(self->client->ps.legsAnim))
	{
		return;
	}

	if (PM_InGetUp(&self->client->ps) || PM_InForceGetUp(&self->client->ps))
	{
		return;
	}

	if (self->client->ps.forcePower < 25 || !WP_ForcePowerUsable(self, FP_STASIS, 0))
	{
		return;
	}

	if (!self->s.number && (cg.zoomMode || in_camera))
	{
		//can't stasis when zoomed in or in cinematic
		return;
	}

	if (self->client->ps.saberLockTime > level.time)
	{
		return;
	}

	const int radius = forceStasisRadius[self->client->ps.forcePowerLevel[FP_STASIS]];

	if (self->client->ps.forcePowerLevel[FP_STASIS] > FORCE_LEVEL_2)
	{
		//Stasis the enemy!
		AngleVectors(self->client->ps.viewangles, forward, nullptr, nullptr);
		VectorNormalize(forward);

		vec3_t center, mins{}, maxs{}, v{};
		const float reach = radius;
		gentity_t* entity_list[MAX_GENTITIES];
		int i;

		VectorCopy(self->currentOrigin, center);
		for (i = 0; i < 3; i++)
		{
			mins[i] = center[i] - reach;
			maxs[i] = center[i] + reach;
		}
		const int num_listed_entities = gi.EntitiesInBox(mins, maxs, entity_list, MAX_GENTITIES);

		for (int e = 0; e < num_listed_entities; e++)
		{
			float dot;
			vec3_t size;
			vec3_t ent_org;
			vec3_t dir;
			traceEnt = entity_list[e];

			if (!traceEnt)
				continue;
			if (traceEnt == self)
				continue;
			if (!traceEnt->inuse)
				continue;

			// find the distance from the edge of the bounding box
			for (i = 0; i < 3; i++)
			{
				if (center[i] < traceEnt->absmin[i])
				{
					v[i] = traceEnt->absmin[i] - center[i];
				}
				else if (center[i] > traceEnt->absmax[i])
				{
					v[i] = center[i] - traceEnt->absmax[i];
				}
				else
				{
					v[i] = 0;
				}
			}

			VectorSubtract(traceEnt->absmax, traceEnt->absmin, size);
			VectorMA(traceEnt->absmin, 0.5, size, ent_org);

			//see if they're in front of me
			//must be within the forward cone
			VectorSubtract(ent_org, center, dir);
			VectorNormalize(dir);
			if ((dot = DotProduct(dir, forward)) < 0.5)
				continue;

			//must be close enough
			const float dist = VectorLength(v);
			if (dist >= reach)
			{
				continue;
			}

			//in PVS?
			if (!traceEnt->bmodel && !gi.inPVS(ent_org, self->client->renderInfo.handLPoint))
			{
				//must be in PVS
				continue;
			}

			//Now check and see if we can actually hit it
			gi.trace(&tr, self->client->renderInfo.handLPoint, vec3_origin, vec3_origin, ent_org, self->s.number, MASK_SHOT, G2_NOCOLLIDE, 0);

			if (tr.fraction < 1.0f && tr.entityNum != traceEnt->s.number)
			{
				//must have clear LOS
				continue;
			}

			// ok, we are within the radius, add us to the incoming list
			forcestasis_anim(self);
			if (traceEnt->s.eType == ET_PLAYER)
			{
				G_AddVoiceEvent(traceEnt, Q_irand(EV_PUSHED1, EV_PUSHED3), 2000);
			}

			if (traceEnt->s.eType == ET_MISSILE && traceEnt->s.eType != TR_STATIONARY)
			{
				vec3_t dir2_me;
				VectorSubtract(self->currentOrigin, traceEnt->currentOrigin, dir2_me);
				const float missilemovement = DotProduct(traceEnt->s.pos.trDelta, dir2_me);

				if (missilemovement >= 0)
				{
					G_StasisMissile(self, traceEnt);

					if (!(self->client->ps.ManualBlockingFlags & 1 << MBF_MISSILESTASIS))
					{
						self->client->ps.ManualBlockingFlags |= 1 << MBF_MISSILESTASIS; // activate the function
					}
				}
			}
			else
			{
				ForceStasisWide(self, traceEnt);
			}
		}
	}
	else
	{
		vec3_t end;
		//Stasis the enemy!
		AngleVectors(self->client->ps.viewangles, forward, nullptr, nullptr);
		VectorNormalize(forward);
		VectorMA(self->client->renderInfo.eyePoint, radius, forward, end);
		forcestasis_anim(self);

		if (self->enemy)
		{
			//I have an enemy
			if (self->client->ps.forcePowerLevel[FP_STASIS] > FORCE_LEVEL_1)
			{
				//arc
				if (DistanceSquared(self->enemy->currentOrigin, self->currentOrigin) < FORCE_STASIS_DIST_SQUARED_HIGH)
				{
					//close enough to grab
					float min_dot = 0.5f;
					if (self->s.number < MAX_CLIENTS)
					{
						//player needs to be facing more directly
						min_dot = 0.2f;
					}
					if (InFront(self->enemy->currentOrigin, self->client->renderInfo.eyePoint,
						self->client->ps.viewangles, min_dot))
					{
						//need to be facing the enemy
						if (gi.inPVS(self->enemy->currentOrigin, self->client->renderInfo.eyePoint))
						{
							//must be in PVS
							gi.trace(&tr, self->client->renderInfo.eyePoint, vec3_origin, vec3_origin,
								self->enemy->currentOrigin, self->s.number, MASK_SHOT,
								static_cast<EG2_Collision>(0), 0);
							if (tr.fraction == 1.0f || tr.entityNum == self->enemy->s.number)
							{
								//must have clear LOS
								traceEnt = self->enemy;
							}
						}
					}
				}
			}
			else
			{
				//Stasis the enemy!
				gi.trace(&tr, self->client->renderInfo.eyePoint, vec3_origin, vec3_origin, end, self->s.number,
					MASK_OPAQUE | CONTENTS_BODY, static_cast<EG2_Collision>(0), 0);
				if (tr.entityNum == ENTITYNUM_NONE || tr.fraction == 1.0 || tr.allsolid || tr.startsolid)
				{
					return;
				}

				traceEnt = &g_entities[tr.entityNum];
			}
		}
		if (!traceEnt)
		{
			//okay, trace straight ahead and see what's there
			gi.trace(&tr, self->client->renderInfo.eyePoint, vec3_origin, vec3_origin, end, self->s.number, MASK_SHOT,
				static_cast<EG2_Collision>(0), 0);
			if (tr.entityNum == ENTITYNUM_NONE || tr.fraction == 1.0 || tr.allsolid || tr.startsolid)
			{
				return;
			}
			traceEnt = &g_entities[tr.entityNum];
			G_AddVoiceEvent(traceEnt, Q_irand(EV_PUSHED1, EV_PUSHED3), 2000);
		}
	}

	if (traceEnt->s.eType != ET_PLAYER)
	{
		// We hit an entity, but it wasn't an NPC.
		return;
	}

	if (traceEnt->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(traceEnt))
	{
		if (!in_camera && traceEnt->NPC && traceEnt->NPC->scriptFlags & SCF_NO_FORCE)
		{
			return;
		}
	}

	if (traceEnt->health > 0 &&
		traceEnt->s.weapon != WP_SABER &&
		traceEnt->client &&
		traceEnt->client->NPC_class != CLASS_REBORN)
	{
		//doesn't affect jedi .but affects everything else??
		const int mod_power_level = WP_AbsorbConversion(traceEnt, traceEnt->client->ps.forcePowerLevel[FP_ABSORB],
			FP_STASIS,
			self->client->ps.forcePowerLevel[FP_STASIS],
			forcePowerNeeded[FP_STASIS]);
		int actual_power_level;
		if (mod_power_level == -1)
		{
			actual_power_level = self->client->ps.forcePowerLevel[FP_STASIS];
		}
		else
		{
			actual_power_level = mod_power_level;
		}

		if (actual_power_level > 0)
		{
			if (traceEnt->client)
			{
				traceEnt->client->ps.stasisTime = level.time + stasisTime[actual_power_level]; //stuck for 5-10 seconds
				VectorClear(traceEnt->client->ps.velocity);

				if (g_SerenityJediEngineMode->integer)
				{
					player_Freeze(traceEnt);

					if (traceEnt->client->NPC_class == CLASS_BOBAFETT ||
						traceEnt->client->NPC_class == CLASS_MANDALORIAN ||
						traceEnt->client->NPC_class == CLASS_JANGO ||
						traceEnt->client->NPC_class == CLASS_JANGODUAL ||
						traceEnt->client->NPC_class == CLASS_ROCKETTROOPER)
					{
						// also disables npc jetpack
						jet_fly_stop(traceEnt);
						if (traceEnt->client->jetPackOn)
						{
							//disable jetpack temporarily
							Jetpack_Off(traceEnt);
							traceEnt->client->jetPackToggleTime = level.time + Q_irand(3000, 10000);
						}
					}

					if (d_slowmoaction->integer && (self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self)))
					{
						if (g_SerenityJediEngineMode->integer == 2)
						{
							G_StartStasisEffect_FORCE_LEVEL_2(self);
						}
					}
				}
			}

			if (gi.G2API_HaveWeGhoul2Models(traceEnt->ghoul2))
			{
				actual_time = cg.time ? cg.time : level.time;
				gi.G2API_GetBoneAnimIndex(&traceEnt->ghoul2[traceEnt->playerModel], traceEnt->rootBone,
					level.time, &current_frame, &junk, &junk, &junk, &animSpeed, nullptr);

				gi.G2API_SetBoneAnimIndex(&traceEnt->ghoul2[traceEnt->playerModel], traceEnt->rootBone,
					current_frame, current_frame + 1,
					BONE_ANIM_OVERRIDE_FREEZE, animSpeed, level.time, current_frame, 100);
				if (traceEnt->headModel > 0)
				{
					gi.G2API_SetBoneAnimIndex(&traceEnt->ghoul2[traceEnt->headModel], traceEnt->headRootBone,
						current_frame, current_frame + 1,
						BONE_ANIM_OVERRIDE_FREEZE, animSpeed, level.time, current_frame, 100);
				}
			}
		}
	}
	else if (traceEnt->health > 0 &&
		traceEnt->s.weapon == WP_SABER &&
		traceEnt->client &&
		(traceEnt->client->ps.forcePower <= BLOCKPOINTS_MISSILE || traceEnt->client->ps.blockPoints <=
			BLOCKPOINTS_HALF)
		&& (traceEnt->client->NPC_class != CLASS_GUARD && traceEnt->client->NPC_class != CLASS_JEDIMASTER))
	{
		//affect jedi.
		const int mod_power_level = WP_AbsorbConversion(traceEnt, traceEnt->client->ps.forcePowerLevel[FP_ABSORB],
			FP_STASIS,
			self->client->ps.forcePowerLevel[FP_STASIS],
			forcePowerNeeded[FP_STASIS]);
		int actual_power_level;
		if (mod_power_level == -1)
		{
			actual_power_level = self->client->ps.forcePowerLevel[FP_STASIS];
		}
		else
		{
			actual_power_level = mod_power_level;
		}

		if (actual_power_level > 0)
		{
			if (traceEnt->client)
			{
				traceEnt->client->ps.stasisJediTime = level.time + stasisJediTime[actual_power_level];
				//stuck for 2-5 seconds
				VectorClear(traceEnt->client->ps.velocity);

				if (d_slowmoaction->integer && (self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self)))
				{
					if (g_SerenityJediEngineMode->integer == 2)
					{
						G_StartStasisEffect_FORCE_LEVEL_2(self);
					}
				}
			}

			if (gi.G2API_HaveWeGhoul2Models(traceEnt->ghoul2))
			{
				actual_time = cg.time ? cg.time : level.time;
				gi.G2API_GetBoneAnimIndex(&traceEnt->ghoul2[traceEnt->playerModel], traceEnt->rootBone,
					level.time, &current_frame, &junk, &junk, &junk, &animSpeed, nullptr);

				gi.G2API_SetBoneAnimIndex(&traceEnt->ghoul2[traceEnt->playerModel], traceEnt->rootBone,
					current_frame, current_frame + 1,
					BONE_ANIM_OVERRIDE_FREEZE, animSpeed, level.time, current_frame, 100);
				if (traceEnt->headModel > 0)
				{
					gi.G2API_SetBoneAnimIndex(&traceEnt->ghoul2[traceEnt->headModel], traceEnt->headRootBone,
						current_frame, current_frame + 1,
						BONE_ANIM_OVERRIDE_FREEZE, animSpeed, level.time, current_frame, 100);
				}
			}
		}
	}
	else if (traceEnt->health > 0 && (traceEnt->client && traceEnt->client->NPC_class == CLASS_GUARD))
	{
		//affect jedi.
		const int mod_power_level = WP_AbsorbConversion(traceEnt, traceEnt->client->ps.forcePowerLevel[FP_ABSORB],
			FP_STASIS,
			self->client->ps.forcePowerLevel[FP_STASIS],
			forcePowerNeeded[FP_STASIS]);
		int actual_power_level;
		if (mod_power_level == -1)
		{
			actual_power_level = self->client->ps.forcePowerLevel[FP_STASIS];
		}
		else
		{
			actual_power_level = mod_power_level;
		}

		if (actual_power_level > 0)
		{
			if (traceEnt->client)
			{
				traceEnt->client->ps.stasisJediTime = level.time + stasisJediTime[actual_power_level];
				//stuck for 2-5 seconds
				VectorClear(traceEnt->client->ps.velocity);

				if (d_slowmoaction->integer && (self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self)))
				{
					if (g_SerenityJediEngineMode->integer == 2)
					{
						G_StartStasisEffect_FORCE_LEVEL_2(self);
					}
				}
			}

			if (gi.G2API_HaveWeGhoul2Models(traceEnt->ghoul2))
			{
				actual_time = cg.time ? cg.time : level.time;
				gi.G2API_GetBoneAnimIndex(&traceEnt->ghoul2[traceEnt->playerModel], traceEnt->rootBone,
					level.time, &current_frame, &junk, &junk, &junk, &animSpeed, nullptr);

				gi.G2API_SetBoneAnimIndex(&traceEnt->ghoul2[traceEnt->playerModel], traceEnt->rootBone,
					current_frame, current_frame + 1,
					BONE_ANIM_OVERRIDE_FREEZE, animSpeed, level.time, current_frame, 100);
				if (traceEnt->headModel > 0)
				{
					gi.G2API_SetBoneAnimIndex(&traceEnt->ghoul2[traceEnt->headModel], traceEnt->headRootBone,
						current_frame, current_frame + 1,
						BONE_ANIM_OVERRIDE_FREEZE, animSpeed, level.time, current_frame, 100);
				}
			}
		}
	}
	else if (traceEnt->health > 0 && jedi_jedi_master_low(traceEnt))
	{
		//affect jedi.
		const int mod_power_level = WP_AbsorbConversion(traceEnt, traceEnt->client->ps.forcePowerLevel[FP_ABSORB],
			FP_STASIS,
			self->client->ps.forcePowerLevel[FP_STASIS],
			forcePowerNeeded[FP_STASIS]);
		int actual_power_level;
		if (mod_power_level == -1)
		{
			actual_power_level = self->client->ps.forcePowerLevel[FP_STASIS];
		}
		else
		{
			actual_power_level = mod_power_level;
		}

		if (actual_power_level > 0)
		{
			if (traceEnt->client)
			{
				traceEnt->client->ps.stasisJediTime = level.time + stasisJediTime[actual_power_level];
				//stuck for 2-5 seconds
				VectorClear(traceEnt->client->ps.velocity);

				if (d_slowmoaction->integer && (self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self)))
				{
					if (g_SerenityJediEngineMode->integer == 2)
					{
						G_StartStasisEffect_FORCE_LEVEL_2(self);
					}
				}
			}

			if (gi.G2API_HaveWeGhoul2Models(traceEnt->ghoul2))
			{
				actual_time = cg.time ? cg.time : level.time;
				gi.G2API_GetBoneAnimIndex(&traceEnt->ghoul2[traceEnt->playerModel], traceEnt->rootBone,
					level.time, &current_frame, &junk, &junk, &junk, &animSpeed, nullptr);

				gi.G2API_SetBoneAnimIndex(&traceEnt->ghoul2[traceEnt->playerModel], traceEnt->rootBone,
					current_frame, current_frame + 1,
					BONE_ANIM_OVERRIDE_FREEZE, animSpeed, level.time, current_frame, 100);
				if (traceEnt->headModel > 0)
				{
					gi.G2API_SetBoneAnimIndex(&traceEnt->ghoul2[traceEnt->headModel], traceEnt->headRootBone,
						current_frame, current_frame + 1,
						BONE_ANIM_OVERRIDE_FREEZE, animSpeed, level.time, current_frame, 100);
				}
			}
		}
	}
	else
	{
		Player_CheckFreeze(traceEnt);
	}
}

void ForceGrasp(gentity_t* self)
{
	trace_t tr;
	vec3_t end, forward;
	gentity_t* traceEnt = nullptr;

	if (self->health <= 0)
	{
		return;
	}
	if (!self->s.number && (cg.zoomMode || in_camera))
	{
		//can't force grip when zoomed in or in cinematic
		return;
	}
	if (self->client->ps.leanofs)
	{
		//can't force-grip while leaning
		return;
	}
	if (self->client->ps.stasisTime > level.time)
	{
		return;
	}

	if (PM_InLedgeMove(self->client->ps.legsAnim))
	{
		return;
	}

	if (self->client->ps.forceGripEntityNum <= ENTITYNUM_WORLD)
	{
		//already gripping
		if (self->client->ps.forcePowerLevel[FP_GRASP] > FORCE_LEVEL_1)
		{
			self->client->ps.forcePowerDuration[FP_GRASP] = level.time + 100;
			self->client->ps.weaponTime = 1000;
			if (self->client->ps.forcePowersActive & 1 << FP_SPEED)
			{
				self->client->ps.weaponTime = floor(self->client->ps.weaponTime * g_timescale->value);
			}
		}
		return;
	}

	if (!WP_ForcePowerUsable(self, FP_GRASP, 0))
	{
		//can't use it right now
		return;
	}

	if (self->client->ps.forcePower < 26)
	{
		//need 20 to start, 6 to hold it for any decent amount of time...
		return;
	}

	if (self->client->ps.weaponTime)
	{
		//busy
		return;
	}

	if (self->client->ps.saberLockTime > level.time)
	{
		//FIXME: can this be a way to break out?
		return;
	}
	//Cause choking anim + health drain in ent in front of me
	NPC_SetAnim(self, SETANIM_TORSO, BOTH_FORCEGRIP_HOLD, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);

	self->client->ps.saber_move = self->client->ps.saberBounceMove = LS_READY;
	//don't finish whatever saber anim you may have been in
	self->client->ps.saberBlocked = BLOCKED_NONE;

	self->client->ps.weaponTime = 1000;
	if (self->client->ps.forcePowersActive & 1 << FP_SPEED)
	{
		self->client->ps.weaponTime = floor(self->client->ps.weaponTime * g_timescale->value);
	}

	AngleVectors(self->client->ps.viewangles, forward, nullptr, nullptr);
	VectorNormalize(forward);
	VectorMA(self->client->renderInfo.handLPoint, FORCE_GRIP_DIST, forward, end);

	if (self->enemy)
	{
		//I have an enemy
		if (!self->enemy->message
			&& !(self->flags & FL_NO_KNOCKBACK))
		{
			//don't auto-pickup guys with keys
			if (DistanceSquared(self->enemy->currentOrigin, self->currentOrigin) < FORCE_GRIP_DIST_SQUARED)
			{
				//close enough to grab
				float min_dot = 0.5f;
				if (self->s.number < MAX_CLIENTS)
				{
					//player needs to be facing more directly
					min_dot = 0.2f;
				}
				if (InFront(self->enemy->currentOrigin, self->client->renderInfo.eyePoint, self->client->ps.viewangles,
					min_dot))
					//self->s.number || //NPCs can always lift enemy since we assume they're looking at them...?
				{
					//need to be facing the enemy
					if (gi.inPVS(self->enemy->currentOrigin, self->client->renderInfo.eyePoint))
					{
						//must be in PVS
						gi.trace(&tr, self->client->renderInfo.eyePoint, vec3_origin, vec3_origin,
							self->enemy->currentOrigin, self->s.number, MASK_SHOT, static_cast<EG2_Collision>(0),
							0);
						if (tr.fraction == 1.0f || tr.entityNum == self->enemy->s.number)
						{
							//must have clear LOS
							traceEnt = self->enemy;
						}
					}
				}
			}
		}
	}
	if (!traceEnt)
	{
		//okay, trace straight ahead and see what's there
		gi.trace(&tr, self->client->renderInfo.handLPoint, vec3_origin, vec3_origin, end, self->s.number, MASK_SHOT,
			static_cast<EG2_Collision>(0), 0);
		if (tr.entityNum >= ENTITYNUM_WORLD || tr.fraction == 1.0 || tr.allsolid || tr.startsolid)
		{
			return;
		}

		traceEnt = &g_entities[tr.entityNum];
	}
	//rww - RAGDOLL_BEGIN
#ifdef JK2_RAGDOLL_GRIPNOHEALTH
	if (!traceEnt || traceEnt == self || traceEnt->bmodel || traceEnt->NPC && traceEnt->NPC->scriptFlags &
		SCF_NO_FORCE)
	{
		return;
	}
#else
//rww - RAGDOLL_END
	if (!traceEnt || traceEnt == self/*???*/ || traceEnt->bmodel || (traceEnt->health <= 0 && traceEnt->takedamage) || (traceEnt->NPC && traceEnt->NPC->scriptFlags & SCF_NO_FORCE))
	{
		return;
	}
	//rww - RAGDOLL_BEGIN
#endif
	//rww - RAGDOLL_END

	if (traceEnt->m_pVehicle != nullptr)
	{
		//is it a vehicle
		//grab pilot if there is one
		if (traceEnt->m_pVehicle->m_pPilot != nullptr
			&& traceEnt->m_pVehicle->m_pPilot->client != nullptr)
		{
			//grip the pilot
			traceEnt = traceEnt->m_pVehicle->m_pPilot;
		}
		else
		{
			//can't grip a vehicle
			return;
		}
	}
	if (traceEnt->client)
	{
		if (traceEnt->client->ps.forceJumpZStart)
		{
			//can't catch them in mid force jump - FIXME: maybe base it on velocity?
			return;
		}
		if (traceEnt->client->ps.pullAttackTime > level.time)
		{
			//can't grip someone who is being pull-attacked or is pull-attacking
			return;
		}
		if (!Q_stricmp("Yoda", traceEnt->NPC_type)
			|| !Q_stricmp("T_Yoda", traceEnt->NPC_type)
			|| !Q_stricmp("md_Yoda", traceEnt->NPC_type)
			|| !Q_stricmp("md_yoda_ep2", traceEnt->NPC_type)
			|| !Q_stricmp("md_yoda_ot", traceEnt->NPC_type)
			|| !Q_stricmp("md_yoda_hr", traceEnt->NPC_type)
			|| char_is_force_user_attacker(traceEnt))
		{
			jedi_play_deflect_sound(traceEnt);
			if (g_SerenityJediEngineMode->integer)
			{
				if (traceEnt->client->NPC_class == CLASS_GALEN
					&& (traceEnt->s.weapon == WP_MELEE || traceEnt->s.weapon == WP_NONE || traceEnt->s.weapon ==
						WP_SABER && !traceEnt->client->ps.SaberActive())
					&& traceEnt->client->ps.groundEntityNum == ENTITYNUM_NONE)
				{
					ForceRepulse(traceEnt, qfalse);
				}
				else
				{
					ForceThrow_MD(traceEnt, qfalse);
				}
			}
			else
			{
				ForceThrow_JKA(traceEnt, qfalse);
			}
			return;
		}

		if (jedi_jedi_master_high(traceEnt))
		{
			jedi_play_deflect_sound(traceEnt);
			if (g_SerenityJediEngineMode->integer)
			{
				ForceThrow_MD(traceEnt, qfalse);
			}
			else
			{
				ForceThrow_JKA(traceEnt, qfalse);
			}

			if (traceEnt->NPC && !G_ControlledByPlayer(traceEnt)) //NPC only
			{
				if ((traceEnt->client->ps.forcePowersKnown & 1 << FP_ABSORB) != 0
					&& (traceEnt->client->ps.forcePowersActive & 1 << FP_ABSORB) == 0)
				{
					//know absorb and not already using it
					if (!Q_irand(0, 5))
					{
						ForceAbsorb(traceEnt);
					}
				}
				G_AddVoiceEvent(traceEnt, Q_irand(EV_TAUNT1, EV_TAUNT5), Q_irand(8000, 12000));
			}
			return;
		}

		if (G_IsRidingVehicle(traceEnt)
			&& traceEnt->s.eFlags & EF_NODRAW)
		{
			//riding *inside* vehicle
			return;
		}

		switch (traceEnt->client->NPC_class)
		{
		case CLASS_GALAKMECH: //cant grip him, he's in armor
			G_AddVoiceEvent(traceEnt, Q_irand(EV_PUSHED1, EV_PUSHED3), Q_irand(3000, 5000));
			return;
		case CLASS_HAZARD_TROOPER: //cant grip him, he's in armor
			return;
		case CLASS_ATST: //much too big to grip!
		case CLASS_RANCOR: //much too big to grip!
		case CLASS_WAMPA: //much too big to grip!
		case CLASS_SAND_CREATURE: //much too big to grip!
			return;
			//no droids either...?
		case CLASS_GONK:
		case CLASS_R2D2:
		case CLASS_R5D2:
		case CLASS_MARK1:
		case CLASS_MARK2:
		case CLASS_MOUSE: //?
		case CLASS_PROTOCOL:
			//*sigh*... in JK3, you'll be able to grab and move *anything*...
			return;
			//not even combat droids?  (No animation for being gripped...)
		case CLASS_SABER_DROID:
		case CLASS_ASSASSIN_DROID:
		case CLASS_DROIDEKA:
			//*sigh*... in JK3, you'll be able to grab and move *anything*...
			return;
		case CLASS_PROBE:
		case CLASS_SEEKER:
		case CLASS_REMOTE:
		case CLASS_SENTRY:
		case CLASS_INTERROGATOR:
			//*sigh*... in JK3, you'll be able to grab and move *anything*...
			return;
		case CLASS_SITHLORD:
		case CLASS_DESANN: //Desann cannot be gripped, he just pushes you back instantly
		case CLASS_VADER:
		case CLASS_KYLE:
		case CLASS_GALEN:
		case CLASS_TAVION:
		case CLASS_YODA:
		case CLASS_LUKE:
		case CLASS_GROGU:
			jedi_play_deflect_sound(traceEnt);
			if (g_SerenityJediEngineMode->integer)
			{
				if (traceEnt->client->NPC_class == CLASS_GALEN
					&& (traceEnt->s.weapon == WP_MELEE || traceEnt->s.weapon == WP_NONE || traceEnt->s.weapon ==
						WP_SABER && !traceEnt->client->ps.SaberActive())
					&& traceEnt->client->ps.groundEntityNum == ENTITYNUM_NONE)
				{
					ForceRepulse(traceEnt, qfalse);
				}
				else
				{
					ForceThrow_MD(traceEnt, qfalse);
				}
			}
			else
			{
				ForceThrow_JKA(traceEnt, qfalse);
			}
			return;
		case CLASS_REBORN:
		case CLASS_BOC:
		case CLASS_SHADOWTROOPER:
		case CLASS_ALORA:
		case CLASS_JEDI:
		case CLASS_PROJECTION:
		case CLASS_AHSOKA:
			if (traceEnt->NPC && traceEnt->NPC->rank > RANK_CIVILIAN && self->client->ps.forcePowerLevel[FP_GRASP] <
				FORCE_LEVEL_2)
			{
				jedi_play_deflect_sound(traceEnt);
				if (g_SerenityJediEngineMode->integer)
				{
					if (traceEnt->client->NPC_class == CLASS_GALEN
						&& (traceEnt->s.weapon == WP_MELEE || traceEnt->s.weapon == WP_NONE || traceEnt->s.weapon ==
							WP_SABER && !traceEnt->client->ps.SaberActive())
						&& traceEnt->client->ps.groundEntityNum == ENTITYNUM_NONE)
					{
						ForceRepulse(traceEnt, qfalse);
					}
					else
					{
						ForceThrow_MD(traceEnt, qfalse);
					}
				}
				else
				{
					ForceThrow_JKA(traceEnt, qfalse);
				}
				return;
			}
			break;
		default:
			break;
		}
		if (traceEnt->s.weapon == WP_EMPLACED_GUN)
		{
			//FIXME: maybe can pull them out?
			return;
		}
		if (self->enemy && traceEnt != self->enemy && traceEnt->client->playerTeam == self->client->playerTeam)
		{
			//can't accidently grip your teammate in combat
			return;
		}
		//=CHECKABSORB===
		if (-1 != WP_AbsorbConversion(traceEnt, traceEnt->client->ps.forcePowerLevel[FP_ABSORB], FP_GRASP,
			self->client->ps.forcePowerLevel[FP_GRASP],
			forcePowerNeeded[self->client->ps.forcePowerLevel[FP_GRASP]]))
		{
			//WP_ForcePowerStop( self, FP_GRIP );
			return;
		}
		//===============
	}
	else
	{
		//can't grip non-clients... right?
		//FIXME: Make it so objects flagged as "grabbable" are let through
		//if ( Q_stricmp( "misc_model_breakable", traceEnt->classname ) || !(traceEnt->s.eFlags&EF_BOUNCE_HALF) || !traceEnt->physicsBounce )
		{
			return;
		}
	}

	// Make sure to turn off Force Protection and Force Absorb.
	if (self->client->ps.forcePowersActive & 1 << FP_PROTECT)
	{
		WP_ForcePowerStop(self, FP_PROTECT);
	}
	if (self->client->ps.forcePowersActive & 1 << FP_ABSORB)
	{
		WP_ForcePowerStop(self, FP_ABSORB);
	}

	WP_ForcePowerStart(self, FP_GRASP, 10);
	//FIXME: rule out other things?
	//FIXME: Jedi resist, like the push and pull?
	self->client->ps.forceGripEntityNum = traceEnt->s.number;
	if (traceEnt->client)
	{
		Vehicle_t* p_veh;
		if ((p_veh = G_IsRidingVehicle(traceEnt)) != nullptr)
		{
			//riding vehicle? pull him off!
			p_veh->m_pVehicleInfo->Eject(p_veh, traceEnt, qtrue);
		}
		G_AddVoiceEvent(traceEnt, Q_irand(EV_PUSHED1, EV_PUSHED3), 2000);

		if (self->client->ps.forcePowerLevel[FP_GRASP] > FORCE_LEVEL_2 || traceEnt->s.weapon == WP_SABER)
		{
			//if we pick up & carry, drop their weap
			if (traceEnt->s.weapon
				&& traceEnt->client->NPC_class != CLASS_ROCKETTROOPER
				&& traceEnt->client->NPC_class != CLASS_VEHICLE
				&& traceEnt->client->NPC_class != CLASS_HAZARD_TROOPER
				&& traceEnt->client->NPC_class != CLASS_TUSKEN
				&& traceEnt->client->NPC_class != CLASS_BOBAFETT
				&& traceEnt->client->NPC_class != CLASS_MANDALORIAN
				&& traceEnt->client->NPC_class != CLASS_JANGO
				&& traceEnt->client->NPC_class != CLASS_JANGODUAL
				&& traceEnt->client->NPC_class != CLASS_ASSASSIN_DROID
				&& traceEnt->client->NPC_class != CLASS_DROIDEKA
				&& traceEnt->client->NPC_class != CLASS_SBD
				&& traceEnt->s.weapon != WP_CONCUSSION) // so rax can't drop his
			{
				if (traceEnt->client->NPC_class == CLASS_BOBAFETT || traceEnt->client->NPC_class == CLASS_MANDALORIAN
					||
					traceEnt->client->NPC_class == CLASS_JANGO || traceEnt->client->NPC_class == CLASS_JANGODUAL)
				{
					//he doesn't drop them, just puts it away
					ChangeWeapon(traceEnt, WP_MELEE);
				}
				else if (traceEnt->s.weapon == WP_MELEE)
				{
					//they can't take that away from me, oh no...
				}
				else if (traceEnt->NPC
					&& traceEnt->NPC->scriptFlags & SCF_DONT_FLEE)
				{
					//*SIGH*... if an NPC can't flee, they can't run after and pick up their weapon, do don't drop it
				}
				else if (traceEnt->s.weapon != WP_SABER)
				{
					WP_DropWeapon(traceEnt, nullptr);
				}
				else
				{
					vec3_t throw_dir = { 0, 0, 20 };

					if (g_SerenityJediEngineMode->integer <= 2 && traceEnt->client->ps.forcePower <= BLOCKPOINTS_FULL
						|| g_SerenityJediEngineMode->integer == 2 && traceEnt->client->ps.blockPoints <=
						BLOCKPOINTS_FULL) //less than 90 BP
					{
						if (g_SerenityJediEngineMode->integer <= 2 && traceEnt->client->ps.forcePower <=
							BLOCKPOINTS_HALF
							|| g_SerenityJediEngineMode->integer == 2 && traceEnt->client->ps.blockPoints <=
							BLOCKPOINTS_HALF) // Less than 50 Bp
						{
							WP_SaberDisarmed(traceEnt, throw_dir);
							G_Sound(traceEnt, G_SoundIndex(va("sound/weapons/saber/bounce%d.wav", Q_irand(1, 3))));
							// low drops saber
						}
						else
						{
							traceEnt->client->ps.SaberDeactivate();
							G_SoundOnEnt(traceEnt, CHAN_WEAPON, "sound/weapons/saber/saberoffquick.wav");
							// he is full so he keeps his saber
						}
					}
				}
			}
		}
		VectorCopy(traceEnt->client->renderInfo.headPoint, self->client->ps.forceGripOrg);
	}
	else
	{
		VectorCopy(traceEnt->currentOrigin, self->client->ps.forceGripOrg);
	}
	self->client->ps.forceGripOrg[2] += 48; //FIXME: define?
	if (self->client->ps.forcePowerLevel[FP_GRASP] < FORCE_LEVEL_2)
	{
		//just a duration
		self->client->ps.forcePowerDebounce[FP_GRASP] = level.time + 250;
		self->client->ps.forcePowerDuration[FP_GRASP] = level.time + 5000;

		if (self->m_pVehicle && self->m_pVehicle->m_pVehicleInfo->Inhabited(self->m_pVehicle))
		{
			//empty vehicles don't make gripped noise
			if (traceEnt
				&& traceEnt->client
				&& traceEnt->client->NPC_class == CLASS_OBJECT)
			{
				//
			}
			else
			{
				traceEnt->s.loopSound = G_SoundIndex("sound/weapons/force/grip.wav");
			}
		}
	}
	else
	{
		if (self->client->ps.forcePowerLevel[FP_GRASP] == FORCE_LEVEL_2)
		{
			//lifting sound?  or always?
		}
		//if ( traceEnt->s.number )
		{
			//picks them up for a second first
			self->client->ps.forcePowerDebounce[FP_GRASP] = level.time + 1000;
		}

		if (traceEnt
			&& traceEnt->client
			&& traceEnt->client->NPC_class == CLASS_OBJECT)
		{
			//
		}
		else
		{
			G_SoundOnEnt(self, CHAN_BODY, "sound/weapons/force/grip.wav");
		}
	}
}

extern void WP_FireBlast(gentity_t* ent, int force_level);

void ForceBlast(gentity_t* self)
{
	int anim;
	if (self->health <= 0)
	{
		return;
	}
	if (!WP_ForcePowerUsable(self, FP_BLAST, 0))
	{
		return;
	}
	if (self->client->ps.forcePowerDebounce[FP_BLAST] > level.time)
	{
		//already using destruction
		return;
	}
	if (!self->s.number && (cg.zoomMode || in_camera))
	{
		//can't destruction when zoomed in or in cinematic
		return;
	}
	if (self->client->ps.saberLockTime > level.time)
	{
		//FIXME: can this be a way to break out?
		return;
	}

	if (PM_InLedgeMove(self->client->ps.legsAnim))
	{
		return;
	}

	if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self) && self->client->ps.weapon == WP_SABER)
		//npc force use limit
	{
		if (self->client->ps.blockPoints < 75 || self->client->ps.forcePower < 75)
		{
			return;
		}
	}

	if (self->s.weapon == WP_MELEE ||
		self->s.weapon == WP_NONE ||
		self->s.weapon == WP_SABER && !self->client->ps.SaberActive() && !in_camera)
	{
		//2-handed PUSH
		if (self->client->ps.groundEntityNum == ENTITYNUM_NONE)
		{
			anim = BOTH_DUAL_PUSH;

			if (self->handLBolt != -1)
			{
				G_PlayEffect(G_EffectIndex("force/invin"), self->playerModel, self->handLBolt, self->s.number,
					self->currentOrigin, 200, qtrue);
			}

			if (self->handRBolt != -1)
			{
				G_PlayEffect(G_EffectIndex("force/invin"), self->playerModel, self->handRBolt, self->s.number,
					self->currentOrigin, 200, qtrue);
			}
		}
		else
		{
			if (self->s.eFlags & EF_FORCE_DRAINED || self->s.eFlags & EF_FORCE_GRIPPED || self->s.eFlags &
				EF_FORCE_GRASPED)
			{
				anim = BOTH_FORCEPUSH;

				if (self->handLBolt != -1)
				{
					G_PlayEffect(G_EffectIndex("force/invin"), self->playerModel, self->handLBolt, self->s.number,
						self->currentOrigin, 200, qtrue);
				}
			}
			else
			{
				anim = BOTH_DUAL_PUSH;

				if (self->handLBolt != -1)
				{
					G_PlayEffect(G_EffectIndex("force/invin"), self->playerModel, self->handLBolt, self->s.number,
						self->currentOrigin, 200, qtrue);
				}

				if (self->handRBolt != -1)
				{
					G_PlayEffect(G_EffectIndex("force/invin"), self->playerModel, self->handRBolt, self->s.number,
						self->currentOrigin, 200, qtrue);
				}
			}
		}
	}
	else
	{
		anim = BOTH_FORCEPUSH;

		if (self->handLBolt != -1 && !in_camera)
		{
			G_PlayEffect(G_EffectIndex("force/invin"), self->playerModel, self->handLBolt, self->s.number,
				self->currentOrigin, 200, qtrue);
		}
	}
	const int sound_index = G_SoundIndex("sound/weapons/force/blast.wav");

	int parts = SETANIM_TORSO;
	if (!PM_InKnockDown(&self->client->ps))
	{
		if (!VectorLengthSquared(self->client->ps.velocity) && !(self->client->ps.pm_flags & PMF_DUCKED))
		{
			parts = SETANIM_BOTH;
		}
	}
	NPC_SetAnim(self, parts, anim, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD | SETANIM_FLAG_RESTART);
	self->client->ps.saber_move = self->client->ps.saberBounceMove = LS_READY;
	//don't finish whatever saber anim you may have been in
	self->client->ps.saberBlocked = BLOCKED_NONE;

	G_Sound(self, sound_index);

	WP_FireBlast(self, self->client->ps.forcePowerLevel[FP_BLAST]);

	WP_ForcePowerStart(self, FP_BLAST, 0);

	self->client->ps.weaponTime = 1000;
	if (self->client->ps.forcePowersActive & 1 << FP_SPEED)
	{
		self->client->ps.weaponTime = floor(self->client->ps.weaponTime * g_timescale->value);
	}
	self->client->ps.forcePowerDebounce[FP_BLAST] = level.time + self->client->ps.torsoAnimTimer + 1500;
}

constexpr auto BLAST_VELOCITY = 1200;
constexpr auto BLAST_DAMAGE = 20;
constexpr auto BLAST_SPLASH_DAMAGE = 35;
constexpr auto BLAST_SPLASH_RADIUS = 80;
constexpr auto BLAST_NPC_DAMAGE_EASY = 10;
constexpr auto BLAST_NPC_DAMAGE_NORMAL = 20;
constexpr auto BLAST_NPC_DAMAGE_HARD = 30;
constexpr auto BLAST_SIZE = 1;

//---------------------------------------------------------
void WP_FireBlast(gentity_t* ent, const int force_level)
//---------------------------------------------------------
{
	vec3_t start, forward;
	int damage = BLAST_DAMAGE;
	float vel = BLAST_VELOCITY;

	if (ent == player)
	{
		damage *= force_level;
	}

	vel *= force_level;

	AngleVectors(ent->client->ps.viewangles, forward, nullptr, nullptr);
	VectorNormalize(forward);

	VectorCopy(ent->client->renderInfo.eyePoint, start);

	gentity_t* missile = create_missile(start, forward, vel, 10000, ent, qfalse);

	missile->classname = "rocket_proj";
	missile->s.weapon = WP_ROCKET_LAUNCHER;
	missile->s.powerups |= 1 << PW_FORCE_PROJECTILE;
	missile->mass = 20;

	// Do the damages
	if (ent->s.number != 0)
	{
		if (g_spskill->integer == 0)
		{
			damage = BLAST_NPC_DAMAGE_EASY;
		}
		else if (g_spskill->integer == 1)
		{
			damage = BLAST_NPC_DAMAGE_NORMAL;
		}
		else
		{
			damage = BLAST_NPC_DAMAGE_HARD;
		}
	}

	// Make it easier to hit things
	VectorSet(missile->maxs, BLAST_SIZE, BLAST_SIZE, BLAST_SIZE);
	VectorScale(missile->maxs, -1, missile->mins);

	missile->damage = damage;

	missile->dflags = DAMAGE_EXTRA_KNOCKBACK;

	missile->methodOfDeath = MOD_DESTRUCTION;
	missile->splashMethodOfDeath = MOD_DESTRUCTION; // ?SPLASH;

	missile->clipmask = MASK_SHOT | CONTENTS_LIGHTSABER;
	missile->splashDamage = damage;
	missile->splashRadius = BLAST_SPLASH_RADIUS * (1.0f + force_level) / 2.0f;

	// we don't want it to ever bounce
	missile->bounceCount = 0;
}

static qhandle_t repulseLoopSound = 0;

void ForceJediRepulse(gentity_t* self)
{
	if (self->health <= 0)
	{
		return;
	}
	if (!self->s.number && (cg.zoomMode || in_camera))
	{
		//can't repulse when zoomed in or in cinematic
		return;
	}
	if (self->client->ps.leanofs)
	{
		//can't repulse while leaning
		return;
	}
	if (!WP_ForcePowerUsable(self, FP_REPULSE, 40))
	{
		return;
	}
	if (self->client->ps.repulseChargeStart)
	{
		return;
	}
	if (self->client->ps.saberLockTime > level.time)
	{
		return;
	}
	if (self->client->ps.forcePowersActive & 1 << FP_PROTECT)
	{
		WP_ForcePowerStop(self, FP_PROTECT);
	}
	if (self->client->ps.forcePowersActive & 1 << FP_PROJECTION)
	{
		WP_ForcePowerStop(self, FP_PROJECTION);
	}
	if (self->client->ps.forcePowersActive & 1 << FP_ABSORB)
	{
		WP_ForcePowerStop(self, FP_ABSORB);
	}

	self->client->ps.repulseChargeStart = level.time;

	NPC_SetAnim(self, SETANIM_TORSO, BOTH_FORCE_PROTECT_FAST, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);

	self->client->ps.saber_move = self->client->ps.saberBounceMove = LS_READY;
	//don't finish whatever saber anim you may have been in
	self->client->ps.saberBlocked = BLOCKED_NONE;

	G_SoundOnEnt(self, CHAN_BODY, "sound/weapons/force/repulsecharge.mp3");

	if (self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self))
	{
		CGCam_BlockShakeSP(0.50f, 1500);
	}

	self->client->ps.weaponTime = self->client->ps.torsoAnimTimer;
	WP_ForcePowerStart(self, FP_REPULSE, 1);
}

int WP_AbsorbConversion(const gentity_t* attacked, const int atd_abs_level, const int at_power,
	const int at_power_level,
	const int at_force_spent)
{
	if (at_power != FP_LIGHTNING &&
		at_power != FP_DRAIN &&
		at_power != FP_GRIP &&
		at_power != FP_PUSH &&
		at_power != FP_PULL &&
		at_power != FP_REPULSE &&
		at_power != FP_GRASP &&
		at_power != FP_LIGHTNING_STRIKE &&
		at_power != FP_STASIS)
	{
		//Only these powers can be absorbed
		return -1;
	}

	if (!atd_abs_level)
	{
		//looks like attacker doesn't have any absorb power
		return -1;
	}

	if (!(attacked->client->ps.forcePowersActive & 1 << FP_ABSORB))
	{
		//absorb is not active
		return -1;
	}

	//Subtract absorb power level from the offensive force power
	int get_level = at_power_level;
	get_level -= atd_abs_level;

	if (get_level < 0)
	{
		get_level = 0;
	}

	//let the attacker absorb an amount of force used in this attack based on his level of absorb
	int add_tot = at_force_spent / 3 * attacked->client->ps.forcePowerLevel[FP_ABSORB];

	if (add_tot < 1 && at_force_spent >= 1)
	{
		add_tot = 1;
	}
	attacked->client->ps.forcePower += add_tot;
	if (attacked->client->ps.forcePower > attacked->client->ps.forcePowerMax)
	{
		attacked->client->ps.forcePower = attacked->client->ps.forcePowerMax;
	}

	G_SoundOnEnt(attacked, CHAN_ITEM, "sound/weapons/force/absorbhit.wav");

	return get_level;
}

void WP_ForcePowerRegenerate(const gentity_t* self, const int override_amt)
{
	if (!self->client)
	{
		return;
	}

	if (self->client->ps.forcePower < self->client->ps.forcePowerMax)
	{
		if (self->flags & FL_FORCEMODE)
		{
			self->client->ps.forcePower = self->client->ps.forcePowerMax;
		}
		else
		{
			if (override_amt)
			{
				self->client->ps.forcePower += override_amt;
			}
			else
			{
				self->client->ps.forcePower++;
			}
		}
		if (self->client->ps.forcePower > self->client->ps.forcePowerMax)
		{
			self->client->ps.forcePower = self->client->ps.forcePowerMax;
		}
	}
}

void WP_BlockPointsRegenerate(const gentity_t* self, const int override_amt)
{
	if (self->client->ps.blockPoints < BLOCK_POINTS_MAX)
	{
		if (self->flags & FL_BLOCKPOINTMODE)
		{
			self->client->ps.blockPoints = BLOCK_POINTS_MAX;
		}
		else
		{
			if (override_amt)
			{
				self->client->ps.blockPoints += override_amt;
			}
			else
			{
				self->client->ps.blockPoints++;
			}
		}
		if (self->client->ps.blockPoints > BLOCK_POINTS_MAX)
		{
			self->client->ps.blockPoints = BLOCK_POINTS_MAX;
		}
	}
}

void wp_block_points_regenerate_over_ride(const gentity_t* self, const int override_amt)
{
	if (self->client->ps.blockPoints < BLOCK_POINTS_MAX)
	{
		if (override_amt)
		{
			self->client->ps.blockPoints += override_amt;
		}
		else
		{
			self->client->ps.blockPoints++;
		}
		if (self->client->ps.blockPoints > BLOCK_POINTS_MAX)
		{
			self->client->ps.blockPoints = BLOCK_POINTS_MAX;
		}
	}
}

void WP_ForcePowerDrain(const gentity_t* self, const forcePowers_t force_power, const int override_amt)
{
	//take away the power
	int drain = override_amt;
	if (!drain)
	{
		drain = forcePowerNeeded[force_power];
	}
	if (!drain)
	{
		return;
	}
	self->client->ps.forcePower -= drain;
	if (self->client->ps.forcePower < 0)
	{
		self->client->ps.forcePower = 0;
	}

	if (g_SerenityJediEngineMode->integer)
	{
		//check for fatigued state.
		if (self->client->ps.forcePower <= BLOCKPOINTS_FATIGUE)
		{
			//Pop the Fatigued flag
			self->client->ps.userInt3 |= 1 << FLAG_FATIGUED;
		}
	}
}

void WP_BlockPointsDrain(const gentity_t* self, const int fatigue)
{
	if (self->client->ps.blockPoints > fatigue)
	{
		self->client->ps.blockPoints -= fatigue;
	}
	else
	{
		self->client->ps.blockPoints = 0;
	}

	if (self->client->ps.blockPoints < 0)
	{
		self->client->ps.blockPoints = 0;
	}
}

extern void Cmd_UseProjection_f(gentity_t* ent);

void WP_ForcePowerStart(gentity_t* self, const forcePowers_t force_power, int override_amt)
{
	int duration = 0;

	self->client->ps.forcePowerDebounce[force_power] = 0;

	//and it in
	//set up duration time
	switch (static_cast<int>(force_power))
	{
	case FP_HEAL:
		self->client->ps.forcePowersActive |= 1 << force_power;
		self->client->ps.forceHealCount = 0;
		WP_StartForceHealEffects(self);
		break;
	case FP_LEVITATION:
		self->client->ps.forcePowersActive |= 1 << force_power;
		break;
	case FP_SPEED:
		//duration is always 5 seconds, player time
		duration = ceil(FORCE_SPEED_DURATION * forceSpeedValue[self->client->ps.forcePowerLevel[force_power]]);

		self->client->ps.forcePowersActive |= 1 << force_power;

		self->s.loopSound = G_SoundIndex("sound/weapons/force/speedloop.wav");

		if (self->client->ps.forcePowerLevel[force_power] > FORCE_LEVEL_2)
		{
			self->client->ps.forcePowerDebounce[force_power] = level.time;
		}
		break;
	case FP_PUSH:
		break;
	case FP_PULL:
		self->client->ps.forcePowersActive |= 1 << force_power;
		break;
	case FP_TELEPATHY:
		break;
	case FP_GRIP:
		duration = 1000;
		self->client->ps.forcePowersActive |= 1 << force_power;
		break;
	case FP_LIGHTNING:
		duration = override_amt;
		override_amt = 0;
		self->client->ps.forcePowersActive |= 1 << force_power;
		break;
		//new Jedi Academy force powers
	case FP_RAGE:
		//duration is always 5 seconds, player time
		duration = ceil(FORCE_RAGE_DURATION * forceSpeedValue[self->client->ps.forcePowerLevel[force_power] - 1]);
		//FIXME: because the timescale scales down (not instant), this doesn't end up being exactly right...
		self->client->ps.forcePowersActive |= 1 << force_power;
		G_SoundOnEnt(self, CHAN_ITEM, "sound/weapons/force/rage.mp3");
		self->s.loopSound = G_SoundIndex("sound/weapons/force/rageloop.wav");
		if (self->chestBolt != -1)
		{
			G_PlayEffect(G_EffectIndex("force/rage2"), self->playerModel, self->chestBolt, self->s.number,
				self->currentOrigin, duration, qtrue);
		}
		break;
	case FP_DRAIN:
		if (self->client->ps.forcePowerLevel[force_power] > FORCE_LEVEL_1
			&& self->client->ps.forceDrainEntityNum >= ENTITYNUM_WORLD)
		{
			duration = override_amt;
			override_amt = 0;
			//HACK: just using this as a timestamp for when the power started, setting debounce to current time shouldn't adversely affect anything else
			self->client->ps.forcePowerDebounce[force_power] = level.time;
		}
		else
		{
			duration = 1000;
		}
		self->client->ps.forcePowersActive |= 1 << force_power;
		break;
	case FP_PROTECT:
		switch (self->client->ps.forcePowerLevel[force_power])
		{
		case FORCE_LEVEL_5:
		case FORCE_LEVEL_4:
		case FORCE_LEVEL_3:
			duration = 20000;
			break;
		case FORCE_LEVEL_2:
			duration = 15000;
			break;
		case FORCE_LEVEL_1:
		default:

			duration = 10000;
			break;
		}
		self->client->ps.forcePowersActive |= 1 << force_power;
		G_SoundOnEnt(self, CHAN_ITEM, "sound/weapons/force/protect.mp3");
		self->s.loopSound = G_SoundIndex("sound/weapons/force/protectloop.wav");
		break;
	case FP_ABSORB:
		duration = 20000;
		self->client->ps.forcePowersActive |= 1 << force_power;
		G_SoundOnEnt(self, CHAN_ITEM, "sound/weapons/force/absorb.mp3");
		self->s.loopSound = G_SoundIndex("sound/weapons/force/absorbloop.wav");
		break;
	case FP_SEE:
		if (self->client->ps.forcePowerLevel[force_power] == FORCE_LEVEL_1)
		{
			duration = 5000;
		}
		else if (self->client->ps.forcePowerLevel[force_power] == FORCE_LEVEL_2)
		{
			duration = 10000;
		}
		else
		{
			duration = 20000;
		}

		self->client->ps.forcePowersActive |= 1 << force_power;
		G_SoundOnEnt(self, CHAN_ITEM, "sound/weapons/force/see.mp3");
		self->s.loopSound = G_SoundIndex("sound/weapons/force/seeloop.wav");
		break;
	case FP_DESTRUCTION:
		break;
	case FP_STASIS:
		break;
	case FP_GRASP:
		if (self->client->ps.forcePowerLevel[force_power] == FORCE_LEVEL_1)
		{
			duration = 2000;
		}
		else if (self->client->ps.forcePowerLevel[force_power] == FORCE_LEVEL_2)
		{
			duration = 3000;
		}
		else
		{
			duration = 5000;
		}
		self->client->ps.forcePowersActive |= 1 << force_power;
		break;
	case FP_REPULSE:
		self->client->ps.forcePowersActive |= 1 << force_power;
		self->client->ps.powerups[PW_FORCE_REPULSE] = Q3_INFINITE;
		self->client->pushEffectFadeTime = 0;
		break;
	case FP_LIGHTNING_STRIKE:
		duration = override_amt;
		override_amt = 0;
		self->client->ps.forcePowersActive |= 1 << force_power;
		break;
	case FP_DEADLYSIGHT:
		if (self->client->ps.forcePowerLevel[force_power] == FORCE_LEVEL_1)
		{
			duration = 600;
		}
		else if (self->client->ps.forcePowerLevel[force_power] == FORCE_LEVEL_2)
		{
			duration = 900;
		}
		else
		{
			duration = 1100;
		}
		self->client->ps.forcePowersActive |= 1 << force_power;
		G_SoundOnEnt(self, CHAN_ITEM, "sound/weapons/force/repulsecharge.mp3");
		self->s.loopSound = G_SoundIndex("sound/weapons/force/protectloop.mp3");
		break;
	case FP_BLAST:
		break;
	case FP_PROJECTION:
		switch (self->client->ps.forcePowerLevel[force_power])
		{
		case FORCE_LEVEL_3:
			duration = 20000;
			break;
		case FORCE_LEVEL_2:
			duration = 15000;
			break;
		case FORCE_LEVEL_1:
		default:
			duration = 10000;
			break;
		}
		self->client->ps.forcePowersActive |= 1 << force_power;
		G_SoundOnEnt(self, CHAN_ITEM, "sound/weapons/force/projection.mp3");
		self->s.loopSound = G_SoundIndex("sound/weapons/force/protectloop.wav");

		Cmd_UseProjection_f(self);

		self->flags |= FL_GODMODE;
		self->flags |= FL_NOTARGET;
		self->client->Isprojecting = qtrue;

		break;
	default:
		break;
	}
	if (duration)
	{
		self->client->ps.forcePowerDuration[force_power] = level.time + duration;
	}
	else
	{
		self->client->ps.forcePowerDuration[force_power] = 0;
	}

	WP_ForcePowerDrain(self, force_power, override_amt);

	if (!self->s.number)
	{
		self->client->sess.missionStats.forceUsed[static_cast<int>(force_power)]++;
	}
}

qboolean WP_ForcePowerAvailable(const gentity_t* self, const forcePowers_t force_power, const int override_amt)
{
	if (force_power == FP_LEVITATION)
	{
		return qtrue;
	}
	const int drain = override_amt ? override_amt : forcePowerNeeded[force_power];
	if (!drain)
	{
		return qtrue;
	}
	if (self->client->ps.forcePower < drain)
	{
		//G_AddEvent( self, EV_NOAMMO, 0 );
		return qfalse;
	}
	return qtrue;
}

extern void CG_PlayerLockedWeaponSpeech(int jumping);
extern qboolean rosh_twin_near_by(const gentity_t* self);

qboolean WP_ForcePowerUsable(const gentity_t* self, const forcePowers_t force_power, const int override_amt)
{
	if (!(self->client->ps.forcePowersKnown & 1 << force_power))
	{
		//don't know this power
		return qfalse;
	}
	if (self->NPC && self->NPC->aiFlags & NPCAI_ROSH)
	{
		if (1 << force_power & FORCE_POWERS_ROSH_FROM_TWINS)
		{
			//this is a force power we can only use when a twin is near us
			if (!rosh_twin_near_by(self))
			{
				return qfalse;
			}
		}
	}

	if (self->client->ps.forcePowerLevel[force_power] <= 0)
	{
		//can't use this power
		return qfalse;
	}

	if (self->flags & FL_LOCK_PLAYER_WEAPONS)
		// yes this locked weapons check also includes force powers, if we need a separate check later I'll make one
	{
		if (self->s.number < MAX_CLIENTS)
		{
			CG_PlayerLockedWeaponSpeech(qfalse);
		}
		return qfalse;
	}

	if (self->client->ps.pm_flags & PMF_STUCK_TO_WALL)
	{
		//no offensive force powers when stuck to wall
		switch (force_power)
		{
		case FP_GRIP:
		case FP_GRASP:
		case FP_LIGHTNING:
		case FP_DRAIN:
		case FP_SABER_OFFENSE:
		case FP_SABER_DEFENSE:
		case FP_SABERTHROW:
		case FP_LIGHTNING_STRIKE:
		case FP_BLAST:
			return qfalse;
		default:
			break;
		}
	}

	if (in_camera && self->s.number < MAX_CLIENTS)
	{
		//player can't turn on force powers during cinematic
		return qfalse;
	}

	if (PM_LockedAnim(self->client->ps.torsoAnim) && self->client->ps.torsoAnimTimer)
	{
		//no force powers during these special anims
		return qfalse;
	}
	if (PM_SuperBreakLoseAnim(self->client->ps.torsoAnim)
		|| PM_SuperBreakWinAnim(self->client->ps.torsoAnim))
	{
		return qfalse;
	}

	if (self->client->ps.forcePowersActive & 1 << force_power)
	{
		//already using this power
		return qfalse;
	}
	if (self->client->NPC_class == CLASS_ATST || self->client->NPC_class == CLASS_DROIDEKA)
	{
		//Doh!  No force powers in an AT-ST!
		return qfalse;
	}
	const Vehicle_t* p_veh;
	if ((p_veh = G_IsRidingVehicle(self)) != nullptr)
	{
		//Doh!  No force powers when flying a vehicle!
		if (p_veh->m_pVehicleInfo->numHands > 1)
		{
			//if in a two-handed vehicle
			return qfalse;
		}
	}
	if (self->client->ps.viewEntity > 0 && self->client->ps.viewEntity < ENTITYNUM_WORLD)
	{
		//Doh!  No force powers when controlling an NPC
		return qfalse;
	}
	if (self->client->ps.eFlags & EF_LOCKED_TO_WEAPON)
	{
		//Doh!  No force powers when in an emplaced gun!
		return qfalse;
	}

	if (self->client->ps.saber[0].saberFlags & SFL_SINGLE_BLADE_THROWABLE //SaberStaff() //using staff
		&& !self->client->ps.dualSabers //only 1, in right hand
		&& !self->client->ps.saber[0].blade[1].active) //only first blade is on
	{
		//allow power
		//FIXME: externalize this condition separately?
	}
	else
	{
		if (force_power == FP_SABERTHROW && self->client->ps.saber[0].saberFlags & SFL_NOT_THROWABLE)
		{
			//cannot throw this kind of saber
			return qfalse;
		}

		if (self->client->ps.saber[0].Active())
		{
			if (self->client->ps.saber[0].saberFlags & SFL_TWO_HANDED)
			{
				if (g_saberRestrictForce->integer)
				{
					switch (force_power)
					{
					case FP_PUSH:
					case FP_PULL:
					case FP_TELEPATHY:
					case FP_GRIP:
					case FP_GRASP:
					case FP_LIGHTNING:
					case FP_DRAIN:
					case FP_LIGHTNING_STRIKE:
					case FP_BLAST:
						return qfalse;
					default:
						break;
					}
				}
			}
			if (self->client->ps.saber[0].saberFlags & SFL_TWO_HANDED
				|| self->client->ps.dualSabers && self->client->ps.saber[1].Active())
			{
				//this saber requires the use of two hands OR our other hand is using an active saber too
				if (self->client->ps.saber[0].forceRestrictions & 1 << force_power)
				{
					//this power is verboten when using this saber
					return qfalse;
				}
			}
		}
		if (self->client->ps.dualSabers && self->client->ps.saber[1].Active())
		{
			if (g_saberRestrictForce->integer)
			{
				switch (force_power)
				{
				case FP_PUSH:
				case FP_PULL:
				case FP_TELEPATHY:
				case FP_GRIP:
				case FP_GRASP:
				case FP_LIGHTNING:
				case FP_DRAIN:
				case FP_LIGHTNING_STRIKE:
				case FP_BLAST:
					return qfalse;
				default:
					break;
				}
			}
			if (self->client->ps.saber[1].forceRestrictions & 1 << force_power)
			{
				//this power is verboten when using this saber
				return qfalse;
			}
		}
	}

	return WP_ForcePowerAvailable(self, force_power, override_amt);
}

void WP_ForcePowerStop(gentity_t* self, const forcePowers_t force_power)
{
	gentity_t* grip_ent;

	if (!(self->client->ps.forcePowersActive & 1 << force_power))
	{
		//umm, wasn't doing it, so...
		return;
	}

	self->client->ps.forcePowersActive &= ~(1 << force_power);

	switch (static_cast<int>(force_power))
	{
	case FP_HEAL:
		if (self->client->ps.forcePowerLevel[force_power] < FORCE_LEVEL_2)
		{
			//if in meditation pose, must come out of it
			//FIXME: BOTH_FORCEHEAL_STOP
			if (self->client->ps.legsAnim == BOTH_FORCEHEAL_START)
			{
				NPC_SetAnim(self, SETANIM_LEGS, BOTH_FORCEHEAL_STOP, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
			}
			if (self->client->ps.torsoAnim == BOTH_FORCEHEAL_START)
			{
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_FORCEHEAL_STOP, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
			}
			self->client->ps.saber_move = self->client->ps.saberBounceMove = LS_READY;
			//don't finish whatever saber anim you may have been in
			self->client->ps.saberBlocked = BLOCKED_NONE;
		}
		WP_StopForceHealEffects(self);
		if (self->health >= self->client->ps.stats[STAT_MAX_HEALTH] / 3)
		{
			gi.G2API_ClearSkinGore(self->ghoul2);
		}
		break;
	case FP_LEVITATION:
		self->client->ps.forcePowerDebounce[force_power] = 0;
		break;
	case FP_SPEED:
		if (!self->s.number)
		{
			//player using force speed
			if (g_timescale->value != 1.0)
			{
				if (!(self->client->ps.forcePowersActive & 1 << FP_RAGE) || self->client->ps.forcePowerLevel[FP_RAGE] <
					FORCE_LEVEL_2)
				{
					//not slowed down because of force rage
					gi.cvar_set("timescale", "1");
				}
			}
		}

		if (self->client->ps.forcePowerLevel[force_power] < FORCE_LEVEL_2)
		{
			self->client->ps.forceSpeedRecoveryTime = level.time + 1500; //recover for 1.5 seconds
		}
		else
		{
			self->client->ps.forceSpeedRecoveryTime = level.time + 1000; //recover for 1 seconds
		}
		self->s.loopSound = 0;
		break;
	case FP_PUSH:
		break;
	case FP_PULL:
		break;
	case FP_TELEPATHY:
		break;
	case FP_GRIP:
		if (self->NPC)
		{
			TIMER_Set(self, "gripping", -level.time);
		}
		if (self->client->ps.forceGripEntityNum < ENTITYNUM_WORLD)
		{
			grip_ent = &g_entities[self->client->ps.forceGripEntityNum];
			if (grip_ent)
			{
				grip_ent->s.loopSound = 0;
				if (grip_ent->client)
				{
					grip_ent->client->ps.eFlags &= ~EF_FORCE_GRIPPED;
					if (self->client->ps.forcePowerLevel[force_power] > FORCE_LEVEL_1)
					{
						//sanity-cap the velocity
						float gripVel = VectorNormalize(grip_ent->client->ps.velocity);
						if (gripVel > 500.0f)
						{
							gripVel = 500.0f;
						}
						VectorScale(grip_ent->client->ps.velocity, gripVel, grip_ent->client->ps.velocity);
					}

					//FIXME: they probably dropped their weapon, should we make them flee?  Or should AI handle no-weapon behavior?
					//rww - RAGDOLL_BEGIN
#ifndef JK2_RAGDOLL_GRIPNOHEALTH
//rww - RAGDOLL_END
					if (grip_ent->health > 0)
						//rww - RAGDOLL_BEGIN
#endif
					//rww - RAGDOLL_END
					{
						int hold_time;
						if (grip_ent->health > 0)
						{
							G_AddEvent(grip_ent, EV_WATER_CLEAR, 0);
						}
						if (grip_ent->client->ps.forcePowerDebounce[FP_PUSH] > level.time)
						{
							//they probably pushed out of it
							hold_time = 0;
						}
						else if (grip_ent->s.weapon == WP_SABER)
						{
							//jedi recover faster
							hold_time = self->client->ps.forcePowerLevel[force_power] * 200;
						}
						else
						{
							hold_time = self->client->ps.forcePowerLevel[force_power] * 500;
						}

						//stop the anims soon, keep them locked in place for a bit
						if (grip_ent->client->ps.torsoAnim == BOTH_CHOKE1 || grip_ent->client->ps.torsoAnim ==
							BOTH_CHOKE3
							|| grip_ent->client->ps.torsoAnim == BOTH_CHOKE4)
						{
							//stop choking anim on torso
							if (grip_ent->client->ps.torsoAnimTimer > hold_time)
							{
								grip_ent->client->ps.torsoAnimTimer = hold_time;
							}
						}
						if (grip_ent->client->ps.legsAnim == BOTH_CHOKE1 || grip_ent->client->ps.legsAnim == BOTH_CHOKE3
							|| grip_ent->client->ps.legsAnim == BOTH_CHOKE4)
						{
							//stop choking anim on legs
							grip_ent->client->ps.legsAnimTimer = 0;
							if (hold_time)
							{
								//lock them in place for a bit
								grip_ent->client->ps.pm_time = grip_ent->client->ps.torsoAnimTimer;
								grip_ent->client->ps.pm_flags |= PMF_TIME_KNOCKBACK;
								if (grip_ent->s.number)
								{
									//NPC
									grip_ent->painDebounceTime = level.time + grip_ent->client->ps.torsoAnimTimer;
								}
								else
								{
									//player
									grip_ent->aimDebounceTime = level.time + grip_ent->client->ps.torsoAnimTimer;
								}
							}
						}
						if (grip_ent->NPC)
						{
							if (!(grip_ent->NPC->aiFlags & NPCAI_DIE_ON_IMPACT))
							{
								//not falling to their death
								grip_ent->NPC->nextBStateThink = level.time + hold_time;
							}
							//if still alive after stopped gripping, let them wake others up
							if (grip_ent->health > 0)
							{
								G_AngerAlert(grip_ent);
							}
						}
					}
				}
				else
				{
					grip_ent->s.eFlags &= ~EF_FORCE_GRIPPED;
					if (grip_ent->s.eType == ET_MISSILE)
					{
						//continue normal movement
						if (grip_ent->s.weapon == WP_THERMAL)
						{
							grip_ent->s.pos.trType = TR_INTERPOLATE;
						}
						else
						{
							grip_ent->s.pos.trType = TR_LINEAR; //FIXME: what about gravity-effected projectiles?
						}
						VectorCopy(grip_ent->currentOrigin, grip_ent->s.pos.trBase);
						grip_ent->s.pos.trTime = level.time;
					}
					else
					{
						//drop it
						grip_ent->e_ThinkFunc = thinkF_G_RunObject;
						grip_ent->nextthink = level.time + FRAMETIME;
						grip_ent->s.pos.trType = TR_GRAVITY;
						VectorCopy(grip_ent->currentOrigin, grip_ent->s.pos.trBase);
						grip_ent->s.pos.trTime = level.time;
					}
				}
			}
			self->s.loopSound = 0;
			self->client->ps.forceGripEntityNum = ENTITYNUM_NONE;
		}
		if (self->client->ps.torsoAnim == BOTH_FORCEGRIP_HOLD)
		{
			NPC_SetAnim(self, SETANIM_BOTH, BOTH_FORCEGRIP_RELEASE, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
		}
		break;
	case FP_LIGHTNING:
		if (self->NPC)
		{
			TIMER_Set(self, "holdLightning", -level.time);
		}
		if (self->client->ps.torsoAnim == BOTH_FORCELIGHTNING_HOLD || self->client->ps.torsoAnim == BOTH_FLAMETHROWER
			|| self->client->ps.torsoAnim == BOTH_FORCELIGHTNING_START)
		{
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_FORCELIGHTNING_RELEASE, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
		}
		else if (self->client->ps.torsoAnim == BOTH_FORCE_2HANDEDLIGHTNING_HOLD
			|| self->client->ps.torsoAnim == BOTH_FORCE_2HANDEDLIGHTNING_START)
		{
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_FORCE_2HANDEDLIGHTNING_RELEASE,
				SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
		}
		if (self->client->ps.forcePowerLevel[force_power] < FORCE_LEVEL_2)
		{
			//don't do it again for 3 seconds, minimum... FIXME: this should be automatic once regeneration is slower (normal)
			self->client->ps.forcePowerDebounce[force_power] = level.time + 3000; //FIXME: define?
		}
		else
		{
			//stop the looping sound
			self->client->ps.forcePowerDebounce[force_power] = level.time + 1000; //FIXME: define?
			self->s.loopSound = 0;
		}
		break;
	case FP_RAGE:
		self->client->ps.forceRageRecoveryTime = level.time + 10000; //recover for 10 seconds
		if (self->client->ps.forcePowerDuration[force_power] > level.time)
		{
			//still had time left, we cut it short
			self->client->ps.forceRageRecoveryTime -= self->client->ps.forcePowerDuration[force_power] - level.time;
			//minus however much time you had left when you cut it short
		}
		if (!self->s.number)
		{
			//player using force speed
			if (g_timescale->value != 1.0)
			{
				if (!(self->client->ps.forcePowersActive & 1 << FP_SPEED))
				{
					//not slowed down because of force speed
					gi.cvar_set("timescale", "1");
				}
			}
		}
		//FIXME: reset my current anim, keeping current frame, but with proper anim speed
		//		otherwise, the anim will continue playing at high speed
		self->s.loopSound = 0;
		if (self->NPC)
		{
			jedi_rage_stop(self);
		}
		if (self->chestBolt != -1)
		{
			G_StopEffect("force/rage2", self->playerModel, self->chestBolt, self->s.number);
		}
		break;
	case FP_DRAIN:
		if (self->NPC)
		{
			TIMER_Set(self, "draining", -level.time);
		}
		if (self->client->ps.forcePowerLevel[force_power] < FORCE_LEVEL_2)
		{
			//don't do it again for 3 seconds, minimum... FIXME: this should be automatic once regeneration is slower (normal)
			self->client->ps.forcePowerDebounce[force_power] = level.time + 3000; //FIXME: define?
		}
		else
		{
			//stop the looping sound
			self->client->ps.forcePowerDebounce[force_power] = level.time + 1000; //FIXME: define?
			self->s.loopSound = 0;
		}
		//drop them
		if (self->client->ps.forceDrainEntityNum < ENTITYNUM_WORLD)
		{
			gentity_t* drain_ent = &g_entities[self->client->ps.forceDrainEntityNum];
			if (drain_ent)
			{
				if (drain_ent->client)
				{
					drain_ent->client->ps.eFlags &= ~EF_FORCE_DRAINED;
					//VectorClear( drainEnt->client->ps.velocity );
					if (drain_ent->health > 0)
					{
						if (drain_ent->client->ps.forcePowerDebounce[FP_PUSH] > level.time)
						{
							//they probably pushed out of it
						}
						else
						{
							if (drain_ent->client->ps.torsoAnim != BOTH_FORCEPUSH)
							{
								//don't stop the push
								drain_ent->client->ps.torsoAnimTimer = 0;
							}
							drain_ent->client->ps.legsAnimTimer = 0;
						}
						if (drain_ent->NPC)
						{
							//if still alive after stopped draining, let them wake others up
							G_AngerAlert(drain_ent);
						}
					}
					else
					{
						//leave the effect playing on them for a few seconds
						drain_ent->s.powerups |= 1 << PW_DRAINED;
						drain_ent->client->ps.powerups[PW_DRAINED] = level.time + Q_irand(1000, 4000);
					}
				}
			}
			self->client->ps.forceDrainEntityNum = ENTITYNUM_NONE;
		}
		if (self->client->ps.torsoAnim == BOTH_HUGGER1)
		{
			//old anim
			NPC_SetAnim(self, SETANIM_BOTH, BOTH_HUGGERSTOP1, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
		}
		else if (self->client->ps.torsoAnim == BOTH_FORCE_DRAIN_GRAB_START
			|| self->client->ps.torsoAnim == BOTH_FORCE_DRAIN_GRAB_HOLD)
		{
			//new anim
			NPC_SetAnim(self, SETANIM_BOTH, BOTH_FORCE_DRAIN_GRAB_END, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
		}
		else if (self->client->ps.torsoAnim == BOTH_FORCE_DRAIN_HOLD
			|| self->client->ps.torsoAnim == BOTH_FORCE_DRAIN_START)
		{
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_FORCE_DRAIN_RELEASE, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
		}
		break;
	case FP_PROTECT:
		self->s.loopSound = 0;
		break;
	case FP_ABSORB:
		self->s.loopSound = 0;
		if (self->client->ps.legsAnim == BOTH_FORCE_ABSORB_START)
		{
			NPC_SetAnim(self, SETANIM_LEGS, BOTH_FORCE_ABSORB_END, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
		}
		if (self->client->ps.torsoAnim == BOTH_FORCE_ABSORB_START)
		{
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_FORCE_ABSORB_END, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
		}
		if (self->client->ps.forcePowerLevel[force_power] < FORCE_LEVEL_2)
		{
			//was stuck, free us in case we interrupted it or something
			self->client->ps.weaponTime = 0;
			self->client->ps.pm_flags &= ~PMF_TIME_KNOCKBACK;
			self->client->ps.pm_time = 0;
			if (self->s.number)
			{
				//NPC
				self->painDebounceTime = 0;
			}
			else
			{
				//player
				self->aimDebounceTime = 0;
			}
		}
		break;
	case FP_SEE:
		self->s.loopSound = 0;
		break;
	case FP_DESTRUCTION:
		self->client->ps.forcePowerDebounce[force_power] = level.time + 4000; //FIXME: define?
		break;
	case FP_STASIS:
		break;
	case FP_GRASP:
		if (self->NPC)
		{
			TIMER_Set(self, "grasping", -level.time);
		}
		if (self->client->ps.forceGripEntityNum < ENTITYNUM_WORLD)
		{
			grip_ent = &g_entities[self->client->ps.forceGripEntityNum];
			if (grip_ent)
			{
				grip_ent->s.loopSound = 0;
				if (grip_ent->client)
				{
					grip_ent->client->ps.eFlags &= ~EF_FORCE_GRASPED;
					if (self->client->ps.forcePowerLevel[force_power] > FORCE_LEVEL_1)
					{
						//sanity-cap the velocity
						float grip_vel = VectorNormalize(grip_ent->client->ps.velocity);
						if (grip_vel > 500.0f)
						{
							grip_vel = 500.0f;
						}
						VectorScale(grip_ent->client->ps.velocity, grip_vel, grip_ent->client->ps.velocity);
					}

					//FIXME: they probably dropped their weapon, should we make them flee?  Or should AI handle no-weapon behavior?
					//rww - RAGDOLL_BEGIN
#ifndef JK2_RAGDOLL_GRIPNOHEALTH
//rww - RAGDOLL_END
					if (grip_ent->health > 0)
						//rww - RAGDOLL_BEGIN
#endif
					//rww - RAGDOLL_END
					{
						int hold_time;
						if (grip_ent->health > 0)
						{
							G_AddEvent(grip_ent, EV_WATER_CLEAR, 0);
						}
						if (grip_ent->client->ps.forcePowerDebounce[FP_PUSH] > level.time)
						{
							//they probably pushed out of it
							hold_time = 0;
						}
						else if (grip_ent->s.weapon == WP_SABER)
						{
							//jedi recover faster
							hold_time = self->client->ps.forcePowerLevel[force_power] * 200;
						}
						else
						{
							hold_time = self->client->ps.forcePowerLevel[force_power] * 500;
						}
						//stop the anims soon, keep them locked in place for a bit
						if (grip_ent->client->ps.torsoAnim == BOTH_CHOKE1 || grip_ent->client->ps.torsoAnim ==
							BOTH_CHOKE3
							|| grip_ent->client->ps.torsoAnim == BOTH_CHOKE4)
						{
							//stop choking anim on torso
							if (grip_ent->client->ps.torsoAnimTimer > hold_time)
							{
								grip_ent->client->ps.torsoAnimTimer = hold_time;
							}
						}

						if (grip_ent->client->ps.legsAnim == BOTH_PULLED_INAIR_F || grip_ent->client->ps.legsAnim ==
							BOTH_SWIM_IDLE1)
						{
							//stop choking anim on legs
							grip_ent->client->ps.legsAnimTimer = 0;
							if (hold_time)
							{
								//lock them in place for a bit
								grip_ent->client->ps.pm_time = grip_ent->client->ps.torsoAnimTimer;
								grip_ent->client->ps.pm_flags |= PMF_TIME_KNOCKBACK;
								if (grip_ent->s.number)
								{
									//NPC
									grip_ent->painDebounceTime = level.time + grip_ent->client->ps.torsoAnimTimer;
								}
								else
								{
									//player
									grip_ent->aimDebounceTime = level.time + grip_ent->client->ps.torsoAnimTimer;
								}
							}
						}
						if (grip_ent->NPC)
						{
							if (!(grip_ent->NPC->aiFlags & NPCAI_DIE_ON_IMPACT))
							{
								//not falling to their death
								grip_ent->NPC->nextBStateThink = level.time + hold_time;
							}
							//if still alive after stopped gripping, let them wake others up
							if (grip_ent->health > 0)
							{
								G_AngerAlert(grip_ent);
							}
						}
					}
				}
				else
				{
					grip_ent->s.eFlags &= ~EF_FORCE_GRASPED;
					if (grip_ent->s.eType == ET_MISSILE)
					{
						//continue normal movement
						if (grip_ent->s.weapon == WP_THERMAL)
						{
							grip_ent->s.pos.trType = TR_INTERPOLATE;
						}
						else
						{
							grip_ent->s.pos.trType = TR_LINEAR; //FIXME: what about gravity-effected projectiles?
						}
						VectorCopy(grip_ent->currentOrigin, grip_ent->s.pos.trBase);
						grip_ent->s.pos.trTime = level.time;
					}
					else
					{
						//drop it
						grip_ent->e_ThinkFunc = thinkF_G_RunObject;
						grip_ent->nextthink = level.time + FRAMETIME;
						grip_ent->s.pos.trType = TR_GRAVITY;
						VectorCopy(grip_ent->currentOrigin, grip_ent->s.pos.trBase);
						grip_ent->s.pos.trTime = level.time;
					}
				}
			}
			self->s.loopSound = 0;
			self->client->ps.forceGripEntityNum = ENTITYNUM_NONE;
		}
		if (self->client->ps.torsoAnim == BOTH_FORCEGRIP_HOLD)
		{
			NPC_SetAnim(self, SETANIM_BOTH, BOTH_FORCEGRIP_RELEASE, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
		}
		break;
	case FP_REPULSE:
		self->client->ps.powerups[PW_FORCE_REPULSE] = 0;

		if (self->client->ps.repulseChargeStart)
		{
			self->s.loopSound = 0;
			ForceRepulseThrow(self, level.time - self->client->ps.repulseChargeStart);
			self->client->ps.repulseChargeStart = 0;
		}
		break;
	case FP_LIGHTNING_STRIKE:
		if (self->NPC)
		{
			TIMER_Set(self, "holdLightning", -level.time);
		}
		if (self->client->ps.forcePowerLevel[force_power] < FORCE_LEVEL_2)
		{
			//don't do it again for 3 seconds, minimum... FIXME: this should be automatic once regeneration is slower (normal)
			self->client->ps.forcePowerDebounce[force_power] = level.time + 3000; //FIXME: define?
		}
		else
		{
			//stop the looping sound
			self->client->ps.forcePowerDebounce[force_power] = level.time + 1000; //FIXME: define?
			self->s.loopSound = 0;
		}
		break;
	case FP_DEADLYSIGHT:
		self->s.loopSound = 0;
		break;
	case FP_BLAST:
		break;
	case FP_PROJECTION:
		G_SoundOnEnt(self, CHAN_ITEM, "sound/items/respawn1.wav");
		self->s.loopSound = 0;
		self->flags &= ~FL_GODMODE;
		self->flags &= ~FL_NOTARGET;
		self->client->Isprojecting = qfalse;
		self->client->projectToggleTime = level.time + Q_irand(5000, 10000);

		break;
	default:
		break;
	}
}

void WP_ForceForceThrow(gentity_t* thrower)
{
	if (!thrower || !thrower->client)
	{
		return;
	}
	qboolean relock = qfalse;
	if (!(thrower->client->ps.forcePowersKnown & 1 << FP_PUSH))
	{
		//give them push just for this specific purpose
		thrower->client->ps.forcePowersKnown |= 1 << FP_PUSH;
		thrower->client->ps.forcePowerLevel[FP_PUSH] = FORCE_LEVEL_1;
	}

	if (thrower->NPC
		&& thrower->NPC->aiFlags & NPCAI_HEAL_ROSH
		&& thrower->flags & FL_LOCK_PLAYER_WEAPONS)
	{
		thrower->flags &= ~FL_LOCK_PLAYER_WEAPONS;
		relock = qtrue;
	}

	if (g_SerenityJediEngineMode->integer)
	{
		if (thrower->client->NPC_class == CLASS_GALEN
			&& (thrower->s.weapon == WP_MELEE || thrower->s.weapon == WP_NONE || thrower->s.weapon == WP_SABER && !
				thrower->client->ps.SaberActive())
			&& thrower->client->ps.groundEntityNum == ENTITYNUM_NONE)
		{
			ForceRepulse(thrower, qfalse);
		}
		else
		{
			ForceThrow_MD(thrower, qfalse);
		}
	}
	else
	{
		ForceThrow_JKA(thrower, qfalse);
	}

	if (relock)
	{
		thrower->flags |= FL_LOCK_PLAYER_WEAPONS;
	}

	if (thrower)
	{
		//take it back off
		thrower->client->ps.forcePowersKnown &= ~(1 << FP_PUSH);
		thrower->client->ps.forcePowerLevel[FP_PUSH] = FORCE_LEVEL_0;
	}
}

extern qboolean PM_ForceJumpingUp(const gentity_t* gent);

static void wp_force_power_run(gentity_t* self, forcePowers_t force_power, usercmd_t* cmd)
{
	float speed, new_speed;
	gentity_t* grip_ent;
	vec3_t angles, dir, grip_org, grip_ent_org;
	float dist;
	extern usercmd_t ucmd;

	switch (static_cast<int>(force_power))
	{
	case FP_HEAL:
		if (self->client->ps.forceHealCount >= FP_MaxForceHeal(self) || self->health >= self->client->ps.stats[
			STAT_MAX_HEALTH])
		{
			//fully healed or used up all 25
			/* Don't play any heal sound here
			if (!Q3_TaskIDPending(self, TID_CHAN_VOICE))
			{
				int index = Q_irand(1, 4);
				if (self->s.number < MAX_CLIENTS)
				{
					G_SoundOnEnt(self, CHAN_VOICE, va("sound/weapons/force/heal%d_%c.mp3", index, g_sex->string[0]));
				}
				else if (self->NPC)
				{
					if (self->NPC->blockedSpeechDebounceTime <= level.time)
					{
						//enough time has passed since our last speech
						if (Q3_TaskIDPending(self, TID_CHAN_VOICE))
						{
							//not playing a scripted line
							//say "Ahhh...."
							if (self->NPC->stats.sex == SEX_MALE
								|| self->NPC->stats.sex == SEX_NEUTRAL)
							{
								G_SoundOnEnt(self, CHAN_VOICE, va("sound/weapons/force/heal%d_m.mp3", index));
							}
							else //all other sexes use female sounds
							{
								G_SoundOnEnt(self, CHAN_VOICE, va("sound/weapons/force/heal%d_f.mp3", index));
							}
						}
					}
				}
			}*/
			WP_ForcePowerStop(self, force_power);
		}
		else if (self->client->ps.forcePowerLevel[FP_HEAL] < FORCE_LEVEL_3 && (cmd->buttons & BUTTON_ATTACK || cmd->
			buttons & BUTTON_ALT_ATTACK || self->painDebounceTime > level.time || self->client->ps.weaponTime && self->
			client->ps.weapon != WP_NONE))
		{
			//attacked or was hit while healing...
			//stop healing
			WP_ForcePowerStop(self, force_power);
		}
		else if (self->client->ps.forcePowerLevel[FP_HEAL] < FORCE_LEVEL_2 && (cmd->rightmove || cmd->forwardmove || cmd
			->upmove > 0))
		{
			//moved while healing... FIXME: also, in WP_ForcePowerStart, stop healing if any other force power is used
			//stop healing
			WP_ForcePowerStop(self, force_power);
		}
		else if (self->client->ps.forcePowerDebounce[FP_HEAL] < level.time)
		{
			//time to heal again
			if (WP_ForcePowerAvailable(self, force_power, 4))
			{
				//have available power
				int heal_interval = FP_ForceHealInterval(self);
				int heal_amount = 1; //hard, normal healing rate
				if (self->s.number < MAX_CLIENTS)
				{
					if (g_spskill->integer == 1)
					{
						//medium, heal twice as fast
						heal_amount *= 2;
					}
					else if (g_spskill->integer == 0)
					{
						//easy, heal 3 times as fast...
						heal_amount *= 3;
					}
					else if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self))
					{
						//npc, heal 3 times as fast...
						heal_amount *= 5;
					}
				}
				if (self->health + heal_amount > self->client->ps.stats[STAT_MAX_HEALTH])
				{
					heal_amount = self->client->ps.stats[STAT_MAX_HEALTH] - self->health;
				}
				self->health += heal_amount;
				self->client->ps.forceHealCount += heal_amount;
				self->client->ps.forcePowerDebounce[FP_HEAL] = level.time + heal_interval;
				WP_ForcePowerDrain(self, force_power, 4);
			}
			else
			{
				//stop
				WP_ForcePowerStop(self, force_power);
			}
		}
		break;
	case FP_LEVITATION:
		if (self->client->ps.groundEntityNum != ENTITYNUM_NONE && !self->client->ps.forceJumpZStart ||
			PM_InLedgeMove(self->client->ps.legsAnim) || PM_InWallHoldMove(self->client->ps.legsAnim))
		{
			//done with jump
			WP_ForcePowerStop(self, force_power);
		}
		else
		{
			if (PM_ForceJumpingUp(self))
			{
				//holding jump in air
				if (cmd->upmove > 10)
				{
					//still trying to go up
					if (WP_ForcePowerAvailable(self, FP_LEVITATION, 1))
					{
						if (self->client->ps.forcePowerDebounce[FP_LEVITATION] < level.time)
						{
							WP_ForcePowerDrain(self, FP_LEVITATION, 5);
							self->client->ps.forcePowerDebounce[FP_LEVITATION] = level.time + 100;
						}
						self->client->ps.forcePowersActive |= 1 << FP_LEVITATION;
						self->client->ps.forceJumpCharge = 1;
						//just used as a flag for the player, cleared when he lands
					}
					else
					{
						//cut the jump short
						WP_ForcePowerStop(self, force_power);
					}
				}
				else
				{
					//cut the jump short
					WP_ForcePowerStop(self, force_power);
				}
			}
			else
			{
				WP_ForcePowerStop(self, force_power);
			}
		}
		break;
	case FP_SPEED:

		speed = forceSpeedValue[self->client->ps.forcePowerLevel[FP_SPEED]];

		if (!self->s.number)
		{
			//player using force speed
			if (!(self->client->ps.forcePowersActive & 1 << FP_RAGE) || self->client->ps.forcePowerLevel[FP_SPEED] >=
				self->client->ps.forcePowerLevel[FP_RAGE])
			{
				//either not using rage or rage is at a lower level than speed
				gi.cvar_set("timescale", va("%4.2f", speed));
				if (g_timescale->value > speed)
				{
					new_speed = g_timescale->value - 0.05;
					if (new_speed < speed)
					{
						new_speed = speed;
					}
					gi.cvar_set("timescale", va("%4.2f", new_speed));
				}
			}
		}
		if (self->client->ps.forcePowersActive & 1 << FP_SPEED)
		{
			self->s.loopSound = G_SoundIndex("sound/weapons/force/speedloop.wav");
		}
		break;
	case FP_PUSH:
		break;
	case FP_PULL:
		break;
	case FP_TELEPATHY:
		break;
	case FP_GRIP:
	{
		if (!WP_ForcePowerAvailable(self, FP_GRIP, 0)
			|| self->client->ps.forcePowerLevel[FP_GRIP] > FORCE_LEVEL_1 && !self->s.number && !(cmd->buttons &
				BUTTON_FORCEGRIP))
		{
			WP_ForcePowerStop(self, FP_GRIP);
			return;
		}
		if (self->client->ps.forceGripEntityNum >= 0 && self->client->ps.forceGripEntityNum < ENTITYNUM_WORLD)
		{
			grip_ent = &g_entities[self->client->ps.forceGripEntityNum];

			if (!grip_ent || !grip_ent->inuse)
			{
				//invalid or freed ent
				WP_ForcePowerStop(self, FP_GRIP);
				return;
			}
#ifndef JK2_RAGDOLL_GRIPNOHEALTH
			if (grip_ent->health <= 0 && grip_ent->takedamage)
			{//either invalid ent, or dead ent
				WP_ForcePowerStop(self, FP_GRIP);
				return;
			}
			else
#endif
				if (self->client->ps.forcePowerLevel[FP_GRIP] == FORCE_LEVEL_1
					&& grip_ent->client
					&& grip_ent->client->ps.groundEntityNum == ENTITYNUM_NONE
					&& grip_ent->client->moveType != MT_FLYSWIM)
				{
					WP_ForcePowerStop(self, FP_GRIP);
					return;
				}
			if (grip_ent->client && grip_ent->client->moveType == MT_FLYSWIM && VectorLengthSquared(
				grip_ent->client->ps.velocity) > 300 * 300)
			{
				//flying creature broke free
				WP_ForcePowerStop(self, FP_GRIP);
				return;
			}
			if (grip_ent->client
				&& grip_ent->health > 0 //dead dudes don't fly
				&& (grip_ent->client->NPC_class == CLASS_BOBAFETT || grip_ent->client->NPC_class ==
					CLASS_MANDALORIAN
					|| grip_ent->client->NPC_class == CLASS_JANGO || grip_ent->client->NPC_class == CLASS_JANGODUAL
					||
					grip_ent->client->NPC_class == CLASS_ROCKETTROOPER)
				&& self->client->ps.forcePowerDebounce[FP_GRIP] < level.time
				&& !Q_irand(0, 3))
			{
				//boba fett - fly away!
				grip_ent->client->ps.forceJumpCharge = 0; //so we don't play the force flip anim
				grip_ent->client->ps.velocity[2] = 250;
				grip_ent->client->ps.forceJumpZStart = grip_ent->currentOrigin[2];
				//so we don't take damage if we land at same height
				grip_ent->client->ps.pm_flags |= PMF_JUMPING;
				G_AddEvent(grip_ent, EV_JUMP, 0);
				JET_FlyStart(grip_ent);
				WP_ForcePowerStop(self, FP_GRIP);
				return;
			}
			if (grip_ent->NPC
				&& grip_ent->client
				&& grip_ent->client->ps.forcePowersKnown
				&& (grip_ent->client->NPC_class == CLASS_REBORN || grip_ent->client->ps.weapon == WP_SABER &&
					grip_ent
					->client->ps.forcePowerLevel[FP_PUSH] > FORCE_LEVEL_0 && grip_ent->client->NPC_class !=
					CLASS_GUARD && !jedi_jedi_master_low(grip_ent))
				&& !jedi_cultist_destroyer(grip_ent)
				&& !Q_irand(0, 100 - grip_ent->NPC->stats.evasion * 8 - g_spskill->integer * 20))
			{
				//a jedi who broke free FIXME: maybe have some minimum grip length- a reaction time?
				WP_ForceForceThrow(grip_ent);
				WP_ForcePowerStop(self, FP_GRIP);
				return;
			}
			if (PM_SaberInAttack(self->client->ps.saber_move)
				|| PM_SaberInStart(self->client->ps.saber_move))
			{
				//started an attack
				WP_ForcePowerStop(self, FP_GRIP);
				return;
			}
			int grip_level = self->client->ps.forcePowerLevel[FP_GRIP];
			if (grip_ent->client)
			{
				grip_level = WP_AbsorbConversion(grip_ent, grip_ent->client->ps.forcePowerLevel[FP_ABSORB], FP_GRIP,
					self->client->ps.forcePowerLevel[FP_GRIP],
					forcePowerNeeded[grip_level]);
			}
			if (!grip_level)
			{
				WP_ForcePowerStop(self, force_power);
				return;
			}

			NPC_SetAnim(self, SETANIM_TORSO, BOTH_FORCEGRIP_HOLD, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);

			if (self->client->ps.torsoAnimTimer < 100)
			{
				//we were already playing this anim, we didn't want to restart it, but we want to hold it for at least 100ms.
				self->client->ps.torsoAnimTimer = 200;
			}
			VectorCopy(self->client->ps.viewangles, angles);
			angles[0] -= 10;
			AngleVectors(angles, dir, nullptr, nullptr);
			if (grip_ent->client)
			{
				//move
				VectorCopy(grip_ent->client->renderInfo.headPoint, grip_ent_org);
			}
			else
			{
				VectorCopy(grip_ent->currentOrigin, grip_ent_org);
			}

			//how far are they
			dist = Distance(self->client->renderInfo.handLPoint, grip_ent_org);

			if (self->client->ps.forcePowerLevel[FP_GRIP] == FORCE_LEVEL_2 &&
				(!InFront(grip_ent_org, self->client->renderInfo.handLPoint, self->client->ps.viewangles, 0.3f) ||
					DistanceSquared(grip_ent_org, self->client->renderInfo.handLPoint) > FORCE_GRIP_DIST_SQUARED))
			{
				//must face them
				WP_ForcePowerStop(self, FP_GRIP);
				return;
			}

			//check for lift or carry
			if (self->client->ps.forcePowerLevel[FP_GRIP] > FORCE_LEVEL_2
				&& (!grip_ent->client || !grip_ent->message && !(grip_ent->flags & FL_NO_KNOCKBACK)))
			{
				//carry
				//cap dist
				if (dist > FORCE_GRIP_3_MAX_DIST)
				{
					dist = FORCE_GRIP_3_MAX_DIST;
				}
				else if (dist < FORCE_GRIP_3_MIN_DIST)
				{
					dist = FORCE_GRIP_3_MIN_DIST;
				}
				VectorMA(self->client->renderInfo.handLPoint, dist, dir, grip_org);
			}
			else if (self->client->ps.forcePowerLevel[FP_GRIP] > FORCE_LEVEL_1)
			{
				//just lift
				VectorCopy(self->client->ps.forceGripOrg, grip_org);
			}
			else
			{
				VectorCopy(grip_ent->currentOrigin, grip_org);
			}

			if (self->client->ps.forcePowerLevel[FP_GRIP] > FORCE_LEVEL_1)
			{
				//if holding him, make sure there's a clear LOS between my hand and him
				trace_t grip_trace;
				gi.trace(&grip_trace, self->client->renderInfo.handLPoint, nullptr, nullptr, grip_ent_org,
					ENTITYNUM_NONE, MASK_FORCE_PUSH, static_cast<EG2_Collision>(0), 0);
				if (grip_trace.startsolid
					|| grip_trace.allsolid
					|| grip_trace.fraction < 1.0f)
				{
					//no clear trace, drop them
					WP_ForcePowerStop(self, FP_GRIP);
					return;
				}
			}
			//now move them
			if (grip_ent->client)
			{
				if (self->client->ps.forcePowerLevel[FP_GRIP] > FORCE_LEVEL_1)
				{
					//level 1 just holds them
					VectorSubtract(grip_org, grip_ent_org, grip_ent->client->ps.velocity);

					if (self->client->ps.forcePowerLevel[FP_GRIP] > FORCE_LEVEL_2
						&& (!grip_ent->client || !grip_ent->message && !(grip_ent->flags & FL_NO_KNOCKBACK)))
					{
						if (grip_ent->s.number < MAX_CLIENTS || G_ControlledByPlayer(grip_ent))
							// npc,s cant throw the player around with grip any more
						{
							VectorSubtract(grip_org, grip_ent_org, grip_ent->client->ps.velocity);
						}
						else
						{
							//level 2 just lifts them
							float grip_dist = VectorNormalize(grip_ent->client->ps.velocity) / 3.0f;

							if (grip_dist < 20.0f)
							{
								if (grip_dist < 2.0f)
								{
									VectorClear(grip_ent->client->ps.velocity);
								}
								else
								{
									VectorScale(grip_ent->client->ps.velocity, grip_dist * grip_dist,
										grip_ent->client->ps.velocity);
								}
							}
							else
							{
								VectorScale(grip_ent->client->ps.velocity, grip_dist * grip_dist,
									grip_ent->client->ps.velocity);
							}
						}
					}
				}
				//stop them from thinking
				grip_ent->client->ps.pm_time = 2000;
				grip_ent->client->ps.pm_flags |= PMF_TIME_KNOCKBACK;
				if (grip_ent->NPC)
				{
					if (!(grip_ent->NPC->aiFlags & NPCAI_DIE_ON_IMPACT))
					{
						//not falling to their death
						grip_ent->NPC->nextBStateThink = level.time + 2000;
					}
					if (self->client->ps.forcePowerLevel[FP_GRIP] > FORCE_LEVEL_1)
					{
						//level 1 just holds them
						vectoangles(dir, angles);
						grip_ent->NPC->desiredYaw = AngleNormalize180(angles[YAW] + 180);
						grip_ent->NPC->desiredPitch = -angles[PITCH];
						SaveNPCGlobals();
						SetNPCGlobals(grip_ent);
						NPC_UpdateAngles(qtrue, qtrue);
						grip_ent->NPC->last_ucmd.angles[0] = ucmd.angles[0];
						grip_ent->NPC->last_ucmd.angles[1] = ucmd.angles[1];
						grip_ent->NPC->last_ucmd.angles[2] = ucmd.angles[2];
						RestoreNPCGlobals();
						//FIXME: why does he turn back to his original angles once he dies or is let go?
					}
				}
				else if (!grip_ent->s.number)
				{
					grip_ent->enemy = self;
					NPC_SetLookTarget(grip_ent, self->s.number, level.time + 1000);
				}

				grip_ent->client->ps.eFlags |= EF_FORCE_GRIPPED;
				//dammit!  Make sure that saber stays off!

				if (!(grip_ent->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCK))
				{
					WP_DeactivateSaber(grip_ent);
				}
				else
				{
					grip_ent->client->ps.ManualBlockingFlags &= ~(1 << HOLDINGBLOCK);
					grip_ent->client->ps.ManualBlockingFlags &= ~(1 << HOLDINGBLOCKANDATTACK);
					grip_ent->client->ps.ManualBlockingFlags &= ~(1 << PERFECTBLOCKING);
					grip_ent->client->ps.ManualBlockingFlags &= ~(1 << MBF_NPCBLOCKING);
					WP_DeactivateSaber(grip_ent);
				}
			}
			else
			{
				//move
				if (self->client->ps.forcePowerLevel[FP_GRIP] > FORCE_LEVEL_1)
				{
					//level 1 just holds them
					VectorCopy(grip_ent->currentOrigin, grip_ent->s.pos.trBase);
					VectorSubtract(grip_org, grip_ent_org, grip_ent->s.pos.trDelta);
					if (self->client->ps.forcePowerLevel[FP_GRIP] > FORCE_LEVEL_2
						&& (!grip_ent->client || !grip_ent->message && !(grip_ent->flags & FL_NO_KNOCKBACK)))
					{
						//level 2 just lifts them
						VectorScale(grip_ent->s.pos.trDelta, 10, grip_ent->s.pos.trDelta);
					}
					grip_ent->s.pos.trType = TR_LINEAR;
					grip_ent->s.pos.trTime = level.time;
				}

				grip_ent->s.eFlags |= EF_FORCE_GRIPPED;
			}

			AddSightEvent(self, grip_org, 128, AEL_DISCOVERED, 20);

			if (self->client->ps.forcePowerDebounce[FP_GRIP] < level.time)
			{
				if (!grip_ent->client
					|| grip_ent->client->NPC_class != CLASS_VEHICLE
					|| grip_ent->m_pVehicle
					&& grip_ent->m_pVehicle->m_pVehicleInfo
					&& grip_ent->m_pVehicle->m_pVehicleInfo->type == VH_ANIMAL)
				{
					//we don't damage the empty vehicle
					grip_ent->painDebounceTime = 0;

					int grip_dmg = forceGripDamage[self->client->ps.forcePowerLevel[FP_GRIP]];

					if (grip_level != -1)
					{
						if (grip_level == 1)
						{
							grip_dmg = floor(static_cast<float>(grip_dmg) / 3.0f);
						}
						else //if ( gripLevel == 2 )
						{
							grip_dmg = floor(static_cast<float>(grip_dmg) / 1.5f);
						}
					}
					G_Damage(grip_ent, self, self, dir, grip_org, grip_dmg, DAMAGE_NO_ARMOR, MOD_CRUSH); //MOD_???
				}
				if (grip_ent->s.number)
				{
					if (self->client->ps.forcePowerLevel[FP_GRIP] > FORCE_LEVEL_2)
					{
						//do damage faster at level 3
						self->client->ps.forcePowerDebounce[FP_GRIP] = level.time + Q_irand(150, 750);
					}
					else
					{
						self->client->ps.forcePowerDebounce[FP_GRIP] = level.time + Q_irand(250, 1000);
					}
				}
				else
				{
					//player takes damage faster
					self->client->ps.forcePowerDebounce[FP_GRIP] = level.time + Q_irand(100, 600);
				}
				if (forceGripDamage[self->client->ps.forcePowerLevel[FP_GRIP]] > 0)
				{
					//no damage at level 1
					WP_ForcePowerDrain(self, FP_GRIP, 3);
				}
				if (self->client->NPC_class == CLASS_KYLE
					&& self->spawnflags & 1)
				{
					//"Boss" Kyle
					if (grip_ent->client)
					{
						if (!Q_irand(0, 2))
						{
							//toss him aside!
							vec3_t v_rt;
							AngleVectors(self->currentAngles, nullptr, v_rt, nullptr);
							//stop gripping
							TIMER_Set(self, "gripping", -level.time);
							WP_ForcePowerStop(self, FP_GRIP);
							//now toss him
							if (Q_irand(0, 1))
							{
								//throw him to my left
								NPC_SetAnim(self, SETANIM_BOTH, BOTH_TOSS1,
									SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
								VectorScale(v_rt, -1500.0f, grip_ent->client->ps.velocity);
								G_Knockdown(grip_ent, self, v_rt, 500, qfalse);
							}
							else
							{
								//throw him to my right
								NPC_SetAnim(self, SETANIM_BOTH, BOTH_TOSS2,
									SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
								VectorScale(v_rt, 1500.0f, grip_ent->client->ps.velocity);
								G_Knockdown(grip_ent, self, v_rt, 500, qfalse);
							}
							//don't do anything for a couple seconds
							self->client->ps.weaponTime = self->client->ps.torsoAnimTimer + 2000;
							self->painDebounceTime = level.time + self->client->ps.weaponTime;
							//stop moving
							VectorClear(self->client->ps.velocity);
							VectorClear(self->client->ps.moveDir);
							return;
						}
					}
				}
			}
			else
			{
				if (!grip_ent->enemy)
				{
					if (grip_ent->client
						&& grip_ent->client->playerTeam == TEAM_PLAYER
						&& self->s.number < MAX_CLIENTS
						&& self->client
						&& self->client->playerTeam == TEAM_PLAYER)
					{
						//this shouldn't make allies instantly turn on you, let the damage->pain routine determine how allies should react to this
					}
					else
					{
						G_SetEnemy(grip_ent, self);
					}
				}
			}

			if (grip_ent->client && grip_ent->health > 0)
			{
				int anim = BOTH_CHOKE3; //left-handed choke

				if (grip_ent->cervicalBolt != -1)
				{
					G_PlayEffect(G_EffectIndex("force/grip_neck"), grip_ent->playerModel, grip_ent->cervicalBolt,
						grip_ent->s.number, grip_ent->currentOrigin, 3000, qtrue);
				}

				if (grip_ent->client->ps.weapon == WP_NONE || grip_ent->client->ps.weapon == WP_MELEE)
				{
					if (!in_camera)
					{
						if (grip_ent->health > 70)
						{
							anim = BOTH_CHOKE4; //two-handed choke
						}
						else if (grip_ent->health > 50)
						{
							anim = BOTH_CHOKE3; //two-handed choke
						}
						else
						{
							anim = BOTH_CHOKE1; //two-handed choke
						}
					}
					else
					{
						anim = BOTH_CHOKE1; //two-handed choke
					}
				}
				if (self->client->ps.forcePowerLevel[FP_GRIP] < FORCE_LEVEL_2)
				{
					//still on ground, only set anim on torso
					if (!in_camera)
					{
						if (grip_ent->health > 50)
						{
							NPC_SetAnim(grip_ent, SETANIM_TORSO, BOTH_CHOKE3,
								SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
						}
						else
						{
							NPC_SetAnim(grip_ent, SETANIM_TORSO, BOTH_CHOKE1,
								SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
						}
					}
					else
					{
						NPC_SetAnim(grip_ent, SETANIM_TORSO, anim, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
					}
				}
				else
				{
					//in air, set on whole body
					if (!in_camera)
					{
						if (grip_ent->health > 70)
						{
							NPC_SetAnim(grip_ent, SETANIM_BOTH, BOTH_CHOKE4,
								SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
						}
						else if (grip_ent->health > 50)
						{
							NPC_SetAnim(grip_ent, SETANIM_BOTH, BOTH_CHOKE3,
								SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
						}
						else
						{
							NPC_SetAnim(grip_ent, SETANIM_BOTH, BOTH_CHOKE1,
								SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
						}
					}
					else
					{
						NPC_SetAnim(grip_ent, SETANIM_BOTH, anim, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
					}
				}
				grip_ent->painDebounceTime = level.time + 2000;
				if (grip_ent->health > 20 && grip_ent->health < 50)
				{
					if (grip_ent->client->NPC_class == CLASS_OBJECT)
					{
						//
					}
					else
					{
						G_SoundOnEnt(grip_ent, CHAN_BODY, "sound/weapons/force/gripdeath.mp3");
					}
				}
			}
		}
	}

	if (self->client->ps.forcePowersActive & 1 << FP_GRIP)
	{
		self->s.loopSound = G_SoundIndex("sound/weapons/force/griploop.wav");
	}
	break;
	case FP_LIGHTNING:
		if (self->client->ps.forcePowerLevel[FP_LIGHTNING] > FORCE_LEVEL_1)
		{
			//higher than level 1
			if (cmd->buttons & BUTTON_FORCE_LIGHTNING)
			{
				//holding it keeps it going
				self->client->ps.forcePowerDuration[FP_LIGHTNING] = level.time + 500;
				ForceLightningAnim(self);
			}
		}
		if (!WP_ForcePowerAvailable(self, force_power, 0))
		{
			WP_ForcePowerStop(self, force_power);
		}
		else
		{
			ForceShootLightning(self);
			if (self->client->ps.torsoAnim == BOTH_FORCE_2HANDEDLIGHTNING
				|| self->client->ps.torsoAnim == BOTH_FORCE_2HANDEDLIGHTNING_OLD
				|| self->client->ps.torsoAnim == BOTH_FORCE_2HANDEDLIGHTNING_NEW
				|| self->client->ps.torsoAnim == BOTH_FORCE_2HANDEDLIGHTNING_START
				|| self->client->ps.torsoAnim == BOTH_FORCE_2HANDEDLIGHTNING_HOLD
				|| self->client->ps.torsoAnim == BOTH_FORCE_2HANDEDLIGHTNING_RELEASE)
			{
				//jackin' 'em up, Palpatine-style
				//extra cost
				WP_ForcePowerDrain(self, force_power, 0);
			}
			WP_ForcePowerDrain(self, force_power, 0);

			if (self->client->ps.forcePowersActive & 1 << FP_LIGHTNING)
			{
				self->s.loopSound = G_SoundIndex("sound/weapons/force/lightningloop.mp3");
			}
		}
		break;
		//new Jedi Academy force powers
	case FP_RAGE:
		if (self->health < 1)
		{
			WP_ForcePowerStop(self, force_power);
			self->client->ps.powerups[PW_INVINCIBLE] = level.time + self->client->ps.torsoAnimTimer + 2000;
			break;
		}
		if (self->client->ps.forceRageDrainTime < level.time)
		{
			int add_time = 400;

			self->health -= 2;

			if (self->client->ps.forcePowerLevel[FP_RAGE] == FORCE_LEVEL_1)
			{
				add_time = 100;
			}
			else if (self->client->ps.forcePowerLevel[FP_RAGE] == FORCE_LEVEL_2)
			{
				add_time = 250;
			}
			else if (self->client->ps.forcePowerLevel[FP_RAGE] == FORCE_LEVEL_3)
			{
				add_time = 500;
			}
			self->client->ps.forceRageDrainTime = level.time + add_time;
		}

		if (self->health < 2)
		{
			self->client->ps.powerups[PW_INVINCIBLE] = level.time + self->client->ps.torsoAnimTimer + 2000;
			self->health = 1;
		}
		else
		{
			int soundduration = 0;
			self->client->ps.stats[STAT_HEALTH] = self->health;

			speed = forceSpeedValue[self->client->ps.forcePowerLevel[FP_RAGE] - 1];

			soundduration = ceil(FORCE_RAGE_DURATION * forceSpeedValue[self->client->ps.forcePowerLevel[FP_RAGE] - 1]);

			if (!self->s.number)
			{
				//player using force rage
				if (!(self->client->ps.forcePowersActive & 1 << FP_SPEED)
					|| self->client->ps.forcePowerLevel[FP_RAGE] > self->client->ps.forcePowerLevel[FP_SPEED] + 1)
				{
					//either not using speed or speed is at a lower level than rage
					gi.cvar_set("timescale", va("%4.2f", speed));
					if (g_timescale->value > speed)
					{
						new_speed = g_timescale->value - 0.05;
						if (new_speed < speed)
						{
							new_speed = speed;
						}
						gi.cvar_set("timescale", va("%4.2f", new_speed));
					}
				}
			}
			if (soundduration)
			{
				self->s.loopSound = G_SoundIndex("sound/weapons/force/rageloop.wav");
			}
			if (self->health < 2)
			{
				self->client->ps.powerups[PW_INVINCIBLE] = level.time + self->client->ps.torsoAnimTimer + 2000;
				self->health = 1;
			}
		}
		break;
	case FP_DRAIN:
		if (cmd->buttons & BUTTON_FORCE_DRAIN)
		{
			//holding it keeps it going
			self->client->ps.forcePowerDuration[FP_DRAIN] = level.time + 500;
		}
		if (!WP_ForcePowerAvailable(self, force_power, 0))
		{
			//no more force power, stop
			WP_ForcePowerStop(self, force_power);
		}
		else if (self->client->ps.forceDrainEntityNum >= 0 && self->client->ps.forceDrainEntityNum < ENTITYNUM_WORLD)
		{
			gentity_t* drain_ent;
			//holding someone
			if (!WP_ForcePowerAvailable(self, FP_DRAIN, 0)
				|| self->client->ps.forcePowerLevel[FP_DRAIN] > FORCE_LEVEL_1
				&& !self->s.number
				&& !(cmd->buttons & BUTTON_FORCE_DRAIN)
				&& self->client->ps.forcePowerDuration[FP_DRAIN] < level.time)
			{
				WP_ForcePowerStop(self, FP_DRAIN);
				return;
			}
			drain_ent = &g_entities[self->client->ps.forceDrainEntityNum];

			if (!drain_ent)
			{
				//invalid ent
				WP_ForcePowerStop(self, FP_DRAIN);
				return;
			}
			if (drain_ent->health <= 0 && drain_ent->takedamage)
				//FIXME: what about things that never had health or lose takedamage when they die?
			{
				//dead ent
				WP_ForcePowerStop(self, FP_DRAIN);
				return;
			}
			if (drain_ent->client && drain_ent->client->moveType == MT_FLYSWIM && VectorLengthSquared(
				NPC->client->ps.velocity) > 300 * 300)
			{
				//flying creature broke free
				WP_ForcePowerStop(self, FP_DRAIN);
				return;
			}
			if (drain_ent->client
				&& drain_ent->health > 0 //dead dudes don't fly
				&& (drain_ent->client->NPC_class == CLASS_BOBAFETT || drain_ent->client->NPC_class == CLASS_MANDALORIAN
					||
					drain_ent->client->NPC_class == CLASS_JANGO || drain_ent->client->NPC_class == CLASS_JANGODUAL ||
					drain_ent->client->NPC_class == CLASS_ROCKETTROOPER)
				&& self->client->ps.forcePowerDebounce[FP_DRAIN] < level.time
				&& !Q_irand(0, 10))
			{
				//boba fett - fly away!
				drain_ent->client->ps.forceJumpCharge = 0; //so we don't play the force flip anim
				drain_ent->client->ps.velocity[2] = 250;
				drain_ent->client->ps.forceJumpZStart = drain_ent->currentOrigin[2];
				//so we don't take damage if we land at same height
				drain_ent->client->ps.pm_flags |= PMF_JUMPING;
				G_AddEvent(drain_ent, EV_JUMP, 0);
				JET_FlyStart(drain_ent);
				WP_ForcePowerStop(self, FP_DRAIN);
				return;
			}
			if (drain_ent->NPC
				&& drain_ent->client
				&& drain_ent->client->ps.forcePowersKnown
				&& ((drain_ent->client->NPC_class == CLASS_REBORN || drain_ent->client->ps.weapon == WP_SABER) &&
					drain_ent
					->client->NPC_class != CLASS_GUARD && !jedi_jedi_master_low(drain_ent))
				&& !jedi_cultist_destroyer(drain_ent)
				&& level.time - (self->client->ps.forcePowerDebounce[FP_DRAIN] > self->client->ps.forcePowerLevel[
					FP_DRAIN] * 500) //at level 1, I always get at least 500ms of drain, at level 3 I get 1500ms
				&& !Q_irand(0, 100 - drain_ent->NPC->stats.evasion * 8 - g_spskill->integer * 15))
			{
				//a jedi who broke free FIXME: maybe have some minimum grip length- a reaction time?
				WP_ForceForceThrow(drain_ent);
				//FIXME: I need to go into some pushed back anim...
				WP_ForcePowerStop(self, FP_DRAIN);
				//can't drain again for 2 seconds
				self->client->ps.forcePowerDebounce[FP_DRAIN] = level.time + 4000;
				return;
			}
			if (self->client->ps.torsoAnim != BOTH_FORCE_DRAIN_GRAB_START
				|| !self->client->ps.torsoAnimTimer)
			{
				NPC_SetAnim(self, SETANIM_BOTH, BOTH_FORCE_DRAIN_GRAB_HOLD, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
			}
			if (self->handLBolt != -1)
			{
				G_PlayEffect(G_EffectIndex("force/drain_hand"), self->playerModel, self->handLBolt, self->s.number,
					self->currentOrigin, 200, qtrue);
			}
			if (self->handRBolt != -1)
			{
				G_PlayEffect(G_EffectIndex("force/drain_hand"), self->playerModel, self->handRBolt, self->s.number,
					self->currentOrigin, 200, qtrue);
			}

			//how far are they
			dist = Distance(self->client->renderInfo.eyePoint, drain_ent->currentOrigin);
			if (DistanceSquared(drain_ent->currentOrigin, self->currentOrigin) > FORCE_DRAIN_DIST_SQUARED)
			{
				//must be close, got away somehow!
				WP_ForcePowerStop(self, FP_DRAIN);
				return;
			}

			//keep my saber off!
			WP_DeactivateSaber(self, qtrue);
			if (drain_ent->client)
			{
				//now move them
				VectorCopy(self->client->ps.viewangles, angles);
				angles[0] = 0;
				AngleVectors(angles, dir, nullptr, nullptr);
				//stop them from thinking
				drain_ent->client->ps.pm_time = 2000;
				drain_ent->client->ps.pm_flags |= PMF_TIME_KNOCKBACK;
				if (drain_ent->NPC)
				{
					if (!(drain_ent->NPC->aiFlags & NPCAI_DIE_ON_IMPACT))
					{
						//not falling to their death
						drain_ent->NPC->nextBStateThink = level.time + 2000;
					}
					vectoangles(dir, angles);
					drain_ent->NPC->desiredYaw = AngleNormalize180(angles[YAW] + 180);
					drain_ent->NPC->desiredPitch = -angles[PITCH];
					SaveNPCGlobals();
					SetNPCGlobals(drain_ent);
					NPC_UpdateAngles(qtrue, qtrue);
					drain_ent->NPC->last_ucmd.angles[0] = ucmd.angles[0];
					drain_ent->NPC->last_ucmd.angles[1] = ucmd.angles[1];
					drain_ent->NPC->last_ucmd.angles[2] = ucmd.angles[2];
					RestoreNPCGlobals();
					//FIXME: why does he turn back to his original angles once he dies or is let go?
				}
				else if (!drain_ent->s.number)
				{
					drain_ent->enemy = self;
					NPC_SetLookTarget(drain_ent, self->s.number, level.time + 1000);
				}

				drain_ent->client->ps.eFlags |= EF_FORCE_DRAINED;
				//dammit!  Make sure that saber stays off!
				WP_DeactivateSaber(drain_ent, qtrue);

				drain_ent->client->ps.ManualBlockingFlags &= ~(1 << HOLDINGBLOCK);
				drain_ent->client->ps.ManualBlockingFlags &= ~(1 << HOLDINGBLOCKANDATTACK);
				drain_ent->client->ps.ManualBlockingFlags &= ~(1 << PERFECTBLOCKING);
				drain_ent->client->ps.ManualBlockingFlags &= ~(1 << MBF_NPCBLOCKING);
			}
			//Shouldn't this be discovered?
			AddSightEvent(self, drain_ent->currentOrigin, 128, AEL_DISCOVERED, 20);

			if (self->client->ps.forcePowerDebounce[FP_DRAIN] < level.time)
			{
				int drain_level = WP_AbsorbConversion(drain_ent, drain_ent->client->ps.forcePowerLevel[FP_ABSORB],
					FP_DRAIN,
					self->client->ps.forcePowerLevel[FP_DRAIN],
					forcePowerNeeded[self->client->ps.forcePowerLevel[FP_DRAIN]]);
				if (drain_level && drain_level == -1
					|| Q_irand(drain_level, 3) < 3)
				{
					//the drain is being absorbed
					ForceDrainEnt(self, drain_ent);
				}
				WP_ForcePowerDrain(self, FP_DRAIN, 3);
			}
			else
			{
				if (!Q_irand(0, 4))
				{
					WP_ForcePowerDrain(self, FP_DRAIN, 1);
				}
				if (!drain_ent->enemy)
				{
					G_SetEnemy(drain_ent, self);
				}
			}
			if (drain_ent->health > 0)
			{
				//still alive
				NPC_SetAnim(drain_ent, SETANIM_BOTH, BOTH_FORCE_DRAIN_GRABBED,
					SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
			}
		}
		else if (self->client->ps.forcePowerLevel[force_power] > FORCE_LEVEL_1)
		{
			//regular distance-drain
			if (cmd->buttons & BUTTON_FORCE_DRAIN)
			{
				//holding it keeps it going
				self->client->ps.forcePowerDuration[FP_DRAIN] = level.time + 500;
				if (self->client->ps.torsoAnim == BOTH_FORCE_DRAIN_START)
				{
					if (!self->client->ps.torsoAnimTimer)
					{
						NPC_SetAnim(self, SETANIM_TORSO, BOTH_FORCE_DRAIN_HOLD,
							SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
					}
					else
					{
						NPC_SetAnim(self, SETANIM_TORSO, BOTH_FORCE_DRAIN_START,
							SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
					}
				}
				else
				{
					NPC_SetAnim(self, SETANIM_TORSO, BOTH_FORCE_DRAIN_HOLD, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
				}
			}
			if (!WP_ForcePowerAvailable(self, force_power, 0))
			{
				WP_ForcePowerStop(self, force_power);
			}
			else
			{
				ForceShootDrain(self);
			}
		}
		if (self->client->ps.forcePowersActive & 1 << FP_DRAIN)
		{
			self->s.loopSound = G_SoundIndex("sound/weapons/force/drain.mp3");
		}
		break;
	case FP_PROTECT:
		if (self->client->ps.forcePowersActive & 1 << FP_PROTECT)
		{
			self->s.loopSound = G_SoundIndex("sound/weapons/force/protectloop.wav");
		}
		break;
	case FP_ABSORB:
		if (self->client->ps.forcePowersActive & 1 << FP_ABSORB)
		{
			self->s.loopSound = G_SoundIndex("sound/weapons/force/absorbloop.wav");
		}
		break;
	case FP_SEE:
		if (self->client->ps.forcePowersActive & 1 << FP_SEE)
		{
			self->s.loopSound = G_SoundIndex("sound/weapons/force/seeloop.wav");
		}
		break;
	case FP_DESTRUCTION:
		break;
	case FP_STASIS:
		break;
	case FP_GRASP:
	{
		if (!WP_ForcePowerAvailable(self, FP_GRASP, 0)
			|| self->client->ps.forcePowerLevel[FP_GRASP] > FORCE_LEVEL_1 && !self->s.number && !(cmd->buttons &
				BUTTON_FORCEGRASP))
		{
			WP_ForcePowerStop(self, FP_GRASP);
			return;
		}
		if (self->client->ps.forceGripEntityNum >= 0 && self->client->ps.forceGripEntityNum < ENTITYNUM_WORLD)
		{
			grip_ent = &g_entities[self->client->ps.forceGripEntityNum];

			if (!grip_ent || !grip_ent->inuse)
			{
				//invalid or freed ent
				WP_ForcePowerStop(self, FP_GRASP);
				return;
			}
#ifndef JK2_RAGDOLL_GRIPNOHEALTH
			if (grip_ent->health <= 0 && grip_ent->takedamage)
			{//either invalid ent, or dead ent
				WP_ForcePowerStop(self, FP_GRASP);
				return;
			}
			else
#endif
				if (self->client->ps.forcePowerLevel[FP_GRASP] == FORCE_LEVEL_1
					&& grip_ent->client
					&& grip_ent->client->ps.groundEntityNum == ENTITYNUM_NONE
					&& grip_ent->client->moveType != MT_FLYSWIM)
				{
					WP_ForcePowerStop(self, FP_GRASP);
					return;
				}
			if (grip_ent->client && grip_ent->client->moveType == MT_FLYSWIM && VectorLengthSquared(
				grip_ent->client->ps.velocity) > 300 * 300)
			{
				//flying creature broke free
				WP_ForcePowerStop(self, FP_GRASP);
				return;
			}
			if (grip_ent->client
				&& grip_ent->health > 0 //dead dudes don't fly
				&& (grip_ent->client->NPC_class == CLASS_BOBAFETT || grip_ent->client->NPC_class ==
					CLASS_MANDALORIAN
					|| grip_ent->client->NPC_class == CLASS_JANGO || grip_ent->client->NPC_class == CLASS_JANGODUAL
					||
					grip_ent->client->NPC_class == CLASS_ROCKETTROOPER)
				&& self->client->ps.forcePowerDebounce[FP_GRASP] < level.time
				&& !Q_irand(0, 3))
			{
				//boba fett - fly away!
				grip_ent->client->ps.forceJumpCharge = 0; //so we don't play the force flip anim
				grip_ent->client->ps.velocity[2] = 250;
				grip_ent->client->ps.forceJumpZStart = grip_ent->currentOrigin[2];
				//so we don't take damage if we land at same height
				grip_ent->client->ps.pm_flags |= PMF_JUMPING;
				G_AddEvent(grip_ent, EV_JUMP, 0);
				JET_FlyStart(grip_ent);
				WP_ForcePowerStop(self, FP_GRASP);
				return;
			}
			if (grip_ent->NPC
				&& grip_ent->client
				&& grip_ent->client->ps.forcePowersKnown
				&& (grip_ent->client->NPC_class == CLASS_REBORN || grip_ent->client->ps.weapon == WP_SABER &&
					grip_ent
					->client->ps.forcePowerLevel[FP_PUSH] > FORCE_LEVEL_0 && grip_ent->client->NPC_class !=
					CLASS_GUARD && !jedi_jedi_master_low(grip_ent))
				&& !jedi_cultist_destroyer(grip_ent)
				&& !Q_irand(0, 100 - grip_ent->NPC->stats.evasion * 8 - g_spskill->integer * 20))
			{
				//a jedi who broke free FIXME: maybe have some minimum grip length- a reaction time?
				WP_ForceForceThrow(grip_ent);
				WP_ForcePowerStop(self, FP_GRASP);
				return;
			}
			if (PM_SaberInAttack(self->client->ps.saber_move)
				|| PM_SaberInStart(self->client->ps.saber_move))
			{
				//started an attack
				WP_ForcePowerStop(self, FP_GRASP);
				return;
			}
			int grip_level = self->client->ps.forcePowerLevel[FP_GRASP];
			if (grip_ent->client)
			{
				grip_level = WP_AbsorbConversion(grip_ent, grip_ent->client->ps.forcePowerLevel[FP_ABSORB],
					FP_GRASP,
					self->client->ps.forcePowerLevel[FP_GRASP],
					forcePowerNeeded[grip_level]);
			}
			if (!grip_level)
			{
				WP_ForcePowerStop(self, force_power);
				return;
			}

			if (self->client->ps.forcePowerLevel[FP_GRASP] > FORCE_LEVEL_1)
			{
				//holding it
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_FORCEGRIP_HOLD, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
				if (self->client->ps.torsoAnimTimer < 100)
				{
					//we were already playing this anim, we didn't want to restart it, but we want to hold it for at least 100ms.
					self->client->ps.torsoAnimTimer = 100;
				}
			}
			//get their org
			VectorCopy(self->client->ps.viewangles, angles);
			angles[0] -= 10;
			AngleVectors(angles, dir, nullptr, nullptr);
			if (grip_ent->client)
			{
				//move
				VectorCopy(grip_ent->client->renderInfo.headPoint, grip_ent_org);
			}
			else
			{
				VectorCopy(grip_ent->currentOrigin, grip_ent_org);
			}

			//how far are they
			dist = Distance(self->client->renderInfo.handLPoint, grip_ent_org);
			if (self->client->ps.forcePowerLevel[FP_GRASP] == FORCE_LEVEL_2 &&
				(!InFront(grip_ent_org, self->client->renderInfo.handLPoint, self->client->ps.viewangles, 0.3f) ||
					DistanceSquared(grip_ent_org, self->client->renderInfo.handLPoint) > FORCE_GRIP_DIST_SQUARED))
			{
				//must face them
				WP_ForcePowerStop(self, FP_GRASP);
				return;
			}

			//check for lift or carry
			if (self->client->ps.forcePowerLevel[FP_GRASP] > FORCE_LEVEL_2
				&& (!grip_ent->client || !grip_ent->message && !(grip_ent->flags & FL_NO_KNOCKBACK)))
			{
				//carry
				//cap dist
				if (dist > FORCE_GRIP_3_MAX_DIST)
				{
					dist = FORCE_GRIP_3_MAX_DIST;
				}
				else if (dist < FORCE_GRIP_3_MIN_DIST)
				{
					dist = FORCE_GRIP_3_MIN_DIST;
				}
				VectorMA(self->client->renderInfo.handLPoint, dist, dir, grip_org);
			}
			else if (self->client->ps.forcePowerLevel[FP_GRASP] > FORCE_LEVEL_1)
			{
				//just lift
				VectorCopy(self->client->ps.forceGripOrg, grip_org);
			}
			else
			{
				VectorCopy(grip_ent->currentOrigin, grip_org);
			}
			if (self->client->ps.forcePowerLevel[FP_GRASP] > FORCE_LEVEL_1)
			{
				//if holding him, make sure there's a clear LOS between my hand and him
				trace_t grip_trace;
				gi.trace(&grip_trace, self->client->renderInfo.handLPoint, nullptr, nullptr, grip_ent_org,
					ENTITYNUM_NONE, MASK_FORCE_PUSH, static_cast<EG2_Collision>(0), 0);
				if (grip_trace.startsolid
					|| grip_trace.allsolid
					|| grip_trace.fraction < 1.0f)
				{
					//no clear trace, drop them
					WP_ForcePowerStop(self, FP_GRASP);
					return;
				}
			}
			//now move them
			if (grip_ent->client)
			{
				if (self->client->ps.forcePowerLevel[FP_GRASP] > FORCE_LEVEL_1)
				{
					//level 1 just holds them
					VectorSubtract(grip_org, grip_ent_org, grip_ent->client->ps.velocity);

					if (self->client->ps.forcePowerLevel[FP_GRASP] > FORCE_LEVEL_2
						&& (!grip_ent->client || !grip_ent->message && !(grip_ent->flags & FL_NO_KNOCKBACK)))
					{
						if (grip_ent->s.number < MAX_CLIENTS || G_ControlledByPlayer(grip_ent))
							// npc,s cant throw the player around with grip any more
						{
							VectorSubtract(grip_org, grip_ent_org, grip_ent->client->ps.velocity);
						}
						else
						{
							//level 2 just lifts them
							float grip_dist = VectorNormalize(grip_ent->client->ps.velocity) / 3.0f;

							if (grip_dist < 20.0f)
							{
								if (grip_dist < 2.0f)
								{
									VectorClear(grip_ent->client->ps.velocity);
								}
								else
								{
									VectorScale(grip_ent->client->ps.velocity, grip_dist * grip_dist,
										grip_ent->client->ps.velocity);
								}
							}
							else
							{
								VectorScale(grip_ent->client->ps.velocity, grip_dist * grip_dist,
									grip_ent->client->ps.velocity);
							}
						}
					}
				}
				//stop them from thinking
				grip_ent->client->ps.pm_time = 2000;
				grip_ent->client->ps.pm_flags |= PMF_TIME_KNOCKBACK;
				if (grip_ent->NPC)
				{
					if (!(grip_ent->NPC->aiFlags & NPCAI_DIE_ON_IMPACT))
					{
						//not falling to their death
						grip_ent->NPC->nextBStateThink = level.time + 2000;
					}
					if (self->client->ps.forcePowerLevel[FP_GRASP] > FORCE_LEVEL_1)
					{
						//level 1 just holds them
						vectoangles(dir, angles);
						grip_ent->NPC->desiredYaw = AngleNormalize180(angles[YAW] + 180);
						grip_ent->NPC->desiredPitch = -angles[PITCH];
						SaveNPCGlobals();
						SetNPCGlobals(grip_ent);
						NPC_UpdateAngles(qtrue, qtrue);
						grip_ent->NPC->last_ucmd.angles[0] = ucmd.angles[0];
						grip_ent->NPC->last_ucmd.angles[1] = ucmd.angles[1];
						grip_ent->NPC->last_ucmd.angles[2] = ucmd.angles[2];
						RestoreNPCGlobals();
					}
				}
				else if (!grip_ent->s.number)
				{
					grip_ent->enemy = self;
					NPC_SetLookTarget(grip_ent, self->s.number, level.time + 1000);
				}

				grip_ent->client->ps.eFlags |= EF_FORCE_GRASPED;
				//dammit!  Make sure that saber stays off!
				WP_DeactivateSaber(grip_ent);
			}
			else
			{
				//move
				if (self->client->ps.forcePowerLevel[FP_GRASP] > FORCE_LEVEL_1)
				{
					//level 1 just holds them
					VectorCopy(grip_ent->currentOrigin, grip_ent->s.pos.trBase);
					VectorSubtract(grip_org, grip_ent_org, grip_ent->s.pos.trDelta);
					//if (self->client->ps.forcePowerLevel[FP_GRASP] > FORCE_LEVEL_2
					//	&& (!grip_ent->client || !grip_ent->message && !(grip_ent->flags & FL_NO_KNOCKBACK)))
					//{
					//	//level 2 just lifts them
					//	VectorScale(grip_ent->s.pos.trDelta, 10, grip_ent->s.pos.trDelta);
					//}
					grip_ent->s.pos.trType = TR_LINEAR;
					grip_ent->s.pos.trTime = level.time;
				}

				grip_ent->s.eFlags |= EF_FORCE_GRASPED;
			}

			AddSightEvent(self, grip_org, 128, AEL_DISCOVERED, 20);

			if (self->client->ps.forcePowerDebounce[FP_GRASP] < level.time)
			{
				if (!grip_ent->client
					|| grip_ent->client->NPC_class != CLASS_VEHICLE
					|| grip_ent->m_pVehicle
					&& grip_ent->m_pVehicle->m_pVehicleInfo
					&& grip_ent->m_pVehicle->m_pVehicleInfo->type == VH_ANIMAL)
				{
					//we don't damage the empty vehicle
					grip_ent->painDebounceTime = 0;
					int grip_dmg = forceGraspDamage[self->client->ps.forcePowerLevel[FP_GRASP]];
					if (grip_level != -1)
					{
						if (grip_level == 1)
						{
							grip_dmg = floor(static_cast<float>(grip_dmg) / 3.0f);
						}
						else //if ( gripLevel == 2 )
						{
							grip_dmg = floor(static_cast<float>(grip_dmg) / 1.5f);
						}
					}
					G_Damage(grip_ent, self, self, dir, grip_org, grip_dmg, DAMAGE_NO_ARMOR, MOD_CRUSH); //MOD_???
				}
				if (grip_ent->s.number)
				{
					if (self->client->ps.forcePowerLevel[FP_GRASP] > FORCE_LEVEL_2)
					{
						//do damage faster at level 3
						self->client->ps.forcePowerDebounce[FP_GRASP] = level.time + Q_irand(150, 750);
					}
					else
					{
						self->client->ps.forcePowerDebounce[FP_GRASP] = level.time + Q_irand(250, 1000);
					}
				}
				else
				{
					//player takes damage faster
					self->client->ps.forcePowerDebounce[FP_GRASP] = level.time + Q_irand(100, 600);
				}
				if (forceGripDamage[self->client->ps.forcePowerLevel[FP_GRASP]] > 0)
				{
					//no damage at level 1
					WP_ForcePowerDrain(self, FP_GRASP, 3);
				}
				if (self->client->NPC_class == CLASS_KYLE
					&& self->spawnflags & 1)
				{
					//"Boss" Kyle
					if (grip_ent->client)
					{
						if (!Q_irand(0, 2))
						{
							//toss him aside!
							vec3_t vRt;
							AngleVectors(self->currentAngles, nullptr, vRt, nullptr);
							//stop gripping
							TIMER_Set(self, "grasping", -level.time);
							WP_ForcePowerStop(self, FP_GRASP);
							//now toss him
							if (Q_irand(0, 1))
							{
								//throw him to my left
								NPC_SetAnim(self, SETANIM_BOTH, BOTH_TOSS1,
									SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
								VectorScale(vRt, -1500.0f, grip_ent->client->ps.velocity);
								G_Knockdown(grip_ent, self, vRt, 500, qfalse);
							}
							else
							{
								//throw him to my right
								NPC_SetAnim(self, SETANIM_BOTH, BOTH_TOSS2,
									SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
								VectorScale(vRt, 1500.0f, grip_ent->client->ps.velocity);
								G_Knockdown(grip_ent, self, vRt, 500, qfalse);
							}
							//don't do anything for a couple seconds
							self->client->ps.weaponTime = self->client->ps.torsoAnimTimer + 2000;
							self->painDebounceTime = level.time + self->client->ps.weaponTime;
							//stop moving
							VectorClear(self->client->ps.velocity);
							VectorClear(self->client->ps.moveDir);
							return;
						}
					}
				}
			}
			else
			{
				if (!grip_ent->enemy)
				{
					if (grip_ent->client
						&& grip_ent->client->playerTeam == TEAM_PLAYER
						&& self->s.number < MAX_CLIENTS
						&& self->client
						&& self->client->playerTeam == TEAM_PLAYER)
					{
						//this shouldn't make allies instantly turn on you, let the damage->pain routine determine how allies should react to this
					}
					else
					{
						G_SetEnemy(grip_ent, self);
					}
				}
			}
			if (grip_ent->client && grip_ent->health > 0)
			{
				int anim = BOTH_SWIM_IDLE1;

				if (grip_ent->client->ps.weapon == WP_NONE || grip_ent->client->ps.weapon == WP_MELEE)
				{
					anim = BOTH_PULLED_INAIR_F;
				}

				if (self->client->ps.forcePowerLevel[FP_GRASP] < FORCE_LEVEL_2)
				{
					//still on ground, only set anim on torso
					NPC_SetAnim(grip_ent, SETANIM_TORSO, anim, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
				}
				else
				{
					//in air, set on whole body
					NPC_SetAnim(grip_ent, SETANIM_BOTH, anim, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
				}
				grip_ent->painDebounceTime = level.time + 2000;
			}
		}
	}
	break;
	case FP_REPULSE:
	{
		if (!self->s.number && !(cmd->buttons & BUTTON_REPULSE))
		{
			WP_ForcePowerStop(self, FP_REPULSE);
			return;
		}
		if (self->client->ps.repulseChargeStart && WP_ForcePowerAvailable(
			self, FP_REPULSE, forcePowerNeeded[FP_REPULSE] + 30))
		{
			static qboolean registered = qfalse;

			if (self->client->ps.groundEntityNum == ENTITYNUM_NONE)
			{
				//still on ground, only set anim on torso
				NPC_SetAnim(self, SETANIM_TORSO, BOTH_FORCE_PROTECT_FAST,
					SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
			}
			else
			{
				//in air, set on whole body
				NPC_SetAnim(self, SETANIM_BOTH, BOTH_FORCE_PROTECT_FAST, SETANIM_FLAG_OVERRIDE | SETANIM_FLAG_HOLD);
			}

			if (self->client->ps.torsoAnimTimer < 100)
			{
				//we were already playing this anim, we didn't want to restart it, but we want to hold it for at least 100ms.
				self->client->ps.torsoAnimTimer = 100;
			}
			if (self->client->ps.legsAnimTimer < 100)
			{
				//we were already playing this anim, we didn't want to restart it, but we want to hold it for at least 100ms.
				self->client->ps.legsAnimTimer = 100;
			}
			if (!registered)
			{
				repulseLoopSound = G_SoundIndex("sound/weapons/force/repulseloop.wav");
				registered = qtrue;
			}
			if (!Q_irand(0, 4))
			{
				WP_ForcePowerDrain(self, FP_REPULSE, 1);
			}

			self->s.loopSound = repulseLoopSound;
			VectorClear(self->client->ps.velocity);
			cmd->forwardmove = 0;
			cmd->rightmove = 0;
			cmd->upmove = 0;
			VectorClear(self->client->ps.moveDir);
		}
		else
		{
			WP_ForcePowerStop(self, FP_REPULSE);
		}
	}
	break;
	case FP_LIGHTNING_STRIKE:
		if (self->client->ps.forcePowerLevel[FP_LIGHTNING_STRIKE] > FORCE_LEVEL_1)
		{
			//higher than level 1
			if (cmd->buttons & BUTTON_LIGHTNING_STRIKE)
			{
				//holding it keeps it going
				self->client->ps.forcePowerDuration[FP_LIGHTNING_STRIKE] = level.time + 500;
			}
		}
		if (!WP_ForcePowerAvailable(self, force_power, 0))
		{
			WP_ForcePowerStop(self, force_power);
		}
		else
		{
			WP_ForcePowerDrain(self, force_power, 0);
		}
		break;
	case FP_DEADLYSIGHT:
		if (self->client->ps.deadlySightLastChecked < level.time)
		{
			vec3_t forward, mins{}, maxs{};
			int e, num_listed_entities;
			gentity_t* entity_list[MAX_GENTITIES];
			gentity_t* check = nullptr;
			trace_t tr;

			int add_time = 200;
			int radius = 1024;

			if (self->client->ps.forcePowerLevel[FP_DEADLYSIGHT] == FORCE_LEVEL_1)
			{
				add_time = 150;
				radius = 1024;
			}
			else if (self->client->ps.forcePowerLevel[FP_DEADLYSIGHT] == FORCE_LEVEL_2)
			{
				add_time = 50;
				radius = 1536;
			}
			else if (self->client->ps.forcePowerLevel[FP_DEADLYSIGHT] == FORCE_LEVEL_3)
			{
				add_time = 10;
				radius = 2048;
			}
			self->client->ps.deadlySightLastChecked = level.time + add_time;

			AngleVectors(self->client->ps.viewangles, forward, nullptr, nullptr);

			for (e = 0; e < 3; e++)
			{
				mins[e] = self->currentOrigin[e] - radius;
				maxs[e] = self->currentOrigin[e] + radius;
			}
			num_listed_entities = gi.EntitiesInBox(mins, maxs, entity_list, MAX_GENTITIES);

			for (e = 0; e < num_listed_entities; e++)
			{
				float min_dot = 0.5f;
				float dist1;
				check = entity_list[e];
				if (check == self)
				{
					//me
					continue;
				}
				if (!check->inuse)
				{
					//freed
					continue;
				}
				if (!check->client)
				{
					//not a client - FIXME: what about turrets?
					continue;
				}

				if (check->health <= 0)
				{
					//dead
					continue;
				}

				if (!gi.inPVS(check->currentOrigin, self->currentOrigin))
				{
					//can't potentially see them
					continue;
				}

				VectorSubtract(check->currentOrigin, self->currentOrigin, dir);
				dist1 = VectorNormalize(dir);

				if (DotProduct(dir, forward) < min_dot)
				{
					//not in front
					continue;
				}

				//really should have a clear LOS to this thing...
				gi.trace(&tr, self->currentOrigin, vec3_origin, vec3_origin, check->currentOrigin, self->s.number,
					MASK_SHOT, static_cast<EG2_Collision>(0), 0);
				if (tr.fraction < 1.0f && tr.entityNum != check->s.number)
				{
					//must have clear shot
					continue;
				}

				if (self->client->ps.forcePowerLevel[FP_DEADLYSIGHT] == FORCE_LEVEL_1)
				{
					G_Damage(check, self, self, nullptr, check->client->renderInfo.headPoint, 2, DAMAGE_EXTRA_KNOCKBACK,
						MOD_BLASTER);
				}
				else if (self->client->ps.forcePowerLevel[FP_DEADLYSIGHT] == FORCE_LEVEL_2)
				{
					G_Damage(check, self, self, nullptr, check->client->renderInfo.headPoint, 4, DAMAGE_EXTRA_KNOCKBACK,
						MOD_BLASTER);
				}
				else if (self->client->ps.forcePowerLevel[FP_DEADLYSIGHT] == FORCE_LEVEL_3)
				{
					G_Damage(check, self, self, nullptr, check->client->renderInfo.headPoint, 6, DAMAGE_NO_KNOCKBACK,
						MOD_SNIPER);
				}

				if (check->ghoul2.size() && check->headBolt != -1)
				{
					G_PlayEffect(G_EffectIndex("volumetric/black_smoke"), check->playerModel, check->headBolt,
						check->s.number, check->currentOrigin, add_time, qtrue);
				}
			}
		}
		break;
	case FP_BLAST:
		break;
	case FP_PROJECTION:
		if (self->client->ps.forcePowersActive & 1 << FP_PROJECTION || cmd->buttons & BUTTON_PROJECTION)
		{
			self->s.loopSound = G_SoundIndex("sound/weapons/force/protectloop.wav");
		}
		break;
	default:
		break;
	}
}

void WP_CheckForcedPowers(gentity_t* self, usercmd_t* ucmd)
{
	for (int force_power = FP_FIRST; force_power < NUM_FORCE_POWERS; force_power++)
	{
		if (self->client->ps.forcePowersForced & 1 << force_power)
		{
			switch (force_power)
			{
			case FP_HEAL:
				ForceHeal(self);
				//do only once
				self->client->ps.forcePowersForced &= ~(1 << force_power);
				break;
			case FP_LEVITATION:
				//nothing
				break;
			case FP_SPEED:
				ForceSpeed(self);
				//do only once
				self->client->ps.forcePowersForced &= ~(1 << force_power);
				break;
			case FP_PUSH:
				if (g_SerenityJediEngineMode->integer)
				{
					if (self->client->NPC_class == CLASS_GALEN
						&& (self->s.weapon == WP_MELEE || self->s.weapon == WP_NONE || self->s.weapon == WP_SABER && !
							self->client->ps.SaberActive())
						&& self->client->ps.groundEntityNum == ENTITYNUM_NONE)
					{
						ForceRepulse(self, qfalse);
					}
					else
					{
						ForceThrow_MD(self, qfalse);
					}
				}
				else
				{
					ForceThrow_JKA(self, qfalse);
				}
				//do only once
				self->client->ps.forcePowersForced &= ~(1 << force_power);
				break;
			case FP_PULL:
				if (g_SerenityJediEngineMode->integer)
				{
					if (self->client->NPC_class == CLASS_GALEN
						&& (self->s.weapon == WP_MELEE || self->s.weapon == WP_NONE || self->s.weapon == WP_SABER && !
							self->client->ps.SaberActive())
						&& self->client->ps.groundEntityNum == ENTITYNUM_NONE)
					{
						ForceRepulse(self, qtrue);
					}
					else
					{
						ForceThrow_MD(self, qtrue);
					}
				}
				else
				{
					ForceThrow_JKA(self, qtrue);
				}
				//do only once
				self->client->ps.forcePowersForced &= ~(1 << force_power);
				break;
			case FP_TELEPATHY:
				//FIXME: target at enemy?
				ForceTelepathy(self);
				//do only once
				self->client->ps.forcePowersForced &= ~(1 << force_power);
				break;
			case FP_GRIP:
				ucmd->buttons &= ~(BUTTON_ATTACK | BUTTON_ALT_ATTACK | BUTTON_FORCE_FOCUS | BUTTON_FORCE_DRAIN |
					BUTTON_FORCE_LIGHTNING | BUTTON_REPULSE | BUTTON_FORCEGRASP | BUTTON_LIGHTNING_STRIKE);
				ucmd->buttons |= BUTTON_FORCEGRIP;
				//holds until cleared
				break;
			case FP_LIGHTNING:
				ucmd->buttons &= ~(BUTTON_ATTACK | BUTTON_ALT_ATTACK | BUTTON_FORCE_FOCUS | BUTTON_FORCEGRIP |
					BUTTON_FORCE_DRAIN | BUTTON_REPULSE | BUTTON_FORCEGRASP | BUTTON_LIGHTNING_STRIKE);
				ucmd->buttons |= BUTTON_FORCE_LIGHTNING;
				//holds until cleared
				break;
			case FP_SABERTHROW:
				ucmd->buttons &= ~(BUTTON_ATTACK | BUTTON_FORCE_FOCUS | BUTTON_FORCEGRIP | BUTTON_FORCE_DRAIN |
					BUTTON_FORCE_LIGHTNING | BUTTON_REPULSE | BUTTON_FORCEGRASP | BUTTON_LIGHTNING_STRIKE);
				ucmd->buttons |= BUTTON_ALT_ATTACK;
				//holds until cleared?
				break;
			case FP_SABER_DEFENSE:
				//nothing
				break;
			case FP_SABER_OFFENSE:
				//nothing
				break;
			case FP_RAGE:
				ForceRage(self);
				//do only once
				self->client->ps.forcePowersForced &= ~(1 << force_power);
				break;
			case FP_PROTECT:
				ForceProtect(self);
				//do only once
				self->client->ps.forcePowersForced &= ~(1 << force_power);
				break;
			case FP_ABSORB:
				ForceAbsorb(self);
				//do only once
				self->client->ps.forcePowersForced &= ~(1 << force_power);
				break;
			case FP_DRAIN:
				ucmd->buttons &= ~(BUTTON_ATTACK | BUTTON_ALT_ATTACK | BUTTON_FORCE_FOCUS | BUTTON_FORCEGRIP |
					BUTTON_FORCE_LIGHTNING | BUTTON_FORCEGRASP | BUTTON_REPULSE);
				ucmd->buttons |= BUTTON_FORCE_DRAIN;
				//holds until cleared
				break;
			case FP_SEE:
				//nothing
				break;
			case FP_DESTRUCTION:
				ForceDestruction(self);
				//do only once
				self->client->ps.forcePowersForced &= ~(1 << force_power);
				break;
			case FP_STASIS:
				ForceStasis(self);
				//do only once
				self->client->ps.forcePowersForced &= ~(1 << force_power);
				break;
			case FP_GRASP:
				ucmd->buttons &= ~(BUTTON_ATTACK | BUTTON_ALT_ATTACK | BUTTON_FORCE_FOCUS | BUTTON_FORCE_DRAIN |
					BUTTON_FORCE_LIGHTNING | BUTTON_FORCEGRIP | BUTTON_REPULSE);
				ucmd->buttons |= BUTTON_FORCEGRASP;
				//holds until cleared
				break;
			case FP_REPULSE:
				ucmd->buttons &= ~(BUTTON_ATTACK | BUTTON_ALT_ATTACK | BUTTON_FORCE_FOCUS | BUTTON_FORCEGRIP |
					BUTTON_FORCE_LIGHTNING | BUTTON_FORCEGRASP | BUTTON_FORCE_DRAIN);
				ucmd->buttons |= BUTTON_REPULSE;
				break;
			case FP_LIGHTNING_STRIKE:
				ucmd->buttons &= ~(BUTTON_ATTACK | BUTTON_ALT_ATTACK | BUTTON_FORCE_FOCUS | BUTTON_FORCEGRIP |
					BUTTON_FORCE_DRAIN | BUTTON_FORCEGRASP | BUTTON_FORCE_DRAIN | BUTTON_FORCE_LIGHTNING);
				ucmd->buttons |= BUTTON_LIGHTNING_STRIKE;
				//holds until cleared
				break;
			case FP_DEADLYSIGHT:
				ForceDeadlySight(self);
				self->client->ps.forcePowersForced &= ~(1 << force_power);
				break;
			case FP_PROJECTION:
				//ucmd->buttons &= ~(BUTTON_ATTACK | BUTTON_ALT_ATTACK | BUTTON_FORCE_FOCUS | BUTTON_FORCEGRIP | BUTTON_FORCE_DRAIN | BUTTON_FORCEGRASP | BUTTON_FORCE_DRAIN | BUTTON_FORCE_LIGHTNING | BUTTON_LIGHTNING_STRIKE);
				//ucmd->buttons |= BUTTON_PROJECTION;
				ForceProjection(self);
				//do only once
				self->client->ps.forcePowersForced &= ~(1 << force_power);
				break;
			case FP_BLAST:
				//FIXME: target at enemy?
				ForceBlast(self);
				//do only once
				self->client->ps.forcePowersForced &= ~(1 << force_power);
				break;
			default:;
			}
		}
	}
}

void BG_ReduceBlasterMishapLevel(playerState_t* ps);

void WP_ForcePowersUpdate(gentity_t* self, usercmd_t* ucmd)
{
	qboolean using_force = qfalse;
	int i;
	//see if any force powers are running
	if (!self)
	{
		return;
	}
	if (!self->client)
	{
		return;
	}

	if (self->health <= 0)
	{
		//if dead, deactivate any active force powers
		for (i = 0; i < NUM_FORCE_POWERS; i++)
		{
			if (self->client->ps.forcePowerDuration[i] || self->client->ps.forcePowersActive & 1 << i)
			{
				WP_ForcePowerStop(self, static_cast<forcePowers_t>(i));
				self->client->ps.forcePowerDuration[i] = 0;
			}
		}
		return;
	}

	WP_CheckForcedPowers(self, ucmd);

	if (g_SerenityJediEngineMode->integer)
	{
		//check for fatigued state.
		if (self->client->ps.forcePower <= BLOCKPOINTS_FATIGUE)
		{
			//Pop the Fatigued flag
			self->client->ps.userInt3 |= 1 << FLAG_FATIGUED;
		}
	}

	if (!self->s.number)
	{
		//player uses different kind of force-jump
	}
	else
	{
		if (self->client->ps.forceJumpCharge)
		{
			//let go of charge button, have charge
			//if leave the ground by some other means, cancel the force jump so we don't suddenly jump when we land.
			if (self->client->ps.groundEntityNum == ENTITYNUM_NONE
				&& !PM_SwimmingAnim(self->client->ps.legsAnim))
			{
				//
			}
			else
			{
				//still on ground, so jump
				ForceJump(self, ucmd);
				return;
			}
		}
	}

	if (ucmd->buttons & BUTTON_REPULSE)
	{
		ForceJediRepulse(self);
		self->client->ps.powerups[PW_INVINCIBLE] = level.time + self->client->ps.torsoAnimTimer + 2000;
	}

	if (ucmd->buttons & BUTTON_FORCEGRASP)
	{
		ForceGrasp(self);
	}

	if (!self->s.number
		&& (self->client->NPC_class == CLASS_BOBAFETT ||
			self->client->NPC_class == CLASS_MANDALORIAN ||
			self->client->NPC_class == CLASS_JANGO ||
			self->client->NPC_class == CLASS_JANGODUAL))
	{
		//Boba Fett
		if (self->client->ps.weapon == WP_MELEE && ucmd->buttons & BUTTON_WALKING && ucmd->buttons & BUTTON_BLOCK)
		{
			//start wrist laser
			Boba_FireWristMissile(self, BOBA_MISSILE_LASER);
			return;
		}
		if (self->client->ps.forcePowerDuration[FP_GRIP])
		{
			Boba_EndWristMissile(self, BOBA_MISSILE_LASER);
			return;
		}
	}
	else if (ucmd->buttons & BUTTON_FORCEGRIP)
	{
		ForceGrip(self);
	}

	if (!self->s.number
		&& (self->client->NPC_class == CLASS_BOBAFETT || self->client->NPC_class == CLASS_MANDALORIAN || self->client->
			NPC_class == CLASS_JANGO || self->client->NPC_class == CLASS_JANGODUAL))
	{
		//Boba Fett
		if (ucmd->buttons & BUTTON_FORCE_LIGHTNING)
		{
			//start flamethrower
			if (self->client->ps.jetpackFuel > 15 && !self->client->hookhasbeenfired)
			{
				//not enough fuel to fire the weapon.
				Mando_DoFlameThrower(self);
			}
			return;
		}
		if (self->client->ps.forcePowerDuration[FP_LIGHTNING])
		{
			self->client->ps.forcePowerDuration[FP_LIGHTNING] = 0;
			Boba_StopFlameThrower(self);
			return;
		}
	}
	else if (ucmd->buttons & BUTTON_FORCE_LIGHTNING)
	{
		ForceLightning(self);
	}

	if (ucmd->buttons & BUTTON_LIGHTNING_STRIKE)
	{
		ForceLightningStrike(self);
	}

	if (ucmd->buttons & BUTTON_PROJECTION)
	{
		ForceProjection(self);
	}

	if ((self->client->ps.communicatingflags & 1 << DASHING) || (IsPressingDashButton(self)))
	{//dash is one of the powers with its own button.. if it's held, call the specific dash power function.
		ForceSpeedDash(self);
	}

	if (!self->s.number
		&& (self->client->NPC_class == CLASS_BOBAFETT || self->client->NPC_class == CLASS_JANGO || self->client->
			NPC_class == CLASS_JANGODUAL))
	{
		//Boba Fett
		if (self->client->ps.weapon != WP_MELEE && self->client->ps.weapon != WP_SABER && ucmd->buttons & BUTTON_WALKING
			&& ucmd->buttons & BUTTON_BLOCK)
		{
			//start wrist rocket
			Boba_FireWristMissile(self, BOBA_MISSILE_VIBROBLADE);
			return;
		}
		if (self->client->ps.forcePowerDuration[FP_DRAIN])
		{
			Boba_EndWristMissile(self, BOBA_MISSILE_VIBROBLADE);

			return;
		}
	}
	else if (ucmd->buttons & BUTTON_FORCE_DRAIN)
	{
		if (!ForceDrain2(self))
		{
			//can't drain-grip someone right in front
			if (self->client->ps.forcePowerLevel[FP_DRAIN] > FORCE_LEVEL_1)
			{
				//try ranged
				ForceDrain(self, qtrue);
			}
		}
	}

	for (i = 0; i < NUM_FORCE_POWERS; i++)
	{
		if (self->client->ps.forcePowerDuration[i])
		{
			if (self->client->ps.forcePowerDuration[i] < level.time)
			{
				if (self->client->ps.forcePowersActive & 1 << i)
				{
					//turn it off
					WP_ForcePowerStop(self, static_cast<forcePowers_t>(i));
				}
				self->client->ps.forcePowerDuration[i] = 0;
			}
		}
		if (self->client->ps.forcePowersActive & 1 << i)
		{
			using_force = qtrue;
			wp_force_power_run(self, static_cast<forcePowers_t>(i), ucmd);
		}
	}
	if (self->client->ps.saberInFlight)
	{
		//don't regen force power while throwing saber
		if (self->client->ps.saberEntityNum < ENTITYNUM_NONE && self->client->ps.saberEntityNum > 0) //player is 0
		{
			//
			if (&g_entities[self->client->ps.saberEntityNum] != nullptr && g_entities[self->client->ps.saberEntityNum].s
				.pos.trType == TR_LINEAR)
			{
				//fell to the ground and we're trying to pull it back
				if (g_SerenityJediEngineMode->integer)
				{
					using_force = qfalse;
				}
				else
				{
					using_force = qtrue;
				}
			}
		}
	}

	if (PM_ForceUsingSaberAnim(self->client->ps.torsoAnim) || pm_saber_innonblockable_attack(self->client->ps.torsoAnim))
	{
		using_force = qtrue;
	}

	if (!using_force)
	{
		//when not using the force, regenerate at 10 points per second
		if (self->client->ps.forcePowerRegenDebounceTime < level.time)
		{
			WP_ForcePowerRegenerate(self, self->client->ps.forcePowerRegenAmount);

			self->client->ps.forcePowerRegenDebounceTime = level.time + self->client->ps.forcePowerRegenRate;

			if (self->NPC && !G_ControlledByPlayer(self)) //npc
			{
				if (g_SerenityJediEngineMode->integer == 1) //npc in md mode
				{
					if (self->client->ps.forceRageRecoveryTime >= level.time)
					{
						//regen half as fast
						self->client->ps.forcePowerRegenDebounceTime += self->client->ps.forcePowerRegenRate;
					}
					else if (PM_SaberInAttack(self->client->ps.saber_move)
						|| pm_saber_in_special_attack(self->client->ps.torsoAnim)
						|| PM_SpinningSaberAnim(self->client->ps.torsoAnim)
						|| PM_SaberInParry(self->client->ps.saber_move)
						|| PM_SaberInReturn(self->client->ps.saber_move)
						|| !WalkCheck(self) && self->s.weapon == WP_SABER
						|| self->client->ps.saberInFlight
						|| PM_SaberInParry(self->client->ps.saber_move))
					{
						//regen half as fast
						self->client->ps.forcePowerRegenDebounceTime += 2000; //1 point per 1 seconds.. super slow
					}
				}
				else // npc in jka mode and amd mode
				{
					if (self->client->ps.forceRageRecoveryTime >= level.time)
					{
						//regen half as fast
						self->client->ps.forcePowerRegenDebounceTime += self->client->ps.forcePowerRegenRate;
					}
					else if (self->client->ps.saberInFlight)
					{
						//regen half as fast
						self->client->ps.forcePowerRegenDebounceTime += 2000; //1 point per 1 seconds.. super slow
					}
				}
			}
			else // player
			{
				if (g_SerenityJediEngineMode->integer) //player in md and amdmode
				{
					if (self->client->ps.forcePower > BLOCKPOINTS_FATIGUE)
					{
						//You gained some FP back.  Cancel the Fatigue status.
						self->client->ps.userInt3 &= ~(1 << FLAG_FATIGUED);
					}
					if (!PM_InKnockDown(&self->client->ps)
						&& WalkCheck(self)
						&& self->client->ps.weaponTime <= 0
						&& self->client->ps.groundEntityNum != ENTITYNUM_NONE
						&& !PM_SaberInBounce(self->client->ps.saber_move)
						&& !PM_SaberInMassiveBounce(self->client->ps.saber_move)
						&& !(PM_StabAnim(self->client->ps.legsAnim) || PM_StabAnim(self->client->ps.torsoAnim)))
					{
						if (PM_RestAnim(self->client->ps.legsAnim))
						{
							WP_ForcePowerRegenerate(self, 4);
							BG_ReduceSaberMishapLevel(&self->client->ps);
							//BG_ReduceBlasterMishapLevel(&self->client->ps);
							self->client->ps.powerups[PW_MEDITATE] = level.time + self->client->ps.torsoAnimTimer +
								3000;
							self->client->ps.eFlags |= EF_MEDITATING;
						}
						else if (PM_CrouchAnim(self->client->ps.legsAnim))
						{
							WP_ForcePowerRegenerate(self, 2);
							BG_ReduceSaberMishapLevel(&self->client->ps);
							//BG_ReduceBlasterMishapLevel(&self->client->ps);
						}
						else if (self->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCK)
						{
							if (g_SerenityJediEngineMode->integer == 2)
							{
								self->client->ps.forcePowerRegenDebounceTime += 2000;
								//1 point per 2 seconds.. super slow
							}
							else
							{
								self->client->ps.forcePowerRegenDebounceTime += 4000;
								//1 point per 4 seconds.. super slow
							}
						}
						else if (self->client->ps.powerups[PW_CLOAKED])
						{
							//regen half as fast
							self->client->ps.forcePowerRegenDebounceTime += self->client->ps.forcePowerRegenRate;
						}
						else
						{
							self->client->ps.eFlags &= ~EF_MEDITATING;
						}
					}
				}
				else //player in jka mode
				{
					if (self->client->ps.forceRageRecoveryTime >= level.time)
					{
						//regen half as fast
						self->client->ps.forcePowerRegenDebounceTime += self->client->ps.forcePowerRegenRate;
					}
				}
			}
		}
	}
}

void WP_BlockPointsUpdate(const gentity_t* self)
{
	const qboolean is_holding_block_button = self->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCK ? qtrue : qfalse;
	//Normal Blocking

	if (self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self)) //player only
	{
		if (!PM_InKnockDown(&self->client->ps)
			&& self->client->ps.groundEntityNum != ENTITYNUM_NONE
			&& WalkCheck(self)
			&& !PM_SaberInAttack(self->client->ps.saber_move)
			&& !pm_saber_in_special_attack(self->client->ps.torsoAnim)
			&& !PM_SpinningSaberAnim(self->client->ps.torsoAnim)
			&& !PM_SaberInParry(self->client->ps.saber_move)
			&& !PM_SaberInReturn(self->client->ps.saber_move)
			&& !PM_Saberinstab(self->client->ps.saber_move)
			&& !PM_SaberInBounce(self->client->ps.saber_move)
			&& !PM_SaberInMassiveBounce(self->client->ps.saber_move)
			&& !is_holding_block_button
			&& !(self->client->buttons & BUTTON_BLOCK))
		{
			//when not using the block, regenerate at 10 points per second
			if (self->client->ps.BlockPointsRegenDebounceTime < level.time)
			{
				WP_BlockPointsRegenerate(self, self->client->ps.BlockPointRegenAmount);

				self->client->ps.BlockPointsRegenDebounceTime = level.time + self->client->ps.BlockPointRegenRate;

				if (PM_RestAnim(self->client->ps.legsAnim))
				{
					WP_BlockPointsRegenerate(self, 4);
					self->client->ps.powerups[PW_MEDITATE] = level.time + self->client->ps.torsoAnimTimer + 3000;
					self->client->ps.eFlags |= EF_MEDITATING;
				}
				else if (PM_CrouchAnim(self->client->ps.legsAnim))
				{
					WP_BlockPointsRegenerate(self, 2);
				}
				else
				{
					if (self->client->ps.forceRageRecoveryTime >= level.time)
					{
						//regen half as fast
						self->client->ps.BlockPointsRegenDebounceTime += self->client->ps.BlockPointRegenRate;
					}
					else if (self->client->ps.blockPoints > BLOCKPOINTS_MISSILE) //slows down for the last 25 points
					{
						//regen half as fast
						self->client->ps.BlockPointsRegenDebounceTime += 2000;
					}
					else if (self->client->ps.saberInFlight) //slows down
					{
						//regen half as fast
						self->client->ps.BlockPointsRegenDebounceTime += 2000;
					}
					else if (self->client->ps.weaponTime <= 0) //slows down
					{
						//regen half as fast
						self->client->ps.BlockPointsRegenDebounceTime += 2000;
					}
					self->client->ps.eFlags &= ~EF_MEDITATING;
				}
			}
		}
	}
	else
	{
		//when not using the block, regenerate at 10 points per second
		if (!PM_InKnockDown(&self->client->ps)
			&& self->client->ps.groundEntityNum != ENTITYNUM_NONE
			&& WalkCheck(self)
			&& !PM_SaberInAttack(self->client->ps.saber_move)
			&& !pm_saber_in_special_attack(self->client->ps.torsoAnim)
			&& !PM_SpinningSaberAnim(self->client->ps.torsoAnim)
			&& !PM_SaberInParry(self->client->ps.saber_move)
			&& !PM_SaberInReturn(self->client->ps.saber_move)
			&& !PM_Saberinstab(self->client->ps.saber_move))
		{
			if (self->client->ps.BlockPointsRegenDebounceTime < level.time)
			{
				WP_BlockPointsRegenerate(self, self->client->ps.BlockPointRegenAmount);

				self->client->ps.BlockPointsRegenDebounceTime = level.time + self->client->ps.BlockPointRegenRate;
				if (self->client->ps.forceRageRecoveryTime >= level.time)
				{
					//regen half as fast
					self->client->ps.BlockPointsRegenDebounceTime += self->client->ps.BlockPointRegenRate;
				}
				else if (self->client->ps.blockPoints > BLOCKPOINTS_MISSILE) //slows down for the last 25 points
				{
					//regen half as fast
					self->client->ps.BlockPointsRegenDebounceTime += 2000;
				}
				else if (self->client->ps.saberInFlight) //slows down
				{
					//regen half as fast
					self->client->ps.BlockPointsRegenDebounceTime += 2000;
				}
				else if (self->client->ps.weaponTime <= 0) //slows down
				{
					//regen half as fast
					self->client->ps.BlockPointsRegenDebounceTime += 2000;
				}
			}
		}
	}
}

void WP_InitForcePowers(const gentity_t* ent)
{
	if (!ent || !ent->client)
	{
		return;
	}

	if (!ent->client->ps.forcePowerMax)
	{
		ent->client->ps.forcePowerMax = FORCE_POWER_MAX;
	}

	if (!ent->client->ps.BlockPointsMax)
	{
		ent->client->ps.BlockPointsMax = FORCE_POWER_MAX;
	}

	if (!ent->client->ps.forcePowerRegenRate)
	{
		ent->client->ps.forcePowerRegenRate = 100;
	}
	if (!ent->client->ps.BlockPointRegenRate)
	{
		ent->client->ps.BlockPointRegenRate = 100;
	}
	ent->client->ps.blockPoints = ent->client->ps.BlockPointsMax;
	ent->client->ps.BlockPointsRegenDebounceTime = level.time;

	ent->client->ps.forcePower = ent->client->ps.forcePowerMax;
	ent->client->ps.forcePowerRegenDebounceTime = level.time;

	ent->client->ps.forceGripEntityNum = ent->client->ps.forceDrainEntityNum = ent->client->ps.pullAttackEntNum =
		ENTITYNUM_NONE;
	ent->client->ps.forceRageRecoveryTime = 0;
	ent->client->ps.forceDrainTime = 0;
	ent->client->ps.pullAttackTime = 0;

	if (ent->s.number < MAX_CLIENTS)
	{
		//player
		if (!g_cheats->integer) //devmaps give you all the FP
		{
			ent->client->ps.forcePowerLevel[FP_SABER_DEFENSE] = FORCE_LEVEL_3;
			ent->client->ps.forcePowerLevel[FP_SABER_OFFENSE] = FORCE_LEVEL_3;
		}
		else
		{
			ent->client->ps.forcePowersKnown = 1 << FP_HEAL | 1 << FP_LEVITATION | 1 << FP_SPEED | 1 << FP_PUSH | 1 <<
				FP_PULL | 1 << FP_TELEPATHY | 1 << FP_GRIP | 1 << FP_LIGHTNING | 1 << FP_SABERTHROW | 1 <<
				FP_SABER_DEFENSE | 1 << FP_SABER_OFFENSE | 1 << FP_RAGE | 1 << FP_DRAIN | 1 << FP_PROTECT | 1 <<
				FP_ABSORB | 1 << FP_SEE | 1 << FP_DESTRUCTION | 1 << FP_STASIS | 1 << FP_GRASP | 1 << FP_REPULSE | 1 <<
				FP_LIGHTNING_STRIKE | 1 << FP_FEAR | 1 << FP_DEADLYSIGHT | 1 << FP_BLAST | 1 << FP_PROJECTION;
			ent->client->ps.forcePowerLevel[FP_HEAL] = FORCE_LEVEL_2;
			ent->client->ps.forcePowerLevel[FP_LEVITATION] = FORCE_LEVEL_2;
			ent->client->ps.forcePowerLevel[FP_PUSH] = FORCE_LEVEL_1;
			ent->client->ps.forcePowerLevel[FP_PULL] = FORCE_LEVEL_1;
			ent->client->ps.forcePowerLevel[FP_SABERTHROW] = FORCE_LEVEL_2;
			ent->client->ps.forcePowerLevel[FP_SPEED] = FORCE_LEVEL_2;
			ent->client->ps.forcePowerLevel[FP_LIGHTNING] = FORCE_LEVEL_1;
			ent->client->ps.forcePowerLevel[FP_TELEPATHY] = FORCE_LEVEL_2;

			ent->client->ps.forcePowerLevel[FP_RAGE] = FORCE_LEVEL_1;
			ent->client->ps.forcePowerLevel[FP_PROTECT] = FORCE_LEVEL_1;
			ent->client->ps.forcePowerLevel[FP_ABSORB] = FORCE_LEVEL_1;
			ent->client->ps.forcePowerLevel[FP_DRAIN] = FORCE_LEVEL_1;
			ent->client->ps.forcePowerLevel[FP_SEE] = FORCE_LEVEL_1;

			ent->client->ps.forcePowerLevel[FP_SABER_DEFENSE] = FORCE_LEVEL_3;
			ent->client->ps.forcePowerLevel[FP_SABER_OFFENSE] = FORCE_LEVEL_3;
			ent->client->ps.forcePowerLevel[FP_GRIP] = FORCE_LEVEL_2;

			ent->client->ps.forcePowerLevel[FP_DESTRUCTION] = FORCE_LEVEL_2;
			ent->client->ps.forcePowerLevel[FP_STASIS] = FORCE_LEVEL_2;

			ent->client->ps.forcePowerLevel[FP_GRASP] = FORCE_LEVEL_2;
			ent->client->ps.forcePowerLevel[FP_REPULSE] = FORCE_LEVEL_2;
			ent->client->ps.forcePowerLevel[FP_LIGHTNING_STRIKE] = FORCE_LEVEL_1;
			ent->client->ps.forcePowerLevel[FP_FEAR] = FORCE_LEVEL_1;
			ent->client->ps.forcePowerLevel[FP_DEADLYSIGHT] = FORCE_LEVEL_1;
			ent->client->ps.forcePowerLevel[FP_BLAST] = FORCE_LEVEL_1;
			ent->client->ps.forcePowerLevel[FP_PROJECTION] = FORCE_LEVEL_1;
		}
	}
}

qboolean WP_DoingForcedAnimationForForcePowers(const gentity_t* self)
{
	if (!self->client)
	{
		return qfalse;
	}
	if (self->client->ps.legsAnim == BOTH_FORCE_ABSORB_START ||
		self->client->ps.legsAnim == BOTH_FORCE_ABSORB_END ||
		self->client->ps.legsAnim == BOTH_FORCE_ABSORB ||
		self->client->ps.torsoAnim == BOTH_FORCE_RAGE ||
		self->client->ps.legsAnim == BOTH_FORCE_PROTECT)
	{
		return qtrue;
	}
	return qfalse;
}

qboolean Jedi_DrainReaction(gentity_t* self)
{
	if (self->health > 0 && !PM_InKnockDown(&self->client->ps)
		&& self->client->ps.torsoAnim != BOTH_FORCE_DRAIN_GRABBED)
	{
		//still alive
		if (self->client->ps.stats[STAT_HEALTH] < 50)
		{
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_SONICPAIN_HOLD, SETANIM_AFLAG_PACE);
		}
		else
		{
			NPC_SetAnim(self, SETANIM_TORSO, BOTH_WIND, SETANIM_AFLAG_PACE);
		}

		self->client->ps.ManualBlockingFlags &= ~(1 << HOLDINGBLOCK);
		self->client->ps.ManualBlockingFlags &= ~(1 << HOLDINGBLOCKANDATTACK);
		self->client->ps.ManualBlockingFlags &= ~(1 << PERFECTBLOCKING);
		self->client->ps.ManualBlockingFlags &= ~(1 << MBF_NPCBLOCKING);
	}
	return qfalse;
}

void G_SaberBounce(const gentity_t* self, gentity_t* other)
{
	if (g_SerenityJediEngineMode->integer < 2)
	{
		return;
	}

	if (other->health <= 30)
	{
		return;
	}

	if (self->client->ps.saberFatigueChainCount < MISHAPLEVEL_TEN)
	{
		return;
	}

	if (pm_saber_innonblockable_attack(self->client->ps.torsoAnim))
	{
		return;
	}

	if (!g_standard_humanoid(other))
	{
		return;
	}

	if (self->s.number >= MAX_CLIENTS && !G_ControlledByPlayer(self))
	{
		return;
	}

	if (self->client->ps.saberBlocked == BLOCKED_NONE)
	{
		if (!pm_saber_in_special_attack(self->client->ps.torsoAnim))
		{
			if (SaberAttacking(self))
			{
				// Saber is in attack, use bounce for this attack.
				self->client->ps.saberBounceMove = PM_SaberBounceForAttack(self->client->ps.saber_move);
				self->client->ps.saberBlocked = BLOCKED_BOUNCE_MOVE;
			}
			else
			{
				// Saber is in defense, use defensive bounce.
				self->client->ps.saberBlocked = BLOCKED_ATK_BOUNCE;
			}
		}
	}
}

void G_Beskar_Attack_Bounce(const gentity_t* self, gentity_t* other)
{
	if (self->client->ps.saberBlocked == BLOCKED_NONE)
	{
		if (!pm_saber_in_special_attack(self->client->ps.torsoAnim))
		{
			if (SaberAttacking(self))
			{
				// Saber is in attack, use bounce for this attack.
				self->client->ps.saberBounceMove = PM_SaberBounceForAttack(self->client->ps.saber_move);
				self->client->ps.saberBlocked = BLOCKED_BOUNCE_MOVE;
			}
			else
			{
				// Saber is in defense, use defensive bounce.
				self->client->ps.saberBlocked = BLOCKED_ATK_BOUNCE;
			}
		}
	}
}

qboolean g_accurate_blocking(const gentity_t* blocker, const gentity_t* attacker, vec3_t hit_loc)
{
	//determines if self (who is blocking) is activating blocking (parrying)
	vec3_t p_angles;
	vec3_t p_right;
	vec3_t parrier_move{};
	vec3_t hit_pos;
	vec3_t hit_flat{}; //flatten 2D version of the hitPos.
	const qboolean in_front = InFront(attacker->client->ps.origin, blocker->client->ps.origin, blocker->client->ps.viewangles, 0.0f);

	if (blocker->s.number < MAX_CLIENTS || G_ControlledByPlayer(blocker))
	{
		if (!(blocker->client->ps.ManualBlockingFlags & 1 << HOLDINGBLOCK))
		{
			return qfalse;
		}
	}

	if (!in_front)
	{
		//can't parry attacks to the rear.
		return qfalse;
	}
	if (PM_SaberInKnockaway(blocker->client->ps.saber_move))
	{
		//already in parry move, continue parrying anything that hits us as long as
		//the attacker is in the same general area that we're facing.
		return qtrue;
	}

	if (PM_KickingAnim(blocker->client->ps.legsAnim))
	{
		//can't parry in kick.
		return qfalse;
	}

	if (BG_SaberInNonIdleDamageMove(&blocker->client->ps)
		|| PM_SaberInBounce(blocker->client->ps.saber_move) || BG_InSlowBounce(&blocker->client->ps))
	{
		//can't parry if we're transitioning into a block from an attack state.
		return qfalse;
	}

	if (blocker->client->ps.pm_flags & PMF_DUCKED)
	{
		//can't parry while ducked or running
		return qfalse;
	}

	if (blocker->client->ps.ManualblockStartTime >= 3000) //3 sec
	{
		//cant perfect parry if your too slow
		return qfalse;
	}

	//set up flatten version of the location of the incoming attack in orientation
	//to the player.
	VectorSubtract(hit_loc, blocker->client->ps.origin, hit_pos);
	VectorSet(p_angles, 0, blocker->client->ps.viewangles[YAW], 0);
	AngleVectors(p_angles, nullptr, p_right, nullptr);
	hit_flat[0] = 0;
	hit_flat[1] = DotProduct(p_right, hit_pos);

	//just bump the hit pos down for the blocking since the average left/right slice happens at about origin +10
	hit_flat[2] = hit_pos[2] - 10;
	VectorNormalize(hit_flat);

	//set up the vector for the direction the player is trying to parry in.
	parrier_move[0] = 0;
	parrier_move[1] = blocker->client->pers.cmd.rightmove;
	parrier_move[2] = -blocker->client->pers.cmd.forwardmove;
	VectorNormalize(parrier_move);

	const float block_dot = DotProduct(hit_flat, parrier_move);

	if (block_dot >= 0.4F)
	{
		//player successfully blocked in the right direction to do a full parry.
		return qtrue;
	}
	//player didn't parry in the correct direction, do blockPoints punishment
	if (blocker->NPC && !G_ControlledByPlayer(blocker))
	{
		//bots just randomly parry to make up for them not intelligently parrying.
		if (NPC_PARRYRATE * g_spskill->integer > Q_irand(0, 999))
		{
			return qtrue;
		}
	}
	return qfalse;
}

static QINLINE int G_GetParryForBlock(const int block)
{
	switch (block)
	{
	case BLOCKED_UPPER_RIGHT:
		return LS_PARRY_UR;
	case BLOCKED_UPPER_RIGHT_PROJ:
		return LS_REFLECT_UR;
	case BLOCKED_UPPER_LEFT:
		return LS_PARRY_UL;
	case BLOCKED_UPPER_LEFT_PROJ:
		return LS_REFLECT_UL;
	case BLOCKED_LOWER_RIGHT:
		return LS_PARRY_LR;
	case BLOCKED_LOWER_RIGHT_PROJ:
		return LS_REFLECT_LR;
	case BLOCKED_LOWER_LEFT:
		return LS_PARRY_LL;
	case BLOCKED_LOWER_LEFT_PROJ:
		return LS_REFLECT_LL;
	case BLOCKED_TOP:
		return LS_PARRY_UP;
	case BLOCKED_TOP_PROJ:
		return LS_REFLECT_UP;
	case BLOCKED_BACK:
		return LS_REFLECT_B;
	default:
		break;
	}

	return LS_NONE;
}

void AnimateStun(gentity_t* self, gentity_t* inflictor)
{
	//place self into a stunned state.
	if (self->client->ps.weapon != WP_SABER)
	{
		//knock them down instead
		G_Knockdown(self, inflictor, vec3_origin, 50, qtrue);
	}
	else if (!PM_SaberInBrokenParry(self->client->ps.saber_move) && !PM_InKnockDown(&self->client->ps))
	{
		if (!PM_SaberInParry(G_GetParryForBlock(self->client->ps.saberBlocked)))
		{
			//not already in a parry position, get one
			if (g_SerenityJediEngineMode->integer)
			{
				if (self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self))
				{
					WP_SaberBlockNonRandom_MD(self, saberHitLocation, qfalse);
				}
				else
				{
					WP_SaberBlockNonRandom(self, saberHitLocation, qfalse);
				}
			}
			else
			{
				WP_SaberBlockNonRandom(self, saberHitLocation, qfalse);
			}
		}

		self->client->ps.saber_move = PM_BrokenParryForParry(G_GetParryForBlock(self->client->ps.saberBlocked));
		self->client->ps.saberBlocked = BLOCKED_PARRY_BROKEN;
	}
	else
	{
		if (self->s.number < MAX_CLIENTS)
		{
			NPC_SetPainEvent(self);
		}
		else
		{
			GEntity_PainFunc(self, inflictor, inflictor, self->currentOrigin, 0, MOD_MELEE);
		}
	}

	npc_check_speak(self);
}

static void player_StopFreeze(gentity_t* self)
{
	if (self && self->client)
	{
		if (self->client->ps.PlayerEffectFlags & 1 << PEF_FREEZING)
		{
			//UnFreeze
			self->client->ps.PlayerEffectFlags &= ~(1 << PEF_FREEZING);
		}
		else
		{
			//UnFreeze
			self->client->ps.PlayerEffectFlags &= ~(1 << PEF_FREEZING);
		}
		self->s.loopSound = 0;
	}
}

void Player_CheckFreeze(gentity_t* self)
{
	if (self && self->client)
	{
		if (self->health <= 0 || self->painDebounceTime < level.time)
		{
			player_StopFreeze(self);
		}
		else if (PM_InRoll(&self->client->ps))
		{
			player_StopFreeze(self);
		}
		else if (TIMER_Done(self, "FreezeDebounce"))
		{
			player_StopFreeze(self);
		}
		else
		{
			player_StopFreeze(self);
		}
	}
}

void player_Freeze(gentity_t* self)
{
	if ((self->s.number < MAX_CLIENTS || G_ControlledByPlayer(self)) && self && self->client)
	{
		if (!(self->client->ps.PlayerEffectFlags & 1 << PEF_FREEZING))
		{
			self->client->ps.PlayerEffectFlags |= 1 << PEF_FREEZING;
			self->s.loopSound = G_SoundIndex("sound/weapons/force/absorbloop.wav");
		}
		else
		{
			player_StopFreeze(self);
		}
	}

	TIMER_Set(self, "FreezeDebounce", 1000);
}

void BG_ReduceSaberMishapLevel(playerState_t* ps)
{
	//reduces a player's mishap meter by one level
	if (ps->saberFatigueChainCount >= MISHAPLEVEL_MAX)
	{
		ps->saberFatigueChainCount = MISHAPLEVEL_FULL;
	}
	else if (ps->saberFatigueChainCount >= MISHAPLEVEL_FULL)
	{
		ps->saberFatigueChainCount = MISHAPLEVEL_THIRTEEN;
	}
	else if (ps->saberFatigueChainCount >= MISHAPLEVEL_THIRTEEN)
	{
		ps->saberFatigueChainCount = MISHAPLEVEL_HUDFLASH;
	}
	else if (ps->saberFatigueChainCount >= MISHAPLEVEL_HUDFLASH)
	{
		ps->saberFatigueChainCount = MISHAPLEVEL_ELEVEN;
	}
	else if (ps->saberFatigueChainCount >= MISHAPLEVEL_ELEVEN)
	{
		ps->saberFatigueChainCount = MISHAPLEVEL_TEN;
	}
	else if (ps->saberFatigueChainCount >= MISHAPLEVEL_TEN)
	{
		ps->saberFatigueChainCount = MISHAPLEVEL_NINE;
	}
	else if (ps->saberFatigueChainCount >= MISHAPLEVEL_NINE)
	{
		ps->saberFatigueChainCount = MISHAPLEVEL_HEAVY;
	}
	else if (ps->saberFatigueChainCount >= MISHAPLEVEL_HEAVY)
	{
		ps->saberFatigueChainCount = MISHAPLEVEL_SEVEN;
	}
	else if (ps->saberFatigueChainCount >= MISHAPLEVEL_SEVEN)
	{
		ps->saberFatigueChainCount = MISHAPLEVEL_SIX;
	}
	else if (ps->saberFatigueChainCount >= MISHAPLEVEL_SIX)
	{
		ps->saberFatigueChainCount = MISHAPLEVEL_LIGHT;
	}
	else if (ps->saberFatigueChainCount >= MISHAPLEVEL_LIGHT)
	{
		ps->saberFatigueChainCount = MISHAPLEVEL_FOUR;
	}
	else if (ps->saberFatigueChainCount >= MISHAPLEVEL_FOUR)
	{
		ps->saberFatigueChainCount = MISHAPLEVEL_SNIPER;
	}
	else if (ps->saberFatigueChainCount >= MISHAPLEVEL_SNIPER)
	{
		ps->saberFatigueChainCount = MISHAPLEVEL_TWO;
	}
	else if (ps->saberFatigueChainCount >= MISHAPLEVEL_TWO)
	{
		ps->saberFatigueChainCount = MISHAPLEVEL_MIN;
	}
	else if (ps->saberFatigueChainCount >= MISHAPLEVEL_MIN)
	{
		if (g_debugFatigueBars->integer)
		{
			ps->saberFatigueChainCount = MISHAPLEVEL_MIN;
		}
		else
		{
			ps->saberFatigueChainCount = MISHAPLEVEL_NONE;
		}
	}
	else
	{
		ps->saberFatigueChainCount = MISHAPLEVEL_NONE;
	}
}

void BG_ReduceBlasterMishapLevel(playerState_t* ps)
{
	//reduces a player's mishap meter by one level
	if (ps->BlasterAttackChainCount >= BLASTERMISHAPLEVEL_MAX)
	{
		ps->BlasterAttackChainCount = BLASTERMISHAPLEVEL_FIFTEEN;
	}
	else if (ps->BlasterAttackChainCount >= BLASTERMISHAPLEVEL_FIFTEEN)
	{
		ps->BlasterAttackChainCount = BLASTERMISHAPLEVEL_FOURTEEN;
	}
	else if (ps->BlasterAttackChainCount >= BLASTERMISHAPLEVEL_FOURTEEN)
	{
		ps->BlasterAttackChainCount = BLASTERMISHAPLEVEL_OVERLOAD;
	}
	else if (ps->BlasterAttackChainCount >= BLASTERMISHAPLEVEL_OVERLOAD)
	{
		ps->BlasterAttackChainCount = BLASTERMISHAPLEVEL_TWELVE;
	}
	else if (ps->BlasterAttackChainCount >= BLASTERMISHAPLEVEL_TWELVE)
	{
		ps->BlasterAttackChainCount = BLASTERMISHAPLEVEL_FULL;
	}
	else if (ps->BlasterAttackChainCount >= BLASTERMISHAPLEVEL_FULL)
	{
		ps->BlasterAttackChainCount = BLASTERMISHAPLEVEL_HEAVYER;
	}
	else if (ps->BlasterAttackChainCount >= BLASTERMISHAPLEVEL_HEAVYER)
	{
		ps->BlasterAttackChainCount = BLASTERMISHAPLEVEL_HALF;
	}
	else if (ps->BlasterAttackChainCount >= BLASTERMISHAPLEVEL_HALF)
	{
		ps->BlasterAttackChainCount = BLASTERMISHAPLEVEL_HEAVY;
	}
	else if (ps->BlasterAttackChainCount >= BLASTERMISHAPLEVEL_HEAVY)
	{
		ps->BlasterAttackChainCount = BLASTERMISHAPLEVEL_MEDIUM;
	}
	else if (ps->BlasterAttackChainCount >= BLASTERMISHAPLEVEL_MEDIUM)
	{
		ps->BlasterAttackChainCount = BLASTERMISHAPLEVEL_LIGHT;
	}
	else if (ps->BlasterAttackChainCount >= BLASTERMISHAPLEVEL_LIGHT)
	{
		ps->BlasterAttackChainCount = BLASTERMISHAPLEVEL_THREE;
	}
	else if (ps->BlasterAttackChainCount >= BLASTERMISHAPLEVEL_THREE)
	{
		ps->BlasterAttackChainCount = BLASTERMISHAPLEVEL_MIN;
	}
	else if (ps->BlasterAttackChainCount >= BLASTERMISHAPLEVEL_MIN)
	{
		ps->BlasterAttackChainCount = BLASTERMISHAPLEVEL_NONE;
	}
	else
	{
		ps->BlasterAttackChainCount = BLASTERMISHAPLEVEL_NONE;
	}
}

void BG_ReduceBlasterMishapLevelAdvanced(playerState_t* ps)
{
	//reduces a player's mishap meter by one level
	if (ps->BlasterAttackChainCount > BLASTERMISHAPLEVEL_MIN)
	{
		ps->BlasterAttackChainCount = BLASTERMISHAPLEVEL_NONE;
	}
	else
	{
		ps->BlasterAttackChainCount = BLASTERMISHAPLEVEL_NONE;
	}
}

qboolean BG_SaberInPartialDamageMove(gentity_t* self)
{
	//The player is attacking with a saber attack that does NO damage AT THIS POINT
	if (pm_saber_innonblockable_attack(self->client->ps.torsoAnim) || self->client->ps.torsoAnim == BOTH_ROLL_STAB)
	{
		float current = 0.0f;
		int end = 0;
		int start = 0;

		if (gi.G2API_GetBoneAnimIndex(&self->ghoul2[self->playerModel],
			self->lowerLumbarBone,
			level.time,
			&current,
			&start,
			&end,
			nullptr,
			nullptr,
			nullptr))
		{
			const float percent_complete = (current - start) / (end - start);

			if (g_IsSaberDoingAttackDamage->integer || g_DebugSaberCombat->integer)
			{
				gi.Printf("%f\n", percent_complete);
			}

			switch (self->client->ps.torsoAnim)
			{
			case BOTH_ATTACK_BACK: return static_cast<qboolean>(percent_complete < 0.30 || percent_complete > 0.80);
			case BOTH_A2_STABBACK1: return static_cast<qboolean>(percent_complete < 0.40 || percent_complete > 0.65);
			case BOTH_CROUCHATTACKBACK1: return static_cast<qboolean>(percent_complete < 0.25 || percent_complete > 0.75);
			case BOTH_BUTTERFLY_LEFT: return static_cast<qboolean>(percent_complete < 0.25 || percent_complete > 0.90);
			case BOTH_BUTTERFLY_RIGHT: return static_cast<qboolean>(percent_complete < 0.25 || percent_complete > 0.90);
			case BOTH_BUTTERFLY_FL1: return static_cast<qboolean>(percent_complete < 0.25 || percent_complete > 0.90);
			case BOTH_BUTTERFLY_FR1: return static_cast<qboolean>(percent_complete < 0.25 || percent_complete > 0.90);
			case BOTH_FJSS_TR_BL: return static_cast<qboolean>(percent_complete < 0.25 || percent_complete > 0.90);
			case BOTH_FJSS_TL_BR: return static_cast<qboolean>(percent_complete < 0.25 || percent_complete > 0.90);
			case BOTH_FORCELEAP2_T__B_: return static_cast<qboolean>(percent_complete < 0.50 || percent_complete > 0.75);
			case BOTH_JUMPFLIPSTABDOWN: return static_cast<qboolean>(percent_complete < 0.20 || percent_complete > 0.80);
			case BOTH_JUMPFLIPSLASHDOWN1: return static_cast<qboolean>(percent_complete < 0.20 || percent_complete > 0.80);
			case BOTH_ROLL_STAB: return static_cast<qboolean>(percent_complete < 0.30 || percent_complete > 0.75);
			case BOTH_JUMPATTACK6: return static_cast<qboolean>(percent_complete < 0.25 || percent_complete > 0.90);
			case BOTH_JUMPATTACK7: return static_cast<qboolean>(percent_complete < 0.35 || percent_complete > 0.90);
			case BOTH_SPINATTACK6: return static_cast<qboolean>(percent_complete < 0.35 || percent_complete > 0.80);
			case BOTH_SPINATTACK7: return static_cast<qboolean>(percent_complete < 0.45 || percent_complete > 0.85);
			case BOTH_FORCELONGLEAP_ATTACK: return static_cast<qboolean>(percent_complete < 0.20 || percent_complete > 0.80);
			case BOTH_STABDOWN: return static_cast<qboolean>(percent_complete < 0.50 || percent_complete > 0.80);
			case BOTH_STABDOWN_STAFF: return static_cast<qboolean>(percent_complete < 0.50 || percent_complete > 0.80);
			case BOTH_STABDOWN_DUAL: return static_cast<qboolean>(percent_complete < 0.50 || percent_complete > 0.80);
			case BOTH_A6_SABERPROTECT: return static_cast<qboolean>(percent_complete < 0.35 || percent_complete > 0.90);
			case BOTH_A7_SOULCAL: return static_cast<qboolean>(percent_complete < 0.25 || percent_complete > 0.90);
			case BOTH_A1_SPECIAL: return static_cast<qboolean>(percent_complete < 0.20 || percent_complete > 0.90);
			case BOTH_A2_SPECIAL: return static_cast<qboolean>(percent_complete < 0.20 || percent_complete > 0.90);
			case BOTH_A3_SPECIAL: return static_cast<qboolean>(percent_complete < 0.20 || percent_complete > 0.90);
			case BOTH_FLIP_ATTACK7: return static_cast<qboolean>(percent_complete < 0.40 || percent_complete > 0.90);
			case BOTH_PULL_IMPALE_STAB: return static_cast<qboolean>(percent_complete < 0.40 || percent_complete > 0.70);
			case BOTH_PULL_IMPALE_SWING: return static_cast<qboolean>(percent_complete < 0.40 || percent_complete > 0.70);
			case BOTH_ALORA_SPIN_SLASH: return static_cast<qboolean>(percent_complete < 0.22 || percent_complete > 0.90);
			case BOTH_A6_FB: return static_cast<qboolean>(percent_complete < 0.45 || percent_complete > 0.80);
			case BOTH_A6_LR: return static_cast<qboolean>(percent_complete < 0.45 || percent_complete > 0.80);
			case BOTH_GRAPPLE_FIRE: return static_cast<qboolean>(percent_complete < 0.20 || percent_complete > 0.90);
			default:;
			}
		}
	}

	return qfalse;
}